<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8d7399087ab69cfbf5452abe2298465ee636d83d" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52248488" /></Metadata><TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="a8eb2-101">提供基底類別，表示運算式樹狀架構節點的類別可由此基底類別衍生。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-101">Provides the base class from which the classes that represent expression tree nodes are derived.</span></span> <span data-ttu-id="a8eb2-102">它也包含 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />) Factory 方法來建立各種節點類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-102">It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types.</span></span> <span data-ttu-id="a8eb2-103">這是 <see langword="abstract" /> 類別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-103">This is an <see langword="abstract" /> class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-104">下列程式碼範例示範如何建立區塊的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-104">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="a8eb2-105">區塊運算式包含兩個<xref:System.Linq.Expressions.MethodCallExpression>物件，另一個<xref:System.Linq.Expressions.ConstantExpression>物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-105">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-106">建構 <see cref="T:System.Linq.Expressions.Expression" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-106">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8eb2-107">建構 <see cref="T:System.Linq.Expressions.Expression" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-107">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType"><span data-ttu-id="a8eb2-108"><see cref="T:System.Linq.Expressions.ExpressionType" /> 可設定為節點類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-108">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-109">此 <see cref="P:System.Linq.Expressions.Expression.Type" /> 的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-109">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="a8eb2-110">初始化 <see cref="T:System.Linq.Expressions.Expression" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-110">Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-111">在衍生類別中的建構函式會從呼叫這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-111">This constructor is called from constructors in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="a8eb2-112">瀏覽這個節點的造訪者。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-112">The visitor to visit this node with.</span></span></param>
        <summary><span data-ttu-id="a8eb2-113">分派給這個節點類型的特定造訪方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-113">Dispatches to the specific visit method for this node type.</span></span> <span data-ttu-id="a8eb2-114">例如，<see cref="T:System.Linq.Expressions.MethodCallExpression" /> 會呼叫 <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-114">For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-115">瀏覽這個節點的結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-115">The result of visiting this node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-116">此預設實作<xref:System.Linq.Expressions.ExpressionType.Extension>節點呼叫<xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-116">This default implementation for <xref:System.Linq.Expressions.ExpressionType.Extension> nodes calls <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span> <span data-ttu-id="a8eb2-117">覆寫這個方法，以更特定的方法，衍生的訪客類別上呼叫<xref:System.Linq.Expressions.ExpressionVisitor>類別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-117">Override this method to call into a more specific method on a derived visitor class of the <xref:System.Linq.Expressions.ExpressionVisitor> class.</span></span> <span data-ttu-id="a8eb2-118">不過，它應該仍支援未知的訪客藉由呼叫<xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-118">However, it should still support unknown visitors by calling <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-119">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術加法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-119">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-120">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-120">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-121">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-121">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-122">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術加法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-122">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-123"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Add" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-124">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-124">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-125"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-125">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-126">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-126">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-127">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-127">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-128"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-128">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-129">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-129">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-130">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-130">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-131">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-131">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-132">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載加法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-132">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-133">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-133">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-134">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-134">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-135">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-135">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-136">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-136">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-137">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-137">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-138">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-138">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-139">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-139">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-140">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-140">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-141">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-141">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-142">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-142">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-143">節點的類型是預先定義的加法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-143">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-144">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-144">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-145">節點的類型為 null 的型別對應至預先定義的加法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-145">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-146">下列程式碼範例示範如何建立將兩個整數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-146">The following code example shows how to create an expression that adds two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-147"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-147"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-148">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Addition 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-148">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-149">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-149">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-150">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-150">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-151">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-151">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-152">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術加法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span> <span data-ttu-id="a8eb2-153">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-153">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-154"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Add" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-155">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-155">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-156"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-156">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-157">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-157">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-158">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-158">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-159"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-159">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-160">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-160">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-161">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-161">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-162">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-162">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-163">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-163">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-164">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載加法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-164">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-165">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-165">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-166">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-166">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-167">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-167">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-168">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-168">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-169">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-169">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-170">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-170">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-171">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-171">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-172">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-172">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-173">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-173">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-174">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-174">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-175">節點的類型是預先定義的加法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-175">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-176">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-176">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-177">節點的類型為 null 的型別對應至預先定義的加法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-177">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-178"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-178"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-179"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-179"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-180"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的加法運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-180"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-181">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的加法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-182">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-182">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-183">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-183">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-184">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的加法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-184">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-185"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-186">下列程式碼範例示範如何建立將值加入整數變數，然後將作業的結果指派給變數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-186">The following code example shows how to create an expression that adds a value to an integer variable and then assigns the result of the operation to the variable.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-187">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-187">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-188">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-188">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-189">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-189">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-190">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的加法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-190">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-191"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-192">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-192">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-193">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-193">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-194">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-194">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-195">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-196">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的加法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-197"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-198">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的加法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-198">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-199">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-199">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-200">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-200">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-201">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的加法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-202"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-203">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-204">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-205">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-205">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-206">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的加法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-207"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-208">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-209">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-210">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-211">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-212">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的加法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-212">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-213"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-214">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術加法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-214">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-215">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-215">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-216">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-216">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-217">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術加法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-218"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-219">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-219">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-220"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-220">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-221">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-221">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-222">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-222">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-223"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-223">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-224">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-224">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-225">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-225">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-226">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-226">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-227">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載加法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-227">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-228">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-228">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-229">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-229">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-230">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-230">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-231">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-231">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-232">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-232">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-233">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-233">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-234">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-234">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-235">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-235">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-236">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-236">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-237">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-237">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-238">節點的類型是預先定義的加法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-238">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-239">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-239">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-240">節點的類型為 null 的型別對應至預先定義的加法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-240">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-241"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-241"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-242">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Addition 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-242">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-243">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-243">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-244">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-244">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-245">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-245">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-246">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術加法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-246">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span> <span data-ttu-id="a8eb2-247">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-247">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-248"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-249">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-249">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-250"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-250">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-251">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-251">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-252">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-252">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-253"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-253">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-254">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-254">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-255">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-255">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-256">作業的實作方法是選擇根據下列規則：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-256">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="a8eb2-257">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-257">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-258">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載加法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-258">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-259">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-259">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-260">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-260">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-261">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-261">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-262">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-262">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-263">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-263">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-264">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-264">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-265">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-265">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-266">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-266">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-267">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-267">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-268">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-268">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-269">節點的類型是預先定義的加法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-269">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-270">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-270">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-271">節點的類型為 null 的型別對應至預先定義的加法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-271">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-272"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-272"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-273"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-273"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-274"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的加法運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-274"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-275">建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="AND" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-275">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-276">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-276">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-277">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-277">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-278">建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="AND" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-278">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-279"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.And" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-280">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-280">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-281"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-281">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-282">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-282">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-283">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-283">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-284"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-284">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-285">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-285">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-286">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-286">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-287">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-287">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-288">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`AND`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-288">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-289">否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-289">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-290">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-290">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-291">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-291">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-292">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-292">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-293">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-293">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-294">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-294">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-295">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-295">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-296">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-296">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-297">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-297">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-298">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-298">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-299">節點的類型是結果型別預先定義之位元`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-299">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-300">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-300">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-301">節點的類型為 null 的型別對應至結果型別預先定義之位元`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-301">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-302">下列程式碼範例示範如何建立運算式，表示這兩個布林值的邏輯 AND 運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-302">The following code example shows how to create an expression that represents a logical AND operation on two Boolean values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-303"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-303"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-304">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義位元 <see langword="AND" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-304">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-305">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-305">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-306">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-306">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-307">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-307">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-308">建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="AND" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-308">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span> <span data-ttu-id="a8eb2-309">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-309">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-310"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.And" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-311">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-311">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-312"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-312">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-313">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-313">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-314">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-314">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-315"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-315">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-316">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-316">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-317">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-317">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-318">作業的實作方法是選擇根據下列規則：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-318">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="a8eb2-319">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-319">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-320">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`AND`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-320">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-321">否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-321">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-322">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-322">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-323">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-323">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-324">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-324">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-325">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-325">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-326">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-326">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-327">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-327">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-328">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-328">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-329">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-329">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-330">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-330">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-331">節點的類型是結果型別預先定義之位元`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-331">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-332">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-332">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-333">節點的類型為 null 的型別對應至結果型別預先定義之位元`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-333">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-334"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-334"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-335"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-335"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-336"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的位元 <see langword="AND" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-336"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-337">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算元計算結果為 <see langword="AND" /> 時才求第二個運算元之值的 <see langword="true" /> 條件運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-338">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-338">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-339">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-339">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-340">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算元計算結果為 <see langword="AND" /> 時才求第二個運算元之值的 <see langword="true" /> 條件運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-340">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-341"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-342">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-342">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-343"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-343">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-344">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-344">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-345">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-345">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-346"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-346">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-347">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-347">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-348">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-348">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-349">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-349">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-350">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`AND`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-350">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a8eb2-351">條件式`AND`運算子無法多載以 C# 或 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-351">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="a8eb2-352">不過，條件式`AND`運算子會評估所使用的位元`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-352">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="a8eb2-353">因此，使用者定義的多載位元`AND`運算子可以是此節點類型的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-353">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="a8eb2-354">否則，如果`left`。型別和`right`。類型為布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-354">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-355">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-355">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-356">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-356">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-357">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-357">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-358">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-358">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-359">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-359">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-360">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個是可為 null，且對應的非 null 的型別相等相對應的引數類型的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-360">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-361">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-361">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-362">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-362">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-363">`left`.型別和`right`。型別都是相同的布林類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-363">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="a8eb2-364">如果`left`。型別和`right`。型別不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-364">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-365">節點的類型是預先定義的條件式的結果型別`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-365">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-366">如果`left`。型別和`right`。型別可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-366">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-367">節點的類型為 null 的型別對應至預先定義的條件式的結果型別`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-367">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-368">下列程式碼範例示範如何建立運算式，執行邏輯和作業，如果其兩個運算元在第一個運算元評估為`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-368">The following code example shows how to create an expression that performs a logical AND operation on its two operands only if the first operand evaluates to `true`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-369"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-369"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-370">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義位元 <see langword="AND" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-370">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-371">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-371">-or-</span></span> 
 <span data-ttu-id="a8eb2-372"><paramref name="left" />.Type 和 <paramref name="right" />.Type 是不相同的布林類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-372"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-373">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-373">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-374">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-374">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-375">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-375">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-376">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表只在第一個運算元解析為 true 時才評估第二個運算元的條件 <see langword="AND" /> 運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-376">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true.</span></span> <span data-ttu-id="a8eb2-377">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-377">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-378"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-379">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-379">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-380"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-380">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-381">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-381">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-382">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-382">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-383"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-383">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-384">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-384">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-385">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-385">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-386">作業的實作方法是選擇根據下列規則：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-386">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="a8eb2-387">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-387">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-388">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`AND`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-388">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a8eb2-389">條件式`AND`運算子無法多載以 C# 或 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-389">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="a8eb2-390">不過，條件式`AND`運算子會評估所使用的位元`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-390">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="a8eb2-391">因此，使用者定義的多載位元`AND`運算子可以是此節點類型的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-391">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="a8eb2-392">否則，如果`left`。型別和`right`。類型為布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-392">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-393">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-393">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-394">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-394">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-395">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-395">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-396">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-396">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-397">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-397">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-398">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個是可為 null，且對應的非 null 的型別相等相對應的引數類型的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-398">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-399">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-399">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-400">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-400">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-401">`left`.型別和`right`。型別都是相同的布林類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-401">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="a8eb2-402">如果`left`。型別和`right`。型別不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-402">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-403">節點的類型是預先定義的條件式的結果型別`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-403">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-404">如果`left`。型別和`right`。型別可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-404">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-405">節點的類型為 null 的型別對應至預先定義的條件式的結果型別`AND`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-405">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-406"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-406"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-407"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-407"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-408"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的位元 <see langword="AND" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-408"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-409">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-409">-or-</span></span> 
 <span data-ttu-id="a8eb2-410"><paramref name="method" /> 為 <see langword="null" />，且 <paramref name="left" />.Type 和 <paramref name="right" />.Type 不是相同的布林類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-410"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-411">建立表示位元 AND 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-411">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-412">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-412">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-413">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-413">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-414">建立表示位元 AND 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-414">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-415"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-416">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-416">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-417">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-417">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-418">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-418">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-419">建立表示位元 AND 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-420"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-421">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-422">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-423">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-423">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-424">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-425">建立表示位元 AND 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-426"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-427">建立 <see cref="T:System.Linq.Expressions.IndexExpression" /> 以存取陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-427">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a8eb2-428">表示多維陣列的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-428">An expression that represents the multidimensional array.</span></span></param>
        <param name="indexes"><span data-ttu-id="a8eb2-429">包含用於對陣列進行索引之運算式的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-429">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="a8eb2-430">建立 <see cref="T:System.Linq.Expressions.IndexExpression" /> 以存取多維陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-430">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-431">建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-431">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-432">表示陣列的運算式，可由使用<xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A>方法，或透過<xref:System.Linq.Expressions.Expression.NewArrayBounds%2A>或<xref:System.Linq.Expressions.Expression.NewArrayInit%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-432">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-433">下列程式碼範例示範如何使用變更的多維陣列中的項目值`ArrayAccess`方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-433">The following code example shows how to change the value of an element in a multidimensional array by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a8eb2-434">表示要編制索引之陣列的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-434">An expression representing the array to index.</span></span></param>
        <param name="indexes"><span data-ttu-id="a8eb2-435">包含用於對陣列進行索引之運算式的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-435">An array that contains expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="a8eb2-436">建立 <see cref="T:System.Linq.Expressions.IndexExpression" /> 以存取陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-436">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-437">建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-437">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-438">表示陣列的運算式，可由使用<xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A>方法，或透過<xref:System.Linq.Expressions.Expression.NewArrayBounds%2A>或<xref:System.Linq.Expressions.Expression.NewArrayInit%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-438">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
 <span data-ttu-id="a8eb2-439">針對多維陣列時，使用<xref:System.Linq.Expressions.Expression.ArrayAccess%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-439">For multidimensional arrays, use the <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-440">下列程式碼範例示範如何使用變更陣列元素的值`ArrayAccess`方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-440">The following code example shows how to change a value of an array element by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-441">建立 <see cref="T:System.Linq.Expressions.Expression" />，表示套用陣列索引運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-441">Creates an <see cref="T:System.Linq.Expressions.Expression" /> that represents applying an array index operator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a8eb2-442">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</span></span></param>
        <param name="indexes"><span data-ttu-id="a8eb2-443"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-443">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-444">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表將陣列索引運算子套用到陣序規範大於 1 的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-444">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-445"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-446">每個項目的`indexes`必須具有<xref:System.Linq.Expressions.Expression.Type%2A>等於<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-446">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="a8eb2-447"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`array`必須代表其陣序規範比對中的項目數的陣列類型`indexes`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-447">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="a8eb2-448">如果的陣序`array`。類型為 1，則這個方法會傳回<xref:System.Linq.Expressions.BinaryExpression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-448">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="a8eb2-449"><xref:System.Linq.Expressions.BinaryExpression.Left%2A>屬性設定為`array`並<xref:System.Linq.Expressions.BinaryExpression.Right%2A>屬性設定為單一項目`indexes`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-449">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="a8eb2-450"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性<xref:System.Linq.Expressions.BinaryExpression>代表項目類型`array`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-450">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="a8eb2-451">如果的陣序`array`。類型為多個，則這個方法會傳回<xref:System.Linq.Expressions.MethodCallExpression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-451">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="a8eb2-452"><xref:System.Linq.Expressions.MethodCallExpression.Method%2A>屬性設定為<xref:System.Reflection.MethodInfo>描述方法的公用執行個體`Get`上所代表的型別<xref:System.Linq.Expressions.Expression.Type%2A>屬性`array`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-452">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-453">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.MethodCallExpression>表示成二維陣列編製索引。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-453">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-454"><paramref name="array" /> 或 <paramref name="indexes" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-454"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-455"><paramref name="array" />.Type 不代表陣列類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-455"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="a8eb2-456">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-456">-or-</span></span> 
<span data-ttu-id="a8eb2-457"><paramref name="array" />.Type 的陣序規範不符合 <paramref name="indexes" /> 中的項目數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-457">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
<span data-ttu-id="a8eb2-458">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-458">-or-</span></span> 
<span data-ttu-id="a8eb2-459"><paramref name="indexes" /> 之一個或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不代表 <see cref="T:System.Int32" /> 類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-459">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a8eb2-460">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-460">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="index"><span data-ttu-id="a8eb2-461">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-461">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-462">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表將陣列索引運算子套用到陣序規範 1 的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-462">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-463"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-464">`index` 必須代表類型的索引<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-464">`index` must represent an index of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="a8eb2-465"><xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.BinaryExpression>是`null`，，同時兩者皆<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>設為`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-465">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null`, and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="a8eb2-466"><xref:System.Linq.Expressions.Expression.Type%2A>屬性等於的項目類型`array`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-466">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the element type of `array`.Type.</span></span> <span data-ttu-id="a8eb2-467"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-467">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-468"><paramref name="array" /> 或 <paramref name="index" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-468"><paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-469"><paramref name="array" />.Type 不代表陣列類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-469"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="a8eb2-470">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-470">-or-</span></span> 
 <span data-ttu-id="a8eb2-471"><paramref name="array" />.Type 代表其陣序規範不為 1 的陣列類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-471"><paramref name="array" />.Type represents an array type whose rank is not 1.</span></span>  
  
<span data-ttu-id="a8eb2-472">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-472">-or-</span></span> 
 <span data-ttu-id="a8eb2-473"><paramref name="index" />.Type 不代表 <see cref="T:System.Int32" /> 類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-473"><paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a8eb2-474"><see cref="T:System.Linq.Expressions.Expression" /> 執行個體 (用於陣列索引運算的索引) 的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-474">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</span></span></param>
        <param name="indexes"><span data-ttu-id="a8eb2-475">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-475">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-476">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表將陣列索引運算子套用到多維陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-476">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-477"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-478">每個項目的`indexes`必須具有<xref:System.Linq.Expressions.Expression.Type%2A>等於<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-478">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="a8eb2-479"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`array`必須代表其陣序規範比對中的項目數的陣列類型`indexes`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-479">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="a8eb2-480">如果的陣序`array`。類型為 1，則這個方法會傳回<xref:System.Linq.Expressions.BinaryExpression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-480">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="a8eb2-481"><xref:System.Linq.Expressions.BinaryExpression.Left%2A>屬性設定為`array`並<xref:System.Linq.Expressions.BinaryExpression.Right%2A>屬性設定為單一項目`indexes`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-481">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="a8eb2-482"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性<xref:System.Linq.Expressions.BinaryExpression>代表項目類型`array`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-482">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="a8eb2-483">如果的陣序`array`。類型為多個，則這個方法會傳回<xref:System.Linq.Expressions.MethodCallExpression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-483">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="a8eb2-484"><xref:System.Linq.Expressions.MethodCallExpression.Method%2A>屬性設定為<xref:System.Reflection.MethodInfo>描述方法的公用執行個體`Get`上所代表的型別<xref:System.Linq.Expressions.Expression.Type%2A>屬性`array`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-484">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-485">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.MethodCallExpression>表示成二維陣列編製索引。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-485">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-486"><paramref name="array" /> 或 <paramref name="indexes" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-486"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-487"><paramref name="array" />.Type 不代表陣列類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-487"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="a8eb2-488">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-488">-or-</span></span> 
<span data-ttu-id="a8eb2-489"><paramref name="array" />.Type 的陣序規範不符合 <paramref name="indexes" /> 中的項目數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-489">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
<span data-ttu-id="a8eb2-490">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-490">-or-</span></span> 
<span data-ttu-id="a8eb2-491"><paramref name="indexes" /> 之一個或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不代表 <see cref="T:System.Int32" /> 類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-491">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a8eb2-492">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-492">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-493">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表用於取得一維陣列長度的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-493">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-494"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性等於 <paramref name="array" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-495"><xref:System.Linq.Expressions.Expression.Type%2A>屬性`array`必須代表陣列型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-495">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type.</span></span>  
  
 <span data-ttu-id="a8eb2-496"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>等於<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-496">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is equal to <xref:System.Int32>.</span></span> <span data-ttu-id="a8eb2-497"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性是`null`，並同時<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>設為`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-497">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`, and both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-498"><paramref name="array" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-498"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-499"><paramref name="array" />.Type 不代表陣列類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-499"><paramref name="array" />.Type does not represent an array type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-500">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-501">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-502">建立代表指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-503"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Assign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-504">`Assign`運算式複製實值類型的值，而且會複製參考類型的參考。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-504">The `Assign` expression copies a value for value types, and it copies a reference for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-505">下列程式碼範例示範如何建立代表指派運算的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-505">The following code example shows how to create an expression that represents an assignment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-506">建立代表成員初始化的 <see cref="T:System.Linq.Expressions.MemberAssignment" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-506">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="a8eb2-507">要將 <see cref="T:System.Reflection.MemberInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-507">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="expression"><span data-ttu-id="a8eb2-508">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-509">建立 <see cref="T:System.Linq.Expressions.MemberAssignment" />，代表初始化欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-509">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-510"><see cref="T:System.Linq.Expressions.MemberAssignment" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 等於 <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-511"><xref:System.Linq.Expressions.Expression.Type%2A>屬性`expression`必須是指派給所代表的型別<xref:System.Reflection.FieldInfo.FieldType%2A>或是<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性`member`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-511">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.FieldInfo.FieldType%2A> or <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of `member`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-512"><paramref name="member" /> 或 <paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-512"><paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-513"><paramref name="member" /> 不代表欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-513"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="a8eb2-514">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-514">-or-</span></span> 
<span data-ttu-id="a8eb2-515"><paramref name="member" /> 所表示的屬性沒有 <see langword="set" /> 存取子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-515">The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.</span></span>  
  
<span data-ttu-id="a8eb2-516">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-516">-or-</span></span> 
 <span data-ttu-id="a8eb2-517">無法將 <paramref name="expression" />.Type 指派給 <paramref name="member" /> 代表的欄位或屬性類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-517"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="a8eb2-518">代表屬性存取子方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-518">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="expression"><span data-ttu-id="a8eb2-519">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-520">建立 <see cref="T:System.Linq.Expressions.MemberAssignment" />，代表使用屬性存取子方法初始化成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-520">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-521"><see cref="T:System.Linq.Expressions.MemberAssignment" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，代表在 <paramref name="propertyAccessor" /> 中存取的屬性，以及將 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> 屬性設定為 <paramref name="expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-522"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`expression`必須是指派給所代表的型別<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性中存取的屬性`propertyAccessor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-522">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the property accessed in `propertyAccessor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-523"><paramref name="propertyAccessor" /> 或 <paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-523"><paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-524"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-524"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="a8eb2-525">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-525">-or-</span></span> 
<span data-ttu-id="a8eb2-526"><paramref name="propertyAccessor" /> 所存取的屬性沒有 <see langword="set" /> 存取子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-526">The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.</span></span>  
  
<span data-ttu-id="a8eb2-527">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-527">-or-</span></span> 
 <span data-ttu-id="a8eb2-528">無法將 <paramref name="expression" />.Type 指派給 <paramref name="member" /> 代表的欄位或屬性類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-528"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-529">建立 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-529">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="a8eb2-530">區塊中的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-530">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-531">建立包含指定的運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-531">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-532">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-532">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-533">區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-533">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="a8eb2-534">區塊中的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-534">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-535">建立包含指定的運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-535">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-536">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-536">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-537">區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-537">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-538">下列程式碼範例示範如何建立區塊的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-538">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="a8eb2-539">區塊運算式包含兩個<xref:System.Linq.Expressions.MethodCallExpression>物件，另一個<xref:System.Linq.Expressions.ConstantExpression>物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-539">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="a8eb2-540">區塊中的變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-540">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="a8eb2-541">區塊中的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-541">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-542">建立包含指定之變數和運算式的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-542">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-543">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-543">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-544">區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-544">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-545">下列程式碼範例示範如何將參數傳遞給區塊的運算式，並處理區塊內的這個參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-545">The following code example shows how to pass a parameter to a block expression and process this parameter within a block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="a8eb2-546">區塊中的變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-546">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="a8eb2-547">區塊中的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-547">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-548">建立包含指定之變數和運算式的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-548">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-549">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-549">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-550">區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-550">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="a8eb2-551">區塊中的第一個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-551">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-552">區塊中的第二個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-552">The second expression in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-553">建立包含兩個運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-553">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-554">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-554">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-555">區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-555">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-556">區塊的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-556">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="a8eb2-557">區塊中的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-557">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-558">建立包含指定的運算式、有指定之結果類型、但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-558">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-559">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-559">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-560">區塊的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-560">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="a8eb2-561">區塊中的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-561">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-562">建立包含指定的運算式、有指定之結果類型、但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-562">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-563">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-563">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="a8eb2-564">區塊中的第一個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-564">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-565">區塊中的第二個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-565">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-566">區塊中的第三個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-566">The third expression in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-567">建立包含三個運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-567">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-568">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-568">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-569">區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-569">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-570">區塊的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-570">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="a8eb2-571">區塊中的變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-571">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="a8eb2-572">區塊中的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-572">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-573">建立包含指定之變數和運算式的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-573">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-574">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-574">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-575">區塊的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-575">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="a8eb2-576">區塊中的變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-576">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="a8eb2-577">區塊中的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-577">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-578">建立包含指定之變數和運算式的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-578">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-579">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-579">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="a8eb2-580">區塊中的第一個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-580">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-581">區塊中的第二個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-581">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-582">區塊中的第三個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-582">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="a8eb2-583">區塊中的第四個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-583">The fourth expression in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-584">建立包含四個運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-584">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-585">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-585">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-586">區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-586">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="a8eb2-587">區塊中的第一個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-587">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-588">區塊中的第二個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-588">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-589">區塊中的第三個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-589">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="a8eb2-590">區塊中的第四個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-590">The fourth expression in the block.</span></span></param>
        <param name="arg4"><span data-ttu-id="a8eb2-591">區塊中的第五個運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-591">The fifth expression in the block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-592">建立包含五個運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-592">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-593">建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-593">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-594">區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-594">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-595">建立表示 break 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-595">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-596"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-596">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-597">建立表示 break 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-597">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-598"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Break、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且包含在跳躍時傳遞至目標標籤的 Null 值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-599">下列範例示範如何建立包含的運算式<xref:System.Linq.Expressions.LoopExpression>物件，使用<xref:System.Linq.Expressions.Expression.Break%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-599">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LoopExpression> object that uses the <xref:System.Linq.Expressions.Expression.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-600"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-600">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="a8eb2-601">將在跳躍時傳遞至關聯標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-601">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="a8eb2-602">建立表示 break 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-602">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span> <span data-ttu-id="a8eb2-603">可以指定跳躍時傳遞至標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-603">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-604"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Break、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-605"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-605">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-606">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-606">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-607">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 break 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-607">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-608"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Break、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-609"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-609">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="a8eb2-610">將在跳躍時傳遞至關聯標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-610">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-611">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-611">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-612">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 break 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-612">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span> <span data-ttu-id="a8eb2-613">可以指定跳躍時傳遞至標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-613">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-614"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Break、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-615">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-615">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-616"><see cref="T:System.Linq.Expressions.Expression" />，指定執行個體方法呼叫的執行個體 (對 <see langword="null" /> (在 Visual Basic 中為 <see langword="static" />) 方法會傳遞 <see langword="Shared" />)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-616">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-617">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-617">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-618">建立代表呼叫不採用任何引數之方法的 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-618">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-619"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-620">若要代表呼叫`static`(`Shared` Visual Basic 中) 方法，請傳入`null`如`instance`時呼叫這個方法的參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-620">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method.</span></span>  
  
 <span data-ttu-id="a8eb2-621">如果`method`代表執行個體方法，<xref:System.Linq.Expressions.Expression.Type%2A>屬性`instance`必須是指派給所表示之方法的宣告型別`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-621">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="a8eb2-622"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>是空的。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-622">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty.</span></span> <span data-ttu-id="a8eb2-623"><xref:System.Linq.Expressions.Expression.Type%2A>屬性所表示之方法的傳回型別等於`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-623">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the return type of the method represented by `method`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-624">下列程式碼範例示範如何建立運算式，會呼叫不含引數的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-624">The following code example shows how to create an expression that calls a method without arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-625"><paramref name="method" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-625"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-626">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-626">-or-</span></span> 
 <span data-ttu-id="a8eb2-627"><paramref name="instance" /> 為 <see langword="null" />，<paramref name="method" /> 則代表執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-627"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-628"><paramref name="instance" />.Type 無法指派給 <paramref name="method" /> 所代表之方法的宣告類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-628"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a8eb2-629">表示目標方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-629">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-630"><see cref="T:System.Linq.Expressions.Expression" /> 的集合，代表呼叫引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-630">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</span></span></param>
        <summary><span data-ttu-id="a8eb2-631">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫靜態方法 (在 Visual Basic 中為共用方法)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-631">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-632"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a8eb2-633">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-633">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-634">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-634">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <summary><span data-ttu-id="a8eb2-635">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用一個引數的 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-635">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-636"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-637">下列範例示範如何建立運算式，會呼叫`static`(`Shared` Visual Basic 中) 採用一個引數的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-637">The following example demonstrates how to create an expression that calls a `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-638"><paramref name="method" /> 為 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-638"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a8eb2-639"><see cref="T:System.Reflection.MethodInfo" />，代表 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法，將 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為與之相等。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-639">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-640">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-640">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-641">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫有引數的 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-641">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-642"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-643">如果`arguments`不是`null`，它必須有相同數目的元素所代表之方法的參數數目為`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-643">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="a8eb2-644">在每個項目`arguments`不得`null`，而且必須是指派給對應的參數`method`，可能之後*加註引號於*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-644">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-645">只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-645">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-646">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-646">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-647">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-647">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="a8eb2-648"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>是空的如果`arguments`是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-648">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="a8eb2-649">否則，它包含相同的項目，做為`arguments`，其中有些可能會加上引號。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-649">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="a8eb2-650"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-650">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span> <span data-ttu-id="a8eb2-651"><xref:System.Linq.Expressions.MethodCallExpression.Object%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-651">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-652"><paramref name="method" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-652"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-653"><paramref name="arguments" /> 中的項目數不等於 <paramref name="method" />所代表之方法的參數數目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-653">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="a8eb2-654">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-654">-or-</span></span> 
<span data-ttu-id="a8eb2-655"><paramref name="arguments" /> 的一或多個項目無法指派給 <paramref name="method" /> 所代表之方法的對應參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-655">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-656">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> (針對 <see langword="null" /> (在 Visual Basic 中為 <see langword="static" />) 方法傳遞 <see langword="Shared" />)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-656">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-657">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-657">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-658"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-659">建立代表呼叫至採用引數之方法的 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-659">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-660"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-661">若要代表呼叫`static`(`Shared` Visual Basic 中) 方法，請傳入`null`如`instance`參數，當您呼叫此方法，或呼叫<xref:System.Linq.Expressions.Expression.Call%2A>改為。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-661">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="a8eb2-662">如果`method`代表執行個體方法，<xref:System.Linq.Expressions.Expression.Type%2A>屬性`instance`必須是指派給所表示之方法的宣告型別`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-662">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="a8eb2-663">如果`arguments`不是`null`，它必須有相同數目的元素所代表之方法的參數數目為`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-663">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="a8eb2-664">在每個項目`arguments`不得`null`，而且必須是指派給對應的參數`method`，可能之後*加註引號於*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-664">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-665">只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-665">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-666">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-666">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-667">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-667">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="a8eb2-668"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>是空的如果`arguments`是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-668">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="a8eb2-669">否則，它包含相同的項目，做為`arguments`，其中有些可能會加上引號。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-669">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="a8eb2-670"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-670">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-671"><paramref name="method" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-671"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-672">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-672">-or-</span></span> 
 <span data-ttu-id="a8eb2-673"><paramref name="instance" /> 為 <see langword="null" />，<paramref name="method" /> 則代表執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-673"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-674"><paramref name="instance" />.Type 無法指派給 <paramref name="method" /> 所代表之方法的宣告類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-674"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="a8eb2-675">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-675">-or-</span></span> 
<span data-ttu-id="a8eb2-676"><paramref name="arguments" /> 中的項目數不等於 <paramref name="method" />所代表之方法的參數數目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-676">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="a8eb2-677">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-677">-or-</span></span> 
<span data-ttu-id="a8eb2-678"><paramref name="arguments" /> 的一或多個項目無法指派給 <paramref name="method" /> 所代表之方法的對應參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-678">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-679"><see cref="T:System.Linq.Expressions.Expression" />，指定執行個體方法呼叫的執行個體 (對 <see langword="null" /> (在 Visual Basic 中為 <see langword="static" />) 方法會傳遞 <see langword="Shared" />)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-679">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-680">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-680">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-681">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-681">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-682">建立代表呼叫至採用引數之方法的 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-682">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-683"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-684">若要代表呼叫`static`(`Shared` Visual Basic 中) 方法，請傳入`null`如`instance`參數，當您呼叫此方法，或呼叫<xref:System.Linq.Expressions.Expression.Call%2A>改為。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-684">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="a8eb2-685">如果`method`代表執行個體方法，<xref:System.Linq.Expressions.Expression.Type%2A>屬性`instance`必須是指派給所表示之方法的宣告型別`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-685">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="a8eb2-686">如果`arguments`不是`null`，它必須有相同數目的元素所代表之方法的參數數目為`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-686">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="a8eb2-687">在每個項目`arguments`不得`null`，而且必須是指派給對應的參數`method`，可能之後*加註引號於*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-687">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-688">只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-688">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-689">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-689">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-690">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-690">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="a8eb2-691"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>是空的如果`arguments`是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-691">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="a8eb2-692">否則，它包含相同的項目，做為`arguments`，其中有些可能會加上引號。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-692">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="a8eb2-693"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`method`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-693">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-694"><paramref name="method" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-694"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-695">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-695">-or-</span></span> 
 <span data-ttu-id="a8eb2-696"><paramref name="instance" /> 為 <see langword="null" />，<paramref name="method" /> 則代表執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-696"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span>  
  
<span data-ttu-id="a8eb2-697">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-697">-or-</span></span> 
 <span data-ttu-id="a8eb2-698"><paramref name="arguments" /> 不是 <see langword="null" />，且它的一或多個子項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-698"><paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-699"><paramref name="instance" />.Type 無法指派給 <paramref name="method" /> 所代表之方法的宣告類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-699"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="a8eb2-700">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-700">-or-</span></span> 
<span data-ttu-id="a8eb2-701"><paramref name="arguments" /> 中的項目數不等於 <paramref name="method" />所代表之方法的參數數目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-701">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="a8eb2-702">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-702">-or-</span></span> 
<span data-ttu-id="a8eb2-703"><paramref name="arguments" /> 的一或多個項目無法指派給 <paramref name="method" /> 所代表之方法的對應參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-703">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a8eb2-704">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-704">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-705">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-705">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-706">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-706">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="a8eb2-707">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用兩個引數的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-707">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-708"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-709"><paramref name="method" /> 為 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-709"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-710">為執行個體呼叫指定執行個體的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-710">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="a8eb2-711">(對靜態方法 (在 Visual Basic 中為共用方法) 傳遞 Null)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-711">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-712">表示目標方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-712">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-713">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-713">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-714">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-714">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="a8eb2-715">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用兩個引數的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-715">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-716"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-717">下列程式碼範例示範如何建立會呼叫執行個體方法具有兩個引數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-717">The following code example shows how to create an expression that calls an instance method that has two arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-718"><see cref="T:System.Linq.Expressions.Expression" />，將搜尋其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性值中的特定方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-718">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</span></span></param>
        <param name="methodName"><span data-ttu-id="a8eb2-719">方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-719">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="a8eb2-720"><see cref="T:System.Type" /> 物件的陣列，這些物件可指定泛型方法的類型參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-720">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="a8eb2-721">當 methodName 指定非泛型方法時，這個引數應該為 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-721">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-722"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，這個陣列代表方法的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-722">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-723">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表透過呼叫適當的 Factory 方法來呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-723">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-724"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 屬性等於 <paramref name="instance" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 設定為代表指定執行個體方法的 <see cref="T:System.Reflection.MethodInfo" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 設定為指定的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-725"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`methodName`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-725">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-726"><paramref name="instance" /> 或 <paramref name="methodName" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-726"><paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-727"><paramref name="methodName" />.Type 或其基底類型中找不到名稱為 <paramref name="typeArguments" />、其類型參數符合 <paramref name="arguments" />，且參數類型符合 <paramref name="instance" /> 的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-727">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span>  
  
<span data-ttu-id="a8eb2-728">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-728">-or-</span></span> 
<span data-ttu-id="a8eb2-729"><paramref name="methodName" />.Type 或其基底類型中找到多個名稱為 <paramref name="typeArguments" />、類型參數符合 <paramref name="arguments" />，且參數類型符合 <paramref name="instance" /> 的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-729">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a8eb2-730">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-730">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-731">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-731">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-732">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-732">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-733">表示第三個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-733">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="a8eb2-734">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用三個引數的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-734">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-735"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-736"><paramref name="method" /> 為 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-736"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-737"><see cref="T:System.Type" />，指定包含所指定 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-737">The <see cref="T:System.Type" /> that specifies the type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</span></span></param>
        <param name="methodName"><span data-ttu-id="a8eb2-738">方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-738">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="a8eb2-739"><see cref="T:System.Type" /> 物件的陣列，這些物件可指定泛型方法的類型參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-739">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="a8eb2-740">當 methodName 指定非泛型方法時，這個引數應該為 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-740">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-741"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，這個陣列代表方法的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-741">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-742">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表透過呼叫適當的 Factory 方法來呼叫 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-742">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-743"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為 <see cref="T:System.Reflection.MethodInfo" />，代表指定的 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-744"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`methodName`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-744">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span> <span data-ttu-id="a8eb2-745"><xref:System.Linq.Expressions.MethodCallExpression.Object%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-745">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-746"><paramref name="type" /> 或 <paramref name="methodName" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-746"><paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-747"><paramref name="methodName" /> 或其基底類型中找不到名稱為 <paramref name="typeArguments" />、類型參數符合 <paramref name="arguments" />，且參數類型符合 <paramref name="type" /> 的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-747">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span>  
  
<span data-ttu-id="a8eb2-748">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-748">-or-</span></span> 
<span data-ttu-id="a8eb2-749"><paramref name="methodName" /> 或其基底類型中找到多個名稱為 <paramref name="typeArguments" />、類型參數符合 <paramref name="arguments" />，且參數類型符合 <paramref name="type" /> 的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-749">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-750">為執行個體呼叫指定執行個體的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-750">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="a8eb2-751">(對靜態方法 (在 Visual Basic 中為共用方法) 傳遞 Null)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-751">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-752">表示目標方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-752">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-753">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-753">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-754">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-754">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-755">表示第三個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-755">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="a8eb2-756">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用三個引數的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-756">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-757"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a8eb2-758">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-758">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-759">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-759">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-760">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-760">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-761">表示第三個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-761">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="a8eb2-762">表示第四個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-762">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <summary><span data-ttu-id="a8eb2-763">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用四個引數的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-763">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-764"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-765"><paramref name="method" /> 為 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-765"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a8eb2-766">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-766">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-767">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-767">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-768">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-768">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-769">表示第三個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-769">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="a8eb2-770">表示第四個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-770">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <param name="arg4"><span data-ttu-id="a8eb2-771">表示第五個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-771">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</span></span></param>
        <summary><span data-ttu-id="a8eb2-772">建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用五個引數的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-772">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-773"><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-774"><paramref name="method" /> 為 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-774"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a8eb2-775">表示節點可精簡為更簡單的節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-775">Indicates that the node can be reduced to a simpler node.</span></span> <span data-ttu-id="a8eb2-776">如果傳回 true，則可呼叫 Reduce() 以產生精簡的形式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-776">If this returns true, Reduce() can be called to produce the reduced form.</span></span></summary>
        <value><span data-ttu-id="a8eb2-777">如果節點可以精簡則為 true，否則為 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-777">True if the node can be reduced, otherwise false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-778">建立代表 catch 陳述式的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-778">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="a8eb2-779"><see cref="T:System.Linq.Expressions.ParameterExpression" />，代表這個處理常式所攔截 <see cref="T:System.Exception" /> 物件的參考。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-780">catch 陳述式的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-780">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="a8eb2-781">建立 <see cref="T:System.Linq.Expressions.CatchBlock" />，代表包含已攔截 <see cref="T:System.Exception" /> 物件參考的 catch 陳述式，以便用於處理常式主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-781">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-782">建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-782">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-783">這個 <see cref="P:System.Linq.Expressions.Expression.Type" /> 將處理之 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-783">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-784">catch 陳述式的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-784">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="a8eb2-785">建立代表 catch 陳述式的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-785">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-786">建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-786">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-787"><xref:System.Linq.Expressions.Expression.Type%2A>的<xref:System.Exception>攔截可以指定但沒有參考<xref:System.Exception>物件都會是可用於<xref:System.Linq.Expressions.CatchBlock>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-787">The <xref:System.Linq.Expressions.Expression.Type%2A> of <xref:System.Exception> to be caught can be specified but no reference to the <xref:System.Exception> object will be available for use in the <xref:System.Linq.Expressions.CatchBlock>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="a8eb2-788"><see cref="T:System.Linq.Expressions.ParameterExpression" />，代表這個處理常式所攔截 <see cref="T:System.Exception" /> 物件的參考。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-789">catch 陳述式的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-789">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="a8eb2-790"><see cref="T:System.Exception" /> 篩選條件的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-790">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="a8eb2-791">建立 <see cref="T:System.Linq.Expressions.CatchBlock" />，代表包含 <see cref="T:System.Exception" /> 篩選條件和已攔截 <see cref="T:System.Exception" /> 物件參考的 catch 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-791">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-792">建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-792">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-793">這個 <see cref="P:System.Linq.Expressions.Expression.Type" /> 將處理之 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-793">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-794">catch 陳述式的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-794">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="a8eb2-795"><see cref="T:System.Exception" /> 篩選條件的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-795">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="a8eb2-796">建立 <see cref="T:System.Linq.Expressions.CatchBlock" />，代表包含 <see cref="T:System.Exception" /> 篩選條件但沒有已攔截 <see cref="T:System.Exception" /> 物件參考的 catch 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-796">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-797">建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-797">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="a8eb2-798">表示原始程式檔的 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-798">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <summary><span data-ttu-id="a8eb2-799">建立用於清除序列點的 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-799">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-800"><see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的執行個體，用於清除序列點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-800">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearning a sequence point.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-801">建立代表聯合運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-801">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-802">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-803">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-803">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-804">建立代表聯合運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-804">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-805"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-806"><xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.BinaryExpression>是`null`，同時兩者皆<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>設為`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-806">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="a8eb2-807"><xref:System.Linq.Expressions.Expression.Type%2A>屬性等於聯合運算的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-807">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the result type of the coalescing operation.</span></span> <span data-ttu-id="a8eb2-808"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-808">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
#### <a name="result-type"></a><span data-ttu-id="a8eb2-809">結果類型</span><span class="sxs-lookup"><span data-stu-id="a8eb2-809">Result Type</span></span>  
 <span data-ttu-id="a8eb2-810">下列規則決定的結果型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-810">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="a8eb2-811">如果`left`。類型代表可為 null 的型別和`right`。類型是隱含地轉換成對應的非 null 的型別，結果型別是不可為 null 相當於`left`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-811">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="a8eb2-812">否則，如果`right`。類型是隱含地轉換成`left`。類型的結果型別是`left`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-812">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="a8eb2-813">否則，如果不可為 null 相當於`left`。類型是隱含地轉換成`right`。類型的結果型別是`right`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-813">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-814"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-814"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-815"><paramref name="left" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不表示參考類型或可為 Null 的實值類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-816"><paramref name="left" />.Type 和 <paramref name="right" />.Type 無法相互轉換。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-816"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/088b1f0d-c1af-4fe1-b4b8-196fd5ea9132"><span data-ttu-id="a8eb2-817">??</span><span class="sxs-lookup"><span data-stu-id="a8eb2-817">??</span></span> <span data-ttu-id="a8eb2-818">運算子 (C# 參考)</span><span class="sxs-lookup"><span data-stu-id="a8eb2-818">Operator (C# Reference)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-819">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-819">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-820">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-820">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-821">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-821">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-822">指定轉換函式，建立代表聯合運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-822">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-823"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-823">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-824"><xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.BinaryExpression>是`null`，同時兩者皆<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>設為`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-824">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 <span data-ttu-id="a8eb2-825"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.BinaryExpression>等於聯合運算的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is equal to the result type of the coalescing operation.</span></span>  
  
 <span data-ttu-id="a8eb2-826">下列規則決定的結果型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-826">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="a8eb2-827">如果`left`。類型代表可為 null 的型別和`right`。類型是隱含地轉換成對應的非 null 的型別，結果型別是不可為 null 相當於`left`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-827">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="a8eb2-828">否則，如果`right`。類型是隱含地轉換成`left`。類型的結果型別是`left`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-828">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="a8eb2-829">否則，如果不可為 null 相當於`left`。類型是隱含地轉換成`right`。類型的結果型別是`right`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-829">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-830"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-830"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-831"><paramref name="left" />.Type 和 <paramref name="right" />.Type 無法相互轉換。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-831"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span>  
  
<span data-ttu-id="a8eb2-832">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-832">-or-</span></span> 
 <span data-ttu-id="a8eb2-833"><paramref name="conversion" /> 不是 <see langword="null" />，且 <paramref name="conversion" />.Type 為委派類型，其採用的引數不是剛好一個。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-833"><paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-834"><paramref name="left" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不表示參考類型或可為 Null 的實值類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span>  
  
<span data-ttu-id="a8eb2-835">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-835">-or-</span></span> 
<span data-ttu-id="a8eb2-836"><paramref name="left" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所表示的類型無法指派至委派類型 <paramref name="conversion" />.Type 的參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-836">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-837">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-837">-or-</span></span> 
<span data-ttu-id="a8eb2-838"><paramref name="right" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不等於委派類型 <paramref name="conversion" />.Type 的傳回類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-838">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-839">建立表示條件陳述式的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-839">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="a8eb2-840">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-840">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="a8eb2-841">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-841">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="a8eb2-842">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-842">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-843">建立表示條件陳述式的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-843">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-844"><see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-844">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-845"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ConditionalExpression>等於<xref:System.Linq.Expressions.Expression.Type%2A>屬性`ifTrue`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-845">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConditionalExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `ifTrue`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-846">下列程式碼範例示範如何建立表示條件陳述式的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-846">The following code example shows how to create an expression that represents a conditional statement.</span></span> <span data-ttu-id="a8eb2-847">如果第一個引數評估為`true`第二個引數執行; 否則會執行第三個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-847">If the first argument evaluates to `true`, the second argument is executed; otherwise, the third argument is executed.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-848"><paramref name="test" />、<paramref name="ifTrue" /> 或 <paramref name="ifFalse" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-848"><paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-849"><paramref name="test" />.Type 不是 <see cref="T:System.Boolean" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-849"><paramref name="test" />.Type is not <see cref="T:System.Boolean" />.</span></span>  
  
<span data-ttu-id="a8eb2-850">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-850">-or-</span></span> 
 <span data-ttu-id="a8eb2-851"><paramref name="ifTrue" />.Type 不等於 <paramref name="ifFalse" />.Type。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-851"><paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</span></span></exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="a8eb2-852">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="a8eb2-853">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-853">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="a8eb2-854">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-854">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-855">要將 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-855">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-856">建立表示條件陳述式的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-856">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-857"><see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-857">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-858">這個方法可讓明確統一的情況下的條件式運算式的結果型別其中的型別`ifTrue`和`ifFalse`運算式是否不相等。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-858">This method allows explicitly unifying the result type of the conditional expression in cases where the types of `ifTrue` and `ifFalse` expressions are not equal.</span></span> <span data-ttu-id="a8eb2-859">這兩種`ifTrue`和`ifFalse`必須可隱含地參考指派給結果型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-859">Types of both `ifTrue` and `ifFalse` must be implicitly reference assignable to the result type.</span></span> <span data-ttu-id="a8eb2-860">`type`允許為<xref:System.Void>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-860">The `type` is allowed to be <xref:System.Void>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-861">建立 <see cref="T:System.Linq.Expressions.ConstantExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-861">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a8eb2-862">要將 <see cref="T:System.Object" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-862">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-863">建立 <see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-863">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-864"><see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Constant" />，而 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-864">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-865"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ConstantExpression>的型別等於`value`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-865">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConstantExpression> is equal to the type of `value`.</span></span> <span data-ttu-id="a8eb2-866">如果`value`已`null`，<xref:System.Linq.Expressions.Expression.Type%2A>等於<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-866">If `value` is `null`, <xref:System.Linq.Expressions.Expression.Type%2A> is equal to <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="a8eb2-867">若要代表`null`，您也可以使用<xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29>方法，與您可以明確指定類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-867">To represent `null`, you can also use the <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> method, with which you can explicitly specify the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-868">下列程式碼範例示範如何建立代表常數值的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-868">The following code example shows how to create an expression that represents a constant value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a8eb2-869">要將 <see cref="T:System.Object" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-869">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-870">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-870">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-871">建立 <see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-871">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-872"><see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Constant" />，且 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-872">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-873">這個方法可用於代表可為 null 類型的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-873">This method can be useful for representing values of nullable types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-874">下列程式碼範例示範如何建立代表可為 null 類型的常數運算式，並將其值設定為`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-874">The following code example shows how to create an expression that represents a constant of the nullable type and set its value to `null`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-875"><paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-875"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-876"><paramref name="value" /> 不為 <see langword="null" />，且 <paramref name="type" /> 無法從 <paramref name="value" /> 的動態類型指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-876"><paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-877">建立代表 continue 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-877">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-878"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-878">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-879">建立代表 continue 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-879">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-880"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Continue、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且包含在跳躍時傳遞至目標標籤的 Null 值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-880">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-881">下列範例示範如何建立會使用的迴圈運算式<xref:System.Linq.Expressions.Expression.Continue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-881">The following example demonstrates how to create a loop expression that uses the <xref:System.Linq.Expressions.Expression.Continue%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-882"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-882">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-883">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-883">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-884">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，代表含指定之類型的 continue 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-884">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-885"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Continue、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 null 值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-885">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-886">建立代表類型轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-886">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-887">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-887">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-888">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-888">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-889">建立代表類型轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-889">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-890"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-890">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-891"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-891">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-892"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 屬性為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-892">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="a8eb2-893">則會消除節點，如果<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-893">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="a8eb2-894">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-894">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-895">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-895">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-896">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-896">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-897">如果有任一個`expression`。型別或`type`是使用者定義型別定義的隱含或明確轉換運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-897">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-898">否則就是：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-898">Otherwise:</span></span>  
  
    -   <span data-ttu-id="a8eb2-899">如果兩個`expression`。型別和`type`代表數值或布林值類型或可為 null 或非可為 null 的列舉類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-899">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="a8eb2-900">如果有任一個`expression`。型別或`type`是參考類型，明確的 boxing 處理，unboxing，或參考轉換存在從`expression`。若要輸入`type`，則實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-900">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-901">已消除或非消除</span><span class="sxs-lookup"><span data-stu-id="a8eb2-901">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-902">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-902">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-903">如果`expression`。類型是指派給實作方法的引數類型，且實作的方法的傳回型別指派給`type`，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-903">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="a8eb2-904">如果一或兩個的`expression`。型別或`type`是 null 的實值類型，而且對應的非可為 null 的實值型別分別等於引數類型和實作方法的傳回型別，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-904">If one or both of `expression`.Type or `type` is a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="a8eb2-905">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-905">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-906">如果兩個`expression`。型別和`type`都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-906">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="a8eb2-907">否則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-907">Otherwise the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-908">下列程式碼範例示範如何建立運算式，表示型別轉換作業。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-908">The following code example shows how to create an expression that represents a type convertion operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-909"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-909"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-910"><paramref name="expression" />.Type 和 <paramref name="type" /> 之間未定義轉換運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-910">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-911">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-912">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-912">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-913">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-913">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-914">建立代表轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />，此轉換作業已指定實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-914">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-915"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-915">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-916"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-916">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-917"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 屬性為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-917">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="a8eb2-918">則會消除節點，如果<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-918">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="a8eb2-919">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-919">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-920">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-920">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-921">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-921">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-922">如果方法不是`null`，它是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-922">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="a8eb2-923">它必須代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-923">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="a8eb2-924">否則，如果`expression`。型別或`type`是使用者定義型別定義的隱含或明確轉換運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-924">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-925">否則就是：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-925">Otherwise:</span></span>  
  
    -   <span data-ttu-id="a8eb2-926">如果兩個`expression`。型別和`type`代表數值或布林值類型或可為 null 或非可為 null 的列舉類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-926">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="a8eb2-927">如果有任一個`expression`。型別或`type`是參考類型，明確的 boxing 處理，unboxing，或參考轉換存在從`expression`。若要輸入`type`，則實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-927">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-928">已消除或非消除</span><span class="sxs-lookup"><span data-stu-id="a8eb2-928">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-929">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-929">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-930">如果`expression`。類型是指派給實作方法的引數類型，且實作的方法的傳回型別指派給`type`，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-930">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="a8eb2-931">如果任一個或兩個的`expression`。型別或`type`可為 null 的實值型別而且分別為相等的引數類型和實作方法的傳回型別對應的非可為 null 的實值型別，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-931">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="a8eb2-932">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-932">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-933">如果兩個`expression`。型別和`type`都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-933">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="a8eb2-934">否則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-934">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-935"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-935"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-936"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-936"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-937"><paramref name="expression" />.Type 和 <paramref name="type" /> 之間未定義轉換運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-937">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
<span data-ttu-id="a8eb2-938">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-938">-or-</span></span> 
 <span data-ttu-id="a8eb2-939"><paramref name="expression" />.Type 無法指派給 <paramref name="method" /> 所代表方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-939"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="a8eb2-940">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-940">-or-</span></span> 
<span data-ttu-id="a8eb2-941"><paramref name="method" /> 所代表方法的傳回類型無法指派給 <paramref name="type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-941">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
<span data-ttu-id="a8eb2-942">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-942">-or-</span></span> 
 <span data-ttu-id="a8eb2-943"><paramref name="expression" />.Type 或 <paramref name="type" /> 是不可為 Null 的實值類型，且對應之不可為 Null 的實值類型不等於 <paramref name="method" /> 所表示之方法的引數類型或傳回類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-943"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="a8eb2-944">已找到一個以上的方法符合 <paramref name="method" /> 說明。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-944">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-945">建立代表轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />；若目標類型已溢位，此運算式便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-945">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-946">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-947">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-947">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-948">建立代表轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />；若目標類型已溢位，此運算式便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-948">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-949"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-949">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-950"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-950">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-951"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 屬性為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-951">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="a8eb2-952">則會消除節點，如果<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-952">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="a8eb2-953">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-953">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-954">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-954">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-955">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-955">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-956">如果有任一個`expression`。型別或`type`是使用者定義型別定義的隱含或明確轉換運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-956">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-957">否則就是：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-957">Otherwise:</span></span>  
  
    -   <span data-ttu-id="a8eb2-958">如果兩個`expression`。型別和`type`代表數值或布林值類型或可為 null 或非可為 null 的列舉類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-958">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="a8eb2-959">如果有任一個`expression`。型別或`type`是參考類型，明確的 boxing 處理，unboxing，或參考轉換存在從`expression`。若要輸入`type`，則實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-959">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-960">已消除或非消除</span><span class="sxs-lookup"><span data-stu-id="a8eb2-960">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-961">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-962">如果`expression`。類型是指派給實作方法的引數類型，且實作的方法的傳回型別指派給`type`，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-962">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="a8eb2-963">如果任一個或兩個的`expression`。型別或`type`可為 null 的實值型別而且分別為相等的引數類型和實作方法的傳回型別對應的非可為 null 的實值型別，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-963">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="a8eb2-964">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-964">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-965">如果兩個`expression`。型別和`type`都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-965">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="a8eb2-966">否則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-966">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-967"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-967"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-968"><paramref name="expression" />.Type 和 <paramref name="type" /> 之間未定義轉換運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-968">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-969">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-969">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-970">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-970">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-971">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-971">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-972">建立代表轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />，如果目標類型已溢位，且已指定此作業的實作方法，則此作業會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-972">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-973"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-973">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-974"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-974">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-975"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 屬性為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-975">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="a8eb2-976">則會消除節點，如果<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-976">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="a8eb2-977">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-977">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-978">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-978">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-979">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-979">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-980">如果方法不是`null`，它是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-980">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="a8eb2-981">它必須代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-981">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="a8eb2-982">否則，如果`expression`。型別或`type`是使用者定義型別定義的隱含或明確轉換運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-982">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-983">否則就是：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-983">Otherwise:</span></span>  
  
    -   <span data-ttu-id="a8eb2-984">如果兩個`expression`。型別和`type`代表數值或布林值類型或可為 null 或非可為 null 的列舉類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-984">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="a8eb2-985">如果有任一個`expression`。型別或`type`是參考類型，明確的 boxing 處理，unboxing，或參考轉換存在從`expression`。若要輸入`type`，則實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-985">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-986">已消除或非消除</span><span class="sxs-lookup"><span data-stu-id="a8eb2-986">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-987">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-987">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-988">如果`expression`。類型是指派給實作方法的引數類型，且實作的方法的傳回型別指派給`type`，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-988">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="a8eb2-989">如果任一個或兩個的`expression`。型別或`type`可為 null 的實值型別而且分別為相等的引數類型和實作方法的傳回型別對應的非可為 null 的實值型別，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-989">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="a8eb2-990">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-990">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-991">如果兩個`expression`。型別和`type`都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-991">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="a8eb2-992">否則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-992">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-993"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-993"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-994"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-994"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-995"><paramref name="expression" />.Type 和 <paramref name="type" /> 之間未定義轉換運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-995">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
<span data-ttu-id="a8eb2-996">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-996">-or-</span></span> 
 <span data-ttu-id="a8eb2-997"><paramref name="expression" />.Type 無法指派給 <paramref name="method" /> 所代表方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-997"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="a8eb2-998">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-998">-or-</span></span> 
<span data-ttu-id="a8eb2-999"><paramref name="method" /> 所代表方法的傳回類型無法指派給 <paramref name="type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-999">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
<span data-ttu-id="a8eb2-1000">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1000">-or-</span></span> 
 <span data-ttu-id="a8eb2-1001"><paramref name="expression" />.Type 或 <paramref name="type" /> 是不可為 Null 的實值類型，且對應之不可為 Null 的實值類型不等於 <paramref name="method" /> 所表示之方法的引數類型或傳回類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1001"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="a8eb2-1002">已找到一個以上的方法符合 <paramref name="method" /> 說明。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1002">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="a8eb2-1003">表示原始程式檔的 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1003">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <param name="startLine"><span data-ttu-id="a8eb2-1004">這個 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的起始行。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1004">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="a8eb2-1005">必須大於 0。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1005">Must be greater than 0.</span></span></param>
        <param name="startColumn"><span data-ttu-id="a8eb2-1006">這個 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的起始欄。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1006">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="a8eb2-1007">必須大於 0。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1007">Must be greater than 0.</span></span></param>
        <param name="endLine"><span data-ttu-id="a8eb2-1008">這個 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的結尾行。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1008">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="a8eb2-1009">必須大於或等於起始行。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1009">Must be greater or equal than the start line.</span></span></param>
        <param name="endColumn"><span data-ttu-id="a8eb2-1010">這個 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的結尾欄。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1010">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="a8eb2-1011">如果結尾行與起始行相同，則結尾欄必須大於或等於起始欄。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1011">If the end line is the same as the start line, it must be greater or equal than the start column.</span></span> <span data-ttu-id="a8eb2-1012">在任何情況下，都必須大於 0。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1012">In any case, must be greater than 0.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1013">使用指定的時間範圍建立 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1013">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1014"><see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1014">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1015">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表運算式遞減 1。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1015">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1016">要遞減的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1016">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1017">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表運算式遞減 1。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1017">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1018">代表遞減後運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1018">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1019">這個運算式會正常運作，並不會變更物件傳遞給它的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1019">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1020">下列程式碼範例示範如何建立運算式的設定，該 substracts 1 從指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1020">The following code example shows how to create an expression that substracts 1 from a given value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1021">要遞減的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1021">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1022">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1022">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1023">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表運算式遞減 1。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1023">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1024">代表遞減後運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1024">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1025">這個運算式會正常運作，並不會變更物件傳遞給它的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1025">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-1026">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1026">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1027">建立 <see cref="T:System.Linq.Expressions.DefaultExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1027">Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1028"><see cref="T:System.Linq.Expressions.DefaultExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Default" />，而 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1028">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-1029">下列程式碼範例示範如何建立運算式，表示指定型別的預設值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1029">The following code example shows how to create an expression that represents a default vaule for a given type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1030">建立代表算術除法運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1030">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1031">將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1031">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1032">將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1032">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1033">建立代表算術除法運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1033">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1034"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1034">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1035">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1035">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1036"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1036">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1037">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1037">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-1038">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1038">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-1039"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1039">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1040">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1040">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1041">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1041">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1042">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1042">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1043">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載除法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1043">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1044">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1044">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1045">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1045">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1046">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1046">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1047">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1047">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1048">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1048">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1049">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1049">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1050">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1050">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1051">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1051">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-1052">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1052">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1053">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1053">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1054">節點的類型是預先定義的除法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1054">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-1055">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1055">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1056">節點的類型為 null 的型別對應至預先定義的除法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1056">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1057">下列程式碼範例示範如何建立運算式，會將其第二個引數的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1057">The following code example shows how to create an expression that divides divides its first argument by its second argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1058"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1058"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1059">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Division 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1059">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1060">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1060">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1061">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1061">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1062">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1062">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1063">建立代表算術除法運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1063">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span> <span data-ttu-id="a8eb2-1064">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1064">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1065"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1065">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1066">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1066">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1067"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1067">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1068">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1068">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-1069">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1069">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-1070"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1070">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1071">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1071">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1072">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1072">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1073">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1073">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1074">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1074">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-1075">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載除法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1075">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1076">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1076">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1077">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1077">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1078">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1078">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1079">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1079">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1080">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1080">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1081">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1081">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1082">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1082">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1083">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1083">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-1084">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1084">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1085">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1085">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1086">節點的類型是預先定義的除法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1086">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-1087">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1087">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1088">節點的類型為 null 的型別對應至預先定義的除法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1088">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1089"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1089"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1090"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1090"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1091"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的除法運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1091"><paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1092">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表不含溢位檢查的除法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1092">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1093">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1093">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1094">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1094">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1095">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表不含溢位檢查的除法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1095">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1096"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1096">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1097">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1097">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1098">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1098">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1099">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1099">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1100">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表不含溢位檢查的除法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1100">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1101"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1101">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1102">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1102">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1103">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1103">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1104">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1104">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-1105">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1105">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1106">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表不含溢位檢查的除法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1106">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1107"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1107">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1108">建立代表動態運算的 <see cref="T:System.Linq.Expressions.DynamicExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1108">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="a8eb2-1109">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1109">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="a8eb2-1110">動態運算式的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1110">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-1111">動態作業的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1111">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1112">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1112">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1113"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1113">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1114"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1114">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="a8eb2-1115">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1115">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="a8eb2-1116">動態運算式的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1116">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-1117">動態作業的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1117">The first argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1118">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1118">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1119"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1119">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1120"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1120">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="a8eb2-1121">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1121">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="a8eb2-1122">動態運算式的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1122">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-1123">動態作業的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1123">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1124">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1124">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1125"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1125">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1126"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1126">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="a8eb2-1127">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1127">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="a8eb2-1128">動態運算式的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1128">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-1129">動態作業的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1129">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-1130">傳遞至動態作業的第二個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1130">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1131">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1131">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1132"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1132">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1133"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1133">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="a8eb2-1134">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1134">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="a8eb2-1135">動態運算式的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1135">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-1136">動態作業的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1136">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-1137">傳遞至動態作業的第二個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1137">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-1138">傳遞至動態作業的第三個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1138">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1139">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1139">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1140"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1140">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1141"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1141">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="a8eb2-1142">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1142">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="a8eb2-1143">動態運算式的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1143">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-1144">動態作業的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1144">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-1145">傳遞至動態作業的第二個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1145">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-1146">傳遞至動態作業的第三個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1146">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="a8eb2-1147">傳遞至動態運算的第四個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1147">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1148">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1148">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1149"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1149">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1150"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1150">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1151">建立 <see cref="T:System.Linq.Expressions.ElementInit" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1151">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="a8eb2-1152">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1152">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-1153"><see cref="T:System.Collections.Generic.IEnumerable`1" />，包含要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1153">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1154">指定 <see cref="T:System.Linq.Expressions.ElementInit" /> 做為第二個引數，建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1154">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1155"><see cref="T:System.Linq.Expressions.ElementInit" />，其 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> 和 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1155">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1156">`addMethod`參數必須代表名為"Add"（不區分大小寫） 的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1156">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="a8eb2-1157">Add 方法必須有相同數目的參數中的項目數為`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1157">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="a8eb2-1158"><xref:System.Linq.Expressions.Expression.Type%2A>屬性中的每個項目的`arguments`必須是指派給 add 方法中，對應參數的型別可能之後*引用*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1158">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-1159">只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1159">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-1160">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1160">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-1161">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1161">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1162">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.ElementInit>，表示呼叫<xref:System.Collections.Generic.Dictionary%602.Add%2A>方法來初始化字典集合的項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1162">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1163"><paramref name="addMethod" /> 或 <paramref name="arguments" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1163"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1164">未將 <paramref name="addMethod" /> 所代表的方法命名為 "Add" (不區分大小寫)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1164">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).</span></span>  
  
<span data-ttu-id="a8eb2-1165">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1165">-or-</span></span> 
<span data-ttu-id="a8eb2-1166"><paramref name="addMethod" /> 所代表的方法不是執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1166">The method that <paramref name="addMethod" /> represents is not an instance method.</span></span>  
  
<span data-ttu-id="a8eb2-1167">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1167">-or-</span></span> 
 <span data-ttu-id="a8eb2-1168"><paramref name="arguments" /> 所包含的項目數與 <paramref name="addMethod" /> 所代表之方法的參數數目不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1168"><paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.</span></span>  
  
<span data-ttu-id="a8eb2-1169">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1169">-or-</span></span> 
<span data-ttu-id="a8eb2-1170"><paramref name="arguments" /> 的一或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="addMethod" /> 所代表之方法的對應參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1170">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="a8eb2-1171">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1171">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-1172">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 物件陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1172">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1173">指定值陣列做為第二個引數，建立 <see cref="T:System.Linq.Expressions.ElementInit" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1173">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1174"><see cref="T:System.Linq.Expressions.ElementInit" />，其 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> 和 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1174">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1175">`addMethod`參數必須代表名為"Add"（不區分大小寫） 的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1175">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="a8eb2-1176">Add 方法必須有相同數目的參數中的項目數為`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1176">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="a8eb2-1177"><xref:System.Linq.Expressions.Expression.Type%2A>屬性中的每個項目的`arguments`必須是指派給 add 方法中，對應參數的型別可能之後*引用*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1177">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-1178">只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1178">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-1179">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1179">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-1180">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1180">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1181">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.ElementInit>，表示呼叫<xref:System.Collections.Generic.Dictionary%602.Add%2A>方法來初始化字典集合的項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1182"><paramref name="addMethod" /> 或 <paramref name="arguments" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1182"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1183">addMethod 所表示的方法名稱不是 "Add" (不區分大小寫)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1183">The method that addMethod represents is not named "Add" (case insensitive).</span></span>  
  
<span data-ttu-id="a8eb2-1184">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1184">-or-</span></span> 
<span data-ttu-id="a8eb2-1185">addMethod 所表示的方法不是執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1185">The method that addMethod represents is not an instance method.</span></span>  
  
<span data-ttu-id="a8eb2-1186">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1186">-or-</span></span> 
<span data-ttu-id="a8eb2-1187">引數包含的項目數目與 addMethod 所表示之方法的參數數目不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1187">arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.</span></span>  
  
<span data-ttu-id="a8eb2-1188">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1188">-or-</span></span> 
<span data-ttu-id="a8eb2-1189"><paramref name="arguments" /> 的一或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="addMethod" /> 所代表之方法的對應參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1189">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8eb2-1190">建立具有 <see cref="T:System.Void" /> 類型的空運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1190">Creates an empty expression that has <see cref="T:System.Void" /> type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1191"><see cref="T:System.Linq.Expressions.DefaultExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Default" />，且 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設為 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1191">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1192">必須是運算式，但不需要採取任何動作，可以使用空運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1192">An empty expression can be used where an expression is expected but no action is desired.</span></span> <span data-ttu-id="a8eb2-1193">比方說，您可以使用空的運算式做為最後一個運算式中的運算式區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1193">For example, you can use an empty expression as the last expression in a block expression.</span></span> <span data-ttu-id="a8eb2-1194">在此情況下，封鎖運算式的傳回值為 void。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1194">In this case, the block expression's return value is void.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1195">下列程式碼範例示範如何建立空的運算式，並將它加入區塊運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1195">The following code example shows how to create an empty expression and add it to a block expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1196">建立代表相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1197">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1197">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1198">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1198">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1199">建立代表相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1199">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1200"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1200">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1201">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1201">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1202"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1202">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1203">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1203">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="a8eb2-1204">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1204">Otherwise, it is `false`.</span></span> <span data-ttu-id="a8eb2-1205"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1205">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="a8eb2-1206">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1206">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1207">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1207">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1208">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1208">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1209">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載等號比較運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1209">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1210">否則，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1210">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1211">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1211">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1212">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1212">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1213">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1213">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1214">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1214">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1215">如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1215">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1216">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1216">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1217">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1217">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1218">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1218">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1219">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1219">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1220">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1220">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1221">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1221">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1222">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1222">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1223">下列程式碼範例示範如何建立會檢查其兩個引數的值是否相等的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1223">The following code example shows how to create an expression that checks whether the values of its two arguments are equal.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1224"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1224"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1225">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義等號比較運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1225">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1226">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1226">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1227">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1227">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="a8eb2-1228"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1228"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1229">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1229">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1230">建立代表相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1230">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span> <span data-ttu-id="a8eb2-1231">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1231">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1232"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1232">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1233">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1233">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1234"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1234">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1235">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1235">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="a8eb2-1236">否則，兩者都是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1236">Otherwise, they are both `false`.</span></span> <span data-ttu-id="a8eb2-1237">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1237">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1238">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1238">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1239">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1239">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1240">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1240">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1241">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載等號比較運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1241">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1242">否則，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1242">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1243">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1243">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1244">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1244">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1245">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1245">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1246">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1246">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1247">如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1247">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1248">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1248">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1249">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1249">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1250">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1250">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1251">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1251">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1252">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1252">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1253">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1253">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1254">節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1254">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1255"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1255"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1256"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1256"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1257"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義等號比較運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1257"><paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1258">建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="XOR" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1258">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1259">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1259">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1260">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1260">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1261">使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立表示位元 <see langword="XOR" /> 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1261">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1262"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1262">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1263">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1263">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1264"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1264">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1265">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1265">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-1266">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1266">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-1267"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1267">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1268">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1268">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1269">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1269">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1270">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1270">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1271">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示多載的使用者定義型別`XOR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1271">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1272">否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1272">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1273">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1273">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1274">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1274">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1275">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1275">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1276">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1276">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1277">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1277">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1278">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1278">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1279">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1279">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-1280">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1280">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1281">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1281">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1282">節點的類型是預先定義的結果型別`XOR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1282">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-1283">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1283">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1284">節點的類型為 null 的型別對應至預先定義的結果型別`XOR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1284">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1285">下列程式碼範例示範如何建立代表邏輯 XOR 運算的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1285">The following code example shows how to create an expression that represents the logical XOR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1286"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1286"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1287">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 <see langword="XOR" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1287">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1288">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1288">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1289">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1289">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1290">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1290">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1291">使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立表示位元 <see langword="XOR" /> 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1291">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span> <span data-ttu-id="a8eb2-1292">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1292">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1293"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1293">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1294">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1294">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1295"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1295">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1296">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1296">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-1297">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1297">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-1298"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1298">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1299">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1299">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1300">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1300">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1301">下列規則決定實作作業的方法選擇：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1301">The following rules determine the chosen implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1302">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1302">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1303">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示多載的使用者定義型別`XOR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1303">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1304">否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1304">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1305">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1305">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1306">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1306">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1307">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1307">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1308">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1308">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1309">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1309">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1310">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1310">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1311">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1311">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-1312">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1312">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1313">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1313">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1314">節點的類型是預先定義的結果型別`XOR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1314">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-1315">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1315">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1316">節點的類型為 null 的型別對應至預先定義的結果型別`XOR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1316">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1317"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1317"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1318"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1318"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1319"><paramref name="method" /> 是 <see langword="null" />，而且未定義類型 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的 <see langword="XOR" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1319"><paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1320">建立代表位元 XOR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1320">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1321">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1321">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1322">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1322">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1323">使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立代表位元 XOR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1323">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1324"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1324">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1325">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1325">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1326">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1326">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1327">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1327">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1328">使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立代表位元 XOR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1328">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1329"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1329">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1330">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1330">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1331">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1332">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1332">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-1333">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1333">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1334">使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立代表位元 XOR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1334">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1335"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1335">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1336">建立代表存取欄位的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1336">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1337">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1337">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="a8eb2-1338">若為 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，<paramref name="expression" /> 必須是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1338">For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <paramref name="expression" /> must be <see langword="null" />.</span></span></param>
        <param name="field"><span data-ttu-id="a8eb2-1339">要將 <see cref="T:System.Reflection.FieldInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1339">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1340">建立代表存取欄位的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1340">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1341"><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1341">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1342"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.FieldInfo.FieldType%2A>屬性`field`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1342">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of `field`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1343"><paramref name="field" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1343"><paramref name="field" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-1344">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1344">-or-</span></span> 
<span data-ttu-id="a8eb2-1345"><paramref name="field" /> 所表示的欄位不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，且 <paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1345">The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1346"><paramref name="expression" />.Type 無法指派給 <paramref name="field" /> 所代表之欄位的宣告類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1346"><paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1347"><see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 包含名為 <paramref name="fieldName" /> 的欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1347">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <paramref name="fieldName" />.</span></span> <span data-ttu-id="a8eb2-1348">如果是靜態欄位，可以是 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1348">This can be null for static fields.</span></span></param>
        <param name="fieldName"><span data-ttu-id="a8eb2-1349">要存取的欄位名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1349">The name of a field to be accessed.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1350">建立 <see cref="T:System.Linq.Expressions.MemberExpression" />，代表存取可指定欄位名稱的欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1350">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1351"><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />、<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 屬性設定為 <paramref name="expression" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為 <see cref="T:System.Reflection.FieldInfo" />，代表 <paramref name="fieldName" /> 所表示的欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1351">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1352"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.FieldInfo.FieldType%2A>屬性<xref:System.Reflection.FieldInfo>所表示的欄位表示`fieldName`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1352">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of the <xref:System.Reflection.FieldInfo> that represents the field denoted by `fieldName`.</span></span>  
  
 <span data-ttu-id="a8eb2-1353">這個方法會搜尋`expression`。類型和其基底類型的欄位，具有名稱`fieldName`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1353">This method searches `expression`.Type and its base types for a field that has the name `fieldName`.</span></span> <span data-ttu-id="a8eb2-1354">公用欄位，優先使用非公用欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1354">Public fields are given preference over non-public fields.</span></span> <span data-ttu-id="a8eb2-1355">如果找到相符的欄位，則此方法會傳遞`expression`而<xref:System.Reflection.FieldInfo>表示該欄位加入<xref:System.Linq.Expressions.Expression.Field%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1355">If a matching field is found, this method passes `expression` and the <xref:System.Reflection.FieldInfo> that represents that field to <xref:System.Linq.Expressions.Expression.Field%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1356">下列程式碼範例示範如何建立代表存取欄位的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1356">The following code example shows how to create an expression that represents accessing a field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1357"><paramref name="expression" /> 或 <paramref name="fieldName" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1357"><paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1358"><paramref name="fieldName" />.Type 或其基底類型中沒有定義名為 <paramref name="expression" /> 的欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1358">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1359">欄位的包含物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1359">The containing object of the field.</span></span> <span data-ttu-id="a8eb2-1360">如果是靜態欄位，可以是 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1360">This can be null for static fields.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-1361">包含欄位的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1361">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</span></span></param>
        <param name="fieldName"><span data-ttu-id="a8eb2-1362">要存取的欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1362">The field to be accessed.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1363">建立代表存取欄位的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1363">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1364">建立的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1364">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="a8eb2-1365">最多包含十六個 <see cref="T:System.Type" /> 物件的陣列，指定 <see langword="System.Action" /> 委派類型的型別引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1365">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1366">建立 <see cref="T:System.Type" /> 物件，這個物件代表具有特定型別引數的泛型 <c>System.Action</c> 委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1366">Creates a <see cref="T:System.Type" /> object that represents a generic <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1367"><c>System.Action</c> 委派的類型，具有指定的型別引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1367">The type of a <c>System.Action</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1368">舉例來說，如果的項目`typeArgs`代表型別`T1…Tn`，產生<xref:System.Type>物件代表建構的委派型別`System.Action<T1,…,Tn>`在 C# 中或`System.Action(Of T1,…,Tn)`Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1368">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Action<T1,…,Tn>` in C# or `System.Action(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1369"><paramref name="typeArgs" /> 包含十六個以上的項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1369"><paramref name="typeArgs" /> contains more than sixteen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1370"><paramref name="typeArgs" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1370"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="a8eb2-1371">委派的型別引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1371">The type arguments of the delegate.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1372">取得 <see cref="P:System.Linq.Expressions.Expression.Type" /> 物件，這個物件代表具有特定型別引數的泛型 <c>System.Func</c> 或 <c>System.Action</c> 委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1372">Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> or <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1373">委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1373">The delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1374">最後一個型別引數判斷委派的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1374">The last type argument determines the return type of the delegate.</span></span> <span data-ttu-id="a8eb2-1375">如果沒有函式或動作夠大時，它會產生自訂的委派型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1375">If no Func or Action is large enough, it will generate a custom delegate type.</span></span>  
  
 <span data-ttu-id="a8eb2-1376">如同函式，最後一個引數是傳回的型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1376">As with Func, the last argument is the return type.</span></span> <span data-ttu-id="a8eb2-1377">它可以設定為 System.Void，產生動作。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1377">It can be set to System.Void to produce an Action.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="a8eb2-1378">包含一到十七個 <see cref="T:System.Type" /> 物件的陣列，指定 <see langword="System.Func" /> 委派類型的型別引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1378">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1379">建立 <see cref="P:System.Linq.Expressions.Expression.Type" /> 物件，這個物件代表具有特定型別引數的泛型 <c>System.Func</c> 委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1379">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> delegate type that has specific type arguments.</span></span> <span data-ttu-id="a8eb2-1380">最後一個型別引數指定已建立之委派的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1380">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1381"><c>System.Func</c> 委派的類型，具有指定的型別引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1381">The type of a <c>System.Func</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1382">`typeArgs` 必須包含至少一個與最多十七項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1382">`typeArgs` must contain at least one and at most seventeen elements.</span></span>  
  
 <span data-ttu-id="a8eb2-1383">舉例來說，如果的項目`typeArgs`代表型別`T1…Tn`，產生<xref:System.Type>物件代表建構的委派型別`System.Func<T1,…,Tn>`在 C# 中或`System.Func(Of T1,…,Tn)`Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1383">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Func<T1,…,Tn>` in C# or `System.Func(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1384"><paramref name="typeArgs" /> 包含少於一個或多過十七個項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1384"><paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1385"><paramref name="typeArgs" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1385"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1386">建立表示 "go to" 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1386">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-1387"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1387">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1388">建立表示 "go to" 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1388">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1389"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Goto、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為指定的值，且包含在跳躍時傳遞至目標標籤的 Null 值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1389">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-1390">下列範例示範如何建立包含的運算式<xref:System.Linq.Expressions.GotoExpression>物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1390">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.GotoExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-1391"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1391">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="a8eb2-1392">將在跳躍時傳遞至關聯標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1392">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1393">建立表示 "go to" 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1393">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span> <span data-ttu-id="a8eb2-1394">可以指定跳躍時傳遞至標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1394">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1395"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Goto、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1395">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-1396"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1396">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-1397">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1397">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1398">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 "go to" 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1398">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1399"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Goto、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為指定的值、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 Null 值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1399">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-1400"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1400">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="a8eb2-1401">將在跳躍時傳遞至關聯標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1401">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-1402">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1402">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1403">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 "go to" 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1403">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span> <span data-ttu-id="a8eb2-1404">可以指定跳躍時傳遞至標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1404">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1405"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Goto、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1405">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1406">建立代表「大於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1406">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1407">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1407">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1408">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1408">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1409">建立代表「大於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1409">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1410"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1410">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1411">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1411">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1412"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1412">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1413">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1413">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="a8eb2-1414">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1414">Otherwise, it is `false`.</span></span> <span data-ttu-id="a8eb2-1415"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1415">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="a8eb2-1416"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1416">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1417">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1417">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1418">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1418">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1419">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1419">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1420">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 大於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1420">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1421">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1421">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1422">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1422">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1423">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1423">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1424">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1424">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1425">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1425">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1426">如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1426">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1427">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1427">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1428">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1428">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1429">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1429">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1430">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1430">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1431">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1431">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1432">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1432">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1433">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1433">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1434">下列程式碼範例示範如何建立可比較兩個整數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1434">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1435"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1435"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1436">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「大於」運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1436">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1437">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1437">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1438">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="a8eb2-1439"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1439"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1440">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1440">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1441">建立代表「大於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1441">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span> <span data-ttu-id="a8eb2-1442">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1442">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1443"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1443">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1444">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1444">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1445"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1445">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1446">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1446">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="a8eb2-1447">否則，兩者都是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1447">Otherwise, they are both `false`.</span></span> <span data-ttu-id="a8eb2-1448"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1448">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1449">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1449">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1450">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1450">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1451">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1451">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="a8eb2-1452">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1452">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1453">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 大於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1453">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1454">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1454">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1455">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1455">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1456">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1456">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1457">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1457">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1458">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1458">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1459">如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1459">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1460">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1460">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1461">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1461">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1462">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1462">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1463">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1463">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1464">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1464">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1465">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1465">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1466">節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1466">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1467"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1467"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1468"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1468"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1469"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「大於」運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1469"><paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1470">建立代表「大於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1471">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1471">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1472">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1472">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1473">建立代表「大於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1473">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1474"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1474">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1475">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1475">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1476"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1476">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1477">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1477">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="a8eb2-1478">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1478">Otherwise, it is `false`.</span></span> <span data-ttu-id="a8eb2-1479"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1479">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="a8eb2-1480"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1480">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1481">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1481">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1482">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1482">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1483">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1483">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1484">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 大於或等於 」 運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1484">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1485">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1485">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1486">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1486">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1487">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1487">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1488">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1488">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1489">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1489">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1490">如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1490">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1491">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1491">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1492">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1492">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1493">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1493">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1494">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1494">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1495">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1495">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1496">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1496">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1497">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1497">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1498">下列程式碼範例示範如何建立可比較兩個整數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1498">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1499"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1499"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1500">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「大於或等於」運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1500">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1501">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1502">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1502">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="a8eb2-1503"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1503"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1504">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1504">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1505">建立代表「大於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1506"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1506">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1507">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1507">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1508"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1508">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1509">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1509">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="a8eb2-1510">否則，兩者都是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1510">Otherwise, they are both `false`.</span></span> <span data-ttu-id="a8eb2-1511"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1511">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1512">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1512">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1513">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1513">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1514">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1514">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1515">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1515">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1516">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 大於或等於 」 運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1516">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1517">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1517">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1518">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1518">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1519">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1519">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1520">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1520">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1521">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1521">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1522">如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1522">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1523">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1523">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1524">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1524">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1525">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1525">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1526">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1526">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1527">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1527">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1528">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1528">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1529">節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1529">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1530"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1530"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1531"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1531"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1532"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的「大於或等於」運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1532"><paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="a8eb2-1533">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1533">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="a8eb2-1534">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1534">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1535">建立 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，代表具有 <see langword="if" /> 陳述式的條件區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1535">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1536"><see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1536">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values.</span></span> <span data-ttu-id="a8eb2-1537"><see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 屬性已設定為預設運算式，而這個方法傳回之結果 <see cref="T:System.Linq.Expressions.ConditionalExpression" /> 的類型為 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1537">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-1538">下列程式碼範例示範如何建立運算式，代表條件式區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1538">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="a8eb2-1539">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1539">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="a8eb2-1540">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1540">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="a8eb2-1541">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1541">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1542">建立 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，代表具有 <see langword="if" /> 和 <see langword="else" /> 陳述式的條件區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1542">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1543"><see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1543">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span> <span data-ttu-id="a8eb2-1544">這個方法所傳回之結果 <see cref="T:System.Linq.Expressions.ConditionalExpression" /> 的類型為 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1544">The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-1545">下列程式碼範例示範如何建立運算式，代表條件式區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1545">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1546">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示運算式值遞增 1。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1546">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1547">要遞增的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1547">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1548">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示運算式值遞增 1。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1548">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1549">表示遞增後運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1549">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1550">這個運算式會正常運作，並不會變更物件傳遞給它的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1550">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1551">下列程式碼範例示範如何建立運算式，表示遞增作業。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1551">The following code example shows how to create an expression that represents an increment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1552">要遞增的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1552">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1553">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1553">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1554">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表運算式遞增 1。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1554">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1555">表示遞增後運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1555">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1556">這個運算式會正常運作，並不會變更物件傳遞給它的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1556">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1557">建立 <see cref="T:System.Linq.Expressions.InvocationExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1557">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1558"><see cref="T:System.Linq.Expressions.Expression" />，代表要套用的委派或 Lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1558">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-1559">包含 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 物件的 <see cref="T:System.Linq.Expressions.Expression" />，代表要套用委派或 Lambda 運算式的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1559">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1560">建立 <see cref="T:System.Linq.Expressions.InvocationExpression" />，將委派或 Lambda 運算式套用至引數運算式清單。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1560">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1561"><see cref="T:System.Linq.Expressions.InvocationExpression" />，可將指定的委派或 Lambda 運算式套用至所提供的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1561">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1562"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.InvocationExpression>代表委派所表示的傳回型別`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1562">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="a8eb2-1563"><xref:System.Linq.Expressions.InvocationExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.InvocationExpression>是空的如果`arguments`是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1563">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="a8eb2-1564">否則，它包含相同的項目，做為`arguments`除外，其中有些<xref:System.Linq.Expressions.Expression>物件可能會*加上引號*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1564">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-1565">只有當對應的參數的委派所表示項目會加上引號`expression`別的<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1565">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-1566">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1566">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-1567">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1567">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1568">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.InvocationExpression>，代表具有指定的引數的 lambda 運算式的引動過程。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1568">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1569"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1569"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1570"><paramref name="expression" />.Type 不代表委派類型或 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1570"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
<span data-ttu-id="a8eb2-1571">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1571">-or-</span></span> 
<span data-ttu-id="a8eb2-1572"><paramref name="arguments" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="expression" /> 所表示之委派的對應參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1572">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1573"><paramref name="arguments" /> 包含的項目數與 <paramref name="expression" /> 所表示委派的參數清單不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1573"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1574"><see cref="T:System.Linq.Expressions.Expression" />，代表要套用的委派或 Lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1574">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-1575"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，代表要套用委派或 Lambda 運算式的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1575">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1576">建立 <see cref="T:System.Linq.Expressions.InvocationExpression" />，將委派或 Lambda 運算式套用至引數運算式清單。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1576">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1577"><see cref="T:System.Linq.Expressions.InvocationExpression" />，可將指定的委派或 Lambda 運算式套用至所提供的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1577">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1578"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.InvocationExpression>代表委派所表示的傳回型別`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1578">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="a8eb2-1579"><xref:System.Linq.Expressions.InvocationExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.InvocationExpression>是空的如果`arguments`是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1579">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="a8eb2-1580">否則，它包含相同的項目，做為`arguments`除外，其中有些<xref:System.Linq.Expressions.Expression>物件可能會*加上引號*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1580">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-1581">只有當對應的參數的委派所表示項目會加上引號`expression`別的<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1581">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-1582">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1582">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-1583">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1583">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1584">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.InvocationExpression>，代表具有指定的引數的 lambda 運算式的引動過程。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1584">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1585"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1585"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1586"><paramref name="expression" />.Type 不代表委派類型或 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1586"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
<span data-ttu-id="a8eb2-1587">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1587">-or-</span></span> 
<span data-ttu-id="a8eb2-1588"><paramref name="arguments" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="expression" /> 所表示之委派的對應參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1588">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1589"><paramref name="arguments" /> 包含的項目數與 <paramref name="expression" /> 所表示委派的參數清單不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1589"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1590">傳回運算式是否評估為 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1590">Returns whether the expression evaluates to false.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1591">要評估的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1591">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1592">傳回運算式是否評估為 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1592">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1593"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1593">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1594">要評估的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1594">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1595">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1595">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1596">傳回運算式是否評估為 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1596">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1597"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1597">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1598">傳回運算式是否評估為 true。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1598">Returns whether the expression evaluates to true.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1599">要評估的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1599">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1600">傳回運算式是否評估為 true。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1600">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1601"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1601">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-1602">要評估的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1602">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1603">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1603">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1604">傳回運算式是否評估為 true。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1604">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1605"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1605">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1606">建立表示標籤的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1606">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8eb2-1607">建立 <see cref="T:System.Linq.Expressions.LabelTarget" />，代表包含 void 類型但沒有名稱的標籤。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1607">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1608">新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1608">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-1609">下列範例示範如何建立包含的運算式<xref:System.Linq.Expressions.LabelTarget>物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1609">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LabelTarget> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-1610">這個 <see cref="T:System.Linq.Expressions.LabelTarget" /> 將與之產生關聯的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1610">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1611">建立 <see cref="T:System.Linq.Expressions.LabelExpression" />，代表沒有預設值的標籤。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1611">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1612">沒有預設值的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1612">A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="a8eb2-1613">標籤名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1613">The name of the label.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1614">建立 <see cref="T:System.Linq.Expressions.LabelTarget" />，代表包含 void 類型和指定之名稱的標籤。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1614">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1615">新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1615">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-1616">跳至標籤時所傳遞值的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1616">The type of value that is passed when jumping to the label.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1617">建立 <see cref="T:System.Linq.Expressions.LabelTarget" />，代表包含指定之類型的標籤。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1617">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1618">新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1618">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-1619">下列範例示範如何使用<xref:System.Linq.Expressions.LabelTarget>迴圈運算式中的物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1619">The following example demonstrates how to use a <xref:System.Linq.Expressions.LabelTarget> object in a loop expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-1620">這個 <see cref="T:System.Linq.Expressions.LabelTarget" /> 將與之產生關聯的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1620">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <param name="defaultValue"><span data-ttu-id="a8eb2-1621">透過一般控制流程到達標籤時，這個 <see cref="T:System.Linq.Expressions.LabelExpression" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1621">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1622">建立 <see cref="T:System.Linq.Expressions.LabelExpression" />，代表包含指定之預設值的標籤。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1622">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1623">包含指定之預設值的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1623">A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-1624">跳至標籤時所傳遞值的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1624">The type of value that is passed when jumping to the label.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-1625">標籤名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1625">The name of the label.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1626">建立 <see cref="T:System.Linq.Expressions.LabelTarget" />，代表包含指定之類型和名稱的標籤。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1626">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1627">新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1627">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1628">建立表示 Lambda 運算式的運算式樹狀架構。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1628">Creates an expression tree that represents a lambda expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-1629">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1629">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1630"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1630">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1631">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1631">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1632"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1632">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-1633">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1633">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1634">用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合之 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1634">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1635">首先透過建構委派類型來建立 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1635">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1636"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1636">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1637">`parameters`參數不能超過 16 個項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1637">The `parameters` parameter must not have more than sixteen elements.</span></span>  
  
 <span data-ttu-id="a8eb2-1638">項目`parameters`必須是參考中的參數運算式等於`body`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1638">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="a8eb2-1639">這個方法會建構其中一個適當的委派型別`System.Func`泛型委派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1639">This method constructs an appropriate delegate type from one of the `System.Func` generic delegates.</span></span> <span data-ttu-id="a8eb2-1640">接著，將委派類型的其中一個<xref:System.Linq.Expressions.ExpressionType.Lambda>factory 方法來建立<xref:System.Linq.Expressions.LambdaExpression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1640">It then passes the delegate type to one of the <xref:System.Linq.Expressions.ExpressionType.Lambda> factory methods to create a <xref:System.Linq.Expressions.LambdaExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1641"><paramref name="body" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1641"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-1642">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1642">-or-</span></span> 
<span data-ttu-id="a8eb2-1643"><paramref name="parameters" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1643">One or more elements of <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1644"><paramref name="parameters" /> 包含十六個以上的項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1644"><paramref name="parameters" /> contains more than sixteen elements.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-1645">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1645">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1646"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1646">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1647"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1647">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1648">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1648">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1649"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1649">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-1650">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1650">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1651"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1651">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1652">陣列，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1652">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1653">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1653">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1654"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1654">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-1655">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1655">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-1656">Lambda 的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1656">The name for the lambda.</span></span> <span data-ttu-id="a8eb2-1657">用於發出偵錯資訊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1657">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1658"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1659">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1659">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1660"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1660">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-1661"><see cref="T:System.Type" />，代表 Lambda 的委派簽章。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1661">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-1662">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1662">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1663"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1663">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1664">首先透過建構委派類型來建立 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1664">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span> <span data-ttu-id="a8eb2-1665">它可用於在編譯階段不知道委派類型時。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1665">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1666">表示 Lambda 運算式的物件，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1666">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1667">此函式傳回的物件是型別<xref:System.Linq.Expressions.Expression%601>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1667">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="a8eb2-1668"><xref:System.Linq.Expressions.LambdaExpression>類型用來代表傳回的物件，因為在編譯時期不知道 lambda 運算式的具象類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1668">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="a8eb2-1669">所表示之委派類型的參數數目`delegateType`必須等於長度`parameters`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1669">The number of parameters for the delegate type represented by`delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="a8eb2-1670">項目`parameters`必須是參考中的參數運算式等於`body`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1670">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="a8eb2-1671"><xref:System.Linq.Expressions.Expression.Type%2A>產生的物件屬性是否等於`delegateType`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1671">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="a8eb2-1672">如果`parameters`已`null`，則<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A>產生之物件的屬性為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1672">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1673">下列範例示範如何建立代表 lambda 運算式，將 1 加上傳遞的引數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1673">The following example demonstrates how to create an expression that represents a lambda expression that adds 1 to the passed argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1674"><paramref name="delegateType" /> 或 <paramref name="body" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1674"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-1675">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1675">-or-</span></span> 
<span data-ttu-id="a8eb2-1676"><paramref name="parameters" /> 中的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1676">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1677"><paramref name="delegateType" /> 不表示委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1677"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
<span data-ttu-id="a8eb2-1678">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1678">-or-</span></span> 
 <span data-ttu-id="a8eb2-1679"><paramref name="body" />.Type 表示的類型無法指派給 <paramref name="delegateType" /> 所表示之委派類型的傳回類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1679"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="a8eb2-1680">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1680">-or-</span></span> 
 <span data-ttu-id="a8eb2-1681"><paramref name="parameters" /> 包含的項目數與 <paramref name="delegateType" /> 所表示之委派類型的參數清單不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1681"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="a8eb2-1682">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1682">-or-</span></span> 
<span data-ttu-id="a8eb2-1683"><paramref name="parameters" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法從由 <paramref name="delegateType" /> 所表示之委派類型的對應參數類型指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1683">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-1684"><see cref="T:System.Type" />，代表 Lambda 的委派簽章。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1684">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-1685">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1685">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1686">用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合之 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1686">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1687">首先透過建構委派類型來建立 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1687">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span> <span data-ttu-id="a8eb2-1688">它可用於在編譯階段不知道委派類型時。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1688">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1689">表示 Lambda 運算式的物件，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1689">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1690">此函式傳回的物件是型別<xref:System.Linq.Expressions.Expression%601>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1690">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="a8eb2-1691"><xref:System.Linq.Expressions.LambdaExpression>類型用來代表傳回的物件，因為在編譯時期不知道 lambda 運算式的具象類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1691">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="a8eb2-1692">所表示之委派類型的參數數目`delegateType`必須等於長度`parameters`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1692">The number of parameters for the delegate type represented by `delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="a8eb2-1693">項目`parameters`必須是參考中的參數運算式等於`body`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1693">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="a8eb2-1694"><xref:System.Linq.Expressions.Expression.Type%2A>產生的物件屬性是否等於`delegateType`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1694">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="a8eb2-1695">如果`parameters`已`null`，則<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A>產生之物件的屬性為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1695">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1696"><paramref name="delegateType" /> 或 <paramref name="body" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1696"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-1697">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1697">-or-</span></span> 
<span data-ttu-id="a8eb2-1698"><paramref name="parameters" /> 中的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1698">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1699"><paramref name="delegateType" /> 不表示委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1699"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
<span data-ttu-id="a8eb2-1700">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1700">-or-</span></span> 
 <span data-ttu-id="a8eb2-1701"><paramref name="body" />.Type 表示的類型無法指派給 <paramref name="delegateType" /> 所表示之委派類型的傳回類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1701"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="a8eb2-1702">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1702">-or-</span></span> 
 <span data-ttu-id="a8eb2-1703"><paramref name="parameters" /> 包含的項目數與 <paramref name="delegateType" /> 所表示之委派類型的參數清單不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1703"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="a8eb2-1704">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1704">-or-</span></span> 
<span data-ttu-id="a8eb2-1705"><paramref name="parameters" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法從由 <paramref name="delegateType" /> 所表示之委派類型的對應參數類型指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1705">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-1706">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1706">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-1707">Lambda 的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1707">The name for the lambda.</span></span> <span data-ttu-id="a8eb2-1708">用於發出偵錯資訊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1708">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1709"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1709">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1710"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1710">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1711">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1711">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1712"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1712">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-1713"><see cref="P:System.Linq.Expressions.Expression.Type" />，代表 Lambda 的委派簽章。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1713">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-1714">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1714">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1715"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1715">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1716"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1716">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1717">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1717">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1718"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1718">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-1719"><see cref="P:System.Linq.Expressions.Expression.Type" />，代表 Lambda 的委派簽章。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1719">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-1720">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1720">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1721"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1721">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1722">陣列，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1722">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1723">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1723">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1724"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1724">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-1725"><see cref="P:System.Linq.Expressions.Expression.Type" />，代表 Lambda 的委派簽章。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1725">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-1726">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1726">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-1727">Lambda 的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1727">The name for the lambda.</span></span> <span data-ttu-id="a8eb2-1728">用於發出偵錯資訊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1728">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1729"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1729">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1730">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1730">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1731"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1731">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-1732"><see cref="P:System.Linq.Expressions.Expression.Type" />，代表 Lambda 的委派簽章。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1732">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-1733">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1733">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-1734">Lambda 的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1734">The name for the lambda.</span></span> <span data-ttu-id="a8eb2-1735">用於發出偵錯資訊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1735">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1736"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1736">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1737"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1737">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1738">首先透過建構委派類型來建立 LambdaExpression。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1738">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1739"><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1739">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="a8eb2-1740">委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1740">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="a8eb2-1741">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1741">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1742"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1742">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1743">建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1743">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1744"><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1744">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1745">委派類型的參數數目`TDelegate`必須等於中的項目數`parameters`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1745">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="a8eb2-1746">項目`parameters`必須是參考中的參數運算式等於`body`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1746">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="a8eb2-1747"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生的物件，代表類型`TDelegate`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1747">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="a8eb2-1748">如果`parameters`已`null`，則<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A>產生之物件的屬性為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1748">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1749"><paramref name="body" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1749"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-1750">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1750">-or-</span></span> 
<span data-ttu-id="a8eb2-1751"><paramref name="parameters" /> 中的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1751">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1752"><paramref name="TDelegate" /> 不是委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1752"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
<span data-ttu-id="a8eb2-1753">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1753">-or-</span></span> 
 <span data-ttu-id="a8eb2-1754"><paramref name="body" />.Type 所表示的類型無法指派給 <paramref name="TDelegate" /> 的傳回類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1754"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="a8eb2-1755">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1755">-or-</span></span> 
 <span data-ttu-id="a8eb2-1756"><paramref name="parameters" /> 包含的項目數與 <paramref name="TDelegate" /> 的參數清單不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1756"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="a8eb2-1757">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1757">-or-</span></span> 
<span data-ttu-id="a8eb2-1758"><paramref name="parameters" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法從 <paramref name="TDelegate" /> 之對應參數類型的類型指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1758">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="a8eb2-1759">委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1759">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="a8eb2-1760">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1760">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1761">用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合之 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1761">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1762">建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1762">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1763"><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1763">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1764">委派類型的參數數目`TDelegate`必須等於中的項目數`parameters`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1764">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="a8eb2-1765">項目`parameters`必須是參考中的參數運算式等於`body`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1765">The elements of `parameters` must be reference equal to the parameter expressions in`body`.</span></span>  
  
 <span data-ttu-id="a8eb2-1766"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生的物件，代表類型`TDelegate`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1766">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="a8eb2-1767">如果`parameters`已`null`，則<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A>產生之物件的屬性為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1767">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1768"><paramref name="body" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1768"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-1769">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1769">-or-</span></span> 
<span data-ttu-id="a8eb2-1770"><paramref name="parameters" /> 中的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1770">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1771"><paramref name="TDelegate" /> 不是委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1771"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
<span data-ttu-id="a8eb2-1772">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1772">-or-</span></span> 
 <span data-ttu-id="a8eb2-1773"><paramref name="body" />.Type 所表示的類型無法指派給 <paramref name="TDelegate" /> 的傳回類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1773"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="a8eb2-1774">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1774">-or-</span></span> 
 <span data-ttu-id="a8eb2-1775"><paramref name="parameters" /> 包含的項目數與 <paramref name="TDelegate" /> 的參數清單不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1775"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="a8eb2-1776">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1776">-or-</span></span> 
<span data-ttu-id="a8eb2-1777"><paramref name="parameters" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法從 <paramref name="TDelegate" /> 之對應參數類型的類型指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1777">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="a8eb2-1778">委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1778">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="a8eb2-1779">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1779">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1780"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1780">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1781"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1781">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1782">建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1782">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1783"><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1783">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="a8eb2-1784">委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1784">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="a8eb2-1785">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1785">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1786"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1786">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1787">陣列，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1787">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1788">建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1788">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1789"><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1789">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="a8eb2-1790">委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1790">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="a8eb2-1791">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1791">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-1792">Lambda 的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1792">The name of the lambda.</span></span> <span data-ttu-id="a8eb2-1793">用於產生偵錯資訊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1793">Used for generating debugging information.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1794"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1794">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1795">建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1795">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1796"><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1796">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="a8eb2-1797">委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1797">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="a8eb2-1798">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1798">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-1799">Lambda 的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1799">The name of the lambda.</span></span> <span data-ttu-id="a8eb2-1800">用於產生偵錯資訊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1800">Used for generating debugging info.</span></span></param>
        <param name="tailCall"><span data-ttu-id="a8eb2-1801"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1801">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="a8eb2-1802"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1802">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1803">建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1803">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1804"><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1804">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1805">建立表示位元左移 (Left-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1805">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1806">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1806">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1807">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1807">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1808">建立表示位元左移 (Left-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1808">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1809"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1809">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1810">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1810">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1811"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1811">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1812">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1812">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-1813">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1813">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-1814"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1814">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1815">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1815">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1816">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1816">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1817">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1817">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1818">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`代表左移位運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1818">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1819">否則，如果`left`。類型為整數類資料類型 (其中<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>，或對應 null 的型別) 和`right`。型別是<xref:System.Int32>，則實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1819">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1820">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1820">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1821">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1821">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1822">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1822">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1823">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1823">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1824">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1824">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1825">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1825">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1826">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1826">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-1827">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1827">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1828">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1828">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1829">節點的類型是預先定義 left-shift 運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1829">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-1830">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1830">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1831">節點的類型為 null 的型別對應至預先定義 left-shift 運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1831">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1832"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1832"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1833">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type. 定義 Left-shift 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1833">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1834">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1834">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1835">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1835">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1836">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1836">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1837">建立表示位元左移 (Left-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1837">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1838"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1838">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1839">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1839">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1840"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1840">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1841">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1841">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-1842">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1842">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-1843"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1843">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1844">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1844">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1845">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1845">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1846">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1846">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1847">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1847">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-1848">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`代表左移位運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1848">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1849">否則，如果`left`。類型為整數類資料類型 (其中<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>，或對應 null 的型別) 和`right`。型別是<xref:System.Int32>，則實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1849">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1850">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1850">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1851">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1851">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1852">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1852">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1853">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1853">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1854">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1854">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1855">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1855">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1856">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1856">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-1857">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1857">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1858">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1858">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1859">節點的類型是預先定義 left-shift 運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1859">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-1860">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1860">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1861">節點的類型為 null 的型別對應至預先定義 left-shift 運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1861">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1862"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1862"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1863"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1863"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1864"><paramref name="method" /> 為 <see langword="null" /> 且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Left-shift 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1864"><paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1865">建立表示位元左移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1865">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1866">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1866">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1867">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1867">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1868">建立表示位元左移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1868">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1869"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1869">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1870">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1870">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1871">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1871">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1872">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1872">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1873">建立表示位元左移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1873">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1874"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1874">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1875">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1875">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1876">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1876">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1877">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1877">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-1878">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1878">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1879">建立表示位元左移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1879">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1880"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1880">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1881">建立代表「小於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1881">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1882">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1882">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1883">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1883">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1884">建立代表「小於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1884">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1885"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1885">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1886">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1886">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1887"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1887">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1888">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1888">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="a8eb2-1889">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1889">Otherwise, it is `false`.</span></span> <span data-ttu-id="a8eb2-1890"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1890">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="a8eb2-1891"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1891">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1892">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1892">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1893">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1893">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1894">作業的實作方法是選擇根據下列規則：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1894">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="a8eb2-1895">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 小於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1895">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1896">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1896">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1897">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1897">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1898">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1898">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1899">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1899">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1900">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1900">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1901">如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1901">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1902">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1902">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1903">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1903">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1904">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1904">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1905">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1905">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1906">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1906">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1907">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1907">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1908">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1908">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1909">下列程式碼範例示範如何建立可比較兩個整數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1909">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1910"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1910"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1911">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「小於」運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1911">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1912">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1912">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1913">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1913">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="a8eb2-1914"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1914"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1915">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1915">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1916">建立代表「小於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1916">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1917"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1917">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1918">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1918">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1919"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1919">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1920">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1920">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="a8eb2-1921">否則，兩者都是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1921">Otherwise, they are both `false`.</span></span> <span data-ttu-id="a8eb2-1922"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1922">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1923">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1923">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1924">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1924">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1925">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1925">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1926">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1926">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1927">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 小於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1927">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1928">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1928">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1929">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1929">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1930">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1930">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1931">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1931">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1932">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1932">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1933">如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1933">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1934">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1934">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1935">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1935">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1936">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1936">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1937">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1937">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1938">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1938">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1939">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1939">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1940">節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1940">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1941"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1941"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-1942"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1942"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1943"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的「小於」運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1943"><paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-1944">建立代表「小於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1944">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1945">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1945">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1946">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1947">建立代表「小於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1947">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1948"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1948">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1949">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1949">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1950"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1950">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1951">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1951">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="a8eb2-1952">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1952">Otherwise, it is `false`.</span></span> <span data-ttu-id="a8eb2-1953"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1953">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="a8eb2-1954"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1954">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1955">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1955">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1956">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1956">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1957">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1957">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1958">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 小於或等於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1958">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1959">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1959">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1960">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1960">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1961">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1962">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1962">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1963">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1963">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1964">如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1964">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1965">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1965">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1966">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1966">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1967">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1967">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1968">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1968">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1969">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1969">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-1970">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1970">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-1971">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1971">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-1972">下列程式碼範例示範如何建立可比較兩個整數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1972">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-1973"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1973"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-1974">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「小於或等於」運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1974">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-1975">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1975">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-1976">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1976">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="a8eb2-1977"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1977"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-1978">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1978">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-1979">建立代表「小於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1979">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-1980"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1980">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-1981">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1981">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-1982"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1982">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-1983">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1983">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="a8eb2-1984">否則，兩者都是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1984">Otherwise, they are both `false`.</span></span> <span data-ttu-id="a8eb2-1985"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1985">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-1986">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1986">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-1987">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1987">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-1988">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1988">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-1989">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1989">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1990">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 小於或等於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1990">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1991">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1991">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-1992">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1992">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-1993">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1993">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-1994">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1994">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-1995">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1995">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-1996">如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1996">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="a8eb2-1997">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1997">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-1998">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1998">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-1999">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-1999">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2000">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2000">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2001">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2001">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-2002">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2002">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2003">節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2003">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2004"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2004"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2005"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2005"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2006"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「小於或等於」運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2006"><paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2007">建立 <see cref="T:System.Linq.Expressions.MemberListBinding" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2007">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="a8eb2-2008"><see cref="T:System.Reflection.MemberInfo" />，表示要將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為與之相等的欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2008">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2009"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2009">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2010">建立 <see cref="T:System.Linq.Expressions.MemberListBinding" />，其中成員是欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2010">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2011"><see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2011">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2012"><paramref name="member" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2012"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2013">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2013">-or-</span></span> 
<span data-ttu-id="a8eb2-2014"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2014">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2015"><paramref name="member" /> 不代表欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2015"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="a8eb2-2016">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2016">-or-</span></span> 
<span data-ttu-id="a8eb2-2017"><paramref name="member" /> 所表示之欄位或屬性的 <see cref="P:System.Reflection.FieldInfo.FieldType" /> 或 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 不會實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2017">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="a8eb2-2018"><see cref="T:System.Reflection.MemberInfo" />，表示要將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為與之相等的欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2018">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2019">用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合之 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2019">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2020">建立 <see cref="T:System.Linq.Expressions.MemberListBinding" />，其中成員是欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2020">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2021"><see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2021">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2022"><paramref name="member" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2022"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2023">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2023">-or-</span></span> 
<span data-ttu-id="a8eb2-2024"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2024">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2025"><paramref name="member" /> 不代表欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2025"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="a8eb2-2026">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2026">-or-</span></span> 
<span data-ttu-id="a8eb2-2027"><paramref name="member" /> 所表示之欄位或屬性的 <see cref="P:System.Reflection.FieldInfo.FieldType" /> 或 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 不會實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2027">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="a8eb2-2028">代表屬性存取子方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2028">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2029"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2029">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2030">根據指定的屬性存取子方法建立 <see cref="T:System.Linq.Expressions.MemberListBinding" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2030">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2031"><see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.MemberInfo" />，表示在 <paramref name="propertyAccessor" /> 中存取的屬性，<see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 則會填入 <paramref name="initializers" /> 的項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2031">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2032"><paramref name="propertyAccessor" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2032"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2033">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2033">-or-</span></span> 
<span data-ttu-id="a8eb2-2034"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2034">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2035"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2035"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="a8eb2-2036">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2036">-or-</span></span> 
<span data-ttu-id="a8eb2-2037">屬性 (由 <paramref name="propertyAccessor" /> 存取表示的方法) 的 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 不會實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2037">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="a8eb2-2038">代表屬性存取子方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2038">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2039">用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合之 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2039">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2040">根據指定的屬性存取子方法建立 <see cref="T:System.Linq.Expressions.MemberListBinding" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2040">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2041"><see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.MemberInfo" />，表示在 <paramref name="propertyAccessor" /> 中存取的屬性，<see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 則會填入 <paramref name="initializers" /> 的項目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2041">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2042"><paramref name="propertyAccessor" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2042"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2043">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2043">-or-</span></span> 
<span data-ttu-id="a8eb2-2044"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2044">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2045"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2045"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="a8eb2-2046">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2046">-or-</span></span> 
<span data-ttu-id="a8eb2-2047">屬性 (由 <paramref name="propertyAccessor" /> 存取表示的方法) 的 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 不會實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2047">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2048">建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2048">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="a8eb2-2049">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2049">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2050"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2050">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2051">建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，它使用指定的 <see cref="T:System.Linq.Expressions.ElementInit" /> 物件初始化集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2051">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2052"><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，且 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2052">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2053"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2053">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="a8eb2-2054"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2054">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2055">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.ListInitExpression>，表示具有兩個索引鍵 / 值組的新字典執行個體初始化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2055">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2056"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2056"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2057">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2057">-or-</span></span> 
<span data-ttu-id="a8eb2-2058"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2058">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2059"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2059"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="a8eb2-2060">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2060">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2061"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2061">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2062">建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其使用名為 "Add" 的方法將項目加入集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2062">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2063"><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，而 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2063">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2064"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2064">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="a8eb2-2065">若要使用的這個多載<xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>， `newExpression`。型別或其基底類型必須宣告名為"Add"（不區分大小寫） 採用一個引數的單一方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2065">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="a8eb2-2066">引數類型必須是可指派所表示的類型從<xref:System.Linq.Expressions.Expression.Type%2A>屬性的第一個元素`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2066">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="a8eb2-2067"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>屬性傳回之<xref:System.Linq.Expressions.ListInitExpression>包含一個項目型別的<xref:System.Linq.Expressions.ElementInit>每個項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2067">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="a8eb2-2068"><xref:System.Linq.Expressions.ElementInit.Arguments%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>是單一集合，其中包含的對應項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2068">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="a8eb2-2069"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>代表探索到的 add 方法`newExpression`。型別或其基底類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2069">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="a8eb2-2070"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2070">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2071"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2071"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2072">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2072">-or-</span></span> 
<span data-ttu-id="a8eb2-2073"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2073">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2074"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2074"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2075">未在 <paramref name="newExpression" />.Type 或其基底型別中宣告名為 "Add" (不區分大小寫) 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2075">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="a8eb2-2076">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2076">-or-</span></span> 
<span data-ttu-id="a8eb2-2077"><paramref name="newExpression" />.Type 或其基底型別中的 add 方法不是只接受一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2077">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
<span data-ttu-id="a8eb2-2078">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2078">-or-</span></span> 
<span data-ttu-id="a8eb2-2079"><paramref name="initializers" />的第一個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所代表的型別，無法指派給 <paramref name="newExpression" />.Type 或其基底型別上的 add 方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2079">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="a8eb2-2080">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2080">-or-</span></span> 
<span data-ttu-id="a8eb2-2081">多個名為 "Add" (不區分大小寫) 的引數相容方法存在於 <paramref name="newExpression" /> .Type 和/或其基底型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2081">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="a8eb2-2082">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2082">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2083">用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合之 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2083">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2084">建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，它使用指定的 <see cref="T:System.Linq.Expressions.ElementInit" /> 物件初始化集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2084">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2085"><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，且 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2085">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2086"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2086">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="a8eb2-2087"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2087">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2088">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.ListInitExpression>，表示具有兩個索引鍵 / 值組的新字典執行個體初始化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2088">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2089"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2089"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2090">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2090">-or-</span></span> 
<span data-ttu-id="a8eb2-2091"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2091">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2092"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2092"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="a8eb2-2093">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2093">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2094">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2094">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2095">建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其使用名為 "Add" 的方法將項目加入集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2095">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2096"><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，而 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2096">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2097"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2097">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="a8eb2-2098">若要使用的這個多載<xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>， `newExpression`。型別或其基底類型必須宣告名為"Add"（不區分大小寫） 採用一個引數的單一方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2098">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="a8eb2-2099">引數類型必須是可指派所表示的類型從<xref:System.Linq.Expressions.Expression.Type%2A>屬性的第一個元素`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2099">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="a8eb2-2100"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>屬性傳回之<xref:System.Linq.Expressions.ListInitExpression>包含一個項目型別的<xref:System.Linq.Expressions.ElementInit>每個項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2100">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="a8eb2-2101"><xref:System.Linq.Expressions.ElementInit.Arguments%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>是單一集合，其中包含的對應項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2101">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="a8eb2-2102"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>代表探索到的 add 方法`newExpression`。型別或其基底類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2102">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="a8eb2-2103"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2103">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2104"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2104"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2105">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2105">-or-</span></span> 
<span data-ttu-id="a8eb2-2106"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2106">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2107"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2107"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2108">未在 <paramref name="newExpression" />.Type 或其基底型別中宣告名為 "Add" (不區分大小寫) 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2108">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="a8eb2-2109">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2109">-or-</span></span> 
<span data-ttu-id="a8eb2-2110"><paramref name="newExpression" />.Type 或其基底型別中的 add 方法不是只接受一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2110">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
<span data-ttu-id="a8eb2-2111">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2111">-or-</span></span> 
<span data-ttu-id="a8eb2-2112"><paramref name="initializers" />的第一個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所代表的型別，無法指派給 <paramref name="newExpression" />.Type 或其基底型別上的 add 方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2112">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="a8eb2-2113">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2113">-or-</span></span> 
<span data-ttu-id="a8eb2-2114">多個名為 "Add" (不區分大小寫) 的引數相容方法存在於 <paramref name="newExpression" /> .Type 和/或其基底型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2114">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="a8eb2-2115">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2115">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="a8eb2-2116"><see cref="T:System.Reflection.MethodInfo" />，代表名為 "Add" (區分大小寫) 的執行個體方法，可將項目加入集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2116">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2117"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2117">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2118">建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其使用指定的方法將項目加入集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2118">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2119"><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，而 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2119">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2120"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2120">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="a8eb2-2121">如果`addMethod`已`null`， `newExpression`。型別或其基底類型必須宣告名為"Add"（不區分大小寫） 採用一個引數的單一方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2121">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="a8eb2-2122">如果`addMethod`不是`null`，它必須表示有一個參數的執行個體方法名為"Add"（不區分大小寫）。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2122">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="a8eb2-2123">所表示的型別<xref:System.Linq.Expressions.Expression.Type%2A>的每個項目的屬性`initializers`必須能夠指派給 add 方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2123">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="a8eb2-2124"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>屬性傳回之<xref:System.Linq.Expressions.ListInitExpression>包含一個項目型別的<xref:System.Linq.Expressions.ElementInit>每個項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2124">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="a8eb2-2125"><xref:System.Linq.Expressions.ElementInit.Arguments%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>是單一集合，其中包含的對應項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2125">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="a8eb2-2126"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>等於`addMethod`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2126">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="a8eb2-2127"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2127">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2128"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2128"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2129">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2129">-or-</span></span> 
<span data-ttu-id="a8eb2-2130"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2130">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2131"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2131"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
<span data-ttu-id="a8eb2-2132">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2132">-or-</span></span> 
 <span data-ttu-id="a8eb2-2133"><paramref name="addMethod" /> 不是 <see langword="null" />，它不表示名為 "Add" (區分大小寫) 的執行個體方法，這個方法剛好只採用一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2133"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
<span data-ttu-id="a8eb2-2134">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2134">-or-</span></span> 
 <span data-ttu-id="a8eb2-2135"><paramref name="addMethod" /> 不是 <see langword="null" />，且 <paramref name="initializers" /> 之一個或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性表示的類型無法指派給 <paramref name="addMethod" /> 所表示之方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2135"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2136"><paramref name="addMethod" /> 是 <see langword="null" />，且 <paramref name="newExpression" />.Type 或其基底類型上沒有採用一個類型相容引數之名為 "Add" 的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2136"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="a8eb2-2137">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2137">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="a8eb2-2138"><see cref="T:System.Reflection.MethodInfo" />，代表採用一個引數的執行個體方法，可將項目加入集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2138">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2139">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2139">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2140">建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其使用指定的方法將項目加入集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2140">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2141"><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，而 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2141">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2142"><xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2142">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="a8eb2-2143">如果`addMethod`已`null`， `newExpression`。型別或其基底類型必須宣告名為"Add"（不區分大小寫） 採用一個引數的單一方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2143">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="a8eb2-2144">如果`addMethod`不是`null`，它必須表示有一個參數的執行個體方法名為"Add"（不區分大小寫）。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2144">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="a8eb2-2145">所表示的型別<xref:System.Linq.Expressions.Expression.Type%2A>的每個項目的屬性`initializers`必須能夠指派給 add 方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2145">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="a8eb2-2146"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>屬性傳回之<xref:System.Linq.Expressions.ListInitExpression>包含一個項目型別的<xref:System.Linq.Expressions.ElementInit>每個項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2146">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="a8eb2-2147"><xref:System.Linq.Expressions.ElementInit.Arguments%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>是單一集合，其中包含的對應項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2147">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="a8eb2-2148"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>等於`addMethod`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2148">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="a8eb2-2149"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2149">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2150"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2150"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2151">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2151">-or-</span></span> 
<span data-ttu-id="a8eb2-2152"><paramref name="initializers" /> 的一個或多個項目為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2152">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2153"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2153"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
<span data-ttu-id="a8eb2-2154">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2154">-or-</span></span> 
 <span data-ttu-id="a8eb2-2155"><paramref name="addMethod" /> 不是 <see langword="null" />，它不表示名為 "Add" (區分大小寫) 的執行個體方法，這個方法剛好只採用一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2155"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
<span data-ttu-id="a8eb2-2156">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2156">-or-</span></span> 
 <span data-ttu-id="a8eb2-2157"><paramref name="addMethod" /> 不是 <see langword="null" />，且 <paramref name="initializers" /> 之一個或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性表示的類型無法指派給 <paramref name="addMethod" /> 所表示之方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2157"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2158"><paramref name="addMethod" /> 是 <see langword="null" />，且 <paramref name="newExpression" />.Type 或其基底類型上沒有採用一個類型相容引數之名為 "Add" 的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2158"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2159">建立 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2159">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-2160">迴圈的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2160">The body of the loop.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2161">建立包含指定之主體的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2161">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2162">建立的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2162">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-2163">迴圈的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2163">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="a8eb2-2164">迴圈主體所使用的 break 目標。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2164">The break target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2165">建立包含指定之主體和 break 目標的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2165">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2166">建立的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2166">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-2167">下列範例示範如何建立包含區塊運算式<xref:System.Linq.Expressions.LoopExpression>物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2167">The following example demonstrates how to create a block expression that contains a <xref:System.Linq.Expressions.LoopExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-2168">迴圈的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2168">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="a8eb2-2169">迴圈主體所使用的 break 目標。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2169">The break target used by the loop body.</span></span></param>
        <param name="continue"><span data-ttu-id="a8eb2-2170">迴圈主體所使用的 continue 目標。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2170">The continue target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2171">建立包含指定之主體的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2171">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2172">建立的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2172">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2173">透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2173">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="a8eb2-2174"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定二進位運算的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2174">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="a8eb2-2175">代表左運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2175">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2176">代表右運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2176">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2177">透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，指定左運算元和右運算元。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2177">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2178"><see cref="T:System.Linq.Expressions.BinaryExpression" />，由呼叫適當的 Factory 方法所產生。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2178">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2179">`binaryType`參數會決定其<xref:System.Linq.Expressions.BinaryExpression>這個方法會呼叫 factory 方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2179">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method calls.</span></span> <span data-ttu-id="a8eb2-2180">例如，如果`binaryType`已<xref:System.Linq.Expressions.ExpressionType.Subtract>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Subtract%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2180">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2181">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29>方法用來建立<xref:System.Linq.Expressions.BinaryExpression>表示從另一個數字的減法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> method to create a <xref:System.Linq.Expressions.BinaryExpression> that represents the subtraction of one number from another.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2182"><paramref name="binaryType" /> 未對應到二進位運算式節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2182"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2183"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2183"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="a8eb2-2184"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定二進位運算的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2184">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="a8eb2-2185">代表左運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2185">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2186">代表右運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2186">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="a8eb2-2187"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2187"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2188"><see cref="T:System.Reflection.MethodInfo" />，可指定實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2188">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2189">透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，指定左運算元、右運算元和實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2189">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2190"><see cref="T:System.Linq.Expressions.BinaryExpression" />，由呼叫適當的 Factory 方法所產生。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2190">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2191">`binaryType`參數會決定其<xref:System.Linq.Expressions.BinaryExpression>factory 方法會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2191">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="a8eb2-2192">例如，如果`binaryType`已<xref:System.Linq.Expressions.ExpressionType.Subtract>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Subtract%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2192">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="a8eb2-2193">`liftToNull`和`method`如果適當的 factory 方法並沒有對應的參數，則會忽略參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2193">The `liftToNull` and `method` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2194"><paramref name="binaryType" /> 未對應到二進位運算式節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2194"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2195"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2195"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="a8eb2-2196"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定二進位運算的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2196">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="a8eb2-2197">代表左運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2197">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2198">代表右運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2198">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="a8eb2-2199"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2199"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2200"><see cref="T:System.Reflection.MethodInfo" />，可指定實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2200">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-2201">代表類型轉換函式的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2201">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</span></span> <span data-ttu-id="a8eb2-2202">只有當 <paramref name="binaryType" /> 為 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> 或複合指派時，才會使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2202">This parameter is used only if <paramref name="binaryType" /> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment..</span></span></param>
        <summary><span data-ttu-id="a8eb2-2203">透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，指定左運算元、右運算元、實作方法和類型轉換函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2203">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2204"><see cref="T:System.Linq.Expressions.BinaryExpression" />，由呼叫適當的 Factory 方法所產生。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2204">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2205">`binaryType`參數會決定其<xref:System.Linq.Expressions.BinaryExpression>factory 方法會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2205">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="a8eb2-2206">例如，如果`binaryType`已<xref:System.Linq.Expressions.ExpressionType.Subtract>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Subtract%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2206">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="a8eb2-2207">`liftToNull`，`method`和`conversion`如果適當的 factory 方法並沒有對應的參數，則會忽略參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2207">The `liftToNull`, `method` and `conversion` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2208"><paramref name="binaryType" /> 未對應到二進位運算式節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2208"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2209"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2209"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-2210">這個 <see cref="P:System.Linq.Expressions.Expression.Type" /> 將處理之 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2210">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="variable"><span data-ttu-id="a8eb2-2211"><see cref="T:System.Linq.Expressions.ParameterExpression" />，代表這個處理常式所攔截 <see cref="T:System.Exception" /> 物件的參考。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2211">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-2212">catch 陳述式的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2212">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="a8eb2-2213"><see cref="T:System.Exception" /> 篩選條件的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2213">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2214">建立 <see cref="T:System.Linq.Expressions.CatchBlock" />，代表含指定之項目的 catch 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2214">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2215">建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2215">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2216">`type` 必須為非 null，而且符合類型`variable`（如果它提供）。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2216">`type` must be non-null and match the type of `variable` (if it is supplied).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2217">建立代表動態運算的 <see cref="T:System.Linq.Expressions.DynamicExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2217">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-2218"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2218">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="a8eb2-2219">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2219">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-2220">動態作業的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2220">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2221">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2221">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2222"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2222">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-2223"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2223">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="a8eb2-2224">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2224">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-2225">動態運算的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2225">The argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2226">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和一個引數所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2226">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2227"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2227">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-2228"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2228">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="a8eb2-2229">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2229">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-2230">動態作業的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2230">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2231">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2231">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2232"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2232">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-2233"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2233">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="a8eb2-2234">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2234">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-2235">動態作業的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2235">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-2236">傳遞至動態作業的第二個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2236">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2237">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和兩個引數所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2237">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2238"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2238">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-2239"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2239">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="a8eb2-2240">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2240">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-2241">動態作業的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2241">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-2242">傳遞至動態作業的第二個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2242">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-2243">傳遞至動態作業的第三個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2243">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2244">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和三個引數所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2244">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2245"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2245">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a8eb2-2246"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2246">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="a8eb2-2247">動態作業的執行階段繫結器。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2247">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="a8eb2-2248">動態作業的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2248">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="a8eb2-2249">傳遞至動態作業的第二個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2249">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="a8eb2-2250">傳遞至動態作業的第三個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2250">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="a8eb2-2251">傳遞至動態運算的第四個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2251">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2252">建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和四個引數所繫結的動態運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2252">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2253"><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2253">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind"><span data-ttu-id="a8eb2-2254"><see cref="T:System.Linq.Expressions.GotoExpressionKind" /> 的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2254">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</span></span></param>
        <param name="target"><span data-ttu-id="a8eb2-2255"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2255">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="a8eb2-2256">將在跳躍時傳遞至關聯標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2256">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-2257">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2257">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2258">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，代表指定之 <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> 的跳躍點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2258">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span></span> <span data-ttu-id="a8eb2-2259">也可以指定在跳躍時傳遞至標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2259">The value passed to the label upon jumping can also be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2260"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 <paramref name="kind" />、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2260">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-2261">屬性所屬的物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2261">The object to which the property belongs.</span></span> <span data-ttu-id="a8eb2-2262">如果屬性為 <see langword="static" /> (在 Visual Basic 中為 <see langword="shared" />)，則應該是 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2262">It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</span></span></param>
        <param name="indexer"><span data-ttu-id="a8eb2-2263"><see cref="T:System.Linq.Expressions.Expression" />，代表要編製索引的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2263">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-2264"><c>IEnumerable&lt;Expression&gt;</c> (在 Visual Basic 中為 <c>IEnumerable (Of Expression)</c>)，包含將用於對屬性進行索引的引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2264">An <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) that contains the arguments that will be used to index the property.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2265">建立 <see cref="T:System.Linq.Expressions.IndexExpression" />，代表存取物件中的索引屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2265">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2266">建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2266">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2267"><see cref="T:System.Linq.Expressions.Expression" />，代表成員所屬的物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2267">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to.</span></span> <span data-ttu-id="a8eb2-2268">如果是靜態成員，可以是 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2268">This can be null for static members.</span></span></param>
        <param name="member"><span data-ttu-id="a8eb2-2269"><see cref="T:System.Reflection.MemberInfo" />，說明要存取的欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2269">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2270">建立代表存取欄位或屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2270">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2271"><see cref="T:System.Linq.Expressions.MemberExpression" />，由呼叫適當的 Factory 方法所產生。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2271">The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2272">這個方法可用來建立<xref:System.Linq.Expressions.MemberExpression>，代表存取欄位或屬性，根據類型`member`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2272">This method can be used to create a <xref:System.Linq.Expressions.MemberExpression> that represents accessing either a field or a property, depending on the type of `member`.</span></span> <span data-ttu-id="a8eb2-2273">如果`member`屬於型別<xref:System.Reflection.FieldInfo>，這個方法會呼叫<xref:System.Linq.Expressions.Expression.Field%2A>建立<xref:System.Linq.Expressions.MemberExpression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2273">If `member` is of type <xref:System.Reflection.FieldInfo>, this method calls <xref:System.Linq.Expressions.Expression.Field%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span> <span data-ttu-id="a8eb2-2274">如果`member`屬於型別<xref:System.Reflection.PropertyInfo>，這個方法會呼叫<xref:System.Linq.Expressions.Expression.Property%2A>建立<xref:System.Linq.Expressions.MemberExpression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2274">If `member` is of type <xref:System.Reflection.PropertyInfo>, this method calls <xref:System.Linq.Expressions.Expression.Property%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2275"><paramref name="member" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2275"><paramref name="member" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2276"><paramref name="member" /> 不代表欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2276"><paramref name="member" /> does not represent a field or property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-2277">try 運算式的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2277">The result type of the try expression.</span></span> <span data-ttu-id="a8eb2-2278">如果為 Null，則 bodh 和所有處理常式必須具有相同的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2278">If null, bodh and all handlers must have identical type.</span></span></param>
        <param name="body"><span data-ttu-id="a8eb2-2279">try 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2279">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="a8eb2-2280">finally 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2280">The body of the finally block.</span></span> <span data-ttu-id="a8eb2-2281">如果 try 區塊沒有相關聯的 finally 區塊，則傳遞 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2281">Pass null if the try block has no finally block associated with it.</span></span></param>
        <param name="fault"><span data-ttu-id="a8eb2-2282">fault 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2282">The body of the fault block.</span></span> <span data-ttu-id="a8eb2-2283">如果 try 區塊沒有相關聯的 fault 區塊，則傳遞 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2283">Pass null if the try block has no fault block associated with it.</span></span></param>
        <param name="handlers"><span data-ttu-id="a8eb2-2284"><see cref="T:System.Linq.Expressions.CatchBlock" /> 的集合，代表要與 try 區塊產生關聯的 catch 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2284">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2285">建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含指定之項目的 try 區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2285">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2286">建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2286">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2287">透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2287">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="a8eb2-2288"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定一元運算的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2288">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="a8eb2-2289">代表運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2289">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-2290"><see cref="T:System.Type" />，指定轉換後的類型 (如果不適用，則傳遞 <see langword="null" />)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2290">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <summary><span data-ttu-id="a8eb2-2291">指定運算元並呼叫適當的 Factory 方法，建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2291">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2292"><see cref="T:System.Linq.Expressions.UnaryExpression" />，由呼叫適當的 Factory 方法所產生。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2292">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2293">`unaryType`參數會決定其<xref:System.Linq.Expressions.UnaryExpression>這個方法會呼叫 factory 方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2293">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="a8eb2-2294">例如，如果`unaryType`等於<xref:System.Linq.Expressions.ExpressionType.Convert>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Convert%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2294">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="a8eb2-2295">`type`如果不適用於呼叫 factory 方法，則會忽略參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2295">The `type`parameter is ignored if it does not apply to the factory method that is called.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2296"><paramref name="operand" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2296"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2297"><paramref name="unaryType" /> 未對應到一元運算式節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2297"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="a8eb2-2298"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定一元運算的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2298">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="a8eb2-2299">代表運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2299">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-2300"><see cref="T:System.Type" />，指定轉換後的類型 (如果不適用，則傳遞 <see langword="null" />)。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2300">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2301">代表實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2301">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2302">指定運算元和實作方法並透過呼叫適當的 Fatory 方法，建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2302">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2303"><see cref="T:System.Linq.Expressions.UnaryExpression" />，由呼叫適當的 Factory 方法所產生。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2303">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2304">`unaryType`參數會決定其<xref:System.Linq.Expressions.UnaryExpression>這個方法會呼叫 factory 方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2304">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="a8eb2-2305">例如，如果`unaryType`等於<xref:System.Linq.Expressions.ExpressionType.Convert>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Convert%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2305">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="a8eb2-2306">`type`和`method`如果它們並不適用於呼叫 factory 方法，則會忽略參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2306">The `type` and `method` parameters are ignored if they do not apply to the factory method that is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2307"><paramref name="operand" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2307"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2308"><paramref name="unaryType" /> 未對應到一元運算式節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2308"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2309">建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化成員的成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2309">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="a8eb2-2310">要將 <see cref="T:System.Reflection.MemberInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2310">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="a8eb2-2311"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2311">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2312">建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化欄位或屬性的成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2312">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2313"><see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2313">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2314">`member`參數必須代表欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2314">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2315"><paramref name="member" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2315"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2316"><paramref name="member" /> 不代表欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2316"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="a8eb2-2317">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2317">-or-</span></span> 
<span data-ttu-id="a8eb2-2318"><paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="member" /> 所表示之欄位或屬性類型的成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2318">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="a8eb2-2319">要將 <see cref="T:System.Reflection.MemberInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2319">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="a8eb2-2320">用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合之 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2320">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2321">建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化欄位或屬性的成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2321">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2322"><see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2322">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2323">`member`參數必須代表欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2323">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2324"><paramref name="member" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2324"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2325"><paramref name="member" /> 不代表欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2325"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="a8eb2-2326">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2326">-or-</span></span> 
<span data-ttu-id="a8eb2-2327"><paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="member" /> 所表示之欄位或屬性類型的成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2327">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="a8eb2-2328"><see cref="T:System.Reflection.MethodInfo" />，代表屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2328">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="a8eb2-2329"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2329">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2330">建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化成員的成員，該成員可透過使用屬性存取子方法來存取。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2330">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2331"><see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，表示在 <paramref name="propertyAccessor" /> 中存取的屬性，<see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 屬性則設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2331">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2332"><paramref name="propertyAccessor" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2332"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2333"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2333"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="a8eb2-2334">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2334">-or-</span></span> 
<span data-ttu-id="a8eb2-2335"><paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="propertyAccessor" /> 所表示之方法存取的屬性類型成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2335">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="a8eb2-2336"><see cref="T:System.Reflection.MethodInfo" />，代表屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2336">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="a8eb2-2337">用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合之 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2337">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2338">建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化成員的成員，該成員可透過使用屬性存取子方法來存取。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2338">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2339"><see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，表示在 <paramref name="propertyAccessor" /> 中存取的屬性，<see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 屬性則設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2339">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2340"><paramref name="propertyAccessor" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2340"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2341"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2341"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="a8eb2-2342">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2342">-or-</span></span> 
<span data-ttu-id="a8eb2-2343"><paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="propertyAccessor" /> 所表示之方法存取的屬性類型成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2343">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2344">表示建立新物件並初始化物件屬性的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2344">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="a8eb2-2345">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2345">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="a8eb2-2346"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2346">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2347">表示建立新物件並初始化物件屬性的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2347">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2348"><see cref="T:System.Linq.Expressions.MemberInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" />，且 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2348">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2349"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberInitExpression>等於<xref:System.Linq.Expressions.Expression.Type%2A>屬性`newExpression`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2349">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2350">下列範例示範建立新的物件，並初始化物件屬性的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2350">The following example demonstrates an expression that creates a new object and initializes a property of the object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2351"><paramref name="newExpression" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2351"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2352"><paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="newExpression" />.Type 所表示之類型的成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2352">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="a8eb2-2353">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2353">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="a8eb2-2354">用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合之 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2354">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2355">建立 <see cref="T:System.Linq.Expressions.MemberInitExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2355">Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2356"><see cref="T:System.Linq.Expressions.MemberInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" />，且 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2356">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2357"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberInitExpression>等於<xref:System.Linq.Expressions.Expression.Type%2A>屬性`newExpression`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2357">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2358">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.MemberInitExpression>，表示新物件的兩個成員初始化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2358">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> method to create a <xref:System.Linq.Expressions.MemberInitExpression> that represents the initialization of two members of a new object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2359"><paramref name="newExpression" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2359"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2360"><paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="newExpression" />.Type 所表示之類型的成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2360">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2361">建立代表算術餘數運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2361">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2362">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2362">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2363">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2363">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2364">建立代表算術餘數運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2364">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2365"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2366">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2366">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2367"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2367">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2368">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2368">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2369">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2369">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-2370"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2370">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2371">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2371">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2372">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2372">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2373">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2373">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2374">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載模數運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2374">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2375">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2375">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2376">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2376">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2377">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2377">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2378">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2378">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2379">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2379">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2380">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2380">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2381">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2381">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2382">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2382">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2383">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2383">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2384">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2384">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2385">節點的類型是預先定義的模數運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2385">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-2386">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2386">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2387">節點的類型為 null 的型別對應至預先定義的模數運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2387">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2388"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2388"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2389">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義餘數運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2389">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2390">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2390">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2391">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2391">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2392">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2392">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2393">建立代表算術餘數運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2393">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2394"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2395">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2395">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2396"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2396">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2397">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2397">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2398">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2398">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-2399"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2399">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2400">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2400">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2401">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2401">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2402">作業的實作方法是選擇根據下列規則：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2402">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="a8eb2-2403">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2403">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-2404">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載模數運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2404">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2405">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2405">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2406">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2406">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2407">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2407">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2408">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2408">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2409">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2409">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2410">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2410">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2411">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2411">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2412">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2412">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2413">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2413">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2414">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2414">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2415">節點的類型是預先定義的模數運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2415">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-2416">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2416">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2417">節點的類型為 null 的型別對應至預先定義的模數運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2417">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2418"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2418"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2419"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2419"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2420"><paramref name="method" /> 是 <see langword="null" />，且未針對 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義模數運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2420"><paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2421">建立表示餘數指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2421">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2422">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2423">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2423">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2424">建立表示餘數指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2424">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2425"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2426">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2427">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2428">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2428">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2429">建立表示餘數指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2429">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2430"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2431">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2432">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2432">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2433">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2433">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-2434">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2435">建立表示餘數指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2436"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2437">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術乘法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2437">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2438">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2439">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2439">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2440">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術乘法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2440">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2441"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2442">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2442">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2443"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2443">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2444">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2444">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2445">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2445">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-2446"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2446">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2447">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2447">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2448">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2448">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2449">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2449">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2450">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載乘法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2450">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2451">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2451">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2452">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2452">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2453">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2453">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2454">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2454">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2455">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2455">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2456">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2456">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2457">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2457">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2458">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2458">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2459">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2459">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2460">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2460">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2461">節點的類型是預先定義的乘法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2461">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-2462">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2462">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2463">節點的類型為 null 的型別對應至預先定義的乘法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2463">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2464">下列程式碼範例示範如何建立將兩個值相乘的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2464">The following code example shows how to create an expression that multiplies two values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2465"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2465"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2466">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Multiplication 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2466">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2467">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2467">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2468">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2468">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2469">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2469">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2470">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術乘法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2471"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2471">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2472">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2472">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2473"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2473">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2474">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2474">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2475">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2475">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-2476"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2476">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2477">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2477">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2478">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2478">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2479">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2479">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2480">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2480">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-2481">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載乘法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2481">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2482">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2482">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2483">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2483">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2484">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2484">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2485">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2485">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2486">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2486">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2487">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2487">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2488">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2488">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2489">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2489">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2490">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2490">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2491">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2491">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2492">節點的類型是預先定義的乘法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2492">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-2493">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2493">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2494">節點的類型為 null 的型別對應至預先定義的乘法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2494">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2495"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2495"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2496"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2496"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2497"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Multiplication 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2497"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2498">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的乘法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2498">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2499">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2499">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2500">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2501">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的乘法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2501">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2502"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2502">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2503">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2503">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2504">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2504">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2505">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2505">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2506">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的乘法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2506">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2507"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2508">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2509">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2509">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2510">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2510">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-2511">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2511">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2512">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的乘法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2512">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2513"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2513">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2514">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的乘法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2514">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2515">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2516">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2516">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2517">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的乘法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2517">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2518"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2519">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2520">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2521">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2521">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2522">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的乘法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2522">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2523"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2524">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2524">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2525">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2525">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2526">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2526">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-2527">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2527">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2528">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的乘法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2528">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2529"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2529">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2530">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術乘法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2530">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2531">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2532">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2533">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術乘法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2533">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2534"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2535">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2535">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2536"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2536">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2537">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2537">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2538">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2538">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-2539"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2539">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2540">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2540">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2541">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2541">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2542">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2542">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2543">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載乘法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2543">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2544">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2544">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2545">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2545">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2546">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2546">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2547">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2547">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2548">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2548">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2549">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2549">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2550">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2550">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2551">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2551">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2552">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2552">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2553">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2553">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2554">節點的類型是預先定義的乘法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2554">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-2555">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2555">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2556">節點的類型為 null 的型別對應至預先定義的乘法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2556">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2557"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2557"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2558">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Multiplication 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2558">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2559">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2559">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2560">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2560">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2561">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2561">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2562">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術乘法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2562">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2563"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2563">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2564">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2564">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2565"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2565">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2566">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2566">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2567">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2567">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-2568"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2568">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2569">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2569">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2570">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2570">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2571">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2571">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2572">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2572">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-2573">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載乘法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2573">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2574">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2574">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2575">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2575">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2576">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2576">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2577">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2577">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2578">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2578">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2579">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2579">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2580">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2580">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2581">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2581">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2582">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2582">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2583">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2583">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2584">節點的類型是預先定義的乘法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2584">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-2585">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2585">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2586">節點的類型為 null 的型別對應至預先定義的乘法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2586">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2587"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2587"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2588"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2588"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2589"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Multiplication 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2589"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2590">建立代表算術負運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2590">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2591">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2591">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2592">建立代表算術負運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2592">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2593"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Negate" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2593">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2594"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2594">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2595"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2595">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2596">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2596">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2597">否則，它們是 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2597">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2598">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2598">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2599">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2599">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2600">如果`expression`。類型是使用者定義的類型定義一元減號運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2600">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2601">否則，如果`expression`。類型為數值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2601">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2602">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2602">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2603">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2603">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2604">如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2604">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2605">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2605">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2606">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2606">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2607">`expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2607">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2608">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2608">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2609">實作的方法是否`null`，節點的類型是`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2609">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="a8eb2-2610">如果`expression`。類型是不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2610">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2611">否則，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2611">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2612">下列範例示範如何建立代表算術負運算的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2612">The following example demonstrates how to create an expression that represents an arithmetic negation operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2613"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2613"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2614">不會為 <paramref name="expression" />.Type 定義一元減號運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2614">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2615">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2615">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2616">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2616">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2617">建立代表算術負運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2617">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2618"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Negate" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2618">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2619"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2619">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2620"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2620">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2621">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2621">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2622">否則，它們是 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2622">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2623">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2623">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2624">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2624">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2625">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2625">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-2626">如果`expression`。類型是使用者定義的類型定義一元減號運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2626">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2627">否則，如果`expression`。類型為數值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2627">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2628">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2628">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2629">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2629">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2630">如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2630">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2631">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2631">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2632">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2632">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2633">`expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2633">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2634">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2634">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2635">實作的方法是否`null`，節點的類型是`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2635">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="a8eb2-2636">如果`expression`。類型是不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2636">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2637">否則，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2637">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2638"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2638"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2639"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2639"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2640"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="expression" />.Type 定義一元減號運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2640"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-2641">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2641">-or-</span></span> 
 <span data-ttu-id="a8eb2-2642"><paramref name="expression" />.Type (如果它是可為 Null 的實質類型，則為其對應之不可為 Null 的類型) 無法指派給 <paramref name="method" /> 所代表之方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2642"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2643">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其代表包含溢位檢查的算術負運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2643">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2644">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2644">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2645">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其代表包含溢位檢查的算術負運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2645">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2646"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2646">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2647"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2647">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2648"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2648">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2649">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2649">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2650">否則，它們是 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2650">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2651">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2651">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2652">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2652">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2653">如果`expression`。類型是使用者定義的類型定義一元減號運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2653">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2654">否則，如果`expression`。類型為數值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2654">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2655">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2655">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2656">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2656">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2657">如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2657">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2658">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2658">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2659">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2659">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2660">`expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2660">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2661">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2661">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2662">實作的方法是否`null`，節點的類型是`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2662">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="a8eb2-2663">如果`expression`。類型是不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2663">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2664">否則，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2664">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2665"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2665"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2666">不會為 <paramref name="expression" />.Type 定義一元減號運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2666">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2667">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2667">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2668">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2668">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2669">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其代表包含溢位檢查的算術負運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2669">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span> <span data-ttu-id="a8eb2-2670">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2670">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2671"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2671">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2672"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2672">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2673"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2673">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2674">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2674">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2675">否則，它們是 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2675">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2676">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2676">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2677">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2677">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2678">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2678">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-2679">如果`expression`。類型是使用者定義的類型定義一元減號運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2679">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2680">否則，如果`expression`。類型為數值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2680">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2681">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2681">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2682">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2682">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2683">如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2683">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2684">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2684">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2685">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2685">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2686">`expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2686">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2687">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2687">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2688">實作的方法是否`null`，節點的類型是`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2688">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="a8eb2-2689">如果`expression`。類型是不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2689">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2690">否則，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2690">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2691"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2691"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2692"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2692"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2693"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="expression" />.Type 定義一元減號運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2693"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-2694">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2694">-or-</span></span> 
 <span data-ttu-id="a8eb2-2695"><paramref name="expression" />.Type (如果它是可為 Null 的實質類型，則為其對應之不可為 Null 的類型) 無法指派給 <paramref name="method" /> 所代表之方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2695"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2696">建立 <see cref="T:System.Linq.Expressions.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2696">Creates a <see cref="T:System.Linq.Expressions.NewExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="a8eb2-2697">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2697">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2698">建立 <see cref="T:System.Linq.Expressions.NewExpression" />，代表呼叫不採用任何引數的指定建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2698">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2699"><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，而 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2699">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2700"><xref:System.Linq.Expressions.NewExpression.Arguments%2A>並<xref:System.Linq.Expressions.NewExpression.Members%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>是空的集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2700">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="a8eb2-2701"><xref:System.Linq.Expressions.Expression.Type%2A>屬性表示建構函式所代表的宣告型別`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2701">The <xref:System.Linq.Expressions.Expression.Type%2A> property represents the declaring type of the constructor represented by `constructor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2702"><paramref name="constructor" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2702"><paramref name="constructor" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2703">由 <paramref name="constructor" /> 表示的建構函式，擁有至少一個參數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2703">The constructor that <paramref name="constructor" /> represents has at least one parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-2704"><see cref="T:System.Type" />，具有不採用任何引數的建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2704">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2705">建立 <see cref="T:System.Linq.Expressions.NewExpression" />，代表呼叫指定類型的無參數建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2705">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2706"><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 屬性設定為 <see cref="T:System.Reflection.ConstructorInfo" />，代表不含指定類型之參數的建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2706">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2707">`type`參數必須代表不含參數的建構函式的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2707">The `type` parameter must represent a type that has a constructor without parameters.</span></span>  
  
 <span data-ttu-id="a8eb2-2708"><xref:System.Linq.Expressions.NewExpression.Arguments%2A>並<xref:System.Linq.Expressions.NewExpression.Members%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>是空的集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2708">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="a8eb2-2709"><xref:System.Linq.Expressions.Expression.Type%2A>屬性等於`type`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2709">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2710">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.New%28System.Type%29>方法用來建立<xref:System.Linq.Expressions.NewExpression>，代表不含參數的建構函式建構一個字典物件的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2710">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.New%28System.Type%29> method to create a <xref:System.Linq.Expressions.NewExpression> that represents constructing a new instance of a dictionary object by calling the constructor without parameters.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2711"><paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2711"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2712"><paramref name="type" /> 表示的類型沒有無參數建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2712">The type that <paramref name="type" /> represents does not have a constructor without parameters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="a8eb2-2713">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2713">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-2714"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2714">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2715">建立 <see cref="T:System.Linq.Expressions.NewExpression" />，其代表以指定之引數呼叫指定的建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2715">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2716"><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2716">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2717">`arguments`參數必須包含相同數目的元素所代表之建構函式的參數數目為`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2717">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="a8eb2-2718">如果`arguments`是`null`，它是空的而<xref:System.Linq.Expressions.NewExpression.Arguments%2A>屬性所產生的<xref:System.Linq.Expressions.NewExpression>為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2718">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="a8eb2-2719"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>代表所表示的建構函式的宣告型別`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2719">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="a8eb2-2720"><xref:System.Linq.Expressions.NewExpression.Members%2A>屬性為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2720">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2721"><paramref name="constructor" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2721"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2722">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2722">-or-</span></span> 
<span data-ttu-id="a8eb2-2723"><paramref name="arguments" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2723">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2724"><paramref name="arguments" /> 參數包含的項目數目與 <paramref name="constructor" /> 所表示之建構函式的參數數目不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2724">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="a8eb2-2725">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2725">-or-</span></span> 
<span data-ttu-id="a8eb2-2726"><paramref name="arguments" /> 項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="constructor" /> 所代表之建構函式的對應參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2726">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="a8eb2-2727">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2727">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-2728">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2728">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2729">建立 <see cref="T:System.Linq.Expressions.NewExpression" />，其代表以指定之引數呼叫指定的建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2729">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2730"><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2730">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2731">`arguments`參數必須包含相同數目的元素所代表之建構函式的參數數目為`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2731">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="a8eb2-2732">如果`arguments`是`null`，它是空的而<xref:System.Linq.Expressions.NewExpression.Arguments%2A>屬性所產生的<xref:System.Linq.Expressions.NewExpression>為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2732">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="a8eb2-2733"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>代表所表示的建構函式的宣告型別`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2733">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="a8eb2-2734"><xref:System.Linq.Expressions.NewExpression.Members%2A>屬性為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2734">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2735"><paramref name="constructor" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2735"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2736">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2736">-or-</span></span> 
<span data-ttu-id="a8eb2-2737"><paramref name="arguments" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2737">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2738"><paramref name="arguments" /> 的長度不符合 <paramref name="constructor" /> 代表之建構函式的參數數目。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2738">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="a8eb2-2739">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2739">-or-</span></span> 
<span data-ttu-id="a8eb2-2740"><paramref name="arguments" /> 項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="constructor" /> 所代表之建構函式的對應參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2740">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="a8eb2-2741">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2741">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-2742"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2742">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="a8eb2-2743"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Reflection.MemberInfo" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2743">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2744">建立 <see cref="T:System.Linq.Expressions.NewExpression" />，其代表以指定之引數呼叫指定的建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2744">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="a8eb2-2745">已指定可存取由建構函式初始化欄位的成員。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2745">The members that access the constructor initialized fields are specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2746"><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />、<see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2746">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2747">`arguments`參數必須包含相同數目的元素所代表之建構函式的參數數目為`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2747">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="a8eb2-2748">如果`arguments`是`null`，它是空的而<xref:System.Linq.Expressions.NewExpression.Arguments%2A>屬性所產生的<xref:System.Linq.Expressions.NewExpression>為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2748">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="a8eb2-2749">如果`members`已`null`，則<xref:System.Linq.Expressions.NewExpression.Members%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2749">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="a8eb2-2750">如果`members`不是`null`，它必須有相同數目的項目`arguments`，且每個項目不得為`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2750">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="a8eb2-2751">每個項目的`members`必須是<xref:System.Reflection.PropertyInfo>，<xref:System.Reflection.FieldInfo>或<xref:System.Reflection.MethodInfo>代表上所代表之建構函式宣告的型別執行個體成員`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2751">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="a8eb2-2752">如果它代表一個屬性，該屬性必須有`get`存取子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2752">If it represents a property, the property must have a `get` accessor.</span></span> <span data-ttu-id="a8eb2-2753">對應項目`arguments`每個項目`members`必須<xref:System.Linq.Expressions.Expression.Type%2A>代表指派給成員的型別類型的屬性，`members`項目代表。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2753">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="a8eb2-2754"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>表示建構函式的宣告型別，`constructor`表示。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2754">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2755"><paramref name="constructor" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2755"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2756">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2756">-or-</span></span> 
<span data-ttu-id="a8eb2-2757"><paramref name="arguments" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2757">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2758">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2758">-or-</span></span> 
<span data-ttu-id="a8eb2-2759"><paramref name="members" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2759">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2760"><paramref name="arguments" /> 參數包含的項目數目與 <paramref name="constructor" /> 所表示之建構函式的參數數目不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2760">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="a8eb2-2761">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2761">-or-</span></span> 
<span data-ttu-id="a8eb2-2762"><paramref name="arguments" /> 項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="constructor" /> 所代表之建構函式的對應參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2762">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="a8eb2-2763">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2763">-or-</span></span> 
<span data-ttu-id="a8eb2-2764"><paramref name="members" /> 參數的項目數與 <paramref name="arguments" /> 的不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2764">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
<span data-ttu-id="a8eb2-2765">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2765">-or-</span></span> 
<span data-ttu-id="a8eb2-2766"><paramref name="arguments" /> 的項目有 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性，它表示無法指派給 <paramref name="members" /> 其對應項目所表示成員類型的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2766">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="a8eb2-2767">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2767">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-2768"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2768">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="a8eb2-2769">用以填入 <see cref="T:System.Reflection.MemberInfo" /> 集合之 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2769">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2770">建立 <see cref="T:System.Linq.Expressions.NewExpression" />，其代表以指定之引數呼叫指定的建構函式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2770">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="a8eb2-2771">已指定可存取由建構函式初始化欄位的成員為陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2771">The members that access the constructor initialized fields are specified as an array.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2772"><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />、<see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2772">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2773">`arguments`參數必須包含相同數目的元素所代表之建構函式的參數數目為`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2773">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="a8eb2-2774">如果`arguments`是`null`，它是空的而<xref:System.Linq.Expressions.NewExpression.Arguments%2A>屬性所產生的<xref:System.Linq.Expressions.NewExpression>為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2774">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="a8eb2-2775">如果`members`已`null`，則<xref:System.Linq.Expressions.NewExpression.Members%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>為空集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2775">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="a8eb2-2776">如果`members`不是`null`，它必須有相同數目的項目`arguments`，且每個項目不得為`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2776">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="a8eb2-2777">每個項目的`members`必須是<xref:System.Reflection.PropertyInfo>，<xref:System.Reflection.FieldInfo>或<xref:System.Reflection.MethodInfo>代表上所代表之建構函式宣告的型別執行個體成員`constructor`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2777">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="a8eb2-2778">如果它代表一個屬性，此屬性必須能夠擷取相關聯的欄位的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2778">If it represents a property, the property must be able to retrieve the value of the associated field.</span></span> <span data-ttu-id="a8eb2-2779">對應項目`arguments`每個項目`members`必須<xref:System.Linq.Expressions.Expression.Type%2A>代表指派給成員的型別類型的屬性，`members`項目代表。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2779">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="a8eb2-2780"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>表示建構函式的宣告型別，`constructor`表示。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2780">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2781"><paramref name="constructor" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2781"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2782">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2782">-or-</span></span> 
<span data-ttu-id="a8eb2-2783"><paramref name="arguments" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2783">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2784">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2784">-or-</span></span> 
<span data-ttu-id="a8eb2-2785"><paramref name="members" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2785">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2786"><paramref name="arguments" /> 參數包含的項目數目與 <paramref name="constructor" /> 所表示之建構函式的參數數目不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2786">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="a8eb2-2787">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2787">-or-</span></span> 
<span data-ttu-id="a8eb2-2788"><paramref name="arguments" /> 項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="constructor" /> 所代表之建構函式的對應參數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2788">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="a8eb2-2789">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2789">-or-</span></span> 
<span data-ttu-id="a8eb2-2790"><paramref name="members" /> 參數的項目數與 <paramref name="arguments" /> 的不同。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2790">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
<span data-ttu-id="a8eb2-2791">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2791">-or-</span></span> 
<span data-ttu-id="a8eb2-2792"><paramref name="arguments" /> 的項目有 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性，它表示無法指派給 <paramref name="members" /> 其對應項目所表示成員類型的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2792">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2793">建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立具有指定之陣序的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2793">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-2794"><see cref="T:System.Type" />，代表陣列的項目類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2794">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="a8eb2-2795"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2795">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2796">建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立具有指定之陣序的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2796">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2797"><see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />，而 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2797">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2798"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewArrayExpression>代表其陣序規範是相等的長度的陣列類型`bounds`其項目類型，而且`type`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2798">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="a8eb2-2799"><xref:System.Linq.Expressions.Expression.Type%2A>的每個項目的屬性`bounds`必須代表整數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2799">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2800">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.NewArrayBounds%2A>方法來建立運算式樹狀結構，表示建立字串陣列，並使其擁有次序為 2。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2800">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2801"><paramref name="type" /> 或 <paramref name="bounds" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2801"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2802">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2802">-or-</span></span> 
<span data-ttu-id="a8eb2-2803"><paramref name="bounds" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2803">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2804"><paramref name="bounds" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不表示整數類資料類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2804">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-2805"><see cref="T:System.Type" />，代表陣列的項目類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2805">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="a8eb2-2806">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2806">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2807">建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立具有指定之陣序的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2807">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2808"><see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />，而 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2808">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2809"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewArrayExpression>代表其陣序規範是相等的長度的陣列類型`bounds`其項目類型，而且`type`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2809">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="a8eb2-2810"><xref:System.Linq.Expressions.Expression.Type%2A>的每個項目的屬性`bounds`必須代表整數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2810">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2811">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.NewArrayBounds%2A>方法來建立運算式樹狀結構，表示建立字串陣列，並使其擁有次序為 2。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2811">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2812"><paramref name="type" /> 或 <paramref name="bounds" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2812"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2813">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2813">-or-</span></span> 
<span data-ttu-id="a8eb2-2814"><paramref name="bounds" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2814">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2815"><paramref name="bounds" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不表示整數類資料類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2816">建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立一維陣列，並從項目清單將此陣列初始化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2816">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-2817"><see cref="T:System.Type" />，代表陣列的項目類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2817">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2818"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2818">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2819">建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立一維陣列，並從項目清單將此陣列初始化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2819">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2820"><see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />，而 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2820">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2821"><xref:System.Linq.Expressions.Expression.Type%2A>每個元素的屬性`initializers`必須代表指派給所表示之類型的型別`type`中，可能之後*加上引號*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2821">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-2822">只有當項目會加上引號`type`是<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2822">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-2823">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2823">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-2824">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2824">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="a8eb2-2825"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewArrayExpression>代表陣列類型，其次序為 1，其項目類型為`type`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2826">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.NewArrayInit%2A>方法用來建立運算式樹狀架構，其代表建立一維字串陣列，初始化字串運算式的清單。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2826">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2827"><paramref name="type" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2827"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2828">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2828">-or-</span></span> 
<span data-ttu-id="a8eb2-2829"><paramref name="initializers" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2829">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2830"><paramref name="initializers" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所表示的類型無法指派給 <paramref name="type" /> 所表示的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2830">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-2831"><see cref="T:System.Type" />，代表陣列的項目類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2831">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="a8eb2-2832">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2832">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2833">建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立一維陣列，並從項目清單將此陣列初始化。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2833">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2834"><see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />，而 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2834">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2835"><xref:System.Linq.Expressions.Expression.Type%2A>每個元素的屬性`initializers`必須代表指派給所表示之類型的型別`type`中，可能之後*加上引號*。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2835">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a8eb2-2836">只有當項目會加上引號`type`是<xref:System.Linq.Expressions.Expression>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2836">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="a8eb2-2837">表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2837">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="a8eb2-2838">產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`initializers`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2838">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="a8eb2-2839"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewArrayExpression>代表陣列類型，其次序為 1，其項目類型為`type`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2839">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2840">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.NewArrayInit%2A>方法用來建立運算式樹狀架構，其代表建立一維字串陣列，初始化字串運算式的清單。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2840">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2841"><paramref name="type" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2841"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-2842">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2842">-or-</span></span> 
<span data-ttu-id="a8eb2-2843"><paramref name="initializers" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2843">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2844"><paramref name="initializers" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所表示的類型無法指派給 <paramref name="type" /> 類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2844">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2845">取得這個 <see cref="T:System.Linq.Expressions.Expression" /> 的節點類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2845">Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <value><span data-ttu-id="a8eb2-2846">其中一個 <see cref="T:System.Linq.Expressions.ExpressionType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2846">One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2847"><xref:System.Linq.Expressions.Expression.NodeType%2A>屬性會提供更具特製化的描述<xref:System.Linq.Expressions.Expression>比只是其衍生的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2847">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property provides a more specialized description of an <xref:System.Linq.Expressions.Expression> than just its derived type.</span></span> <span data-ttu-id="a8eb2-2848">比方說，<xref:System.Linq.Expressions.BinaryExpression>可用來代表許多不同類型的二進位運算式，例如除法運算或 「 大於 」 作業。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2848">For example, a <xref:System.Linq.Expressions.BinaryExpression> can be used to represent many different kinds of binary expressions, such as a division operation or a "greater than" operation.</span></span> <span data-ttu-id="a8eb2-2849"><xref:System.Linq.Expressions.Expression.NodeType%2A>屬性會描述這些二進位運算式，做為<xref:System.Linq.Expressions.ExpressionType.Divide>和<xref:System.Linq.Expressions.ExpressionType.GreaterThan>分別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2849">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property would describe these binary expressions as <xref:System.Linq.Expressions.ExpressionType.Divide> and <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectively.</span></span>  
  
 <span data-ttu-id="a8eb2-2850">運算式的靜態的 CLR 型別，<xref:System.Linq.Expressions.Expression>物件表示由<xref:System.Linq.Expressions.Expression.Type%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2850">The static CLR type of the expression that the <xref:System.Linq.Expressions.Expression> object represents is represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2851">建立表示位元補數運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2851">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2852">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2853">建立表示位元補數運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2853">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2854"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Not" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2854">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2855"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2855">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2856"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2856">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2857">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2857">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2858">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2858">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2859">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2859">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2860">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2860">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2861">如果`expression`。類型是使用者定義的類型定義一元 not 運算子<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2861">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2862">否則，如果`expression`。類型是數值或布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2862">Otherwise, if `expression`.Type is a numeric or Boolean type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2863">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2863">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2864">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2864">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2865">如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2865">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2866">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2866">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2867">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2867">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2868">`expression`.類型為 null 的實值類型，而且對應的非 null 的型別等於實作方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2868">`expression`.Type is a nullable value type and the corresponding non-nullable type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2869">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2869">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2870">實作的方法是否`null`，節點的類型是`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2870">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="a8eb2-2871">如果`expression`。類型是不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2871">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2872">否則，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2872">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-2873">下列範例示範如何建立運算式，表示 邏輯 NOT 運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2873">The following example demonstrates how to create an expression that represents a logical NOT operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2874"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2874"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2875">不會為 <paramref name="expression" />.Type 定義一元 NOT 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2875">The unary not operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2876">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2876">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2877">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2877">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2878">建立表示位元補數運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2878">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span> <span data-ttu-id="a8eb2-2879">實作的方法可加以指定。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2879">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2880"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Not" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2880">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2881"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2881">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2882"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2882">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2883">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2883">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2884">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2884">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2885">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2885">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2886">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2886">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2887">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2887">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-2888">如果`expression`。類型是使用者定義的類型定義一元 not 運算子<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2888">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2889">否則，如果`expression`。類型為數值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2889">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2890">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2890">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2891">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2891">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2892">如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2892">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2893">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2893">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2894">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2894">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2895">`expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2895">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2896">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2896">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2897">實作的方法是否`null`，節點的類型是`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2897">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="a8eb2-2898">如果`expression`。類型是不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2898">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2899">否則，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2899">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2900"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2900"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2901"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2901"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2902"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="expression" />.Type 定義一元 NOT 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2902"><paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-2903">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2903">-or-</span></span> 
 <span data-ttu-id="a8eb2-2904"><paramref name="expression" />.Type (如果它是可為 Null 的實質類型，則為其對應之不可為 Null 的類型) 無法指派給 <paramref name="method" /> 所代表之方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2904"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2905">建立代表不相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2905">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2906">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2906">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2907">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2907">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2908">建立代表不相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2908">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2909"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2909">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2910">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2910">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2911"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2911">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2912">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2912">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="a8eb2-2913">否則為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2913">Otherwise, it is `false`.</span></span> <span data-ttu-id="a8eb2-2914"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2914">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="a8eb2-2915"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2915">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2916">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2916">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2917">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2917">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2918">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2918">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2919">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載不等比較運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2919">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2920">否則，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2920">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2921">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2921">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2922">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2922">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2923">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2923">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2924">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2924">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2925">如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2925">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2926">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2926">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2927">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2927">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-2928">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2928">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2929">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2929">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2930">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2930">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-2931">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2931">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2932">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2932">The type of the node is <xref:System.Boolean>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2933"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2933"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2934">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義不等比較運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2934">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2935">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2935">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2936">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2936">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="a8eb2-2937"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2937"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2938">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2938">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2939">建立代表不相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2939">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2940"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2940">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2941">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2941">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2942"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2942">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2943">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2943">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="a8eb2-2944">否則，兩者都是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2944">Otherwise, they are both `false`.</span></span> <span data-ttu-id="a8eb2-2945"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2945">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2946">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2946">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2947">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2947">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2948">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2948">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2949">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2949">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2950">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載不等比較運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2950">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2951">否則，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2951">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2952">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2952">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2953">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2953">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2954">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2954">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2955">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2955">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2956">如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2956">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2957">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2957">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2958">實作方法的傳回型別是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2958">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="a8eb2-2959">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2959">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2960">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2960">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2961">節點的類型是<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2961">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="a8eb2-2962">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2962">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-2963">節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2963">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-2964"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2964"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-2965"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2965"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-2966"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義不等比較運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2966"><paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2967">傳回表示 1 補數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2967">Returns the expression representing the ones complement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2968"><see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2968">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2969">傳回表示 1 補數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2969">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2970"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2970">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-2971"><see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2971">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-2972">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2972">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2973">傳回表示 1 補數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2973">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2974"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2974">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-2975">建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="OR" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2975">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-2976">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2976">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-2977">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2977">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-2978">建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="OR" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2978">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-2979"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Or" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2979">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-2980">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2980">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-2981"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2981">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-2982">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2982">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-2983">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2983">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-2984"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2984">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-2985">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2985">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-2986">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2986">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-2987">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2987">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-2988">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`OR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2988">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2989">否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2989">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-2990">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2990">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-2991">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2991">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2992">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2992">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2993">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2993">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-2994">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2994">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-2995">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2995">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-2996">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2996">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-2997">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2997">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-2998">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2998">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-2999">節點的類型是結果型別預先定義之位元`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-2999">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3000">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3000">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3001">節點的類型為 null 的型別對應至結果型別預先定義之位元`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3001">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3002">下列程式碼範例示範如何建立代表邏輯 OR 運算的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3002">The following code example shows how to create an expression that represents a logical OR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3003"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3003"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3004">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義位元 <see langword="OR" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3004">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3005">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3005">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3006">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3006">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3007">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3007">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3008">建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="OR" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3008">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3009"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Or" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3009">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3010">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3010">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3011"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3011">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3012">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3012">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3013">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3013">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3014"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3014">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3015">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3015">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3016">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3016">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3017">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3017">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3018">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3018">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3019">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`OR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3019">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3020">否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3020">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3021">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3021">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3022">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3022">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3023">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3023">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3024">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3024">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3025">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3025">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3026">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3026">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3027">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3027">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3028">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3028">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3029">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3029">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3030">節點的類型是結果型別預先定義之位元`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3030">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3031">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3031">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3032">節點的類型為 null 的型別對應至結果型別預先定義之位元`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3032">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3033"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3033"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3034"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3034"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3035"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的位元 <see langword="OR" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3035"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3036">建立表示位元 OR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3036">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3037">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3037">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3038">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3038">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3039">建立表示位元 OR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3039">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3040"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3040">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3041">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3041">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3042">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3042">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3043">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3043">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3044">建立表示位元 OR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3044">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3045"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3045">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3046">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3046">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3047">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3047">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3048">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3048">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-3049">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3049">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3050">建立表示位元 OR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3050">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3051"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3051">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3052">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算子評估為 <see langword="OR" /> 時才評估第二個運算元的條件 <see langword="false" /> 運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3052">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operator evaluates to <see langword="false" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3053">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3053">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3054">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3054">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3055">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算元計算結果為 <see langword="OR" /> 時才求第二個運算元之值的 <see langword="false" /> 條件運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3055">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3056"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3056">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3057">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3057">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3058"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3058">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3059">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3059">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3060">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3060">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3061"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3061">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3062">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3062">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3063">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3063">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3064">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3064">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3065">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`OR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3065">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a8eb2-3066">條件式`OR`運算子無法多載以 C# 或 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3066">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="a8eb2-3067">不過，條件式`OR`運算子會評估所使用的位元`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3067">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="a8eb2-3068">因此，使用者定義的多載位元`OR`運算子可以是此節點類型的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3068">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="a8eb2-3069">否則，如果`left`。型別和`right`。類型為布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3069">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3070">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3070">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3071">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3071">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3072">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3072">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3073">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3073">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3074">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3074">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3075">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個是可為 null，且對應的非 null 的型別相等相對應的引數類型的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3075">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3076">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3076">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3077">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3077">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3078">`left`.型別和`right`。型別都是相同的布林類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3078">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="a8eb2-3079">如果`left`。型別和`right`。型別不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3079">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3080">節點的類型是預先定義的條件式的結果型別`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3080">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3081">如果`left`。型別和`right`。型別可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3081">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3082">節點的類型為 null 的型別對應至預先定義的條件式的結果型別`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3082">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3083">下列程式碼範例示範如何建立運算式，表示邏輯`OR`第一個運算元評估為時，才評估第二個運算元的作業`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3083">The following code example shows how to create an expression that represents a logical `OR` operation that evaluates the second operand only if the first operand evaluates to `false`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3084"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3084"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3085">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義位元 <see langword="OR" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3085">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-3086">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3086">-or-</span></span> 
 <span data-ttu-id="a8eb2-3087"><paramref name="left" />.Type 和 <paramref name="right" />.Type 是不相同的布林類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3087"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3088">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3088">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3089">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3089">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3090">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3090">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3091">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算元計算結果為 <see langword="OR" /> 時才求第二個運算元之值的 <see langword="false" /> 條件運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3091">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3092"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3092">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3093">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3093">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3094"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3094">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3095">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3095">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3096">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3096">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3097"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3097">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3098">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3098">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3099">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3099">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3100">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3100">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3101">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3101">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-3102">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`OR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3102">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a8eb2-3103">條件式`OR`運算子無法多載以 C# 或 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3103">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="a8eb2-3104">不過，條件式`OR`運算子會評估所使用的位元`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3104">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="a8eb2-3105">因此，使用者定義的多載位元`OR`運算子可以是此節點類型的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3105">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="a8eb2-3106">否則，如果`left`。型別和`right`。類型為布林值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3106">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3107">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3107">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3108">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3108">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3109">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3109">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3110">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3110">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3111">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3111">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3112">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個是可為 null，且對應的非 null 的型別相等相對應的引數類型的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3112">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3113">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3113">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3114">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3114">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3115">`left`.型別和`right`。型別都是相同的布林類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3115">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="a8eb2-3116">如果`left`。型別和`right`。型別不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3116">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3117">節點的類型是預先定義的條件式的結果型別`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3117">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3118">如果`left`。型別和`right`。型別可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3118">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3119">節點的類型為 null 的型別對應至預先定義的條件式的結果型別`OR`運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3119">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3120"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3120"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3121"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3121"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3122"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的位元 <see langword="OR" /> 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3122"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-3123">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3123">-or-</span></span> 
 <span data-ttu-id="a8eb2-3124"><paramref name="method" /> 為 <see langword="null" />，且 <paramref name="left" />.Type 和 <paramref name="right" />.Type 不是相同的布林類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3124"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3125">建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3125">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-3126">參數或變數的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3126">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3127">建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3127">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3128">建立含指定之名稱和類型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3128">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-3129">下列範例示範如何建立<xref:System.Linq.Expressions.MethodCallExpression>列印的值的物件<xref:System.Linq.Expressions.ParameterExpression>物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3129">The following example demonstrates how to create a <xref:System.Linq.Expressions.MethodCallExpression> object that prints the value of a <xref:System.Linq.Expressions.ParameterExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-3130">參數或變數的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3130">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-3131">參數或變數的名稱，僅供偵錯或列印之用。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3131">The name of the parameter or variable, used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3132">建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3132">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3133"><see cref="T:System.Linq.Expressions.ParameterExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" />，且 <see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3133">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3134"><paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3134"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3135">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞減 1 的運算式指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3135">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3136">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3136">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3137">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞減 1 的運算式指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3137">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3138">表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3138">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3139">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3139">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3140">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3140">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3141">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞減 1 的運算式指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3141">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3142">表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3142">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3143">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞增 1 的運算式指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3143">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3144">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3144">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3145">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞增 1 的運算式指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3145">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3146">表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3146">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3147">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3147">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3148">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3148">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3149">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞增 1 的運算式指派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3149">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3150">表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3150">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3151">建立代表將數字提升為乘冪數的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3151">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3152">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3152">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3153">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3153">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3154">建立代表將數字提升為乘冪數的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3154">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3155"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Power" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3155">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3156">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3156">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3157"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3157">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3158">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3158">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3159">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3159">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3160"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3160">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3161">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3161">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3162">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3162">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3163">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3163">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3164">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載的乘冪運算子<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3164">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3165">否則，如果`left`。型別和`right`。型別都<xref:System.Double>，則實作方法是<xref:System.Math.Pow%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3165">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3166">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3166">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="a8eb2-3167">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3167">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3168">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3168">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3169">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3169">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3170">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3170">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3171">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3171">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3172"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3172"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3173">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Exponentiation 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3173">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-3174">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3174">-or-</span></span> 
 <span data-ttu-id="a8eb2-3175"><paramref name="left" />.Type 和 (或) <paramref name="right" />.Type 不是 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3175"><paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3176">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3176">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3177">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3177">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3178">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3178">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3179">建立代表將數字提升為乘冪數的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3179">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3180"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Power" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3180">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3181">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3181">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3182"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3182">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3183">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3183">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3184">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3184">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3185"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3185">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3186">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3186">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3187">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3187">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3188">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3188">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3189">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3189">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3190">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載的乘冪運算子<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3190">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3191">否則，如果`left`。型別和`right`。型別都<xref:System.Double>，則實作方法是<xref:System.Math.Pow%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3191">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3192">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3192">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="a8eb2-3193">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3193">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3194">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3194">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3195">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3195">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3196">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3196">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3197">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3197">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3198"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3198"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3199"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3199"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3200"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的乘冪運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3200"><paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-3201">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3201">-or-</span></span> 
 <span data-ttu-id="a8eb2-3202"><paramref name="method" /> 是 <see langword="null" /> 和 <paramref name="left" />.Type，且/或 <paramref name="right" />.Type 不是 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3202"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3203">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示將運算式自乘為乘冪，並且將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3203">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3204">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3205">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3205">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3206">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示將運算式自乘為乘冪，並且將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3207"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3208">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3209">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3210">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3211">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示將運算式自乘為乘冪，並且將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3211">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3212"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3212">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3213">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3213">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3214">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3214">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3215">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3215">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-3216">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3216">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3217">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示將運算式自乘為乘冪，並且將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3218"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3219">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞減 1，並將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3219">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3220">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3220">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3221">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞減 1，並將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3221">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3222">表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3222">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3223">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3223">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3224">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3224">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3225">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞減 1，並將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3225">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3226">表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3226">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3227">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞增 1，並將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3227">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3228">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3228">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3229">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞增 1，並將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3229">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3230">表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3230">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3231">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3231">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3232">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3232">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3233">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞增 1，並將結果指派回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3233">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3234">表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3234">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3235">建立代表存取屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3235">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3236">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3236">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="a8eb2-3237">如果是靜態屬性，可以是 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3237">This can be null for static properties.</span></span></param>
        <param name="propertyAccessor"><span data-ttu-id="a8eb2-3238"><see cref="T:System.Reflection.MethodInfo" />，代表屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3238">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3239">建立 <see cref="T:System.Linq.Expressions.MemberExpression" />，代表透過使用屬性存取子來存取屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3239">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3240"><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />、<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 屬性設定為 <paramref name="expression" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，代表在 <paramref name="propertyAccessor" /> 中存取的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3240">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3241"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性<xref:System.Linq.Expressions.MemberExpression.Member%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3241">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="a8eb2-3242">如果所表示的方法`propertyAccessor`已`static`(`Shared`在 Visual Basic 中)，`expression`可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3242">If the method represented by `propertyAccessor` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3243"><paramref name="propertyAccessor" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3243"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-3244">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3244">-or-</span></span> 
<span data-ttu-id="a8eb2-3245"><paramref name="propertyAccessor" /> 所表示的方法不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，且 <paramref name="expression" /> 是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3245">The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3246"><paramref name="expression" />.Type 無法指派給 <paramref name="propertyAccessor" /> 所代表之方法的宣告類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3246"><paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.</span></span>  
  
<span data-ttu-id="a8eb2-3247">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3247">-or-</span></span> 
<span data-ttu-id="a8eb2-3248"><paramref name="propertyAccessor" /> 所表示的方法不是屬性存取子方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3248">The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3249">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3249">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="a8eb2-3250">如果是靜態屬性，可以是 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3250">This can be null for static properties.</span></span></param>
        <param name="property"><span data-ttu-id="a8eb2-3251">要將 <see cref="T:System.Reflection.PropertyInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3251">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3252">建立代表存取屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3252">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3253"><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3253">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3254"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性<xref:System.Linq.Expressions.MemberExpression.Member%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3254">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="a8eb2-3255">如果此屬性以表示`property`已`static`(`Shared`在 Visual Basic 中)，`expression`可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3255">If the property represented by `property` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3256"><paramref name="property" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3256"><paramref name="property" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a8eb2-3257">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3257">-or-</span></span> 
<span data-ttu-id="a8eb2-3258"><paramref name="property" /> 所表示的屬性不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，且 <paramref name="expression" /> 是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3258">The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3259"><paramref name="expression" />.Type 無法指派給 <paramref name="property" /> 所表示屬性的宣告類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3259"><paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3260"><see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 包含名為 <paramref name="propertyName" /> 的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3260">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <paramref name="propertyName" />.</span></span> <span data-ttu-id="a8eb2-3261">如果是靜態屬性，可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3261">This can be <see langword="null" /> for static properties.</span></span></param>
        <param name="propertyName"><span data-ttu-id="a8eb2-3262">要存取的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3262">The name of a property to be accessed.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3263">建立代表存取屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3263">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3264"><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />、<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 屬性設定為 <paramref name="expression" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，代表 <paramref name="propertyName" /> 所表示的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3264">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3265"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性<xref:System.Reflection.PropertyInfo>所表示的屬性表示`propertyName`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3265">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the <xref:System.Reflection.PropertyInfo> that represents the property denoted by `propertyName`.</span></span>  
  
 <span data-ttu-id="a8eb2-3266">這個方法會搜尋`expression`。型別和屬性名稱之屬性的基底類型`propertyName`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3266">This method searches `expression`.Type and its base types for a property that has the name `propertyName`.</span></span> <span data-ttu-id="a8eb2-3267">公用屬性，優先非公用屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3267">Public properties are given preference over non-public properties.</span></span> <span data-ttu-id="a8eb2-3268">如果找到相符的屬性，則此方法會傳遞`expression`而<xref:System.Reflection.PropertyInfo>表示該屬性<xref:System.Linq.Expressions.Expression.Property%2A>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3268">If a matching property is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> that represents that property to <xref:System.Linq.Expressions.Expression.Property%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3269">下列範例示範如何建立代表存取屬性的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3269">The following example shows how to create an expression that represents accessing a property.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3270"><paramref name="expression" /> 或 <paramref name="propertyName" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3270"><paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3271"><paramref name="propertyName" />.Type 或其基底類型中沒有定義名為 <paramref name="expression" /> 的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3271">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-3272">屬性所屬的物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3272">The object to which the property belongs.</span></span> <span data-ttu-id="a8eb2-3273">如果屬性為靜態/共用屬性，就必須為 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3273">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="a8eb2-3274"><see cref="T:System.Reflection.PropertyInfo" />，代表要編製索引的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3274">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-3275"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 物件的 <see cref="T:System.Linq.Expressions.Expression" />，用於對屬性進行索引。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3275">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3276">建立 <see cref="T:System.Linq.Expressions.IndexExpression" />，表示索引之屬性的存取結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3276">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3277">建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3277">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-3278">屬性所屬的物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3278">The object to which the property belongs.</span></span> <span data-ttu-id="a8eb2-3279">如果屬性為靜態/共用屬性，就必須為 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3279">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="a8eb2-3280"><see cref="T:System.Reflection.PropertyInfo" />，代表要編製索引的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3280">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-3281"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，用於對屬性進行索引。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3281">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3282">建立 <see cref="T:System.Linq.Expressions.IndexExpression" />，表示索引之屬性的存取結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3282">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3283">建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3283">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="a8eb2-3284">屬性所屬的物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3284">The object to which the property belongs.</span></span> <span data-ttu-id="a8eb2-3285">如果屬性為靜態/共用屬性，就必須為 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3285">If the property is static/shared, it must be null.</span></span></param>
        <param name="propertyName"><span data-ttu-id="a8eb2-3286">索引子的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3286">The name of the indexer.</span></span></param>
        <param name="arguments"><span data-ttu-id="a8eb2-3287"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，用於對屬性進行索引。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3287">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3288">建立 <see cref="T:System.Linq.Expressions.IndexExpression" />，表示索引之屬性的存取結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3288">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3289">建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3289">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3290">屬性的包含物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3290">The containing object of the property.</span></span> <span data-ttu-id="a8eb2-3291">如果是靜態屬性，可以是 null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3291">This can be null for static properties.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-3292">包含屬性的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3292">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</span></span></param>
        <param name="propertyName"><span data-ttu-id="a8eb2-3293">要存取的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3293">The property to be accessed.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3294">建立用於存取屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3294">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3295">建立的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3295">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3296"><see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 包含名為 <paramref name="propertyOrFieldName" /> 的屬性或欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3296">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <paramref name="propertyOrFieldName" />.</span></span> <span data-ttu-id="a8eb2-3297">如果是靜態成員，可以是 Null。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3297">This can be null for static members.</span></span></param>
        <param name="propertyOrFieldName"><span data-ttu-id="a8eb2-3298">要存取之屬性或欄位的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3298">The name of a property or field to be accessed.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3299">建立 <see cref="T:System.Linq.Expressions.MemberExpression" />，代表存取屬性或欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3299">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3300"><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />、<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 屬性設定為 <paramref name="expression" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" /> 或 <see cref="T:System.Reflection.FieldInfo" />，代表 <paramref name="propertyOrFieldName" /> 所表示的屬性或欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3300">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3301"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.PropertyInfo.PropertyType%2A>或<xref:System.Reflection.FieldInfo.FieldType%2A>的屬性<xref:System.Reflection.PropertyInfo>或<xref:System.Reflection.FieldInfo>，分別表示的屬性或欄位以表示`propertyOrFieldName`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3301">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> or <xref:System.Reflection.FieldInfo.FieldType%2A> properties of the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo>, respectively, that represents the property or field denoted by `propertyOrFieldName`.</span></span>  
  
 <span data-ttu-id="a8eb2-3302">這個方法會搜尋`expression`。類型和其屬性或欄位名稱的基底類型`propertyOrFieldName`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3302">This method searches `expression`.Type and its base types for a property or field that has the name `propertyOrFieldName`.</span></span> <span data-ttu-id="a8eb2-3303">公用屬性和欄位，優先非公用屬性和欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3303">Public properties and fields are given preference over non-public properties and fields.</span></span> <span data-ttu-id="a8eb2-3304">此外，屬性優先欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3304">Also, properties are given preference over fields.</span></span> <span data-ttu-id="a8eb2-3305">如果找到相符的屬性或欄位，則此方法會傳遞`expression`而<xref:System.Reflection.PropertyInfo>或<xref:System.Reflection.FieldInfo>，表示該屬性或欄位<xref:System.Linq.Expressions.Expression.Property%2A>或<xref:System.Linq.Expressions.Expression.Field%2A>分別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3305">If a matching property or field is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo> that represents that property or field to <xref:System.Linq.Expressions.Expression.Property%2A> or <xref:System.Linq.Expressions.Expression.Field%2A>, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3306">下列範例示範如何建立代表存取屬性或欄位的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3306">The following example shows how to create an expression that represents accessing a property or field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3307"><paramref name="expression" /> 或 <paramref name="propertyOrFieldName" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3307"><paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3308"><paramref name="propertyOrFieldName" />.Type 或其基底類型中沒有定義名為 <paramref name="expression" /> 的屬性或欄位。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3308">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3309">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3309">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3310">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表具有 <see cref="T:System.Linq.Expressions.Expression" /> 類型常數值的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3310">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3311"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Quote" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3311">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3312"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>代表建構的型別<xref:System.Linq.Expressions.Expression%601>，其中型別引數是所表示的型別`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3312">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents the constructed type <xref:System.Linq.Expressions.Expression%601>, where the type argument is the type represented by `expression`.Type.</span></span> <span data-ttu-id="a8eb2-3313"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3313">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`.</span></span> <span data-ttu-id="a8eb2-3314">兩者<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3314">Both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3315"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3315"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8eb2-3316">將這個節點精簡為更簡單的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3316">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="a8eb2-3317">如果 CanReduce 傳回 true，則應該傳回有效的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3317">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="a8eb2-3318">這個方法可以傳回其他本身必須精簡的節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3318">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3319">精簡的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3319">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8eb2-3320">將這個節點精簡為更簡單的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3320">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="a8eb2-3321">如果 CanReduce 傳回 true，則應該傳回有效的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3321">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="a8eb2-3322">這個方法可以傳回其他本身必須精簡的節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3322">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3323">精簡的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3323">The reduced expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3324">不同於減少，這個方法會檢查縮減的節點符合某些非變異值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3324">Unlike Reduce, this method checks that the reduced node satisfies certain invariants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8eb2-3325">將運算式精簡為已知的節點類型 (不是 Extension 節點)，如果已經是已知的類型，則僅傳回運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3325">Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3326">精簡的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3326">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3327">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3327">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3328">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3328">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3329">建立表示參考相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3329">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3330"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3330">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3331">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3332">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3332">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3333">建立表示參考不相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3333">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3334"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3334">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3335">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示重新擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3335">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8eb2-3336">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示重新擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3336">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3337">表示重新擲回例外狀況的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3337">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-3338">運算式的新 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3338">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3339">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表重新擲回含指定之類型的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3339">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3340">表示重新擲回例外狀況的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3340">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3341">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示 return 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3341">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-3342"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3342">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3343">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示 return 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3343">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3344"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Return、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且包含在跳躍時傳遞至目標標籤的 Null 值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3344">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-3345"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3345">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="a8eb2-3346">將在跳躍時傳遞至關聯標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3346">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3347">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示 return 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3347">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span> <span data-ttu-id="a8eb2-3348">可以指定跳躍時傳遞至標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3348">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3349"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Continue、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3349">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-3350">下列範例示範如何建立包含的運算式<xref:System.Linq.Expressions.Expression.Return%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3350">The following example demonstrates how to create an expression that contains the <xref:System.Linq.Expressions.Expression.Return%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-3351"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3351">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-3352">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3352">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3353">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 return 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3353">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3354"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Return、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 null 值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3354">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="a8eb2-3355"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3355">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="a8eb2-3356">將在跳躍時傳遞至關聯標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3356">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-3357">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3357">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3358">建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 return 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3358">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span> <span data-ttu-id="a8eb2-3359">可以指定跳躍時傳遞至標籤的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3359">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3360"><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於Continue、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3360">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3361">建立代表位元右移 (Right-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3361">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3362">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3362">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3363">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3363">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3364">建立代表位元右移 (Right-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3364">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3365"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3366">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3366">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3367"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3367">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3368">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3368">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3369">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3369">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3370"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3370">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3371">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3371">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3372">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3372">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3373">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3373">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3374">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`代表向右移位運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3374">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3375">否則，如果`left`。類型為整數類資料類型 (其中<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>，或對應 null 的型別) 和`right`。型別是<xref:System.Int32>，則實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3375">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3376">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3376">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3377">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3377">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3378">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3378">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3379">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3379">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3380">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3380">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3381">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3381">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3382">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3382">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3383">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3383">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3384">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3384">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3385">節點的類型是預先定義的向右移位運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3385">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3386">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3386">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3387">節點的類型為 null 的型別對應至預先定義的向右移位運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3387">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3388"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3388"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3389">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Right-shift 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3389">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3390">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3390">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3391">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3391">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3392">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3392">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3393">建立代表位元右移 (Right-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3393">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3394"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3395">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3395">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3396"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3396">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3397">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3397">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3398">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3398">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3399"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3399">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3400">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3400">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3401">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3401">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3402">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3402">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3403">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3403">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-3404">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`代表向右移位運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3404">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3405">否則，如果`left`。類型為整數類資料類型 (其中<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>，或對應 null 的型別) 和`right`。型別是<xref:System.Int32>，則實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3405">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3406">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3406">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3407">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3407">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3408">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3408">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3409">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3409">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3410">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3410">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3411">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3411">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3412">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3412">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3413">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3413">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3414">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3414">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3415">節點的類型是預先定義的向右移位運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3415">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3416">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3416">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3417">節點的類型為 null 的型別對應至預先定義的向右移位運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3417">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3418"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3418"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3419"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3419"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3420"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Right-shift 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3420"><paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3421">建立表示位元右移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3421">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3422">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3423">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3423">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3424">建立表示位元右移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3424">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3425"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3426">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3427">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3428">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3428">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3429">建立表示位元右移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3429">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3430"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3431">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3432">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3432">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3433">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3433">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-3434">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3435">建立表示位元右移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3436"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3437">建立 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3437">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="a8eb2-3438"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 物件的集合，用來填入 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3438">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3439">建立 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3439">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3440"><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" />，而 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3440">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="a8eb2-3441">用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合之 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3441">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3442">建立 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3442">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3443"><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" />，而 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3443">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3444">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術減法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3444">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3445">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3445">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3446">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3446">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3447">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術減法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3447">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3448"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3448">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3449">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3449">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3450"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3450">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3451">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3451">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3452">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3452">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3453"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3453">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3454">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3454">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3455">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3455">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3456">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3456">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3457">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載減法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3457">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3458">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3458">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3459">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3459">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3460">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3460">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3461">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3461">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3462">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3462">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3463">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3463">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3464">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3464">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3465">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3465">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3466">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3466">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3467">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3467">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3468">節點的類型是預先定義的減法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3468">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3469">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3469">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3470">節點的類型為 null 的型別對應至預先定義的減法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3470">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3471">下列程式碼範例示範如何建立減去的引數，從第一個引數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3471">The following code example shows how to create an expression that subtracts the argument from the first argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3472"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3472"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3473">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Subtraction 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3473">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3474">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3474">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3475">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3475">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3476">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3476">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3477">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術減法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3477">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3478"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3478">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3479">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3479">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3480"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3480">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3481">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3481">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3482">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3482">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3483"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3483">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3484">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3484">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3485">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3485">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3486">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3486">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3487">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3487">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-3488">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載減法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3488">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3489">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3489">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3490">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3490">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3491">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3491">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3492">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3492">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3493">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3493">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3494">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3494">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3495">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3495">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3496">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3496">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3497">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3497">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3498">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3498">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3499">節點的類型是預先定義的減法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3499">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3500">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3500">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3501">節點的類型為 null 的型別對應至預先定義的減法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3501">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3502"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3502"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3503"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3503"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3504"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的減法運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3504"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3505">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的減法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3506">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3506">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3507">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3507">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3508">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的減法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3508">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3509"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3509">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3510">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3510">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3511">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3511">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3512">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3512">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3513">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的減法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3513">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3514"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3514">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3515">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3516">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3516">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3517">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3517">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-3518">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3518">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3519">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的減法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3519">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3520"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3520">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3521">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的減法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3521">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3522">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3522">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3523">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3523">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3524">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的減法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3524">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3525"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3525">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3526">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3526">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3527">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3527">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3528">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3528">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3529">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的減法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3529">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3530"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3530">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3531">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3532">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3533">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3533">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="a8eb2-3534">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3534">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3535">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的減法指派運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3535">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3536"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3536">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3537">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術減法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3537">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3538">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3538">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3539">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3539">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3540">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術減法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3540">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3541"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3541">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3542">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3542">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3543"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3543">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3544">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3544">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3545">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3545">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3546"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3546">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3547">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3547">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3548">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3548">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3549">下列規則決定選取作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3549">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3550">如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載減法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3550">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3551">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3551">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3552">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3552">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3553">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3553">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3554">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3554">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3555">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3555">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3556">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3556">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3557">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3557">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3558">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3558">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3559">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3559">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3560">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3560">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3561">節點的類型是預先定義的減法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3561">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3562">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3562">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3563">節點的類型為 null 的型別對應至預先定義的減法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3563">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3564"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3564"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3565">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Subtraction 運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3565">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a8eb2-3566">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3566">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="a8eb2-3567">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3567">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3568">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3568">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3569">建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術減法運算。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3569">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3570"><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3570">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3571">產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3571">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3572"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3572">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3573">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3573">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3574">否則，它們是`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3574">Otherwise, they are `false`.</span></span> <span data-ttu-id="a8eb2-3575"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3575">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="a8eb2-3576">下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3576">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3577">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3577">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3578">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3578">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="a8eb2-3579">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3579">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-3580">否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載減法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3580">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3581">否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3581">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3582">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3582">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3583">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3583">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3584">如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3584">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3585">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3585">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3586">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3586">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3587">`left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3587">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3588">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3588">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3589">如果實作的方法是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3589">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3590">如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3590">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3591">節點的類型是預先定義的減法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3591">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="a8eb2-3592">如果`left`。型別和`right`。型別都可為 null，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3592">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="a8eb2-3593">節點的類型為 null 的型別對應至預先定義的減法運算子的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3593">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3594"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3594"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3595"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3595"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3596"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的減法運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3596"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3597">建立表示 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 陳述式的 <see langword="switch" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3597">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="a8eb2-3598">針對每個案例所要測試的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3598">The value to be tested against each case.</span></span></param>
        <param name="cases"><span data-ttu-id="a8eb2-3599">這個 switch 運算式的案例集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3599">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3600">建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，代表不含 default case 的 <see langword="switch" /> 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3600">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3601">建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3601">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3602">所有<xref:System.Linq.Expressions.SwitchCase>中的物件<xref:System.Linq.Expressions.SwitchExpression>物件必須有相同的型別，除非<xref:System.Linq.Expressions.SwitchExpression>具有類型`void`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3602">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="a8eb2-3603">每個<xref:System.Linq.Expressions.SwitchCase>物件具有隱含`break`陳述式，這表示沒有任何隱含的執行順序從一個 case 標籤之間。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3603">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="a8eb2-3604">如果`switchValue`不符合任何的情況下，會擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3604">If `switchValue` does not match any of the cases, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3605">下列範例示範如何建立代表不含預設 case 陳述式參數的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3605">The following example demonstrates how to create an expression that represents a swtich statement without a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="a8eb2-3606">針對每個案例所要測試的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3606">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="a8eb2-3607">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3607">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="cases"><span data-ttu-id="a8eb2-3608">這個 switch 運算式的案例集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3608">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3609">建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3609">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3610">建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3610">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3611">所有<xref:System.Linq.Expressions.SwitchCase>中的物件<xref:System.Linq.Expressions.SwitchExpression>物件必須有相同的型別，除非<xref:System.Linq.Expressions.SwitchExpression>具有類型`void`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3611">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="a8eb2-3612">每個<xref:System.Linq.Expressions.SwitchCase>物件具有隱含`break`陳述式，這表示沒有任何隱含的執行順序從一個 case 標籤之間。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3612">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="a8eb2-3613">如果`switchValue`不符的情況下，預設的情況所代表的任何`defaultBody`執行。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3613">If `switchValue` does not match any of the cases, the default case represented by `defaultBody` is run.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3614">下列範例示範如何建立具有預設情況的參數陳述式表示的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3614">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="a8eb2-3615">針對每個案例所要測試的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3615">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="a8eb2-3616">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3616">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="a8eb2-3617">要使用的相等比較方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3617">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="a8eb2-3618">這個 switch 運算式的案例集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3618">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3619">建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3619">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3620">建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3620">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="a8eb2-3621">針對每個案例所要測試的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3621">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="a8eb2-3622">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3622">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="a8eb2-3623">要使用的相等比較方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3623">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="a8eb2-3624">這個 switch 運算式的案例集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3624">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3625">建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3625">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3626">建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3626">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-3627">參數的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3627">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="a8eb2-3628">針對每個案例所要測試的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3628">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="a8eb2-3629">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3629">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="a8eb2-3630">要使用的相等比較方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3630">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="a8eb2-3631">這個 switch 運算式的案例集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3631">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3632">建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3632">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3633">建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3633">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-3634">參數的結果類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3634">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="a8eb2-3635">針對每個案例所要測試的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3635">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="a8eb2-3636">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3636">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="a8eb2-3637">要使用的相等比較方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3637">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="a8eb2-3638">這個 switch 運算式的案例集合。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3638">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3639">建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3639">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case..</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3640">建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3640">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3641">建立要在 <see cref="T:System.Linq.Expressions.SwitchCase" /> 物件中使用的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3641">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-3642">案例的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3642">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="a8eb2-3643">案例的測試值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3643">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3644">建立要在 <see cref="T:System.Linq.Expressions.SwitchCase" /> 物件中使用的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3644">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3645">建立的 <see cref="T:System.Linq.Expressions.SwitchCase" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3645">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3646">所有<xref:System.Linq.Expressions.SwitchCase>中的物件<xref:System.Linq.Expressions.SwitchExpression>物件必須有相同的型別，除非<xref:System.Linq.Expressions.SwitchExpression>具有類型`void`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3646">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="a8eb2-3647">每個<xref:System.Linq.Expressions.SwitchCase>物件具有隱含`break`陳述式，這表示沒有任何隱含的執行順序從一個 case 標籤之間。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3647">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3648">下列範例示範如何建立具有預設情況的參數陳述式表示的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3648">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-3649">案例的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3649">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="a8eb2-3650">案例的測試值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3650">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3651">建立 <see cref="T:System.Linq.Expressions.SwitchCase" /> 以便用於 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3651">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3652">建立的 <see cref="T:System.Linq.Expressions.SwitchCase" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3652">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3653">建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3653">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="a8eb2-3654">要將 <see cref="T:System.String" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3654">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3655">建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3655">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3656"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3656">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="a8eb2-3657">要將 <see cref="T:System.String" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3657">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="a8eb2-3658">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3658">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3659">建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3659">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3660"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3660">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="a8eb2-3661">要將 <see cref="T:System.String" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3661">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="a8eb2-3662">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3662">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="a8eb2-3663">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3663">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3664">建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3664">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3665"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3665">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="a8eb2-3666">要將 <see cref="T:System.String" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3666">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="a8eb2-3667">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3667">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="a8eb2-3668">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3668">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <param name="documentType"><span data-ttu-id="a8eb2-3669">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3669">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3670">建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3670">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3671"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />、<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />、<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3671">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3672">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3672">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a8eb2-3673"><see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3673">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3674">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3674">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3675">表示例外狀況的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3675">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-3676">下列範例示範如何建立<xref:System.Linq.Expressions.TryExpression>物件，使用<xref:System.Linq.Expressions.Expression.Throw%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3676">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that uses the <xref:System.Linq.Expressions.Expression.Throw%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a8eb2-3677"><see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3677">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-3678">運算式的新 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3678">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3679">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表擲回含指定之類型的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3679">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3680">表示例外狀況的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3680">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8eb2-3681">傳回 <see cref="T:System.Linq.Expressions.Expression" /> 的文字表示。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3681">Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3682"><see cref="T:System.Linq.Expressions.Expression" /> 的文字表示。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3682">A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-3683">try 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3683">The body of the try block.</span></span></param>
        <param name="handlers"><span data-ttu-id="a8eb2-3684">零個或多個 <see cref="T:System.Linq.Expressions.CatchBlock" /> 的陣列，表示要與 try 區塊產生關聯的 catch 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3684">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3685">建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含 catch 陳述式 (數目不拘) 但不含 fault 區塊或 finally 區塊的 try 區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3685">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3686">建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3686">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-3687">下列範例示範如何建立<xref:System.Linq.Expressions.TryExpression>包含 catch 陳述式的物件。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3687">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-3688">try 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3688">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="a8eb2-3689">finally 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3689">The body of the finally block.</span></span></param>
        <param name="handlers"><span data-ttu-id="a8eb2-3690">零個或多個 <see cref="T:System.Linq.Expressions.CatchBlock" /> 的陣列，表示要與 try 區塊產生關聯的 catch 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3690">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3691">建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含 catch 陳述式 (數目不拘) 和 finally 區塊的 try 區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3691">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3692">建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3692">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a8eb2-3693">下列範例示範如何建立<xref:System.Linq.Expressions.TryExpression>包含 catch 陳述式的物件和 finally 陳述式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3693">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement and a finally statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-3694">try 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3694">The body of the try block.</span></span></param>
        <param name="fault"><span data-ttu-id="a8eb2-3695">fault 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3695">The body of the fault block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3696">建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含 fault 區塊但不含任何 catch 陳述式的 try 區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3696">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3697">建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3697">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="a8eb2-3698">try 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3698">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="a8eb2-3699">finally 區塊的主體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3699">The body of the finally block.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3700">建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含 finally 區塊但不含任何 catch 陳述式的 try 區塊。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3700">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3701">建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3701">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="a8eb2-3702">Type 物件的陣列，指定 System.Action 委派類型的型別引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3702">An array of Type objects that specify the type arguments for the System.Action delegate type.</span></span></param>
        <param name="actionType"><span data-ttu-id="a8eb2-3703">這個方法在傳回時會包含具有特定型別引數的泛型 System.Action 委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3703">When this method returns, contains the generic System.Action delegate type that has specific type arguments.</span></span> <span data-ttu-id="a8eb2-3704">如果沒有符合 <paramref name="typeArgs" /> 的泛型 System.Action 委派，則包含 Null。這個參數以未初始化的狀態傳遞。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3704">Contains null if there is no generic System.Action delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3705">建立 <see cref="P:System.Linq.Expressions.Expression.Type" /> 物件，這個物件代表具有特定型別引數的泛型 System.Action 委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3705">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3706">如果已針對特定 <paramref name="typeArgs" /> 建立泛型 System.Action 委派類型，則傳回 true，否則傳回 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3706">true if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="a8eb2-3707">Type 物件的陣列，指定 System.Func 委派類型的型別引數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3707">An array of Type objects that specify the type arguments for the System.Func delegate type.</span></span></param>
        <param name="funcType"><span data-ttu-id="a8eb2-3708">這個方法在傳回時會包含具有特定型別引數的泛型 System.Func 委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3708">When this method returns, contains the generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="a8eb2-3709">如果沒有符合 <paramref name="typeArgs" /> 的泛型 System.Func 委派，則包含 Null。這個參數以未初始化的狀態傳遞。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3709">Contains null if there is no generic System.Func delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3710">建立 <see cref="P:System.Linq.Expressions.Expression.Type" /> 物件，這個物件代表具有特定型別引數的泛型 System.Func 委派類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3710">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="a8eb2-3711">最後一個型別引數指定已建立之委派的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3711">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3712">如果已針對特定 <paramref name="typeArgs" /> 建立泛型 System.Func 委派類型，則傳回 true，否則傳回 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3712">true if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3713">取得此 <see cref="T:System.Linq.Expressions.Expression" /> 代表之運算式的靜態類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3713">Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</span></span></summary>
        <value><span data-ttu-id="a8eb2-3714">代表運算式靜態類型的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3714">The <see cref="T:System.Type" /> that represents the static type of the expression.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3715"><xref:System.Linq.Expressions.Expression.NodeType%2A>是運算式樹狀結構節點的型別，而<xref:System.Linq.Expressions.Expression.Type%2A>代表運算式節點所表示的靜態 common language runtime (CLR) 類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3715">The <xref:System.Linq.Expressions.Expression.NodeType%2A> is the type of the expression tree node, whereas the <xref:System.Linq.Expressions.Expression.Type%2A> represents the static common language runtime (CLR) type of the expression that the node represents.</span></span> <span data-ttu-id="a8eb2-3716">比方說，使用不同的節點類型的兩個節點可以有相同<xref:System.Linq.Expressions.Expression.Type%2A>，如下列程式碼範例所示。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3716">For example, two nodes with different node types can have the same <xref:System.Linq.Expressions.Expression.Type%2A>, as shown in the following code example.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3717">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3717">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-3718">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3718">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3719">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表明確參考或 Boxing 轉換，其中若轉換失敗，則提供 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3719">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3720"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3720">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3721"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3721">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is `null`.</span></span> <span data-ttu-id="a8eb2-3722"><xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>屬性都`false`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3722">The <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> properties are both `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3723">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29>方法用來建立<xref:System.Linq.Expressions.UnaryExpression>表示不可為 null 的整數運算式，可為 null 的整數型別參考轉換。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3723">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.UnaryExpression> that represents the reference conversion of a non-nullable integer expression to the nullable integer type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3724"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3724"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3725">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3725">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-3726">要將 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3726">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3727">建立 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> 以比較執行階段類型識別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3727">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3728"><see cref="T:System.Linq.Expressions.TypeBinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> 以及 <see cref="T:System.Linq.Expressions.Expression" /> 和 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> 屬性設為指定值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3728">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3729">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3729">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-3730">要將 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3731">建立 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3731">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3732"><see cref="T:System.Linq.Expressions.TypeBinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> 以及 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> 屬性設為指定值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3732">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3733"><xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>代表<xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3733">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a8eb2-3734">下列範例示範如何使用<xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29>方法用來建立<xref:System.Linq.Expressions.TypeBinaryExpression>表示對字串值的型別測試<xref:System.Int32>型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3734">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.TypeBinaryExpression> that represents a type test of a string value against the <xref:System.Int32> type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3735"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3735"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3736">建立代表一元加法運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3736">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3737">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3737">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3738">建立代表一元加法運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3738">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3739"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3739">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3740"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3740">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3741"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3741">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3742">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3742">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3743">否則，它們是 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3743">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3744">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3744">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3745">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3745">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3746">如果`expression`。類型是使用者定義的類型定義一元正運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3746">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3747">否則，如果`expression`。類型為數值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3747">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3748">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3748">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3749">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3749">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3750">如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3750">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3751">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3751">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3752">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3752">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3753">`expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3753">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3754">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3754">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3755">實作的方法是否`null`，節點的類型是`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3755">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="a8eb2-3756">如果`expression`。類型是不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3756">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3757">否則，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3757">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3758"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3758"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3759">不會為 <paramref name="expression" />.Type 定義一元正運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3759">The unary plus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3760">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3760">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="a8eb2-3761">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3761">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3762">建立代表一元加法運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3762">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3763"><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3763">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3764"><xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3764">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="a8eb2-3765"><xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3765">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="a8eb2-3766">則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3766">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="a8eb2-3767">否則，它們是 false。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3767">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="a8eb2-3768">實作方法</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3768">Implementing Method</span></span>  
 <span data-ttu-id="a8eb2-3769">下列規則會決定作業的實作方法：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3769">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="a8eb2-3770">如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數，方法是在節點的實作方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3770">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="a8eb2-3771">如果`expression`。類型是使用者定義的類型定義一元正運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3771">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3772">否則，如果`expression`。類型為數值類型、 實作方法是`null`。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3772">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="a8eb2-3773">節點型別已消除或非消除和</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3773">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="a8eb2-3774">如果實作的方法不是`null`:</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3774">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="a8eb2-3775">如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3775">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3776">節點的類型是實作方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3776">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="a8eb2-3777">如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3777">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="a8eb2-3778">`expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3778">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="a8eb2-3779">實作方法的傳回型別是不可為 null 的實值型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3779">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="a8eb2-3780">實作的方法是否`null`，節點的類型是`expression`。型別。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3780">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="a8eb2-3781">如果`expression`。類型是不可為 null，則不會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3781">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="a8eb2-3782">否則，則會消除節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3782">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8eb2-3783"><paramref name="expression" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3783"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a8eb2-3784"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3784"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8eb2-3785"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="expression" />.Type 定義一元正運算子。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3785"><paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="a8eb2-3786">-或-</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3786">-or-</span></span> 
 <span data-ttu-id="a8eb2-3787"><paramref name="expression" />.Type (如果它是可為 Null 的實質類型，則為其對應之不可為 Null 的類型) 無法指派給 <paramref name="method" /> 所代表之方法的引數類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3787"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="a8eb2-3788">要 Unbox 的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3788">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</span></span></param>
        <param name="type"><span data-ttu-id="a8eb2-3789">運算式的新 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3789">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3790">建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表明確 Unboxing。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3790">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3791"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3791">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a8eb2-3792">建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3792">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-3793">參數或變數的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3793">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3794">建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3794">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3795">建立含指定之名稱和類型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3795">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a8eb2-3796">參數或變數的類型。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3796">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="a8eb2-3797">參數或變數的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3797">The name of the parameter or variable.</span></span> <span data-ttu-id="a8eb2-3798">這個名稱僅供偵錯或列印之用。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3798">This name is used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3799">建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3799">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3800">建立含指定之名稱和類型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3800">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="a8eb2-3801"><see cref="T:System.Func`2" /> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3801">An instance of <see cref="T:System.Func`2" />.</span></span></param>
        <summary><span data-ttu-id="a8eb2-3802">精簡節點，然後呼叫精簡後的運算式上的訪問項委派。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3802">Reduces the node and then calls the visitor delegate on the reduced expression.</span></span> <span data-ttu-id="a8eb2-3803">如果節點無法縮減，此方法會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3803">The method throws an exception if the node is not reducible.</span></span></summary>
        <returns><span data-ttu-id="a8eb2-3804">受訪的運算式，或是在樹狀中應取代該運算式的運算式。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3804">The expression being visited, or an expression which should replace it in the tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8eb2-3805">覆寫這個方法，以提供從頭到尾參與節點的子系的邏輯。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3805">Override this method to provide logic to walk the node's children.</span></span> <span data-ttu-id="a8eb2-3806">一般實作會呼叫訪客。在每個子系，請瀏覽，如果有任何這些變更，應該會傳回已修改的子系本身的新複本。</span><span class="sxs-lookup"><span data-stu-id="a8eb2-3806">A typical implementation will call visitor.Visit on each of its children, and if any of them change, should return a new copy of itself with the modified children.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>