<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata><Meta Name="ms.openlocfilehash" Value="572416f2fe374dea80fd8d8d2b2642156673f844" /><Meta Name="ms.sourcegitcommit" Value="9802d4c6745a8ae514b26f144fb3969265b224ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/22/2018" /><Meta Name="ms.locfileid" Value="53751657" /></Metadata><TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供基底類別，表示運算式樹狀架構節點的類別可由此基底類別衍生。 它也包含 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />) Factory 方法來建立各種節點類型。 這是 <see langword="abstract" /> 類別。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何建立區塊的運算式。 區塊運算式包含兩個<xref:System.Linq.Expressions.MethodCallExpression>物件，另一個<xref:System.Linq.Expressions.ConstantExpression>物件。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建構 <see cref="T:System.Linq.Expressions.Expression" /> 的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>建構 <see cref="T:System.Linq.Expressions.Expression" /> 的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType"><see cref="T:System.Linq.Expressions.ExpressionType" /> 可設定為節點類型。</param>
        <param name="type">此 <see cref="P:System.Linq.Expressions.Expression.Type" /> 的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>初始化 <see cref="T:System.Linq.Expressions.Expression" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別中的建構函式會從呼叫這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">瀏覽這個節點的造訪者。</param>
        <summary>分派給這個節點類型的特定造訪方法。 例如，<see cref="T:System.Linq.Expressions.MethodCallExpression" /> 會呼叫 <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />。</summary>
        <returns>瀏覽這個節點的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此預設實作<xref:System.Linq.Expressions.ExpressionType.Extension>節點呼叫<xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>。 覆寫這個方法，以更特定的方法，衍生的訪客類別上呼叫<xref:System.Linq.Expressions.ExpressionVisitor>類別。 不過，它應該仍支援未知的訪客藉由呼叫<xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術加法運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術加法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Add" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載加法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的加法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的加法運算子的結果類型。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立將兩個整數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Addition 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術加法運算。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Add" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載加法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的加法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的加法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的加法運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的加法指派運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的加法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何建立將值加入整數變數，然後將作業的結果指派給變數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的加法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的加法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的加法指派運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的加法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的加法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的加法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術加法運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術加法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載加法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的加法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的加法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Addition 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術加法運算。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 作業的實作方法是選擇根據下列規則：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載加法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的加法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的加法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的加法運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="AND" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="AND" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.And" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`AND`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是結果型別預先定義之位元`AND`運算子。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至結果型別預先定義之位元`AND`運算子。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立運算式，表示這兩個布林值的邏輯 AND 運算。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義位元 <see langword="AND" /> 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="AND" />。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.And" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 作業的實作方法是選擇根據下列規則：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`AND`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是結果型別預先定義之位元`AND`運算子。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至結果型別預先定義之位元`AND`運算子。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的位元 <see langword="AND" /> 運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算元計算結果為 <see langword="AND" /> 時才求第二個運算元之值的 <see langword="true" /> 條件運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算元計算結果為 <see langword="AND" /> 時才求第二個運算元之值的 <see langword="true" /> 條件運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`AND`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
    > [!NOTE]
    >  條件式`AND`運算子無法多載以 C# 或 Visual Basic。 不過，條件式`AND`運算子會評估所使用的位元`AND`運算子。 因此，使用者定義的多載位元`AND`運算子可以是此節點類型的實作方法。  
  
-   否則，如果`left`。型別和`right`。類型為布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個是可為 null，且對應的非 null 的型別相等相對應的引數類型的實作方法。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   `left`.型別和`right`。型別都是相同的布林類型。  
  
-   如果`left`。型別和`right`。型別不可為 null，則不會消除節點。 節點的類型是預先定義的條件式的結果型別`AND`運算子。  
  
-   如果`left`。型別和`right`。型別可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的條件式的結果型別`AND`運算子。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立運算式，執行邏輯和作業，如果其兩個運算元在第一個運算元評估為`true`。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義位元 <see langword="AND" /> 運算子。  
  
-或- 
 <paramref name="left" />.Type 和 <paramref name="right" />.Type 是不相同的布林類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表只在第一個運算元解析為 true 時才評估第二個運算元的條件 <see langword="AND" /> 運算。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 作業的實作方法是選擇根據下列規則：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`AND`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
    > [!NOTE]
    >  條件式`AND`運算子無法多載以 C# 或 Visual Basic。 不過，條件式`AND`運算子會評估所使用的位元`AND`運算子。 因此，使用者定義的多載位元`AND`運算子可以是此節點類型的實作方法。  
  
-   否則，如果`left`。型別和`right`。類型為布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個是可為 null，且對應的非 null 的型別相等相對應的引數類型的實作方法。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   `left`.型別和`right`。型別都是相同的布林類型。  
  
-   如果`left`。型別和`right`。型別不可為 null，則不會消除節點。 節點的類型是預先定義的條件式的結果型別`AND`運算子。  
  
-   如果`left`。型別和`right`。型別可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的條件式的結果型別`AND`運算子。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的位元 <see langword="AND" /> 運算子。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />，且 <paramref name="left" />.Type 和 <paramref name="right" />.Type 不是相同的布林類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元 AND 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示位元 AND 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立表示位元 AND 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立表示位元 AND 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.IndexExpression" /> 以存取陣列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">表示多維陣列的運算式。</param>
        <param name="indexes">包含用於對陣列進行索引之運算式的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.IndexExpression" /> 以存取多維陣列。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示陣列的運算式，可由使用<xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A>方法，或透過<xref:System.Linq.Expressions.Expression.NewArrayBounds%2A>或<xref:System.Linq.Expressions.Expression.NewArrayInit%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用變更的多維陣列中的項目值`ArrayAccess`方法。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">表示要編制索引之陣列的運算式。</param>
        <param name="indexes">包含用於對陣列進行索引之運算式的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.IndexExpression" /> 以存取陣列。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示陣列的運算式，可由使用<xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A>方法，或透過<xref:System.Linq.Expressions.Expression.NewArrayBounds%2A>或<xref:System.Linq.Expressions.Expression.NewArrayInit%2A>。  
  
 針對多維陣列時，使用<xref:System.Linq.Expressions.Expression.ArrayAccess%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用變更陣列元素的值`ArrayAccess`方法。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.Expression" />，表示套用陣列索引運算子。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />。</param>
        <param name="indexes"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表將陣列索引運算子套用到陣序規範大於 1 的陣列。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個項目的`indexes`必須具有<xref:System.Linq.Expressions.Expression.Type%2A>等於<xref:System.Int32>。 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`array`必須代表其陣序規範比對中的項目數的陣列類型`indexes`。  
  
 如果的陣序`array`。類型為 1，則這個方法會傳回<xref:System.Linq.Expressions.BinaryExpression>。 <xref:System.Linq.Expressions.BinaryExpression.Left%2A>屬性設定為`array`並<xref:System.Linq.Expressions.BinaryExpression.Right%2A>屬性設定為單一項目`indexes`。 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性<xref:System.Linq.Expressions.BinaryExpression>代表項目類型`array`。型別。  
  
 如果的陣序`array`。類型為多個，則這個方法會傳回<xref:System.Linq.Expressions.MethodCallExpression>。 <xref:System.Linq.Expressions.MethodCallExpression.Method%2A>屬性設定為<xref:System.Reflection.MethodInfo>描述方法的公用執行個體`Get`上所代表的型別<xref:System.Linq.Expressions.Expression.Type%2A>屬性`array`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.MethodCallExpression>表示成二維陣列編製索引。  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 或 <paramref name="indexes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />.Type 不代表陣列類型。  
  
-或- 
<paramref name="array" />.Type 的陣序規範不符合 <paramref name="indexes" /> 中的項目數。  
  
-或- 
<paramref name="indexes" /> 之一或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不代表 <see cref="T:System.Int32" /> 類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="index">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表將陣列索引運算子套用到陣序規範 1 的陣列。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` 必須代表類型的索引<xref:System.Int32>。  
  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.BinaryExpression>是`null`，，同時兩者皆<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>設為`false`。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性等於的項目類型`array`。型別。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 或 <paramref name="index" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />.Type 不代表陣列類型。  
  
-或- 
 <paramref name="array" />.Type 代表其陣序規範不為 1 的陣列類型。  
  
-或- 
 <paramref name="index" />.Type 不代表 <see cref="T:System.Int32" /> 類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Linq.Expressions.Expression" /> 執行個體 (用於陣列索引運算的索引) 的陣列。</param>
        <param name="indexes">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表將陣列索引運算子套用到多維陣列。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個項目的`indexes`必須具有<xref:System.Linq.Expressions.Expression.Type%2A>等於<xref:System.Int32>。 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`array`必須代表其陣序規範比對中的項目數的陣列類型`indexes`。  
  
 如果的陣序`array`。類型為 1，則這個方法會傳回<xref:System.Linq.Expressions.BinaryExpression>。 <xref:System.Linq.Expressions.BinaryExpression.Left%2A>屬性設定為`array`並<xref:System.Linq.Expressions.BinaryExpression.Right%2A>屬性設定為單一項目`indexes`。 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性<xref:System.Linq.Expressions.BinaryExpression>代表項目類型`array`。型別。  
  
 如果的陣序`array`。類型為多個，則這個方法會傳回<xref:System.Linq.Expressions.MethodCallExpression>。 <xref:System.Linq.Expressions.MethodCallExpression.Method%2A>屬性設定為<xref:System.Reflection.MethodInfo>描述方法的公用執行個體`Get`上所代表的型別<xref:System.Linq.Expressions.Expression.Type%2A>屬性`array`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.MethodCallExpression>表示成二維陣列編製索引。  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 或 <paramref name="indexes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />.Type 不代表陣列類型。  
  
-或- 
<paramref name="array" />.Type 的陣序規範不符合 <paramref name="indexes" /> 中的項目數。  
  
-或- 
<paramref name="indexes" /> 之一或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不代表 <see cref="T:System.Int32" /> 類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表用於取得一維陣列長度的運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性等於 <paramref name="array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性`array`必須代表陣列型別。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>等於<xref:System.Int32>。 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性是`null`，並同時<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>設為`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />.Type 不代表陣列類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Assign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Assign`運算式複製實值類型的值，而且會複製參考類型的參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立代表指派運算的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表成員初始化的 <see cref="T:System.Linq.Expressions.MemberAssignment" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">要將 <see cref="T:System.Reflection.MemberInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</param>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberAssignment" />，代表初始化欄位或屬性。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberAssignment" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 等於 <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性`expression`必須是指派給所代表的型別<xref:System.Reflection.FieldInfo.FieldType%2A>或是<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性`member`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 或 <paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" /> 不代表欄位或屬性。  
  
-或- 
<paramref name="member" /> 所表示的屬性沒有 <see langword="set" /> 存取子。  
  
-或- 
 無法將 <paramref name="expression" />.Type 指派給 <paramref name="member" /> 代表的欄位或屬性類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">代表屬性存取子方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberAssignment" />，代表使用屬性存取子方法初始化成員。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberAssignment" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，代表在 <paramref name="propertyAccessor" /> 中存取的屬性，以及將 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> 屬性設定為 <paramref name="expression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`expression`必須是指派給所代表的型別<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性中存取的屬性`propertyAccessor`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 或 <paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。  
  
-或- 
<paramref name="propertyAccessor" /> 所存取的屬性沒有 <see langword="set" /> 存取子。  
  
-或- 
 無法將 <paramref name="expression" />.Type 指派給 <paramref name="member" /> 代表的欄位或屬性類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">區塊中的運算式。</param>
        <summary>建立包含指定的運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">區塊中的運算式。</param>
        <summary>建立包含指定的運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立區塊的運算式。 區塊運算式包含兩個<xref:System.Linq.Expressions.MethodCallExpression>物件，另一個<xref:System.Linq.Expressions.ConstantExpression>物件。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">區塊中的變數。</param>
        <param name="expressions">區塊中的運算式。</param>
        <summary>建立包含指定之變數和運算式的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。  
  
   
  
## Examples  
 下列程式碼範例示範如何將參數傳遞給區塊的運算式，並處理區塊內的這個參數。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">區塊中的變數。</param>
        <param name="expressions">區塊中的運算式。</param>
        <summary>建立包含指定之變數和運算式的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">區塊中的第一個運算式。</param>
        <param name="arg1">區塊中的第二個運算式。</param>
        <summary>建立包含兩個運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">區塊的結果類型。</param>
        <param name="expressions">區塊中的運算式。</param>
        <summary>建立包含指定的運算式、有指定之結果類型、但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">區塊的結果類型。</param>
        <param name="expressions">區塊中的運算式。</param>
        <summary>建立包含指定的運算式、有指定之結果類型、但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">區塊中的第一個運算式。</param>
        <param name="arg1">區塊中的第二個運算式。</param>
        <param name="arg2">區塊中的第三個運算式。</param>
        <summary>建立包含三個運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">區塊的結果類型。</param>
        <param name="variables">區塊中的變數。</param>
        <param name="expressions">區塊中的運算式。</param>
        <summary>建立包含指定之變數和運算式的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">區塊的結果類型。</param>
        <param name="variables">區塊中的變數。</param>
        <param name="expressions">區塊中的運算式。</param>
        <summary>建立包含指定之變數和運算式的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">區塊中的第一個運算式。</param>
        <param name="arg1">區塊中的第二個運算式。</param>
        <param name="arg2">區塊中的第三個運算式。</param>
        <param name="arg3">區塊中的第四個運算式。</param>
        <summary>建立包含四個運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">區塊中的第一個運算式。</param>
        <param name="arg1">區塊中的第二個運算式。</param>
        <param name="arg2">區塊中的第三個運算式。</param>
        <param name="arg3">區塊中的第四個運算式。</param>
        <param name="arg4">區塊中的第五個運算式。</param>
        <summary>建立包含五個運算式但沒有任何變數的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 區塊運算式執行時，它會在區塊中傳回的最後一個運算式的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示 break 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <summary>建立表示 break 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Break、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且包含在跳躍時傳遞至目標標籤的 Null 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立包含的運算式<xref:System.Linq.Expressions.LoopExpression>物件，使用<xref:System.Linq.Expressions.Expression.Break%2A>方法。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="value">將在跳躍時傳遞至關聯標籤的值。</param>
        <summary>建立表示 break 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。 可以指定跳躍時傳遞至標籤的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Break、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 break 陳述式。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Break、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="value">將在跳躍時傳遞至關聯標籤的值。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 break 陳述式。 可以指定跳躍時傳遞至標籤的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Break、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Linq.Expressions.Expression" />，指定執行個體方法呼叫的執行個體 (對 <see langword="null" /> (在 Visual Basic 中為 <see langword="static" />) 方法會傳遞 <see langword="Shared" />)。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</param>
        <summary>建立代表呼叫不採用任何引數之方法的 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要代表呼叫`static`(`Shared` Visual Basic 中) 方法，請傳入`null`如`instance`時呼叫這個方法的參數。  
  
 如果`method`代表執行個體方法，<xref:System.Linq.Expressions.Expression.Type%2A>屬性`instance`必須是指派給所表示之方法的宣告型別`method`。  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>是空的。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性所表示之方法的傳回型別等於`method`。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立運算式，會呼叫不含引數的方法。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="instance" /> 為 <see langword="null" />，<paramref name="method" /> 則代表執行個體方法。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />.Type 無法指派給 <paramref name="method" /> 所代表之方法的宣告類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">表示目標方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 的集合，代表呼叫引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫靜態方法 (在 Visual Basic 中為共用方法)。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</param>
        <param name="arg0">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用一個引數的 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立運算式，會呼叫`static`(`Shared` Visual Basic 中) 採用一個引數的方法。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" />，代表 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法，將 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為與之相等。</param>
        <param name="arguments">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫有引數的 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`arguments`不是`null`，它必須有相同數目的元素所代表之方法的參數數目為`method`。 在每個項目`arguments`不得`null`，而且必須是指派給對應的參數`method`，可能之後*加註引號於*。  
  
> [!NOTE]
>  只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>是空的如果`arguments`是`null`。 否則，它包含相同的項目，做為`arguments`，其中有些可能會加上引號。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`method`。 <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> 屬性為 `null`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> 中的項目數不等於 <paramref name="method" />所代表之方法的參數數目。  
  
-或- 
<paramref name="arguments" /> 的一或多個項目無法指派給 <paramref name="method" /> 所代表之方法的對應參數。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> (針對 <see langword="null" /> (在 Visual Basic 中為 <see langword="static" />) 方法傳遞 <see langword="Shared" />)。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件。</param>
        <summary>建立代表呼叫至採用引數之方法的 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要代表呼叫`static`(`Shared` Visual Basic 中) 方法，請傳入`null`如`instance`參數，當您呼叫此方法，或呼叫<xref:System.Linq.Expressions.Expression.Call%2A>改為。  
  
 如果`method`代表執行個體方法，<xref:System.Linq.Expressions.Expression.Type%2A>屬性`instance`必須是指派給所表示之方法的宣告型別`method`。  
  
 如果`arguments`不是`null`，它必須有相同數目的元素所代表之方法的參數數目為`method`。 在每個項目`arguments`不得`null`，而且必須是指派給對應的參數`method`，可能之後*加註引號於*。  
  
> [!NOTE]
>  只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>是空的如果`arguments`是`null`。 否則，它包含相同的項目，做為`arguments`，其中有些可能會加上引號。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`method`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="instance" /> 為 <see langword="null" />，<paramref name="method" /> 則代表執行個體方法。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />.Type 無法指派給 <paramref name="method" /> 所代表之方法的宣告類型。  
  
-或- 
<paramref name="arguments" /> 中的項目數不等於 <paramref name="method" />所代表之方法的參數數目。  
  
-或- 
<paramref name="arguments" /> 的一或多個項目無法指派給 <paramref name="method" /> 所代表之方法的對應參數。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Linq.Expressions.Expression" />，指定執行個體方法呼叫的執行個體 (對 <see langword="null" /> (在 Visual Basic 中為 <see langword="static" />) 方法會傳遞 <see langword="Shared" />)。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</param>
        <param name="arguments">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 物件的陣列。</param>
        <summary>建立代表呼叫至採用引數之方法的 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要代表呼叫`static`(`Shared` Visual Basic 中) 方法，請傳入`null`如`instance`參數，當您呼叫此方法，或呼叫<xref:System.Linq.Expressions.Expression.Call%2A>改為。  
  
 如果`method`代表執行個體方法，<xref:System.Linq.Expressions.Expression.Type%2A>屬性`instance`必須是指派給所表示之方法的宣告型別`method`。  
  
 如果`arguments`不是`null`，它必須有相同數目的元素所代表之方法的參數數目為`method`。 在每個項目`arguments`不得`null`，而且必須是指派給對應的參數`method`，可能之後*加註引號於*。  
  
> [!NOTE]
>  只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>是空的如果`arguments`是`null`。 否則，它包含相同的項目，做為`arguments`，其中有些可能會加上引號。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`method`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="instance" /> 為 <see langword="null" />，<paramref name="method" /> 則代表執行個體方法。  
  
-或- 
 <paramref name="arguments" /> 不是 <see langword="null" />，且它的一或多個子項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />.Type 無法指派給 <paramref name="method" /> 所代表之方法的宣告類型。  
  
-或- 
<paramref name="arguments" /> 中的項目數不等於 <paramref name="method" />所代表之方法的參數數目。  
  
-或- 
<paramref name="arguments" /> 的一或多個項目無法指派給 <paramref name="method" /> 所代表之方法的對應參數。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</param>
        <param name="arg0">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg1">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用兩個引數的靜態方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">為執行個體呼叫指定執行個體的 <see cref="T:System.Linq.Expressions.Expression" />。 (對靜態方法 (在 Visual Basic 中為共用方法) 傳遞 Null)。</param>
        <param name="method">表示目標方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="arg0">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg1">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用兩個引數的方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何建立會呼叫執行個體方法具有兩個引數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Linq.Expressions.Expression" />，將搜尋其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性值中的特定方法。</param>
        <param name="methodName">方法的名稱。</param>
        <param name="typeArguments"><see cref="T:System.Type" /> 物件的陣列，這些物件可指定泛型方法的類型參數。 當 methodName 指定非泛型方法時，這個引數應該為 Null。</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，這個陣列代表方法的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表透過呼叫適當的 Factory 方法來呼叫方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 屬性等於 <paramref name="instance" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 設定為代表指定執行個體方法的 <see cref="T:System.Reflection.MethodInfo" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 設定為指定的引數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`methodName`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 或 <paramref name="methodName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="methodName" />.Type 或其基底類型中找不到名稱為 <paramref name="typeArguments" />、其類型參數符合 <paramref name="arguments" />，且參數類型符合 <paramref name="instance" /> 的方法。  
  
-或- 
<paramref name="methodName" />.Type 或其基底類型中找到多個名稱為 <paramref name="typeArguments" />、類型參數符合 <paramref name="arguments" />，且參數類型符合 <paramref name="instance" /> 的方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</param>
        <param name="arg0">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg1">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg2">表示第三個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用三個引數的靜態方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">包含所指定 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法的型別。</param>
        <param name="methodName">方法的名稱。</param>
        <param name="typeArguments"><see cref="T:System.Type" /> 物件的陣列，這些物件可指定泛型方法的類型參數。 當 methodName 指定非泛型方法時，這個引數應該為 Null。</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，這個陣列代表方法的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表透過呼叫適當的 Factory 方法來呼叫 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為 <see cref="T:System.Reflection.MethodInfo" />，代表指定的 <see langword="static" /> (在 Visual Basic 中則為 <see langword="Shared" />) 方法，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 屬性設定為指定的引數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MethodCallExpression>等於所表示之方法的傳回型別`methodName`。 <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> 屬性為 `null`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 或 <paramref name="methodName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="methodName" /> 或其基底類型中找不到名稱為 <paramref name="typeArguments" />、類型參數符合 <paramref name="arguments" />，且參數類型符合 <paramref name="type" /> 的方法。  
  
-或- 
<paramref name="methodName" /> 或其基底類型中找到多個名稱為 <paramref name="typeArguments" />、類型參數符合 <paramref name="arguments" />，且參數類型符合 <paramref name="type" /> 的方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">為執行個體呼叫指定執行個體的 <see cref="T:System.Linq.Expressions.Expression" />。 (對靜態方法 (在 Visual Basic 中為共用方法) 傳遞 Null)。</param>
        <param name="method">表示目標方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="arg0">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg1">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg2">表示第三個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用三個引數的方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</param>
        <param name="arg0">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg1">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg2">表示第三個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg3">表示第四個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用四個引數的靜態方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</param>
        <param name="arg0">表示第一個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg1">表示第二個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg2">表示第三個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg3">表示第四個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="arg4">表示第五個引數的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，代表呼叫採用五個引數的靜態方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示節點可精簡為更簡單的節點。 如果傳回 true，則可呼叫 Reduce() 以產生精簡的形式。</summary>
        <value><see langword="true" /> 如果可以減少節點;否則， <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表 catch 陳述式的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><see cref="T:System.Linq.Expressions.ParameterExpression" />，代表這個處理常式所攔截 <see cref="T:System.Exception" /> 物件的參考。</param>
        <param name="body">catch 陳述式的主體。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.CatchBlock" />，代表包含已攔截 <see cref="T:System.Exception" /> 物件參考的 catch 陳述式，以便用於處理常式主體。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="P:System.Linq.Expressions.Expression.Type" /> 將處理之 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</param>
        <param name="body">catch 陳述式的主體。</param>
        <summary>建立代表 catch 陳述式的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>的<xref:System.Exception>攔截可以指定但沒有參考<xref:System.Exception>物件都會是可用於<xref:System.Linq.Expressions.CatchBlock>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><see cref="T:System.Linq.Expressions.ParameterExpression" />，代表這個處理常式所攔截 <see cref="T:System.Exception" /> 物件的參考。</param>
        <param name="body">catch 陳述式的主體。</param>
        <param name="filter"><see cref="T:System.Exception" /> 篩選條件的主體。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.CatchBlock" />，代表包含 <see cref="T:System.Exception" /> 篩選條件和已攔截 <see cref="T:System.Exception" /> 物件參考的 catch 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="P:System.Linq.Expressions.Expression.Type" /> 將處理之 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</param>
        <param name="body">catch 陳述式的主體。</param>
        <param name="filter"><see cref="T:System.Exception" /> 篩選條件的主體。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.CatchBlock" />，代表包含 <see cref="T:System.Exception" /> 篩選條件但沒有已攔截 <see cref="T:System.Exception" /> 物件參考的 catch 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">表示原始程式檔的 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />。</param>
        <summary>建立用於清除序列點的 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的執行個體，用於清除序列點。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表聯合運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表聯合運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.BinaryExpression>是`null`，同時兩者皆<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>設為`false`。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性等於聯合運算的結果類型。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
#### <a name="result-type"></a>結果類型  
 下列規則決定的結果型別：  
  
-   如果`left`。類型代表可為 null 的型別和`right`。類型是隱含地轉換成對應的非 null 的型別，結果型別是不可為 null 相當於`left`。型別。  
  
-   否則，如果`right`。類型是隱含地轉換成`left`。類型的結果型別是`left`。型別。  
  
-   否則，如果不可為 null 相當於`left`。類型是隱含地轉換成`right`。類型的結果型別是`right`。型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不表示參考類型或可為 Null 的實值類型。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" />.Type 和 <paramref name="right" />.Type 無法相互轉換。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/088b1f0d-c1af-4fe1-b4b8-196fd5ea9132">?? 運算子 (C# 參考)</related>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>指定轉換函式，建立代表聯合運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.BinaryExpression>是`null`，同時兩者皆<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>設為`false`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.BinaryExpression>等於聯合運算的結果類型。  
  
 下列規則決定的結果型別：  
  
-   如果`left`。類型代表可為 null 的型別和`right`。類型是隱含地轉換成對應的非 null 的型別，結果型別是不可為 null 相當於`left`。型別。  
  
-   否則，如果`right`。類型是隱含地轉換成`left`。類型的結果型別是`left`。型別。  
  
-   否則，如果不可為 null 相當於`left`。類型是隱含地轉換成`right`。類型的結果型別是`right`。型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" />.Type 和 <paramref name="right" />.Type 無法相互轉換。  
  
-或- 
 <paramref name="conversion" /> 不是 <see langword="null" />，且 <paramref name="conversion" />.Type 為委派類型，其採用的引數不是剛好一個。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不表示參考類型或可為 Null 的實值類型。  
  
-或- 
<paramref name="left" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所表示的類型無法指派至委派類型 <paramref name="conversion" />.Type 的參數類型。  
  
-或- 
<paramref name="right" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不等於委派類型 <paramref name="conversion" />.Type 的傳回類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示條件陳述式的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</param>
        <param name="ifTrue">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</param>
        <param name="ifFalse">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</param>
        <summary>建立表示條件陳述式的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ConditionalExpression>等於<xref:System.Linq.Expressions.Expression.Type%2A>屬性`ifTrue`。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立表示條件陳述式的運算式。 如果第一個引數評估為`true`第二個引數執行; 否則會執行第三個引數。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="test" />、<paramref name="ifTrue" /> 或 <paramref name="ifFalse" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="test" />.Type 不是 <see cref="T:System.Boolean" />。  
  
-或- 
 <paramref name="ifTrue" />.Type 不等於 <paramref name="ifFalse" />.Type。</exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</param>
        <param name="ifTrue">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</param>
        <param name="ifFalse">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</param>
        <param name="type">要將 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立表示條件陳述式的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓明確統一的情況下的條件式運算式的結果型別其中的型別`ifTrue`和`ifFalse`運算式是否不相等。 這兩種`ifTrue`和`ifFalse`必須可隱含地參考指派給結果型別。 `type`允許為<xref:System.Void>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.ConstantExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要將 <see cref="T:System.Object" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 屬性設定為指定的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Constant" />，而 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ConstantExpression>的型別等於`value`。 如果`value`已`null`，<xref:System.Linq.Expressions.Expression.Type%2A>等於<xref:System.Object>。  
  
 若要代表`null`，您也可以使用<xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29>方法，與您可以明確指定類型。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立代表常數值的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">要將 <see cref="T:System.Object" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Constant" />，且 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可用於代表可為 null 類型的值。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立代表可為 null 類型的常數運算式，並將其值設定為`null`。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不為 <see langword="null" />，且 <paramref name="type" /> 無法從 <paramref name="value" /> 的動態類型指派。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表 continue 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <summary>建立代表 continue 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Continue、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且包含在跳躍時傳遞至目標標籤的 Null 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立會使用的迴圈運算式<xref:System.Linq.Expressions.Expression.Continue%2A>方法。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，代表含指定之類型的 continue 陳述式。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Continue、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 null 值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表類型轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立代表類型轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 屬性為 `false`。 則會消除節點，如果<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>是`true`。 否則為 `false`。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果有任一個`expression`。型別或`type`是使用者定義型別定義的隱含或明確轉換運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則就是：  
  
    -   如果兩個`expression`。型別和`type`代表數值或布林值類型或可為 null 或非可為 null 的列舉類型、 實作方法是`null`。  
  
    -   如果有任一個`expression`。型別或`type`是參考類型，明確的 boxing 處理，unboxing，或參考轉換存在從`expression`。若要輸入`type`，則實作方法是`null`。  
  
#### <a name="lifted-versus-non-lifted"></a>已消除或非消除  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，且實作的方法的傳回型別指派給`type`，則不會消除節點。  
  
-   如果一或兩個的`expression`。型別或`type`是 null 的實值類型，而且對應的非可為 null 的實值型別分別等於引數類型和實作方法的傳回型別，則會消除節點。  
  
 如果實作的方法是`null`:  
  
-   如果兩個`expression`。型別和`type`都不可為 null，則不會消除節點。  
  
-   否則會消除節點。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立運算式，表示型別轉換作業。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type 和 <paramref name="type" /> 之間未定義轉換運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</param>
        <summary>建立代表轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />，此轉換作業已指定實作方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 屬性為 `false`。 則會消除節點，如果<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>是`true`。 否則為 `false`。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果方法不是`null`，它是實作的方法。 它必須代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數的方法。  
  
-   否則，如果`expression`。型別或`type`是使用者定義型別定義的隱含或明確轉換運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則就是：  
  
    -   如果兩個`expression`。型別和`type`代表數值或布林值類型或可為 null 或非可為 null 的列舉類型、 實作方法是`null`。  
  
    -   如果有任一個`expression`。型別或`type`是參考類型，明確的 boxing 處理，unboxing，或參考轉換存在從`expression`。若要輸入`type`，則實作方法是`null`。  
  
#### <a name="lifted-versus-non-lifted"></a>已消除或非消除  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，且實作的方法的傳回型別指派給`type`，則不會消除節點。  
  
-   如果任一個或兩個的`expression`。型別或`type`可為 null 的實值型別而且分別為相等的引數類型和實作方法的傳回型別對應的非可為 null 的實值型別，則會消除節點。  
  
 如果實作的方法是`null`:  
  
-   如果兩個`expression`。型別和`type`都不可為 null，則不會消除節點。  
  
-   否則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type 和 <paramref name="type" /> 之間未定義轉換運算子。  
  
-或- 
 <paramref name="expression" />.Type 無法指派給 <paramref name="method" /> 所代表方法的引數類型。  
  
-或- 
<paramref name="method" /> 所代表方法的傳回類型無法指派給 <paramref name="type" />。  
  
-或- 
 <paramref name="expression" />.Type 或 <paramref name="type" /> 是不可為 Null 的實值類型，且對應之不可為 Null 的實值類型不等於 <paramref name="method" /> 所表示之方法的引數類型或傳回類型。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">已找到一個以上的方法符合 <paramref name="method" /> 說明。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />；若目標類型已溢位，此運算式便會擲回例外狀況。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立代表轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />；若目標類型已溢位，此運算式便會擲回例外狀況。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 屬性為 `false`。 則會消除節點，如果<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>是`true`。 否則為 `false`。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果有任一個`expression`。型別或`type`是使用者定義型別定義的隱含或明確轉換運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則就是：  
  
    -   如果兩個`expression`。型別和`type`代表數值或布林值類型或可為 null 或非可為 null 的列舉類型、 實作方法是`null`。  
  
    -   如果有任一個`expression`。型別或`type`是參考類型，明確的 boxing 處理，unboxing，或參考轉換存在從`expression`。若要輸入`type`，則實作方法是`null`。  
  
#### <a name="lifted-versus-non-lifted"></a>已消除或非消除  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，且實作的方法的傳回型別指派給`type`，則不會消除節點。  
  
-   如果任一個或兩個的`expression`。型別或`type`可為 null 的實值型別而且分別為相等的引數類型和實作方法的傳回型別對應的非可為 null 的實值型別，則會消除節點。  
  
 如果實作的方法是`null`:  
  
-   如果兩個`expression`。型別和`type`都不可為 null，則不會消除節點。  
  
-   否則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type 和 <paramref name="type" /> 之間未定義轉換運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</param>
        <summary>建立代表轉換作業的 <see cref="T:System.Linq.Expressions.UnaryExpression" />，如果目標類型已溢位，且已指定此作業的實作方法，則此作業會擲回例外狀況。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 屬性為 `false`。 則會消除節點，如果<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>是`true`。 否則為 `false`。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果方法不是`null`，它是實作的方法。 它必須代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數的方法。  
  
-   否則，如果`expression`。型別或`type`是使用者定義型別定義的隱含或明確轉換運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則就是：  
  
    -   如果兩個`expression`。型別和`type`代表數值或布林值類型或可為 null 或非可為 null 的列舉類型、 實作方法是`null`。  
  
    -   如果有任一個`expression`。型別或`type`是參考類型，明確的 boxing 處理，unboxing，或參考轉換存在從`expression`。若要輸入`type`，則實作方法是`null`。  
  
#### <a name="lifted-versus-non-lifted"></a>已消除或非消除  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，且實作的方法的傳回型別指派給`type`，則不會消除節點。  
  
-   如果任一個或兩個的`expression`。型別或`type`可為 null 的實值型別而且分別為相等的引數類型和實作方法的傳回型別對應的非可為 null 的實值型別，則會消除節點。  
  
 如果實作的方法是`null`:  
  
-   如果兩個`expression`。型別和`type`都不可為 null，則不會消除節點。  
  
-   否則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type 和 <paramref name="type" /> 之間未定義轉換運算子。  
  
-或- 
 <paramref name="expression" />.Type 無法指派給 <paramref name="method" /> 所代表方法的引數類型。  
  
-或- 
<paramref name="method" /> 所代表方法的傳回類型無法指派給 <paramref name="type" />。  
  
-或- 
 <paramref name="expression" />.Type 或 <paramref name="type" /> 是不可為 Null 的實值類型，且對應之不可為 Null 的實值類型不等於 <paramref name="method" /> 所表示之方法的引數類型或傳回類型。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">已找到一個以上的方法符合 <paramref name="method" /> 說明。</exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">表示原始程式檔的 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />。</param>
        <param name="startLine">這個 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的起始行。 必須大於 0。</param>
        <param name="startColumn">這個 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的起始欄。 必須大於 0。</param>
        <param name="endLine">這個 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的結尾行。 必須大於或等於起始行。</param>
        <param name="endColumn">這個 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的結尾欄。 如果結尾行與起始行相同，則結尾欄必須大於或等於起始欄。 在任何情況下，都必須大於 0。</param>
        <summary>使用指定的時間範圍建立 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表運算式遞減 1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要遞減的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表運算式遞減 1。</summary>
        <returns>代表遞減後運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個運算式會正常運作，並不會變更物件傳遞給它的值。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立運算式的設定，該 substracts 1 從指定的值。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要遞減的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表運算式遞減 1。</summary>
        <returns>代表遞減後運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個運算式會正常運作，並不會變更物件傳遞給它的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DefaultExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的類型。</summary>
        <returns><see cref="T:System.Linq.Expressions.DefaultExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Default" />，而 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何建立運算式，表示指定型別的預設值。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表算術除法運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表算術除法運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載除法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的除法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的除法運算子的結果類型。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立運算式，會將其第二個引數的第一個引數。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Division 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表算術除法運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載除法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的除法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的除法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的除法運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表不含溢位檢查的除法指派運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表不含溢位檢查的除法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表不含溢位檢查的除法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，代表不含溢位檢查的除法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表動態運算的 <see cref="T:System.Linq.Expressions.DynamicExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="returnType">動態運算式的結果類型。</param>
        <param name="arguments">動態作業的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="returnType">動態運算式的結果類型。</param>
        <param name="arg0">動態作業的第一個引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="returnType">動態運算式的結果類型。</param>
        <param name="arguments">動態作業的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="returnType">動態運算式的結果類型。</param>
        <param name="arg0">動態作業的第一個引數。</param>
        <param name="arg1">傳遞至動態作業的第二個引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="returnType">動態運算式的結果類型。</param>
        <param name="arg0">動態作業的第一個引數。</param>
        <param name="arg1">傳遞至動態作業的第二個引數。</param>
        <param name="arg2">傳遞至動態作業的第三個引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="returnType">動態運算式的結果類型。</param>
        <param name="arg0">動態作業的第一個引數。</param>
        <param name="arg1">傳遞至動態作業的第二個引數。</param>
        <param name="arg2">傳遞至動態作業的第三個引數。</param>
        <param name="arg3">傳遞至動態運算的第四個引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A>結果屬性會從引數的型別推斷而來，並指定傳回型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.ElementInit" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />。</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" />，包含要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 物件。</param>
        <summary>指定 <see cref="T:System.Linq.Expressions.ElementInit" /> 做為第二個引數，建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.ElementInit" />，其 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> 和 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod`參數必須代表名為"Add"（不區分大小寫） 的執行個體方法。 Add 方法必須有相同數目的參數中的項目數為`arguments`。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性中的每個項目的`arguments`必須是指派給 add 方法中，對應參數的型別可能之後*引用*。  
  
> [!NOTE]
>  只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.ElementInit>，表示呼叫<xref:System.Collections.Generic.Dictionary%602.Add%2A>方法來初始化字典集合的項目。  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addMethod" /> 或 <paramref name="arguments" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">未將 <paramref name="addMethod" /> 所代表的方法命名為 "Add" (不區分大小寫)。  
  
-或- 
<paramref name="addMethod" /> 所代表的方法不是執行個體方法。  
  
-或- 
 <paramref name="arguments" /> 所包含的項目數與 <paramref name="addMethod" /> 所代表之方法的參數數目不同。  
  
-或- 
<paramref name="arguments" /> 的一或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="addMethod" /> 所代表之方法的對應參數類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />。</param>
        <param name="arguments">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 物件陣列。</param>
        <summary>指定值陣列做為第二個引數，建立 <see cref="T:System.Linq.Expressions.ElementInit" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.ElementInit" />，其 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> 和 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod`參數必須代表名為"Add"（不區分大小寫） 的執行個體方法。 Add 方法必須有相同數目的參數中的項目數為`arguments`。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性中的每個項目的`arguments`必須是指派給 add 方法中，對應參數的型別可能之後*引用*。  
  
> [!NOTE]
>  只有當對應的方法參數的類型是項目會加上引號<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.ElementInit>，表示呼叫<xref:System.Collections.Generic.Dictionary%602.Add%2A>方法來初始化字典集合的項目。  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addMethod" /> 或 <paramref name="arguments" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">addMethod 所表示的方法名稱不是 "Add" (不區分大小寫)。  
  
-或- 
addMethod 所表示的方法不是執行個體方法。  
  
-或- 
引數包含的項目數目與 addMethod 所表示之方法的參數數目不同。  
  
-或- 
<paramref name="arguments" /> 的一或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="addMethod" /> 所代表之方法的對應參數類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立具有 <see cref="T:System.Void" /> 類型的空運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.DefaultExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Default" />，且 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設為 <see cref="T:System.Void" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必須是運算式，但不需要採取任何動作，可以使用空運算式。 比方說，您可以使用空的運算式做為最後一個運算式中的運算式區塊。 在此情況下，封鎖運算式的傳回值為 void。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立空的運算式，並將它加入區塊運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。 否則為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載等號比較運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型是<xref:System.Boolean>。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立會檢查其兩個引數的值是否相等的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義等號比較運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="liftToNull"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。 否則，兩者都是`false`。 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載等號比較運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義等號比較運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="XOR" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立表示位元 <see langword="XOR" /> 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示多載的使用者定義型別`XOR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的結果型別`XOR`運算子。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的結果型別`XOR`運算子。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立代表邏輯 XOR 運算的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 <see langword="XOR" /> 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立表示位元 <see langword="XOR" /> 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定實作作業的方法選擇：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示多載的使用者定義型別`XOR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的結果型別`XOR`運算子。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的結果型別`XOR`運算子。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義類型 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的 <see langword="XOR" /> 運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表位元 XOR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立代表位元 XOR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立代表位元 XOR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>使用 <c>op_ExclusiveOr</c> 作為使用者定義型別，建立代表位元 XOR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表存取欄位的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。 若為 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，<paramref name="expression" /> 必須是 <see langword="null" />。</param>
        <param name="field">要將 <see cref="T:System.Reflection.FieldInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />。</param>
        <summary>建立代表存取欄位的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.FieldInfo.FieldType%2A>屬性`field`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="field" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="field" /> 所表示的欄位不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，且 <paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type 無法指派給 <paramref name="field" /> 所代表之欄位的宣告類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 包含名為 <paramref name="fieldName" /> 的欄位。 如果是靜態欄位，可以是 Null。</param>
        <param name="fieldName">要存取的欄位名稱。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberExpression" />，代表存取可指定欄位名稱的欄位。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />、<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 屬性設定為 <paramref name="expression" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為 <see cref="T:System.Reflection.FieldInfo" />，代表 <paramref name="fieldName" /> 所表示的欄位。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.FieldInfo.FieldType%2A>屬性<xref:System.Reflection.FieldInfo>所表示的欄位表示`fieldName`。  
  
 這個方法會搜尋`expression`。類型和其基底類型的欄位，具有名稱`fieldName`。 公用欄位，優先使用非公用欄位。 如果找到相符的欄位，則此方法會傳遞`expression`而<xref:System.Reflection.FieldInfo>表示該欄位加入<xref:System.Linq.Expressions.Expression.Field%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立代表存取欄位的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="fieldName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="fieldName" />.Type 或其基底類型中沒有定義名為 <paramref name="expression" /> 的欄位。</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">欄位的包含物件。 如果是靜態欄位，可以是 Null。</param>
        <param name="type">包含欄位的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <param name="fieldName">要存取的欄位。</param>
        <summary>建立代表存取欄位的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">最多包含十六個 <see cref="T:System.Type" /> 物件的陣列，指定 <see langword="System.Action" /> 委派類型的型別引數。</param>
        <summary>建立 <see cref="T:System.Type" /> 物件，這個物件代表具有特定型別引數的泛型 <c>System.Action</c> 委派類型。</summary>
        <returns><c>System.Action</c> 委派的類型，具有指定的型別引數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 舉例來說，如果的項目`typeArgs`代表型別`T1…Tn`，產生<xref:System.Type>物件代表建構的委派型別`System.Action<T1,…,Tn>`在 C# 中或`System.Action(Of T1,…,Tn)`Visual Basic 中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeArgs" /> 包含十六個以上的項目。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArgs" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">委派的型別引數。</param>
        <summary>取得 <see cref="P:System.Linq.Expressions.Expression.Type" /> 物件，這個物件代表具有特定型別引數的泛型 <c>System.Func</c> 或 <c>System.Action</c> 委派類型。</summary>
        <returns>委派類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最後一個型別引數判斷委派的傳回型別。 如果沒有函式或動作夠大時，它會產生自訂的委派型別。  
  
 如同函式，最後一個引數是傳回的型別。 它可以設定為 System.Void，產生動作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">包含一到十七個 <see cref="T:System.Type" /> 物件的陣列，指定 <see langword="System.Func" /> 委派類型的型別引數。</param>
        <summary>建立 <see cref="P:System.Linq.Expressions.Expression.Type" /> 物件，這個物件代表具有特定型別引數的泛型 <c>System.Func</c> 委派類型。 最後一個型別引數指定已建立之委派的傳回型別。</summary>
        <returns><c>System.Func</c> 委派的類型，具有指定的型別引數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs` 必須包含至少一個與最多十七項目。  
  
 舉例來說，如果的項目`typeArgs`代表型別`T1…Tn`，產生<xref:System.Type>物件代表建構的委派型別`System.Func<T1,…,Tn>`在 C# 中或`System.Func(Of T1,…,Tn)`Visual Basic 中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeArgs" /> 包含少於一個或多過十七個項目。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArgs" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示 "go to" 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <summary>建立表示 "go to" 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Goto、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為指定的值，且包含在跳躍時傳遞至目標標籤的 Null 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立包含的運算式<xref:System.Linq.Expressions.GotoExpression>物件。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="value">將在跳躍時傳遞至關聯標籤的值。</param>
        <summary>建立表示 "go to" 陳述式的 <see cref="T:System.Linq.Expressions.GotoExpression" />。 可以指定跳躍時傳遞至標籤的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Goto、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 "go to" 陳述式。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Goto、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為指定的值、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 Null 值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="value">將在跳躍時傳遞至關聯標籤的值。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 "go to" 陳述式。 可以指定跳躍時傳遞至標籤的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Goto、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表「大於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表「大於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。 否則為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 大於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型是<xref:System.Boolean>。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立可比較兩個整數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「大於」運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="liftToNull"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表「大於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。 否則，兩者都是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 大於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「大於」運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表「大於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表「大於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。 否則為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 大於或等於 」 運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型是<xref:System.Boolean>。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立可比較兩個整數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「大於或等於」運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="liftToNull"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表「大於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。 否則，兩者都是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 大於或等於 」 運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的「大於或等於」運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</param>
        <param name="ifTrue">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，代表具有 <see langword="if" /> 陳述式的條件區塊。</summary>
        <returns><see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 屬性設定為指定的值。 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 屬性已設定為預設運算式，而這個方法傳回之結果 <see cref="T:System.Linq.Expressions.ConditionalExpression" /> 的類型為 <see cref="T:System.Void" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何建立運算式，代表條件式區塊。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</param>
        <param name="ifTrue">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</param>
        <param name="ifFalse">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，代表具有 <see langword="if" /> 和 <see langword="else" /> 陳述式的條件區塊。</summary>
        <returns><see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 屬性設定為指定的值。 這個方法所傳回之結果 <see cref="T:System.Linq.Expressions.ConditionalExpression" /> 的類型為 <see cref="T:System.Void" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何建立運算式，代表條件式區塊。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示運算式值遞增 1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要遞增的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示運算式值遞增 1。</summary>
        <returns>表示遞增後運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個運算式會正常運作，並不會變更物件傳遞給它的值。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立運算式，表示遞增作業。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要遞增的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表運算式遞增 1。</summary>
        <returns>表示遞增後運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個運算式會正常運作，並不會變更物件傳遞給它的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.InvocationExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />，代表要套用的委派或 Lambda 運算式。</param>
        <param name="arguments">包含 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 物件的 <see cref="T:System.Linq.Expressions.Expression" />，代表要套用委派或 Lambda 運算式的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.InvocationExpression" />，將委派或 Lambda 運算式套用至引數運算式清單。</summary>
        <returns><see cref="T:System.Linq.Expressions.InvocationExpression" />，可將指定的委派或 Lambda 運算式套用至所提供的引數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.InvocationExpression>代表委派所表示的傳回型別`expression`。型別。  
  
 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.InvocationExpression>是空的如果`arguments`是`null`。 否則，它包含相同的項目，做為`arguments`除外，其中有些<xref:System.Linq.Expressions.Expression>物件可能會*加上引號*。  
  
> [!NOTE]
>  只有當對應的參數的委派所表示項目會加上引號`expression`別的<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.InvocationExpression>，代表具有指定的引數的 lambda 運算式的引動過程。  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type 不代表委派類型或 <see cref="T:System.Linq.Expressions.Expression`1" />。  
  
-或- 
<paramref name="arguments" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="expression" /> 所表示之委派的對應參數類型。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="arguments" /> 包含的項目數與 <paramref name="expression" /> 所表示委派的參數清單不同。</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />，代表要套用的委派或 Lambda 運算式。</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，代表要套用委派或 Lambda 運算式的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.InvocationExpression" />，將委派或 Lambda 運算式套用至引數運算式清單。</summary>
        <returns><see cref="T:System.Linq.Expressions.InvocationExpression" />，可將指定的委派或 Lambda 運算式套用至所提供的引數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.InvocationExpression>代表委派所表示的傳回型別`expression`。型別。  
  
 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A>屬性產生<xref:System.Linq.Expressions.InvocationExpression>是空的如果`arguments`是`null`。 否則，它包含相同的項目，做為`arguments`除外，其中有些<xref:System.Linq.Expressions.Expression>物件可能會*加上引號*。  
  
> [!NOTE]
>  只有當對應的參數的委派所表示項目會加上引號`expression`別的<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`arguments`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.InvocationExpression>，代表具有指定的引數的 lambda 運算式的引動過程。  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type 不代表委派類型或 <see cref="T:System.Linq.Expressions.Expression`1" />。  
  
-或- 
<paramref name="arguments" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="expression" /> 所表示之委派的對應參數類型。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="arguments" /> 包含的項目數與 <paramref name="expression" /> 所表示委派的參數清單不同。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回運算式是否評估為 false。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要評估的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>傳回運算式是否評估為 false。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要評估的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>傳回運算式是否評估為 false。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回運算式是否評估為 true。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要評估的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>傳回運算式是否評估為 true。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要評估的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>傳回運算式是否評估為 true。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示標籤的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.LabelTarget" />，代表包含 void 類型但沒有名稱的標籤。</summary>
        <returns>新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立包含的運算式<xref:System.Linq.Expressions.LabelTarget>物件。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">這個 <see cref="T:System.Linq.Expressions.LabelTarget" /> 將與之產生關聯的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.LabelExpression" />，代表沒有預設值的標籤。</summary>
        <returns>沒有預設值的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">標籤名稱。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.LabelTarget" />，代表包含 void 類型和指定之名稱的標籤。</summary>
        <returns>新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">跳至標籤時所傳遞值的類型。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.LabelTarget" />，代表包含指定之類型的標籤。</summary>
        <returns>新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.LabelTarget>迴圈運算式中的物件。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">這個 <see cref="T:System.Linq.Expressions.LabelTarget" /> 將與之產生關聯的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</param>
        <param name="defaultValue">透過一般控制流程到達標籤時，這個 <see cref="T:System.Linq.Expressions.LabelExpression" /> 的值。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.LabelExpression" />，代表包含指定之預設值的標籤。</summary>
        <returns>包含指定之預設值的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">跳至標籤時所傳遞值的類型。</param>
        <param name="name">標籤名稱。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.LabelTarget" />，代表包含指定之類型和名稱的標籤。</summary>
        <returns>新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示 Lambda 運算式的運算式樹狀架構。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="parameters">用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合之 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件的陣列。</param>
        <summary>首先透過建構委派類型來建立 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `parameters`參數不能超過 16 個項目。  
  
 項目`parameters`必須是參考中的參數運算式等於`body`。  
  
 這個方法會建構其中一個適當的委派型別`System.Func`泛型委派。 接著，將委派類型的其中一個<xref:System.Linq.Expressions.ExpressionType.Lambda>factory 方法來建立<xref:System.Linq.Expressions.LambdaExpression>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="parameters" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" /> 包含十六個以上的項目。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters">陣列，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="name">Lambda 的名稱。 用於發出偵錯資訊。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Type" />，代表 Lambda 的委派簽章。</param>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 <see cref="T:System.Linq.Expressions.LambdaExpression" />。 它可用於在編譯階段不知道委派類型時。</summary>
        <returns>表示 Lambda 運算式的物件，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函式傳回的物件是型別<xref:System.Linq.Expressions.Expression%601>。 <xref:System.Linq.Expressions.LambdaExpression>類型用來代表傳回的物件，因為在編譯時期不知道 lambda 運算式的具象類型。  
  
 所表示之委派類型的參數數目`delegateType`必須等於長度`parameters`。  
  
 項目`parameters`必須是參考中的參數運算式等於`body`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>產生的物件屬性是否等於`delegateType`。 如果`parameters`已`null`，則<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A>產生之物件的屬性為空集合。  
  
   
  
## Examples  
 下列範例示範如何建立代表 lambda 運算式，將 1 加上傳遞的引數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="delegateType" /> 或 <paramref name="body" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="parameters" /> 中的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> 不表示委派類型。  
  
-或- 
 <paramref name="body" />.Type 表示的類型無法指派給 <paramref name="delegateType" /> 所表示之委派類型的傳回類型。  
  
-或- 
 <paramref name="parameters" /> 包含的項目數與 <paramref name="delegateType" /> 所表示之委派類型的參數清單不同。  
  
-或- 
<paramref name="parameters" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法從由 <paramref name="delegateType" /> 所表示之委派類型的對應參數類型指派。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Type" />，代表 Lambda 的委派簽章。</param>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="parameters">用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合之 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件的陣列。</param>
        <summary>首先透過建構委派類型來建立 <see cref="T:System.Linq.Expressions.LambdaExpression" />。 它可用於在編譯階段不知道委派類型時。</summary>
        <returns>表示 Lambda 運算式的物件，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函式傳回的物件是型別<xref:System.Linq.Expressions.Expression%601>。 <xref:System.Linq.Expressions.LambdaExpression>類型用來代表傳回的物件，因為在編譯時期不知道 lambda 運算式的具象類型。  
  
 所表示之委派類型的參數數目`delegateType`必須等於長度`parameters`。  
  
 項目`parameters`必須是參考中的參數運算式等於`body`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>產生的物件屬性是否等於`delegateType`。 如果`parameters`已`null`，則<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A>產生之物件的屬性為空集合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="delegateType" /> 或 <paramref name="body" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="parameters" /> 中的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> 不表示委派類型。  
  
-或- 
 <paramref name="body" />.Type 表示的類型無法指派給 <paramref name="delegateType" /> 所表示之委派類型的傳回類型。  
  
-或- 
 <paramref name="parameters" /> 包含的項目數與 <paramref name="delegateType" /> 所表示之委派類型的參數清單不同。  
  
-或- 
<paramref name="parameters" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法從由 <paramref name="delegateType" /> 所表示之委派類型的對應參數類型指派。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="name">Lambda 的名稱。 用於發出偵錯資訊。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="P:System.Linq.Expressions.Expression.Type" />，代表 Lambda 的委派簽章。</param>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="P:System.Linq.Expressions.Expression.Type" />，代表 Lambda 的委派簽章。</param>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters">陣列，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="P:System.Linq.Expressions.Expression.Type" />，代表 Lambda 的委派簽章。</param>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="name">Lambda 的名稱。 用於發出偵錯資訊。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="P:System.Linq.Expressions.Expression.Type" />，代表 Lambda 的委派簽章。</param>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="name">Lambda 的名稱。 用於發出偵錯資訊。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>首先透過建構委派類型來建立 LambdaExpression。</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 Lambda，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">委派類型。</typeparam>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 委派類型的參數數目`TDelegate`必須等於中的項目數`parameters`。  
  
 項目`parameters`必須是參考中的參數運算式等於`body`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生的物件，代表類型`TDelegate`。 如果`parameters`已`null`，則<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A>產生之物件的屬性為空集合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="parameters" /> 中的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="TDelegate" /> 不是委派類型。  
  
-或- 
 <paramref name="body" />.Type 所表示的類型無法指派給 <paramref name="TDelegate" /> 的傳回類型。  
  
-或- 
 <paramref name="parameters" /> 包含的項目數與 <paramref name="TDelegate" /> 的參數清單不同。  
  
-或- 
<paramref name="parameters" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法從 <paramref name="TDelegate" /> 之對應參數類型的類型指派。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">委派類型。</typeparam>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="parameters">用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合之 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 委派類型的參數數目`TDelegate`必須等於中的項目數`parameters`。  
  
 項目`parameters`必須是參考中的參數運算式等於`body`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生的物件，代表類型`TDelegate`。 如果`parameters`已`null`，則<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A>產生之物件的屬性為空集合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="parameters" /> 中的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="TDelegate" /> 不是委派類型。  
  
-或- 
 <paramref name="body" />.Type 所表示的類型無法指派給 <paramref name="TDelegate" /> 的傳回類型。  
  
-或- 
 <paramref name="parameters" /> 包含的項目數與 <paramref name="TDelegate" /> 的參數清單不同。  
  
-或- 
<paramref name="parameters" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法從 <paramref name="TDelegate" /> 之對應參數類型的類型指派。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">委派類型。</typeparam>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">委派類型。</typeparam>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters">陣列，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">委派類型。</typeparam>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="name">Lambda 的名稱。 用於產生偵錯資訊。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">委派類型。</typeparam>
        <param name="body">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</param>
        <param name="name">Lambda 的名稱。 用於產生偵錯資訊。</param>
        <param name="tailCall"><see cref="T:System.Boolean" />，其代表編譯所建立的運算式時，是否會套用 tail 呼叫最佳化。</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.Expression`1" />，其中委派類型在編譯階段為已知。</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元左移 (Left-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示位元左移 (Left-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`代表左移位運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。類型為整數類資料類型 (其中<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>，或對應 null 的型別) 和`right`。型別是<xref:System.Int32>，則實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義 left-shift 運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義 left-shift 運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type. 定義 Left-shift 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立表示位元左移 (Left-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`代表左移位運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。類型為整數類資料類型 (其中<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>，或對應 null 的型別) 和`right`。型別是<xref:System.Int32>，則實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義 left-shift 運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義 left-shift 運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" /> 且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Left-shift 運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元左移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示位元左移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立表示位元左移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立表示位元左移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表「小於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表「小於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。 否則為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 作業的實作方法是選擇根據下列規則：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 小於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型是<xref:System.Boolean>。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立可比較兩個整數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「小於」運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="liftToNull"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表「小於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。 否則，兩者都是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 小於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的「小於」運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表「小於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表「小於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。 否則為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 小於或等於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型是<xref:System.Boolean>。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立可比較兩個整數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「小於或等於」運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="liftToNull"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表「小於或等於」數值比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。 否則，兩者都是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`代表 「 小於或等於 」 運算子，會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義「小於或等於」運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberListBinding" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" />，表示要將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為與之相等的欄位或屬性。</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberListBinding" />，其中成員是欄位或屬性。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" /> 不代表欄位或屬性。  
  
-或- 
<paramref name="member" /> 所表示之欄位或屬性的 <see cref="P:System.Reflection.FieldInfo.FieldType" /> 或 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 不會實作 <see cref="T:System.Collections.IEnumerable" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" />，表示要將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為與之相等的欄位或屬性。</param>
        <param name="initializers">用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合之 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberListBinding" />，其中成員是欄位或屬性。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" /> 不代表欄位或屬性。  
  
-或- 
<paramref name="member" /> 所表示之欄位或屬性的 <see cref="P:System.Reflection.FieldInfo.FieldType" /> 或 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 不會實作 <see cref="T:System.Collections.IEnumerable" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">代表屬性存取子方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 物件。</param>
        <summary>根據指定的屬性存取子方法建立 <see cref="T:System.Linq.Expressions.MemberListBinding" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.MemberInfo" />，表示在 <paramref name="propertyAccessor" /> 中存取的屬性，<see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 則會填入 <paramref name="initializers" /> 的項目。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。  
  
-或- 
屬性 (由 <paramref name="propertyAccessor" /> 存取表示的方法) 的 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 不會實作 <see cref="T:System.Collections.IEnumerable" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">代表屬性存取子方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="initializers">用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合之 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 物件的陣列。</param>
        <summary>根據指定的屬性存取子方法建立 <see cref="T:System.Linq.Expressions.MemberListBinding" /> 物件。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.MemberInfo" />，表示在 <paramref name="propertyAccessor" /> 中存取的屬性，<see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 則會填入 <paramref name="initializers" /> 的項目。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。  
  
-或- 
屬性 (由 <paramref name="propertyAccessor" /> 存取表示的方法) 的 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 不會實作 <see cref="T:System.Collections.IEnumerable" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，它使用指定的 <see cref="T:System.Linq.Expressions.ElementInit" /> 物件初始化集合。</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，且 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.ListInitExpression>，表示具有兩個索引鍵 / 值組的新字典執行個體初始化。  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其使用名為 "Add" 的方法將項目加入集合。</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，而 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。  
  
 若要使用的這個多載<xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>， `newExpression`。型別或其基底類型必須宣告名為"Add"（不區分大小寫） 採用一個引數的單一方法。 引數類型必須是可指派所表示的類型從<xref:System.Linq.Expressions.Expression.Type%2A>屬性的第一個元素`initializers`。  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>屬性傳回之<xref:System.Linq.Expressions.ListInitExpression>包含一個項目型別的<xref:System.Linq.Expressions.ElementInit>每個項目`initializers`。 <xref:System.Linq.Expressions.ElementInit.Arguments%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>是單一集合，其中包含的對應項目`initializers`。 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>代表探索到的 add 方法`newExpression`。型別或其基底類型。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</exception>
        <exception cref="T:System.InvalidOperationException">未在 <paramref name="newExpression" />.Type 或其基底型別中宣告名為 "Add" (不區分大小寫) 的執行個體。  
  
-或- 
<paramref name="newExpression" />.Type 或其基底型別中的 add 方法不是只接受一個引數。  
  
-或- 
<paramref name="initializers" />的第一個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所代表的型別，無法指派給 <paramref name="newExpression" />.Type 或其基底型別上的 add 方法的引數類型。  
  
-或- 
多個名為 "Add" (不區分大小寫) 的引數相容方法存在於 <paramref name="newExpression" /> .Type 和/或其基底型別。</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</param>
        <param name="initializers">用以填入 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合之 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，它使用指定的 <see cref="T:System.Linq.Expressions.ElementInit" /> 物件初始化集合。</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，且 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.ListInitExpression>，表示具有兩個索引鍵 / 值組的新字典執行個體初始化。  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</param>
        <param name="initializers">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其使用名為 "Add" 的方法將項目加入集合。</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，而 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。  
  
 若要使用的這個多載<xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>， `newExpression`。型別或其基底類型必須宣告名為"Add"（不區分大小寫） 採用一個引數的單一方法。 引數類型必須是可指派所表示的類型從<xref:System.Linq.Expressions.Expression.Type%2A>屬性的第一個元素`initializers`。  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>屬性傳回之<xref:System.Linq.Expressions.ListInitExpression>包含一個項目型別的<xref:System.Linq.Expressions.ElementInit>每個項目`initializers`。 <xref:System.Linq.Expressions.ElementInit.Arguments%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>是單一集合，其中包含的對應項目`initializers`。 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>代表探索到的 add 方法`newExpression`。型別或其基底類型。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。</exception>
        <exception cref="T:System.InvalidOperationException">未在 <paramref name="newExpression" />.Type 或其基底型別中宣告名為 "Add" (不區分大小寫) 的執行個體。  
  
-或- 
<paramref name="newExpression" />.Type 或其基底型別中的 add 方法不是只接受一個引數。  
  
-或- 
<paramref name="initializers" />的第一個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所代表的型別，無法指派給 <paramref name="newExpression" />.Type 或其基底型別上的 add 方法的引數類型。  
  
-或- 
多個名為 "Add" (不區分大小寫) 的引數相容方法存在於 <paramref name="newExpression" /> .Type 和/或其基底型別。</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</param>
        <param name="addMethod"><see cref="T:System.Reflection.MethodInfo" />，代表名為 "Add" (區分大小寫) 的執行個體方法，可將項目加入集合。</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其使用指定的方法將項目加入集合。</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，而 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。  
  
 如果`addMethod`已`null`， `newExpression`。型別或其基底類型必須宣告名為"Add"（不區分大小寫） 採用一個引數的單一方法。 如果`addMethod`不是`null`，它必須表示有一個參數的執行個體方法名為"Add"（不區分大小寫）。 所表示的型別<xref:System.Linq.Expressions.Expression.Type%2A>的每個項目的屬性`initializers`必須能夠指派給 add 方法的引數類型。  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>屬性傳回之<xref:System.Linq.Expressions.ListInitExpression>包含一個項目型別的<xref:System.Linq.Expressions.ElementInit>每個項目`initializers`。 <xref:System.Linq.Expressions.ElementInit.Arguments%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>是單一集合，其中包含的對應項目`initializers`。 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>等於`addMethod`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。  
  
-或- 
 <paramref name="addMethod" /> 不是 <see langword="null" />，它不表示名為 "Add" (區分大小寫) 的執行個體方法，這個方法剛好只採用一個引數。  
  
-或- 
 <paramref name="addMethod" /> 不是 <see langword="null" />，且 <paramref name="initializers" /> 之一或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性表示的類型無法指派給 <paramref name="addMethod" /> 所表示之方法的引數類型。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="addMethod" /> 是 <see langword="null" />，且 <paramref name="newExpression" />.Type 或其基底類型上沒有採用一個類型相容引數之名為 "Add" 的執行個體方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</param>
        <param name="addMethod"><see cref="T:System.Reflection.MethodInfo" />，代表採用一個引數的執行個體方法，可將項目加入集合。</param>
        <param name="initializers">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其使用指定的方法將項目加入集合。</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，而 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>的屬性`newExpression`必須代表可實作型別<xref:System.Collections.IEnumerable>。  
  
 如果`addMethod`已`null`， `newExpression`。型別或其基底類型必須宣告名為"Add"（不區分大小寫） 採用一個引數的單一方法。 如果`addMethod`不是`null`，它必須表示有一個參數的執行個體方法名為"Add"（不區分大小寫）。 所表示的型別<xref:System.Linq.Expressions.Expression.Type%2A>的每個項目的屬性`initializers`必須能夠指派給 add 方法的引數類型。  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>屬性傳回之<xref:System.Linq.Expressions.ListInitExpression>包含一個項目型別的<xref:System.Linq.Expressions.ElementInit>每個項目`initializers`。 <xref:System.Linq.Expressions.ElementInit.Arguments%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>是單一集合，其中包含的對應項目`initializers`。 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A>每個元素的屬性<xref:System.Linq.Expressions.ListInitExpression.Initializers%2A>等於`addMethod`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.ListInitExpression>等於`newExpression`。型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type 未實作 <see cref="T:System.Collections.IEnumerable" />。  
  
-或- 
 <paramref name="addMethod" /> 不是 <see langword="null" />，它不表示名為 "Add" (區分大小寫) 的執行個體方法，這個方法剛好只採用一個引數。  
  
-或- 
 <paramref name="addMethod" /> 不是 <see langword="null" />，且 <paramref name="initializers" /> 之一或多個項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性表示的類型無法指派給 <paramref name="addMethod" /> 所表示之方法的引數類型。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="addMethod" /> 是 <see langword="null" />，且 <paramref name="newExpression" />.Type 或其基底類型上沒有採用一個類型相容引數之名為 "Add" 的執行個體方法。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.LoopExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">迴圈的主體。</param>
        <summary>建立包含指定之主體的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">迴圈的主體。</param>
        <param name="break">迴圈主體所使用的 break 目標。</param>
        <summary>建立包含指定之主體和 break 目標的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立包含區塊運算式<xref:System.Linq.Expressions.LoopExpression>物件。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">迴圈的主體。</param>
        <param name="break">迴圈主體所使用的 break 目標。</param>
        <param name="continue">迴圈主體所使用的 continue 目標。</param>
        <summary>建立包含指定之主體的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定二進位運算的類型。</param>
        <param name="left">代表左運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="right">代表右運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，指定左運算元和右運算元。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，由呼叫適當的 Factory 方法所產生。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType`參數會決定其<xref:System.Linq.Expressions.BinaryExpression>這個方法會呼叫 factory 方法。 例如，如果`binaryType`已<xref:System.Linq.Expressions.ExpressionType.Subtract>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Subtract%2A>。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29>方法用來建立<xref:System.Linq.Expressions.BinaryExpression>表示從另一個數字的減法。  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" /> 未對應到二進位運算式節點。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定二進位運算的類型。</param>
        <param name="left">代表左運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="right">代表右運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="liftToNull"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" />，可指定實作的方法。</param>
        <summary>透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，指定左運算元、右運算元和實作方法。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，由呼叫適當的 Factory 方法所產生。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType`參數會決定其<xref:System.Linq.Expressions.BinaryExpression>factory 方法會呼叫這個方法。 例如，如果`binaryType`已<xref:System.Linq.Expressions.ExpressionType.Subtract>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Subtract%2A>。 `liftToNull`和`method`如果適當的 factory 方法並沒有對應的參數，則會忽略參數。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" /> 未對應到二進位運算式節點。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定二進位運算的類型。</param>
        <param name="left">代表左運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="right">代表右運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="liftToNull"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" />，可指定實作的方法。</param>
        <param name="conversion">代表類型轉換函式的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。 只有當 <paramref name="binaryType" /> 為 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> 或複合指派時，才會使用此參數。</param>
        <summary>透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，指定左運算元、右運算元、實作方法和類型轉換函式。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，由呼叫適當的 Factory 方法所產生。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType`參數會決定其<xref:System.Linq.Expressions.BinaryExpression>factory 方法會呼叫這個方法。 例如，如果`binaryType`已<xref:System.Linq.Expressions.ExpressionType.Subtract>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Subtract%2A>。 `liftToNull`，`method`和`conversion`如果適當的 factory 方法並沒有對應的參數，則會忽略參數。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" /> 未對應到二進位運算式節點。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="P:System.Linq.Expressions.Expression.Type" /> 將處理之 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</param>
        <param name="variable"><see cref="T:System.Linq.Expressions.ParameterExpression" />，代表這個處理常式所攔截 <see cref="T:System.Exception" /> 物件的參考。</param>
        <param name="body">catch 陳述式的主體。</param>
        <param name="filter"><see cref="T:System.Exception" /> 篩選條件的主體。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.CatchBlock" />，代表含指定之項目的 catch 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` 必須為非 null，而且符合類型`variable`（如果它提供）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表動態運算的 <see cref="T:System.Linq.Expressions.DynamicExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</param>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="arguments">動態作業的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</param>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="arg0">動態運算的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和一個引數所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</param>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="arguments">動態作業的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</param>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="arg0">動態作業的第一個引數。</param>
        <param name="arg1">傳遞至動態作業的第二個引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和兩個引數所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</param>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="arg0">動態作業的第一個引數。</param>
        <param name="arg1">傳遞至動態作業的第二個引數。</param>
        <param name="arg2">傳遞至動態作業的第三個引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和三個引數所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 所使用的委派類型。</param>
        <param name="binder">動態作業的執行階段繫結器。</param>
        <param name="arg0">動態作業的第一個引數。</param>
        <param name="arg1">傳遞至動態作業的第二個引數。</param>
        <param name="arg2">傳遞至動態作業的第三個引數。</param>
        <param name="arg3">傳遞至動態運算的第四個引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.DynamicExpression" />，代表指定之 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和四個引數所繫結的動態運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等於 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，且 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind"><see cref="T:System.Linq.Expressions.GotoExpressionKind" /> 的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="value">將在跳躍時傳遞至關聯標籤的值。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，代表指定之 <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> 的跳躍點。 也可以指定在跳躍時傳遞至標籤的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 <paramref name="kind" />、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">屬性所屬的物件。 如果屬性為 <see langword="static" /> (在 Visual Basic 中為 <see langword="shared" />)，則應該是 Null。</param>
        <param name="indexer"><see cref="T:System.Linq.Expressions.Expression" />，代表要編製索引的屬性。</param>
        <param name="arguments"><c>IEnumerable&lt;Expression&gt;</c> (在 Visual Basic 中為 <c>IEnumerable (Of Expression)</c>)，包含將用於對屬性進行索引的引數。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.IndexExpression" />，代表存取物件中的索引屬性。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />，代表成員所屬的物件。 如果是靜態成員，可以是 Null。</param>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" />，說明要存取的欄位或屬性。</param>
        <summary>建立代表存取欄位或屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" />，由呼叫適當的 Factory 方法所產生。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可用來建立<xref:System.Linq.Expressions.MemberExpression>，代表存取欄位或屬性，根據類型`member`。 如果`member`屬於型別<xref:System.Reflection.FieldInfo>，這個方法會呼叫<xref:System.Linq.Expressions.Expression.Field%2A>建立<xref:System.Linq.Expressions.MemberExpression>。 如果`member`屬於型別<xref:System.Reflection.PropertyInfo>，這個方法會呼叫<xref:System.Linq.Expressions.Expression.Property%2A>建立<xref:System.Linq.Expressions.MemberExpression>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" /> 不代表欄位或屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">try 運算式的結果類型。 如果為 Null，則 bodh 和所有處理常式必須具有相同的類型。</param>
        <param name="body">try 區塊的主體。</param>
        <param name="finally">finally 區塊的主體。 如果 try 區塊沒有相關聯的 finally 區塊，則傳遞 Null。</param>
        <param name="fault">fault 區塊的主體。 如果 try 區塊沒有相關聯的 fault 區塊，則傳遞 Null。</param>
        <param name="handlers"><see cref="T:System.Linq.Expressions.CatchBlock" /> 的集合，代表要與 try 區塊產生關聯的 catch 陳述式。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含指定之項目的 try 區塊。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>透過呼叫適當的 Factory 方法來建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定一元運算的類型。</param>
        <param name="operand">代表運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="type"><see cref="T:System.Type" />，指定轉換後的類型 (如果不適用，則傳遞 <see langword="null" />)。</param>
        <summary>指定運算元並呼叫適當的 Factory 方法，建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，由呼叫適當的 Factory 方法所產生。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `unaryType`參數會決定其<xref:System.Linq.Expressions.UnaryExpression>這個方法會呼叫 factory 方法。 例如，如果`unaryType`等於<xref:System.Linq.Expressions.ExpressionType.Convert>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Convert%2A>。 `type`如果不適用於呼叫 factory 方法，則會忽略參數。  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="operand" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="unaryType" /> 未對應到一元運算式節點。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType"><see cref="T:System.Linq.Expressions.ExpressionType" />，指定一元運算的類型。</param>
        <param name="operand">代表運算元的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="type"><see cref="T:System.Type" />，指定轉換後的類型 (如果不適用，則傳遞 <see langword="null" />)。</param>
        <param name="method">代表實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>指定運算元和實作方法並透過呼叫適當的 Fatory 方法，建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，由呼叫適當的 Factory 方法所產生。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `unaryType`參數會決定其<xref:System.Linq.Expressions.UnaryExpression>這個方法會呼叫 factory 方法。 例如，如果`unaryType`等於<xref:System.Linq.Expressions.ExpressionType.Convert>，這個方法會叫用<xref:System.Linq.Expressions.Expression.Convert%2A>。 `type`和`method`如果它們並不適用於呼叫 factory 方法，則會忽略參數。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="operand" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="unaryType" /> 未對應到一元運算式節點。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化成員的成員。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">要將 <see cref="T:System.Reflection.MemberInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</param>
        <param name="bindings"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化欄位或屬性的成員。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member`參數必須代表欄位或屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" /> 不代表欄位或屬性。  
  
-或- 
<paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="member" /> 所表示之欄位或屬性類型的成員。</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">要將 <see cref="T:System.Reflection.MemberInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</param>
        <param name="bindings">用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合之 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化欄位或屬性的成員。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member`參數必須代表欄位或屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" /> 不代表欄位或屬性。  
  
-或- 
<paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="member" /> 所表示之欄位或屬性類型的成員。</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" />，代表屬性存取子方法。</param>
        <param name="bindings"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化成員的成員，該成員可透過使用屬性存取子方法來存取。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，表示在 <paramref name="propertyAccessor" /> 中存取的屬性，<see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 屬性則設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。  
  
-或- 
<paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="propertyAccessor" /> 所表示之方法存取的屬性類型成員。</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" />，代表屬性存取子方法。</param>
        <param name="bindings">用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合之 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，表示遞迴初始化成員的成員，該成員可透過使用屬性存取子方法來存取。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 屬性等於 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，並將 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，表示在 <paramref name="propertyAccessor" /> 中存取的屬性，<see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 屬性則設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" /> 不代表屬性存取子方法。  
  
-或- 
<paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="propertyAccessor" /> 所表示之方法存取的屬性類型成員。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>表示建立新物件並初始化物件屬性的運算式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />。</param>
        <param name="bindings"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 物件。</param>
        <summary>表示建立新物件並初始化物件屬性的運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" />，且 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberInitExpression>等於<xref:System.Linq.Expressions.Expression.Type%2A>屬性`newExpression`。  
  
   
  
## Examples  
 下列範例示範建立新的物件，並初始化物件屬性的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="newExpression" />.Type 所表示之類型的成員。</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">要將 <see cref="T:System.Linq.Expressions.NewExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />。</param>
        <param name="bindings">用以填入 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合之 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberInitExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" />，且 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberInitExpression>等於<xref:System.Linq.Expressions.Expression.Type%2A>屬性`newExpression`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29>方法用來建立<xref:System.Linq.Expressions.MemberInitExpression>，表示新物件的兩個成員初始化。  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 或 <paramref name="bindings" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bindings" /> 之項目的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 屬性不表示 <paramref name="newExpression" />.Type 所表示之類型的成員。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表算術餘數運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表算術餘數運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載模數運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的模數運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的模數運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義餘數運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表算術餘數運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 作業的實作方法是選擇根據下列規則：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載模數運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的模數運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的模數運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，且未針對 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義模數運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示餘數指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示餘數指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立表示餘數指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立表示餘數指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術乘法運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術乘法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載乘法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的乘法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的乘法運算子的結果類型。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立將兩個值相乘的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Multiplication 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術乘法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載乘法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的乘法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的乘法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Multiplication 運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的乘法指派運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的乘法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的乘法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的乘法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的乘法指派運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的乘法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的乘法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的乘法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術乘法運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術乘法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載乘法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的乘法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的乘法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Multiplication 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術乘法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載乘法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的乘法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的乘法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Multiplication 運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表算術負運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <summary>建立代表算術負運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Negate" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是 false。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`expression`。類型是使用者定義的類型定義一元減號運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則，如果`expression`。類型為數值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 實作的方法是否`null`，節點的類型是`expression`。型別。 如果`expression`。類型是不可為 null，則不會消除節點。 否則，則會消除節點。  
  
   
  
## Examples  
 下列範例示範如何建立代表算術負運算的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="expression" />.Type 定義一元減號運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</param>
        <summary>建立代表算術負運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Negate" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是 false。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數，方法是在節點的實作方法。  
  
-   如果`expression`。類型是使用者定義的類型定義一元減號運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則，如果`expression`。類型為數值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 實作的方法是否`null`，節點的類型是`expression`。型別。 如果`expression`。類型是不可為 null，則不會消除節點。 否則，則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="expression" />.Type 定義一元減號運算子。  
  
-或- 
 <paramref name="expression" />.Type (如果它是可為 Null 的實質類型，則為其對應之不可為 Null 的類型) 無法指派給 <paramref name="method" /> 所代表之方法的引數類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其代表包含溢位檢查的算術負運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其代表包含溢位檢查的算術負運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是 false。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`expression`。類型是使用者定義的類型定義一元減號運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則，如果`expression`。類型為數值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 實作的方法是否`null`，節點的類型是`expression`。型別。 如果`expression`。類型是不可為 null，則不會消除節點。 否則，則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="expression" />.Type 定義一元減號運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其代表包含溢位檢查的算術負運算。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是 false。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數，方法是在節點的實作方法。  
  
-   如果`expression`。類型是使用者定義的類型定義一元減號運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則，如果`expression`。類型為數值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 實作的方法是否`null`，節點的類型是`expression`。型別。 如果`expression`。類型是不可為 null，則不會消除節點。 否則，則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="expression" />.Type 定義一元減號運算子。  
  
-或- 
 <paramref name="expression" />.Type (如果它是可為 Null 的實質類型，則為其對應之不可為 Null 的類型) 無法指派給 <paramref name="method" /> 所代表之方法的引數類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewExpression" />，代表呼叫不採用任何引數的指定建構函式。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，而 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.NewExpression.Arguments%2A>並<xref:System.Linq.Expressions.NewExpression.Members%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>是空的集合。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性表示建構函式所代表的宣告型別`constructor`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">由 <paramref name="constructor" /> 表示的建構函式，擁有至少一個參數。</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" />，具有不採用任何引數的建構函式。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewExpression" />，代表呼叫指定類型的無參數建構函式。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 屬性設定為 <see cref="T:System.Reflection.ConstructorInfo" />，代表不含指定類型之參數的建構函式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type`參數必須代表不含參數的建構函式的類型。  
  
 <xref:System.Linq.Expressions.NewExpression.Arguments%2A>並<xref:System.Linq.Expressions.NewExpression.Members%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>是空的集合。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性等於`type`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.New%28System.Type%29>方法用來建立<xref:System.Linq.Expressions.NewExpression>，代表不含參數的建構函式建構一個字典物件的新執行個體。  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 表示的類型沒有無參數建構函式。</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewExpression" />，其代表以指定之引數呼叫指定的建構函式。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments`參數必須包含相同數目的元素所代表之建構函式的參數數目為`constructor`。 如果`arguments`是`null`，它是空的而<xref:System.Linq.Expressions.NewExpression.Arguments%2A>屬性所產生的<xref:System.Linq.Expressions.NewExpression>為空集合。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>代表所表示的建構函式的宣告型別`constructor`。 <xref:System.Linq.Expressions.NewExpression.Members%2A>屬性為空集合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="arguments" /> 的項目是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> 參數包含的項目數目與 <paramref name="constructor" /> 所表示之建構函式的參數數目不同。  
  
-或- 
<paramref name="arguments" /> 項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="constructor" /> 所代表之建構函式的對應參數類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</param>
        <param name="arguments">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewExpression" />，其代表以指定之引數呼叫指定的建構函式。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments`參數必須包含相同數目的元素所代表之建構函式的參數數目為`constructor`。 如果`arguments`是`null`，它是空的而<xref:System.Linq.Expressions.NewExpression.Arguments%2A>屬性所產生的<xref:System.Linq.Expressions.NewExpression>為空集合。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>代表所表示的建構函式的宣告型別`constructor`。 <xref:System.Linq.Expressions.NewExpression.Members%2A>屬性為空集合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="arguments" /> 的項目是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> 的長度不符合 <paramref name="constructor" /> 代表之建構函式的參數數目。  
  
-或- 
<paramref name="arguments" /> 項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="constructor" /> 所代表之建構函式的對應參數類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 物件。</param>
        <param name="members"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Reflection.MemberInfo" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewExpression" />，其代表以指定之引數呼叫指定的建構函式。 已指定可存取由建構函式初始化欄位的成員。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />、<see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments`參數必須包含相同數目的元素所代表之建構函式的參數數目為`constructor`。 如果`arguments`是`null`，它是空的而<xref:System.Linq.Expressions.NewExpression.Arguments%2A>屬性所產生的<xref:System.Linq.Expressions.NewExpression>為空集合。  
  
 如果`members`已`null`，則<xref:System.Linq.Expressions.NewExpression.Members%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>為空集合。 如果`members`不是`null`，它必須有相同數目的項目`arguments`，且每個項目不得為`null`。 每個項目的`members`必須是<xref:System.Reflection.PropertyInfo>，<xref:System.Reflection.FieldInfo>或<xref:System.Reflection.MethodInfo>代表上所代表之建構函式宣告的型別執行個體成員`constructor`。 如果它代表一個屬性，該屬性必須有`get`存取子。 對應項目`arguments`每個項目`members`必須<xref:System.Linq.Expressions.Expression.Type%2A>代表指派給成員的型別類型的屬性，`members`項目代表。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>表示建構函式的宣告型別，`constructor`表示。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="arguments" /> 的項目是 <see langword="null" />。  
  
-或- 
<paramref name="members" /> 的項目是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> 參數包含的項目數目與 <paramref name="constructor" /> 所表示之建構函式的參數數目不同。  
  
-或- 
<paramref name="arguments" /> 項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="constructor" /> 所代表之建構函式的對應參數類型。  
  
-或- 
<paramref name="members" /> 參數的項目數與 <paramref name="arguments" /> 的不同。  
  
-或- 
<paramref name="arguments" /> 的項目有 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性，它表示無法指派給 <paramref name="members" /> 其對應項目所表示成員類型的類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">要將 <see cref="T:System.Reflection.ConstructorInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 物件。</param>
        <param name="members">用以填入 <see cref="T:System.Reflection.MemberInfo" /> 集合之 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewExpression" />，其代表以指定之引數呼叫指定的建構函式。 已指定可存取由建構函式初始化欄位的成員為陣列。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，且 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />、<see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments`參數必須包含相同數目的元素所代表之建構函式的參數數目為`constructor`。 如果`arguments`是`null`，它是空的而<xref:System.Linq.Expressions.NewExpression.Arguments%2A>屬性所產生的<xref:System.Linq.Expressions.NewExpression>為空集合。  
  
 如果`members`已`null`，則<xref:System.Linq.Expressions.NewExpression.Members%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>為空集合。 如果`members`不是`null`，它必須有相同數目的項目`arguments`，且每個項目不得為`null`。 每個項目的`members`必須是<xref:System.Reflection.PropertyInfo>，<xref:System.Reflection.FieldInfo>或<xref:System.Reflection.MethodInfo>代表上所代表之建構函式宣告的型別執行個體成員`constructor`。 如果它代表一個屬性，此屬性必須能夠擷取相關聯的欄位的值。 對應項目`arguments`每個項目`members`必須<xref:System.Linq.Expressions.Expression.Type%2A>代表指派給成員的型別類型的屬性，`members`項目代表。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewExpression>表示建構函式的宣告型別，`constructor`表示。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="arguments" /> 的項目是 <see langword="null" />。  
  
-或- 
<paramref name="members" /> 的項目是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> 參數包含的項目數目與 <paramref name="constructor" /> 所表示之建構函式的參數數目不同。  
  
-或- 
<paramref name="arguments" /> 項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性無法指派給 <paramref name="constructor" /> 所代表之建構函式的對應參數類型。  
  
-或- 
<paramref name="members" /> 參數的項目數與 <paramref name="arguments" /> 的不同。  
  
-或- 
<paramref name="arguments" /> 的項目有 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性，它表示無法指派給 <paramref name="members" /> 其對應項目所表示成員類型的類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立具有指定之陣序的陣列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" />，代表陣列的項目類型。</param>
        <param name="bounds"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立具有指定之陣序的陣列。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />，而 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewArrayExpression>代表其陣序規範是相等的長度的陣列類型`bounds`其項目類型，而且`type`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>的每個項目的屬性`bounds`必須代表整數型別。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.NewArrayBounds%2A>方法來建立運算式樹狀結構，表示建立字串陣列，並使其擁有次序為 2。  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 或 <paramref name="bounds" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="bounds" /> 的項目是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bounds" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不表示整數類資料類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" />，代表陣列的項目類型。</param>
        <param name="bounds">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立具有指定之陣序的陣列。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />，而 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewArrayExpression>代表其陣序規範是相等的長度的陣列類型`bounds`其項目類型，而且`type`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>的每個項目的屬性`bounds`必須代表整數型別。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.NewArrayBounds%2A>方法來建立運算式樹狀結構，表示建立字串陣列，並使其擁有次序為 2。  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 或 <paramref name="bounds" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="bounds" /> 的項目是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bounds" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性不表示整數類資料類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立一維陣列，並從項目清單將此陣列初始化。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" />，代表陣列的項目類型。</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 物件。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立一維陣列，並從項目清單將此陣列初始化。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />，而 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>每個元素的屬性`initializers`必須代表指派給所表示之類型的型別`type`中，可能之後*加上引號*。  
  
> [!NOTE]
>  只有當項目會加上引號`type`是<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`initializers`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewArrayExpression>代表陣列類型，其次序為 1，其項目類型為`type`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.NewArrayInit%2A>方法用來建立運算式樹狀架構，其代表建立一維字串陣列，初始化字串運算式的清單。  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的項目是 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="initializers" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所表示的類型無法指派給 <paramref name="type" /> 所表示的類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" />，代表陣列的項目類型。</param>
        <param name="initializers">用以填入 <see cref="T:System.Linq.Expressions.Expression" /> 集合之 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其代表建立一維陣列，並從項目清單將此陣列初始化。</summary>
        <returns><see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />，而 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>每個元素的屬性`initializers`必須代表指派給所表示之類型的型別`type`中，可能之後*加上引號*。  
  
> [!NOTE]
>  只有當項目會加上引號`type`是<xref:System.Linq.Expressions.Expression>。 表示項目包裝在加註引號於<xref:System.Linq.Expressions.ExpressionType.Quote>節點。 產生的節點是<xref:System.Linq.Expressions.UnaryExpression>其<xref:System.Linq.Expressions.UnaryExpression.Operand%2A>屬性是項目`initializers`。  
  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.NewArrayExpression>代表陣列類型，其次序為 1，其項目類型為`type`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.NewArrayInit%2A>方法用來建立運算式樹狀架構，其代表建立一維字串陣列，初始化字串運算式的清單。  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 或 <paramref name="initializers" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="initializers" /> 的項目是 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="initializers" /> 之項目的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性所表示的類型無法指派給 <paramref name="type" /> 類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 <see cref="T:System.Linq.Expressions.Expression" /> 的節點類型。</summary>
        <value>其中一個 <see cref="T:System.Linq.Expressions.ExpressionType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.NodeType%2A>屬性會提供更具特製化的描述<xref:System.Linq.Expressions.Expression>比只是其衍生的類型。 比方說，<xref:System.Linq.Expressions.BinaryExpression>可用來代表許多不同類型的二進位運算式，例如除法運算或 「 大於 」 作業。 <xref:System.Linq.Expressions.Expression.NodeType%2A>屬性會描述這些二進位運算式，做為<xref:System.Linq.Expressions.ExpressionType.Divide>和<xref:System.Linq.Expressions.ExpressionType.GreaterThan>分別。  
  
 運算式的靜態的 CLR 型別，<xref:System.Linq.Expressions.Expression>物件表示由<xref:System.Linq.Expressions.Expression.Type%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元補數運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <summary>建立表示位元補數運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Not" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`expression`。類型是使用者定義的類型定義一元 not 運算子<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則，如果`expression`。類型是數值或布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `expression`.類型為 null 的實值類型，而且對應的非 null 的型別等於實作方法的引數類型。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 實作的方法是否`null`，節點的類型是`expression`。型別。 如果`expression`。類型是不可為 null，則不會消除節點。 否則，則會消除節點。  
  
   
  
## Examples  
 下列範例示範如何建立運算式，表示 邏輯 NOT 運算。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="expression" />.Type 定義一元 NOT 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</param>
        <summary>建立表示位元補數運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。 實作的方法可加以指定。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Not" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數，方法是在節點的實作方法。  
  
-   如果`expression`。類型是使用者定義的類型定義一元 not 運算子<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則，如果`expression`。類型為數值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 實作的方法是否`null`，節點的類型是`expression`。型別。 如果`expression`。類型是不可為 null，則不會消除節點。 否則，則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="expression" />.Type 定義一元 NOT 運算子。  
  
-或- 
 <paramref name="expression" />.Type (如果它是可為 Null 的實質類型，則為其對應之不可為 Null 的類型) 無法指派給 <paramref name="method" /> 所代表之方法的引數類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表不相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表不相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`。 否則為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 屬性一律為 `false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載不等比較運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點和節點的類型是<xref:System.Boolean>:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型是<xref:System.Boolean>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義不等比較運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="liftToNull"><see langword="true" /> 表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="true" />，<see langword="false" /> 則表示將 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 設定為 <see langword="false" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表不相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>屬性是`true`並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性等於`liftToNull`。 否則，兩者都是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載不等比較運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點。此外，節點的型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`:  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是<xref:System.Boolean>。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是<xref:System.Boolean>。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點型別可為 null<xref:System.Boolean>如果`liftToNull`是`true`或是<xref:System.Boolean>如果`liftToNull`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義不等比較運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回表示 1 補數的運算式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>傳回表示 1 補數的運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>傳回表示 1 補數的運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="OR" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="OR" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Or" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`OR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是結果型別預先定義之位元`OR`運算子。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至結果型別預先定義之位元`OR`運算子。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立代表邏輯 OR 運算的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義位元 <see langword="OR" /> 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立表示位元 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 運算的 <see langword="OR" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Or" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`OR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。類型為整數或布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是結果型別預先定義之位元`OR`運算子。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至結果型別預先定義之位元`OR`運算子。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的位元 <see langword="OR" /> 運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元 OR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示位元 OR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立表示位元 OR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立表示位元 OR 指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算子評估為 <see langword="OR" /> 時才評估第二個運算元的條件 <see langword="false" /> 運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算元計算結果為 <see langword="OR" /> 時才求第二個運算元之值的 <see langword="false" /> 條件運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`OR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
    > [!NOTE]
    >  條件式`OR`運算子無法多載以 C# 或 Visual Basic。 不過，條件式`OR`運算子會評估所使用的位元`OR`運算子。 因此，使用者定義的多載位元`OR`運算子可以是此節點類型的實作方法。  
  
-   否則，如果`left`。型別和`right`。類型為布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個是可為 null，且對應的非 null 的型別相等相對應的引數類型的實作方法。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   `left`.型別和`right`。型別都是相同的布林類型。  
  
-   如果`left`。型別和`right`。型別不可為 null，則不會消除節點。 節點的類型是預先定義的條件式的結果型別`OR`運算子。  
  
-   如果`left`。型別和`right`。型別可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的條件式的結果型別`OR`運算子。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立運算式，表示邏輯`OR`第一個運算元評估為時，才評估第二個運算元的作業`false`。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義位元 <see langword="OR" /> 運算子。  
  
-或- 
 <paramref name="left" />.Type 和 <paramref name="right" />.Type 是不相同的布林類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示只在第一個運算元計算結果為 <see langword="OR" /> 時才求第二個運算元之值的 <see langword="false" /> 條件運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載位元`OR`運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
    > [!NOTE]
    >  條件式`OR`運算子無法多載以 C# 或 Visual Basic。 不過，條件式`OR`運算子會評估所使用的位元`OR`運算子。 因此，使用者定義的多載位元`OR`運算子可以是此節點類型的實作方法。  
  
-   否則，如果`left`。型別和`right`。類型為布林值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個是可為 null，且對應的非 null 的型別相等相對應的引數類型的實作方法。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   `left`.型別和`right`。型別都是相同的布林類型。  
  
-   如果`left`。型別和`right`。型別不可為 null，則不會消除節點。 節點的類型是預先定義的條件式的結果型別`OR`運算子。  
  
-   如果`left`。型別和`right`。型別可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的條件式的結果型別`OR`運算子。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的位元 <see langword="OR" /> 運算子。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />，且 <paramref name="left" />.Type 和 <paramref name="right" />.Type 不是相同的布林類型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">參數或變數的類型。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</summary>
        <returns>建立含指定之名稱和類型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立<xref:System.Linq.Expressions.MethodCallExpression>列印的值的物件<xref:System.Linq.Expressions.ParameterExpression>物件。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">參數或變數的類型。</param>
        <param name="name">參數或變數的名稱，僅供偵錯或列印之用。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</summary>
        <returns><see cref="T:System.Linq.Expressions.ParameterExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" />，且 <see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞減 1 的運算式指派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞減 1 的運算式指派。</summary>
        <returns>表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞減 1 的運算式指派。</summary>
        <returns>表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞增 1 的運算式指派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞增 1 的運算式指派。</summary>
        <returns>表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示後面接續原始運算式遞增 1 的運算式指派。</summary>
        <returns>表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表將數字提升為乘冪數的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表將數字提升為乘冪數的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Power" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載的乘冪運算子<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別都<xref:System.Double>，則實作方法是<xref:System.Math.Pow%2A>。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Exponentiation 運算子。  
  
-或- 
 <paramref name="left" />.Type 和 (或) <paramref name="right" />.Type 不是 <see cref="T:System.Double" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表將數字提升為乘冪數的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Power" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是實作的方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`表示使用者定義型別多載的乘冪運算子<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別都<xref:System.Double>，則實作方法是<xref:System.Math.Pow%2A>。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的乘冪運算子。  
  
-或- 
 <paramref name="method" /> 是 <see langword="null" /> 和 <paramref name="left" />.Type，且/或 <paramref name="right" />.Type 不是 <see cref="T:System.Double" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示將運算式自乘為乘冪，並且將結果指派回運算式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示將運算式自乘為乘冪，並且將結果指派回運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示將運算式自乘為乘冪，並且將結果指派回運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示將運算式自乘為乘冪，並且將結果指派回運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞減 1，並將結果指派回運算式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞減 1，並將結果指派回運算式。</summary>
        <returns>表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞減 1，並將結果指派回運算式。</summary>
        <returns>表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞增 1，並將結果指派回運算式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞增 1，並將結果指派回運算式。</summary>
        <returns>表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要套用上述作業的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="method">表示實作方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，可讓運算式遞增 1，並將結果指派回運算式。</summary>
        <returns>表示結果運算式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表存取屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。 如果是靜態屬性，可以是 null。</param>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" />，代表屬性存取子方法。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberExpression" />，代表透過使用屬性存取子來存取屬性。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />、<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 屬性設定為 <paramref name="expression" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，代表在 <paramref name="propertyAccessor" /> 中存取的屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性<xref:System.Linq.Expressions.MemberExpression.Member%2A>。  
  
 如果所表示的方法`propertyAccessor`已`static`(`Shared`在 Visual Basic 中)，`expression`可以是`null`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="propertyAccessor" /> 所表示的方法不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，且 <paramref name="expression" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type 無法指派給 <paramref name="propertyAccessor" /> 所代表之方法的宣告類型。  
  
-或- 
<paramref name="propertyAccessor" /> 所表示的方法不是屬性存取子方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。 如果是靜態屬性，可以是 null。</param>
        <param name="property">要將 <see cref="T:System.Reflection.PropertyInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />。</param>
        <summary>建立代表存取屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性<xref:System.Linq.Expressions.MemberExpression.Member%2A>。  
  
 如果此屬性以表示`property`已`static`(`Shared`在 Visual Basic 中)，`expression`可以是`null`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="property" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="property" /> 所表示的屬性不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，且 <paramref name="expression" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type 無法指派給 <paramref name="property" /> 所表示屬性的宣告類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 包含名為 <paramref name="propertyName" /> 的屬性。 如果是靜態屬性，可以是 <see langword="null" />。</param>
        <param name="propertyName">要存取的屬性名稱。</param>
        <summary>建立代表存取屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />、<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 屬性設定為 <paramref name="expression" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" />，代表 <paramref name="propertyName" /> 所表示的屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.PropertyInfo.PropertyType%2A>屬性<xref:System.Reflection.PropertyInfo>所表示的屬性表示`propertyName`。  
  
 這個方法會搜尋`expression`。型別和屬性名稱之屬性的基底類型`propertyName`。 公用屬性，優先非公用屬性。 如果找到相符的屬性，則此方法會傳遞`expression`而<xref:System.Reflection.PropertyInfo>表示該屬性<xref:System.Linq.Expressions.Expression.Property%2A>。  
  
   
  
## Examples  
 下列範例示範如何建立代表存取屬性的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="propertyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyName" />.Type 或其基底類型中沒有定義名為 <paramref name="expression" /> 的屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">屬性所屬的物件。 如果屬性為靜態/共用屬性，就必須為 null。</param>
        <param name="indexer"><see cref="T:System.Reflection.PropertyInfo" />，代表要編製索引的屬性。</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 物件的 <see cref="T:System.Linq.Expressions.Expression" />，用於對屬性進行索引。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.IndexExpression" />，表示索引之屬性的存取結果。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">屬性所屬的物件。 如果屬性為靜態/共用屬性，就必須為 null。</param>
        <param name="indexer"><see cref="T:System.Reflection.PropertyInfo" />，代表要編製索引的屬性。</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，用於對屬性進行索引。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.IndexExpression" />，表示索引之屬性的存取結果。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">屬性所屬的物件。 如果屬性為靜態/共用屬性，就必須為 null。</param>
        <param name="propertyName">索引子的名稱。</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 物件的陣列，用於對屬性進行索引。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.IndexExpression" />，表示索引之屬性的存取結果。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">屬性的包含物件。 如果是靜態屬性，可以是 null。</param>
        <param name="type">包含屬性的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <param name="propertyName">要存取的屬性。</param>
        <summary>建立用於存取屬性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 包含名為 <paramref name="propertyOrFieldName" /> 的屬性或欄位。 如果是靜態成員，可以是 Null。</param>
        <param name="propertyOrFieldName">要存取之屬性或欄位的名稱。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.MemberExpression" />，代表存取屬性或欄位。</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />、<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 屬性設定為 <paramref name="expression" />，且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 屬性設定為 <see cref="T:System.Reflection.PropertyInfo" /> 或 <see cref="T:System.Reflection.FieldInfo" />，代表 <paramref name="propertyOrFieldName" /> 所表示的屬性或欄位。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.MemberExpression>等於<xref:System.Reflection.PropertyInfo.PropertyType%2A>或<xref:System.Reflection.FieldInfo.FieldType%2A>的屬性<xref:System.Reflection.PropertyInfo>或<xref:System.Reflection.FieldInfo>，分別表示的屬性或欄位以表示`propertyOrFieldName`。  
  
 這個方法會搜尋`expression`。類型和其屬性或欄位名稱的基底類型`propertyOrFieldName`。 公用屬性和欄位，優先非公用屬性和欄位。 此外，屬性優先欄位。 如果找到相符的屬性或欄位，則此方法會傳遞`expression`而<xref:System.Reflection.PropertyInfo>或<xref:System.Reflection.FieldInfo>，表示該屬性或欄位<xref:System.Linq.Expressions.Expression.Property%2A>或<xref:System.Linq.Expressions.Expression.Field%2A>分別。  
  
   
  
## Examples  
 下列範例示範如何建立代表存取屬性或欄位的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="propertyOrFieldName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyOrFieldName" />.Type 或其基底類型中沒有定義名為 <paramref name="expression" /> 的屬性或欄位。</exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表具有 <see cref="T:System.Linq.Expressions.Expression" /> 類型常數值的運算式。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Quote" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>代表建構的型別<xref:System.Linq.Expressions.Expression%601>，其中型別引數是所表示的型別`expression`。型別。 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 屬性為 `null`。 兩者<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將這個節點精簡為更簡單的運算式。 如果 CanReduce 傳回 true，則應該傳回有效的運算式。 這個方法可以傳回其他本身必須精簡的節點。</summary>
        <returns>精簡的運算式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將這個節點精簡為更簡單的運算式。 如果 CanReduce 傳回 true，則應該傳回有效的運算式。 這個方法可以傳回其他本身必須精簡的節點。</summary>
        <returns>精簡的運算式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於減少，這個方法會檢查縮減的節點符合某些非變異值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將運算式精簡為已知的節點類型 (不是 Extension 節點)，如果已經是已知的類型，則僅傳回運算式。</summary>
        <returns>精簡的運算式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示參考相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示參考不相等比較的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示重新擲回例外狀況。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示重新擲回例外狀況。</summary>
        <returns>表示重新擲回例外狀況的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">運算式的新 <see cref="T:System.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表重新擲回含指定之類型的例外狀況。</summary>
        <returns>表示重新擲回例外狀況的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示 return 陳述式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示 return 陳述式。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Return、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且包含在跳躍時傳遞至目標標籤的 Null 值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="value">將在跳躍時傳遞至關聯標籤的值。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示 return 陳述式。 可以指定跳躍時傳遞至標籤的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Continue、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />，且，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立包含的運算式<xref:System.Linq.Expressions.Expression.Return%2A>方法。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 return 陳述式。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於 Return、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 null 值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> 將跳躍的目標 <see cref="T:System.Linq.Expressions.GotoExpression" />。</param>
        <param name="value">將在跳躍時傳遞至關聯標籤的值。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.GotoExpression" />，表示含指定之類型的 return 陳述式。 可以指定跳躍時傳遞至標籤的值。</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等於Continue、<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 屬性設定為 <paramref name="target" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為 <paramref name="type" />，且包含在跳躍時傳遞至目標標籤的 <paramref name="value" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表位元右移 (Right-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立代表位元右移 (Right-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`代表向右移位運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。類型為整數類資料類型 (其中<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>，或對應 null 的型別) 和`right`。型別是<xref:System.Int32>，則實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的向右移位運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的向右移位運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Right-shift 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立代表位元右移 (Right-Shift) 運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或`right`代表向右移位運算子會多載的使用者定義型別<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。類型為整數類資料類型 (其中<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>，或對應 null 的型別) 和`right`。型別是<xref:System.Int32>，則實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的向右移位運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的向右移位運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Right-shift 運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示位元右移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立表示位元右移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立表示位元右移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立表示位元右移位指派運算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 物件的集合，用來填入 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 集合。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體。</summary>
        <returns><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" />，而 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">用以填入 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合之 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 物件的陣列。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體。</summary>
        <returns><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的執行個體，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" />，而 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術減法運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術減法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載減法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的減法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的減法運算子的結果類型。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立減去的引數，從第一個引數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Subtraction 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表不含溢位檢查的算術減法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載減法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的減法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的減法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的減法運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的減法指派運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的減法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的減法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示不含溢位檢查的減法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的減法指派運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的減法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的減法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <param name="conversion">要將 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，表示包含溢位檢查的減法指派運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術減法運算。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術減法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則決定選取作業的實作方法：  
  
-   如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載減法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的減法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的減法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定義 Subtraction 運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</param>
        <param name="right">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其代表包含溢位檢查的算術減法運算。</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />，且 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 產生<xref:System.Linq.Expressions.BinaryExpression>具有<xref:System.Linq.Expressions.BinaryExpression.Method%2A>屬性設定為 實作方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是`false`。 <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 屬性為 `null`。  
  
 下列資訊說明實作方法，也就是節點類型，以及節點是否已消除。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用兩個引數，方法是在節點的實作方法。  
  
-   否則，如果<xref:System.Linq.Expressions.Expression.Type%2A>property`left`或是`right`表示使用者定義型別多載減法運算子，<xref:System.Reflection.MethodInfo>表示方法是實作的方法。  
  
-   否則，如果`left`。型別和`right`。型別是數值類型，實作的方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`left`。型別和`right`。類型可指派給對應的實作方法的引數型別，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `left`.型別和`right`。類型為這兩個實值型別，其中至少一個可為 null，對應的非 null 的型別則等於對應的實作方法的引數型別。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 如果實作的方法是`null`:  
  
-   如果`left`。型別和`right`。型別都不可為 null，則不會消除節點。 節點的類型是預先定義的減法運算子的結果類型。  
  
-   如果`left`。型別和`right`。型別都可為 null，則會消除節點。 節點的類型為 null 的型別對應至預先定義的減法運算子的結果類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 或 <paramref name="right" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而它所代表的方法會傳回 <see langword="void" />、不是 <see langword="static" /> (Visual Basic 中的 <see langword="Shared" />)，或者未確切採用兩個引數。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 是 <see langword="null" />，而且未定義 <paramref name="left" />.Type 和 <paramref name="right" />.Type 的減法運算子。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 陳述式的 <see langword="switch" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">針對每個案例所要測試的值。</param>
        <param name="cases">這個 switch 運算式的案例集合。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，代表不含 default case 的 <see langword="switch" /> 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有<xref:System.Linq.Expressions.SwitchCase>中的物件<xref:System.Linq.Expressions.SwitchExpression>物件必須有相同的型別，除非<xref:System.Linq.Expressions.SwitchExpression>具有類型`void`。  
  
 每個<xref:System.Linq.Expressions.SwitchCase>物件具有隱含`break`陳述式，這表示沒有任何隱含的執行順序從一個 case 標籤之間。  
  
 如果`switchValue`不符合任何的情況下，會擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例示範如何建立代表不含預設 case 陳述式參數的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">針對每個案例所要測試的值。</param>
        <param name="defaultBody">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</param>
        <param name="cases">這個 switch 運算式的案例集合。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有<xref:System.Linq.Expressions.SwitchCase>中的物件<xref:System.Linq.Expressions.SwitchExpression>物件必須有相同的型別，除非<xref:System.Linq.Expressions.SwitchExpression>具有類型`void`。  
  
 每個<xref:System.Linq.Expressions.SwitchCase>物件具有隱含`break`陳述式，這表示沒有任何隱含的執行順序從一個 case 標籤之間。  
  
 如果`switchValue`不符的情況下，預設的情況所代表的任何`defaultBody`執行。  
  
   
  
## Examples  
 下列範例示範如何建立具有預設情況的參數陳述式表示的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">針對每個案例所要測試的值。</param>
        <param name="defaultBody">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</param>
        <param name="comparison">要使用的相等比較方法。</param>
        <param name="cases">這個 switch 運算式的案例集合。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">針對每個案例所要測試的值。</param>
        <param name="defaultBody">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</param>
        <param name="comparison">要使用的相等比較方法。</param>
        <param name="cases">這個 switch 運算式的案例集合。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">參數的結果類型。</param>
        <param name="switchValue">針對每個案例所要測試的值。</param>
        <param name="defaultBody">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</param>
        <param name="comparison">要使用的相等比較方法。</param>
        <param name="cases">這個 switch 運算式的案例集合。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">參數的結果類型。</param>
        <param name="switchValue">針對每個案例所要測試的值。</param>
        <param name="defaultBody">如果 <paramref name="switchValue" /> 不符合任何案例，則為參數結果。</param>
        <param name="comparison">要使用的相等比較方法。</param>
        <param name="cases">這個 switch 運算式的案例集合。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SwitchExpression" />，其代表具有預設情況的 <see langword="switch" /> 陳述式。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立要在 <see cref="T:System.Linq.Expressions.SwitchCase" /> 物件中使用的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">案例的主體。</param>
        <param name="testValues">案例的測試值。</param>
        <summary>建立要在 <see cref="T:System.Linq.Expressions.SwitchCase" /> 物件中使用的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 物件。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.SwitchCase" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有<xref:System.Linq.Expressions.SwitchCase>中的物件<xref:System.Linq.Expressions.SwitchExpression>物件必須有相同的型別，除非<xref:System.Linq.Expressions.SwitchExpression>具有類型`void`。  
  
 每個<xref:System.Linq.Expressions.SwitchCase>物件具有隱含`break`陳述式，這表示沒有任何隱含的執行順序從一個 case 標籤之間。  
  
   
  
## Examples  
 下列範例示範如何建立具有預設情況的參數陳述式表示的運算式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">案例的主體。</param>
        <param name="testValues">案例的測試值。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SwitchCase" /> 以便用於 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.SwitchCase" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要將 <see cref="T:System.String" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</summary>
        <returns><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">要將 <see cref="T:System.String" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</param>
        <param name="language">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</summary>
        <returns><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">要將 <see cref="T:System.String" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</param>
        <param name="language">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</param>
        <param name="languageVendor">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</summary>
        <returns><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">要將 <see cref="T:System.String" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</param>
        <param name="language">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</param>
        <param name="languageVendor">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />。</param>
        <param name="documentType">要將 <see cref="T:System.Guid" /> 設定為與之相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的執行個體。</summary>
        <returns><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />、<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />、<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> 屬性設定為指定的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示擲回例外狀況。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Linq.Expressions.Expression" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，表示擲回例外狀況。</summary>
        <returns>表示例外狀況的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立<xref:System.Linq.Expressions.TryExpression>物件，使用<xref:System.Linq.Expressions.Expression.Throw%2A>方法。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="type">運算式的新 <see cref="T:System.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表擲回含指定之類型的例外狀況。</summary>
        <returns>表示例外狀況的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Linq.Expressions.Expression" /> 的文字表示。</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression" /> 的文字表示。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">try 區塊的主體。</param>
        <param name="handlers">零個或多個 <see cref="T:System.Linq.Expressions.CatchBlock" /> 的陣列，表示要與 try 區塊產生關聯的 catch 陳述式。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含 catch 陳述式 (數目不拘) 但不含 fault 區塊或 finally 區塊的 try 區塊。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立<xref:System.Linq.Expressions.TryExpression>包含 catch 陳述式的物件。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">try 區塊的主體。</param>
        <param name="finally">finally 區塊的主體。</param>
        <param name="handlers">零個或多個 <see cref="T:System.Linq.Expressions.CatchBlock" /> 的陣列，表示要與 try 區塊產生關聯的 catch 陳述式。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含 catch 陳述式 (數目不拘) 和 finally 區塊的 try 區塊。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何建立<xref:System.Linq.Expressions.TryExpression>包含 catch 陳述式的物件和 finally 陳述式。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">try 區塊的主體。</param>
        <param name="fault">fault 區塊的主體。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含 fault 區塊但不含任何 catch 陳述式的 try 區塊。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">try 區塊的主體。</param>
        <param name="finally">finally 區塊的主體。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.TryExpression" />，代表含 finally 區塊但不含任何 catch 陳述式的 try 區塊。</summary>
        <returns>建立的 <see cref="T:System.Linq.Expressions.TryExpression" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Type 物件的陣列，指定 System.Action 委派類型的型別引數。</param>
        <param name="actionType">這個方法在傳回時會包含具有特定型別引數的泛型 System.Action 委派類型。 如果沒有符合 <paramref name="typeArgs" /> 的泛型 System.Action 委派，則包含 Null。這個參數以未初始化的狀態傳遞。</param>
        <summary>建立 <see cref="P:System.Linq.Expressions.Expression.Type" /> 物件，這個物件代表具有特定型別引數的泛型 System.Action 委派類型。</summary>
        <returns>如果已針對特定 <paramref name="typeArgs" /> 建立泛型 System.Action 委派類型，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Type 物件的陣列，指定 System.Func 委派類型的型別引數。</param>
        <param name="funcType">這個方法在傳回時會包含具有特定型別引數的泛型 System.Func 委派類型。 如果沒有符合 <paramref name="typeArgs" /> 的泛型 System.Func 委派，則包含 Null。這個參數以未初始化的狀態傳遞。</param>
        <summary>建立 <see cref="P:System.Linq.Expressions.Expression.Type" /> 物件，這個物件代表具有特定型別引數的泛型 System.Func 委派類型。 最後一個型別引數指定已建立之委派的傳回型別。</summary>
        <returns>如果已針對特定 <paramref name="typeArgs" /> 建立泛型 System.Func 委派類型，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此 <see cref="T:System.Linq.Expressions.Expression" /> 代表之運算式的靜態類型。</summary>
        <value>代表運算式靜態類型的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.NodeType%2A>是運算式樹狀結構節點的型別，而<xref:System.Linq.Expressions.Expression.Type%2A>代表運算式節點所表示的靜態 common language runtime (CLR) 類型。 比方說，使用不同的節點類型的兩個節點可以有相同<xref:System.Linq.Expressions.Expression.Type%2A>，如下列程式碼範例所示。  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="type">要將 <see cref="T:System.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表明確參考或 Boxing 轉換，其中若轉換失敗，則提供 <see langword="null" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>是`null`。 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>屬性都`false`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29>方法用來建立<xref:System.Linq.Expressions.UnaryExpression>表示不可為 null 的整數運算式，可為 null 的整數型別參考轉換。  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="type">要將 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> 以比較執行階段類型識別。</summary>
        <returns><see cref="T:System.Linq.Expressions.TypeBinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> 以及 <see cref="T:System.Linq.Expressions.Expression" /> 和 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> 屬性設為指定值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />。</param>
        <param name="type">要將 <see cref="P:System.Linq.Expressions.Expression.Type" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.TypeBinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> 以及 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> 屬性設為指定值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>代表<xref:System.Boolean>。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29>方法用來建立<xref:System.Linq.Expressions.TypeBinaryExpression>表示對字串值的型別測試<xref:System.Int32>型別。  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 或 <paramref name="type" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立代表一元加法運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <summary>建立代表一元加法運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" />，而 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是 false。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`expression`。類型是使用者定義的類型定義一元正運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則，如果`expression`。類型為數值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 實作的方法是否`null`，節點的類型是`expression`。型別。 如果`expression`。類型是不可為 null，則不會消除節點。 否則，則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不會為 <paramref name="expression" />.Type 定義一元正運算子。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">要將 <see cref="T:System.Linq.Expressions.Expression" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</param>
        <param name="method">要將 <see cref="T:System.Reflection.MethodInfo" /> 屬性設定為與之相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</param>
        <summary>建立代表一元加法運算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 屬性等於 <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" />，且 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 屬性設定為指定的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A>屬性產生<xref:System.Linq.Expressions.UnaryExpression>設為實作的方法。 <xref:System.Linq.Expressions.Expression.Type%2A>屬性設定為節點的類型。 則會消除節點，如果<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A>並<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>屬性都`true`。 否則，它們是 false。  
  
#### <a name="implementing-method"></a>實作方法  
 下列規則會決定作業的實作方法：  
  
-   如果`method`不是`null`代表非 void， `static` (`Shared` Visual Basic 中) 採用一個引數，方法是在節點的實作方法。  
  
-   如果`expression`。類型是使用者定義的類型定義一元正運算子，<xref:System.Reflection.MethodInfo>表示的運算子是實作的方法。  
  
-   否則，如果`expression`。類型為數值類型、 實作方法是`null`。  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>節點型別已消除或非消除和  
 如果實作的方法不是`null`:  
  
-   如果`expression`。類型是指派給實作方法的引數類型，則不會消除節點。 節點的類型是實作方法的傳回型別。  
  
-   如果符合下列兩項條件，則會消除節點，節點的類型為 null 的型別對應至實作方法的傳回型別：  
  
    -   `expression`.類型為 null 的實值類型，而且對應的非可為 null 的實值型別等於實作方法的引數類型。  
  
    -   實作方法的傳回型別是不可為 null 的實值型別。  
  
 實作的方法是否`null`，節點的類型是`expression`。型別。 如果`expression`。類型是不可為 null，則不會消除節點。 否則，則會消除節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" /> 不是 <see langword="null" />，而且其代表的方法傳回的是 <see langword="void" />，不是 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />)，或者使用的引數不是剛好一個。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" /> 為 <see langword="null" />，且不會為 <paramref name="expression" />.Type 定義一元正運算子。  
  
-或- 
 <paramref name="expression" />.Type (如果它是可為 Null 的實質類型，則為其對應之不可為 Null 的類型) 無法指派給 <paramref name="method" /> 所代表之方法的引數類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">要 Unbox 的 <see cref="T:System.Linq.Expressions.Expression" />。</param>
        <param name="type">運算式的新 <see cref="T:System.Type" />。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.UnaryExpression" />，代表明確 Unboxing。</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">參數或變數的類型。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</summary>
        <returns>建立含指定之名稱和類型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">參數或變數的類型。</param>
        <param name="name">參數或變數的名稱。 這個名稱僅供偵錯或列印之用。</param>
        <summary>建立 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點，此節點可用以識別運算式樹狀中的參數或變數。</summary>
        <returns>建立含指定之名稱和類型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 節點。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><see cref="T:System.Func`2" /> 的執行個體。</param>
        <summary>精簡節點，然後呼叫精簡後的運算式上的訪問項委派。 如果節點無法縮減，此方法會擲回例外狀況。</summary>
        <returns>受訪的運算式，或是在樹狀中應取代該運算式的運算式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫這個方法，以提供從頭到尾參與節點的子系的邏輯。 一般實作會呼叫訪客。在每個子系，請瀏覽，如果有任何這些變更，應該會傳回已修改的子系本身的新複本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>