<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="32da3a4f246af136cf0a6d8ef5bbe62b7f5d4aa6" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48616293" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="b6fb2-101">為附加配置器的衍生控制項自訂呈現方式，以針對特定瀏覽器修改預設標記或行為，而且此類別為所有控制項配置器繼承來源的基底類別。</span>
      <span class="sxs-lookup">
        <span data-stu-id="b6fb2-101">Customizes rendering for the derived control to which the adapter is attached, to modify the default markup or behavior for specific browsers, and is the base class from which all control adapters inherit.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-102">控制項配接器會覆寫特定的元件<xref:System.Web.UI.Control>類別方法和其執行開發週期，以允許瀏覽器或特定標記的處理中的事件。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-102">Control adapters are components that override certain <xref:System.Web.UI.Control> class methods and events in its execution lifecycle to allow browser or markup-specific handling.</span></span> <span data-ttu-id="b6fb2-103">.NET Framework 對應的單一衍生的控制項介面卡<xref:System.Web.UI.Control>針對每個用戶端要求的物件。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-103">The .NET Framework maps a single derived control adapter to a <xref:System.Web.UI.Control> object for each client request.</span></span>  
  
 <span data-ttu-id="b6fb2-104">配接器會修改特定瀏覽器或瀏覽器類別的控制項，或做為任意的篩選條件，某些功能。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-104">An adapter modifies a control for a specific browser or class of browsers or acts as an arbitrary filter on some capability.</span></span> <span data-ttu-id="b6fb2-105">通常配接器會定義瀏覽器 （例如 XHTML 或 HTML 3.2） 所使用的標記語言。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-105">Typically the adapter is defined by the markup language that the browser uses (for example, XHTML or HTML 3.2).</span></span> <span data-ttu-id="b6fb2-106">大部分的轉譯行為中的靈活度可以封裝在特製化類別衍生自<xref:System.Web.UI.HtmlTextWriter>類別。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-106">Much of the adaptability in rendering behavior can be encapsulated in the specialized classes that derive from the <xref:System.Web.UI.HtmlTextWriter> class.</span></span> <span data-ttu-id="b6fb2-107">因此，很可能單一配接器可以用於多個瀏覽器類別行為或中的靈活度，包含<xref:System.Web.UI.HtmlTextWriter>類別可以讓控制項配接器使用非必要。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-107">Therefore, it is likely that a single adapter can be used for a number of browser class behaviors or that inclusion of the adaptability in the <xref:System.Web.UI.HtmlTextWriter> classes could make the use of a control adapter unnecessary.</span></span>  
  
 <span data-ttu-id="b6fb2-108">控制項類別的配接器適用於所有的控制項繼承自該類別，除非有更具特製化的配接器。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-108">An adapter for a control class applies to all controls that inherit from that class, unless more specialized adapters are present.</span></span> <span data-ttu-id="b6fb2-109">例如，針對配接器<xref:System.Web.UI.WebControls.BaseValidator>類別可用於所有`Validator`物件。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-109">For example, an adapter for the <xref:System.Web.UI.WebControls.BaseValidator> class can be used for all `Validator` objects.</span></span>  
  
 <span data-ttu-id="b6fb2-110">配接器通常不會繼承直接從<xref:System.Web.UI.Adapters.ControlAdapter>類別，但其中一個特定目標的配接器基底類別，可提供其他控制項類型和目標瀏覽器所特有的功能，或需要特定的轉譯。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-110">Adapters typically do not inherit directly from the <xref:System.Web.UI.Adapters.ControlAdapter> class, but from one of the target-specific adapter base classes that provide additional functionality specific to the control type and target browser or the particular rendering required.</span></span>  
  
 <span data-ttu-id="b6fb2-111">控制項本身並不一定需要配接器。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-111">Controls themselves do not necessarily require an adapter.</span></span> <span data-ttu-id="b6fb2-112">如果控制項透過撰寫擴充的通常已足夠子控制項配接器。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-112">If controls are extended through composition, generally the child control adapters are sufficient.</span></span>  
  
 <span data-ttu-id="b6fb2-113">每個控制項都有明確對應到配接器透過.browser 定義檔。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-113">Each control has explicit mappings to adapters through the .browser definition files.</span></span> <span data-ttu-id="b6fb2-114">因此，任何存取權<xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType>屬性使用<xref:System.Web.HttpBrowserCapabilities>從控制項的介面卡的對應執行查閱的瀏覽器定義檔案中擷取的物件。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-114">Thus, any access to the <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> property uses the <xref:System.Web.HttpBrowserCapabilities> object extracted from the browser definition files to perform the lookup for the mapping of the adapter to control.</span></span>  
  
 <span data-ttu-id="b6fb2-115">在處理期間，.NET Framework 會攔截可能是特定目標的控制項可覆寫方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-115">During processing, the .NET Framework intercepts calls to the overridable methods of a control that could be target-specific.</span></span> <span data-ttu-id="b6fb2-116">如果附加控制項配接器，.NET Framework 會呼叫相關聯的配接器的方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-116">If a control adapter is attached, the .NET Framework calls the associated adapter methods.</span></span>  
  
 <span data-ttu-id="b6fb2-117">配接器會透過控制項執行轉譯<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-117">The adapter performs rendering for the control through the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method.</span></span> <span data-ttu-id="b6fb2-118">覆寫時，如果<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>可能不應該呼叫基底類別實作因為回到執行呼叫<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-118">If overridden, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potentially should not call the base class implementation because that performs a call back on the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b6fb2-119">這可能會導致發生兩次，一次是由配接器，另一次是由控制項所呈現。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-119">This might cause the rendering to occur twice, once by the adapter and once by the control.</span></span>  
  
 <span data-ttu-id="b6fb2-120"><xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>基礎方法呼叫<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>控制項的方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-120">The <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> base method calls back on the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method of the control.</span></span> <span data-ttu-id="b6fb2-121">因此，如果您覆寫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>，您不應該呼叫基底類別實作，除非您實作的轉譯除了提供<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>的控制項。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-121">Thus, if you override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, you should not call the base class implementation unless the rendering you implement is in addition to that provided by <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> of the control.</span></span>  
  
 <span data-ttu-id="b6fb2-122">您必須確定.NET Framework 會為子控制項的配接器執行攔截。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-122">You must ensure that the .NET Framework performs interception for adapters of the child controls.</span></span> <span data-ttu-id="b6fb2-123">您可以藉由呼叫<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>基底方法，它會呼叫<xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType>方法的控制項，從您<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>覆寫。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-123">You can do this by calling the <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> base method, which calls the <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> method of the control, from your <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> override.</span></span>  
  
 <span data-ttu-id="b6fb2-124"><xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>並<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>立即之前和之後 （分別） 控制項呼叫，方法由控制項呼叫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-124">The <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> methods are called by the control immediately before and after (respectively) the control calls the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method.</span></span> <span data-ttu-id="b6fb2-125">如果前置和後置的轉譯唯一的瀏覽器特定處理工作所需<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>並<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>可能會讓不必要的覆寫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-125">If pre- and post-rendering are the only browser-specific processing tasks required, using <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> might make it unnecessary to override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>.</span></span> <span data-ttu-id="b6fb2-126">預設行為<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>並<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法是呼叫的對應方法<xref:System.Web.UI.HtmlTextWriter>。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-126">The default behavior of the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> methods is to call the corresponding methods of the <xref:System.Web.UI.HtmlTextWriter>.</span></span>  
  
 <span data-ttu-id="b6fb2-127">若要維護自己的狀態資訊，可以覆寫控制項配置器<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-127">To maintain its own state information, a control adapter can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> methods.</span></span> <span data-ttu-id="b6fb2-128"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>私用的控制項和檢視狀態會儲存及載入，分別時呼叫。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-128"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> are called when the private control and view states are saved and loaded, respectively.</span></span>  
  
 <span data-ttu-id="b6fb2-129"><xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>，以及<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>base 回在相對應的方法呼叫<xref:System.Web.UI.Control>類別方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-129">The <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> base methods call back on the corresponding <xref:System.Web.UI.Control> class methods.</span></span> <span data-ttu-id="b6fb2-130">因此，任一<xref:System.Web.UI.Adapters.ControlAdapter>會覆寫的方法必須呼叫其基底的方法; 否則此事件相關聯<xref:System.Web.UI.Control>類別方法就不會引發。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-130">Thus, any of these <xref:System.Web.UI.Adapters.ControlAdapter> methods that are overridden must call their base methods; otherwise, the event associated with the <xref:System.Web.UI.Control> class method will not be raised.</span></span>  
  
 <span data-ttu-id="b6fb2-131">控制項和配接器選擇性地實作<xref:System.Web.UI.IPostBackDataHandler>和<xref:System.Web.UI.IPostBackEventHandler>介面。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-131">Controls and adapters optionally implement the <xref:System.Web.UI.IPostBackDataHandler> and <xref:System.Web.UI.IPostBackEventHandler> interfaces.</span></span> <span data-ttu-id="b6fb2-132">.NET Framework 會決定配接器是否存在，以及配接器是否實作這些介面。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-132">The .NET Framework determines whether an adapter exists and whether the adapter implements these interfaces.</span></span> <span data-ttu-id="b6fb2-133">若是如此，配接器應該覆寫<xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>， <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>，和<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>方法，視。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-133">If it does, the adapter should override the <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, and <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> methods, as necessary.</span></span> <span data-ttu-id="b6fb2-134">如果無法辨識的回傳資料配接器中，它必須回呼來處理在控制項上。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-134">If the postback data is not recognized in the adapter, it must call back on the control to process it.</span></span> <span data-ttu-id="b6fb2-135">後續的事件處理常式也必須回呼的控制項上。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-135">Subsequent event handlers also must call back on the control.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="b6fb2-136">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別，需要一般的配接器功能的控制項應該擁有基底類別，名為模式中的對應介面卡<paramref name="ControlType" /><see langword="Adapter" /> (比方說， <see langword="TextBoxAdapter" />)。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-136">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, a control that requires general adapter functionality should have a corresponding adapter base class, named in the pattern <paramref name="ControlType" /><see langword="Adapter" /> (for example, <see langword="TextBoxAdapter" />).</span>
        </span>
        <span data-ttu-id="b6fb2-137">配接器應該至少會傳回透過控制項的強型別執行個體其<see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" />屬性。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-137">The adapter should at a minimum return a strongly-typed instance of the control through its <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> property.</span>
        </span>
        <span data-ttu-id="b6fb2-138">1.</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-138">1.</span>
        </span>
        <span data-ttu-id="b6fb2-139">控制配接器應該在模式中為指定的控制項類型和標記語言<paramref name="MarkupControlType" /><see langword="Adapter" /> (比方說， <see langword="XhtmlTextBoxAdapter" />)。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-139">Control adapters for a given control type and markup language should be named in the pattern <paramref name="MarkupControlType" /><see langword="Adapter" /> (for example, <see langword="XhtmlTextBoxAdapter" />).</span>
        </span>
        <span data-ttu-id="b6fb2-140">控制項的配接器應該實作在<see langword="Adapters" />subnamespace。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-140">Adapters for a control should be implemented in an <see langword="Adapters" /> subnamespace.</span>
        </span>
        <span data-ttu-id="b6fb2-141">控制項配接器應該繼承自適當的基底類別，並遵循相同的繼承模型，做為控制項。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-141">Control adapters should inherit from the appropriate base class and follow the same inheritance model as the control.</span>
        </span>
        <span data-ttu-id="b6fb2-142">比方說，繼承自控制項的配接器<see cref="T:System.Web.UI.Control" />基底類別應該繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別或相關<paramref name="ControlType" /><see langword="Adapter" />類別。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-142">For example, an adapter for a control inheriting from the <see cref="T:System.Web.UI.Control" /> base class should inherit from either the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class or the relevant <paramref name="ControlType" /><see langword="Adapter" /> class.</span>
        </span>
        <span data-ttu-id="b6fb2-143">任何特製化的配接器應該定義底下的所有裝置節點.browser 組態檔中特製化的控制項。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-143">Any specialized adapters should be defined for the specialized control under all of the device nodes in configuration .browser files.</span>
        </span>
        <span data-ttu-id="b6fb2-144">確認已連接的介面卡，或附加配接器實作特定介面，不應該假設適當實作的控制項。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-144">A properly implemented control should not assume that an adapter is attached, or that the attached adapter implements a specific interface.</span>
        </span>
        <span data-ttu-id="b6fb2-145">相反地，它應該先檢查這些呼叫。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-145">Instead, it should check for these before calling.</span>
        </span>
        <span data-ttu-id="b6fb2-146">很有可能模擬這類覆寫在控制項中，受保護的事件方法<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法的<see cref="T:System.Web.UI.WebControls.LinkButton" />。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-146">It is possible to simulate overriding protected event methods in the control, such as the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method of the <see cref="T:System.Web.UI.WebControls.LinkButton" />.</span>
        </span>
        <span data-ttu-id="b6fb2-147">首先，建立使用配接器類別<c>OnClick</c>方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-147">First, create an adapter class with an <c>OnClick</c> method.</span>
        </span>
        <span data-ttu-id="b6fb2-148">然後建立新的控制項衍生自<see cref="T:System.Web.UI.WebControls.LinkButton" />，並覆寫<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-148">Then create a new control derived from <see cref="T:System.Web.UI.WebControls.LinkButton" /> and override the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method.</span>
        </span>
        <span data-ttu-id="b6fb2-149">已覆寫<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法呼叫<c>OnClick</c>配接器的方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-149">The overriden <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method calls the <c>OnClick</c> method of the adapter.</span>
        </span>
        <span data-ttu-id="b6fb2-150">配接器物件可透過受保護<see cref="P:System.Web.UI.Control.Adapter" />屬性<see cref="T:System.Web.UI.Control" />類別。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-150">The adapter object is available through the protected <see cref="P:System.Web.UI.Control.Adapter" /> property of the <see cref="T:System.Web.UI.Control" /> class.</span>
        </span>
        <span data-ttu-id="b6fb2-151">
          <see cref="P:System.Web.UI.Control.Adapter" />控制項的屬性是<see langword="null" />沒有相關聯的配接器時，因此任何程式碼前應該檢查該條件的呼叫配接器的方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="b6fb2-151">The <see cref="P:System.Web.UI.Control.Adapter" /> property of the control is <see langword="null" /> when there is no associated adapter, so any code should check for that condition before calling methods of the adapter.</span>
        </span>
      </para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b6fb2-152">初始化 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-152">Initializes a new instance of the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-153">.NET Framework 內部建構此配接器，它會建立對應時<xref:System.Web.UI.Control>物件。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-153">The .NET Framework internally constructs this adapter when it creates the corresponding <xref:System.Web.UI.Control> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="b6fb2-154">包含呈現特定目標輸出方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-154">The <see cref="T:System.Web.UI.HtmlTextWriter" /> containing methods to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-155">在呈現控制項之前呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-155">Called prior to the rendering of a control.</span>
          </span>
          <span data-ttu-id="b6fb2-156">在衍生的配置器類別中，產生特定目標所需的開頭標記 (而非 HTML 瀏覽器所需)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-156">In a derived adapter class, generates opening tags that are required by a specific target but not needed by HTML browsers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-157"><xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法之前呼叫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法，而且用於特定目標先執行前置處理控制項的呈現。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-157">The <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method is called just before the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method, and is used to perform target-specific preprocessing before the rendering of the control.</span></span>  
  
 <span data-ttu-id="b6fb2-158">使用<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法搭配<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法，以確定開頭和結尾標記的一致性。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-158">Use the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method in combination with the <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method to ensure opening and closing tag consistency.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-159">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別，<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基底方法呼叫<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-159">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-160">因此，覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />方法應該呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基底方法，只有其處理，而不是，<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-160">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b6fb2-161">取得對用戶端瀏覽器功能的參考 (此用戶端是發出目前 HTTP 要求的用戶端)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-161">Gets a reference to the browser capabilities of the client making the current HTTP request.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b6fb2-162">
            <see cref="T:System.Web.HttpBrowserCapabilities" />，指定用戶端瀏覽器和標記功能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-162">An <see cref="T:System.Web.HttpBrowserCapabilities" /> specifying client browser and markup capabilities.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-163">A<xref:System.Web.UI.Adapters.ControlAdapter>物件可以決定從用戶端瀏覽器功能<xref:System.Web.HttpBrowserCapabilities>所傳回的物件<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-163">A <xref:System.Web.UI.Adapters.ControlAdapter> object determines the client browser capabilities from the <xref:System.Web.HttpBrowserCapabilities> object that is returned by the <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> property.</span></span> <span data-ttu-id="b6fb2-164">這可讓<xref:System.Web.UI.Adapters.ControlAdapter>物件來呈現瀏覽器特定的標記，或修改的行為<xref:System.Web.UI.Control>。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-164">This enables the <xref:System.Web.UI.Adapters.ControlAdapter> object to render browser-specific markup or otherwise modify the behavior of the <xref:System.Web.UI.Control>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b6fb2-165">下列程式碼範例示範如何使用<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>屬性來存取要求的瀏覽器的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-165">The following code example shows how to use the <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> property to access the details of the requesting browser.</span></span> <span data-ttu-id="b6fb2-166">在此範例中，程式碼會檢查以判斷是否適用於 JavaScript 中，瀏覽器，並可讓開發人員在此情況下呈現自訂的輸出。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-166">In this example, the code checks to determine whether the browser is compatible with JavaScript, and then allows the developer to render customized output in that case.</span></span>  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b6fb2-167">取得控制項的參考 (指控制項配置器附加的控制項)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-167">Gets a reference to the control to which this control adapter is attached.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b6fb2-168">
            <see cref="T:System.Web.UI.Control" /> 所附加的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-168">The <see cref="T:System.Web.UI.Control" /> to which this <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> is attached.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-169">當在衍生的控制項配接器附加至控制項時，.NET Framework 會呼叫特定配接器成員，而不是控制項成員。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-169">When a derived control adapter is attached to a control, the .NET Framework calls certain adapter members instead of the control members.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b6fb2-170">下列程式碼範例示範如何衍生的自訂控制項<xref:System.Web.UI.Control>類別，並接著建立對應的介面卡繼承自<xref:System.Web.UI.Adapters.ControlAdapter>類別。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-170">The following code example shows how to derive a custom control from the <xref:System.Web.UI.Control> class, and then create a corresponding adapter that inherits from the <xref:System.Web.UI.Adapters.ControlAdapter> class.</span></span> <span data-ttu-id="b6fb2-171">配接器會覆寫<xref:System.Web.UI.Adapters.ControlAdapter.Control%2A>屬性，並傳回控制項的強型別參考。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-171">The adapter overrides the <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> property and returns a strongly-typed reference to the control.</span></span>  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-172">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別中，最少，您應該實作<see langword="Control" />屬性以傳回控制項的強型別執行個體，範例 &gt; 一節中所示。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-172">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, at a minimum, you should implement a <see langword="Control" /> property to return a strongly-typed instance of the control, as shown in the Example section.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b6fb2-173">為複合控制項建立特定目標的子控制項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-173">Creates the target-specific child controls for a composite control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-174">如果沒有衍生的控制項配接器會附加至<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>覆寫方法，而不是呼叫覆寫<xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-174">If there is a derived control adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> method is overridden, the override is called instead of the <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b6fb2-175">因此，<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>可用來建立特定目標的子控制項集合。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-175">Thus, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> can be used to create a target-specific child control set.</span></span>  
  
 <span data-ttu-id="b6fb2-176">如需有關如何結合控制項來建立新的控制項的詳細資訊，請參閱[複合控制項](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-176">For more information about combining controls to create a new control, see [Composite Controls](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-177">如果您建立繼承的類別並覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />方法時，請勿呼叫基底方法，除非您想要將控制項新增至這些方法所建立的基底。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-177">If you create an inheriting class and override the <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> method, do not call the base method unless you want to add controls to those created by the base method.</span>
            </span>
            <span data-ttu-id="b6fb2-178">否則您可以建立兩組子控制項。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-178">Otherwise you could create two sets of child controls.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="b6fb2-179">包含呈現特定目標輸出方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-179">The <see cref="T:System.Web.UI.HtmlTextWriter" /> containing methods to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-180">在呈現控制項之後呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-180">Called after the rendering of a control.</span>
          </span>
          <span data-ttu-id="b6fb2-181">在衍生的配置器類別中，產生特定目標所需的結尾標記 (而非 HTML 瀏覽器所需)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-181">In a derived adapter class, generates closing tags that are required by a specific target but not needed by HTML browsers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-182"><xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法呼叫之後<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法，並用來呈現控制項之後，執行特定目標的後置處理。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-182">The <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method is called just after the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method, and is used to perform target-specific postprocessing after the rendering of the control.</span></span>  
  
 <span data-ttu-id="b6fb2-183">使用<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法搭配<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法，以確定開頭和結尾標記的一致性。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-183">Use the <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method in combination with the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method to ensure opening and closing tag consistency.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-184">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別，<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基底方法呼叫<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-184">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-185">因此，覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />方法應該呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基底方法，只有其處理，而不是，<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-185">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="b6fb2-186">
            <see cref="T:System.Object" />，包含做為 <see cref="T:System.Web.UI.StateBag" /> 的配置器控制狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-186">An <see cref="T:System.Object" /> that contains the adapter's control state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-187">載入之前在對頁面發出要求的期間由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> 所儲存的配置器控制項狀態資訊 (與此控制項配置器相關聯的控制項便存在於此頁面中)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-187">Loads adapter control state information that was saved by <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> during a previous request to the page where the control associated with this control adapter resides.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-188">控制項狀態是即使已停用檢視狀態所需的基本狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-188">Control state is the essential state information needed even if view state is disabled.</span></span> <span data-ttu-id="b6fb2-189">當配接器需要維護自己的控制項狀態資訊時，它可以覆寫<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-189">When an adapter needs to maintain its own control state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> methods.</span></span>  
  
 <span data-ttu-id="b6fb2-190">配接器可能需要維持控制項狀態資訊時需要有狀態要求相關聯控制項的狀態分開維護的功能。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-190">An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</span></span> <span data-ttu-id="b6fb2-191">例如，大型的文字顯示和一群組成複合控制項<xref:System.Web.UI.WebControls.RadioButton>控制項可能會呈現為桌上型電腦瀏覽器的單一檢視。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-191">For example, a composite control consisting of a large textual display and a group of <xref:System.Web.UI.WebControls.RadioButton> controls might render as a single view on desktop computer browsers.</span></span> <span data-ttu-id="b6fb2-192">在其他瀏覽器中，它可能會分割成其呈現方式，與另一個則用於選項按鈕群組的文字顯示的單一檢視。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-192">On other browsers, it might split its rendering—one view for the textual display and the other for the radio button group.</span></span> <span data-ttu-id="b6fb2-193">配接器必須維護其本身特定目標的相關資訊目前現用檢視表。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-193">The adapter would need to maintain its own target-specific information about the currently active view.</span></span>  
  
 <span data-ttu-id="b6fb2-194"><xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>方法之後，立即呼叫<xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType>方法，請在`LoadState`生命週期階段。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-194">The <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> method is called immediately after the <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> method, in the `LoadState` lifecycle stage.</span></span> <span data-ttu-id="b6fb2-195">配接器控制狀態是分開的且除了控制項的控制項狀態。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-195">The adapter control state is separate and in addition to the control state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="b6fb2-196">
            <see cref="T:System.Object" />，包含當做 <see cref="T:System.Web.UI.StateBag" /> 的配置器檢視狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-196">An <see cref="T:System.Object" /> that contains the adapter view state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-197">載入之前在對頁面發出要求的期間由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> 所儲存的配置器檢視狀態資訊 (與此控制項配置器相關聯的控制項便存在於此頁面中)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-197">Loads adapter view state information that was saved by <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> during a previous request to the page where the control associated with this control adapter resides.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-198">當配接器需要維護自己的檢視狀態資訊時，它可以覆寫<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-198">When an adapter needs to maintain its own view state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> methods.</span></span>  
  
 <span data-ttu-id="b6fb2-199">配接器必須跨要求，獨立於關聯控制項的檢視狀態，必須維護的資料時維持檢視狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-199">An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the view state of the associated control.</span></span> <span data-ttu-id="b6fb2-200">例如，桌上型電腦瀏覽器上的方格控制項可能會轉譯為單一檢視的資料列和資料行的值。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-200">For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</span></span> <span data-ttu-id="b6fb2-201">在其他瀏覽器中，它可能會分割成其轉譯成多個不同檢視的詳細資訊，例如資料列和詳細資料的單一資料列的清單。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-201">On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</span></span> <span data-ttu-id="b6fb2-202">配接器需要維護的資料不在檢視狀態中目前作用中的檢視。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-202">The adapter would need to maintain the data for the views that are not currently active in view state.</span></span>  
  
 <span data-ttu-id="b6fb2-203"><xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法之前，立即呼叫<xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType>方法中的`LoadState`生命週期階段。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-203">The <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> method is called immediately before the <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> method in the `LoadState` lifecycle stage.</span></span> <span data-ttu-id="b6fb2-204">配接器檢視狀態是分開的且除了控制項的檢視狀態。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-204">The adapter view state is separate and in addition to the view state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="b6fb2-205">包含事件資料的 <see cref="T:System.EventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-205">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-206">為關聯控制項覆寫 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-206">Overrides the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-207">如果沒有配接器會附加至<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>覆寫方法，而不是呼叫覆寫方法<xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-207">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b6fb2-208">覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>至執行中的特定目標的處理`Initialize`控制項生命週期的階段。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-208">Override <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> to perform target-specific processing in the `Initialize` stage of the control lifecycle.</span></span> <span data-ttu-id="b6fb2-209">一般而言，這些是在建立控制項時，會執行的函式。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-209">Typically, these are functions that are performed when a control is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b6fb2-210">下列程式碼範例衍生自訂的控制項配接器從<xref:System.Web.UI.Adapters.ControlAdapter>類別。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-210">The following code sample derives a custom control adapter from the <xref:System.Web.UI.Adapters.ControlAdapter> class.</span></span> <span data-ttu-id="b6fb2-211">它接著會覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>方法相關聯的控制項上設定屬性，並呼叫基底方法，以完成控制項初始化。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-211">It then overrides the <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> method to set a property on the associated control and call the base method to complete the control initialization.</span></span>  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-212">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別和介面卡覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />方法中，配接器必須呼叫對應的基底類別方法接著會呼叫<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-212">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-213">如果<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />不會呼叫方法，<see cref="E:System.Web.UI.Control.Init" />不會引發事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-213">If the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.Init" /> event will not be raised.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="b6fb2-214">包含事件資料的 <see cref="T:System.EventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-214">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-215">為關聯控制項覆寫 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-215">Overrides the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-216">如果沒有配接器會附加至<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>覆寫方法，而不是呼叫覆寫方法<xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-216">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b6fb2-217">覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>方法，以執行中的特定目標的處理`Load`控制項生命週期的階段。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-217">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> method to perform target-specific processing in the `Load` stage of the control lifecycle.</span></span> <span data-ttu-id="b6fb2-218">一般而言，這些是應該為每個用戶端要求執行的函式。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-218">Typically, these are functions that should be performed for each client request.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-219">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別和介面卡覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />方法中，配接器必須呼叫對應的基底類別方法接著會呼叫<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-219">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-220">如果<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />不會呼叫，<see cref="E:System.Web.UI.Control.Load" />不會引發事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-220">If <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Load" /> event will not be raised.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="b6fb2-221">包含事件資料的 <see cref="T:System.EventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-221">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-222">為關聯控制項覆寫 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-222">Overrides the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-223">如果沒有配接器會附加至<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>覆寫方法，而不是呼叫覆寫方法<xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-223">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b6fb2-224">覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>方法，以執行中的特定目標的處理`PreRender`控制項生命週期的階段。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-224">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> method to perform target-specific processing in the `PreRender` stage of the control lifecycle.</span></span> <span data-ttu-id="b6fb2-225">一般而言，這些是緊接在之前的控制項輸出的轉譯的函式。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-225">Typically, these are functions that immediately precede rendering of the control output.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-226">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別和介面卡覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />方法中，配接器必須呼叫對應的基底類別方法接著會呼叫<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-226">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-227">如果<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />不會呼叫方法，<see cref="E:System.Web.UI.Control.PreRender" />不會引發事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-227">If the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.PreRender" /> event will not be raised.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="b6fb2-228">包含事件資料的 <see cref="T:System.EventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-228">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-229">為關聯控制項覆寫 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-229">Overrides the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-230">如果沒有配接器會附加至<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>覆寫方法，而不是呼叫覆寫方法<xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-230">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b6fb2-231">覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>方法來執行特定目標的處理`Unload`控制項生命週期的階段。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-231">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> method to do target-specific processing in the `Unload` stage of the control lifecycle.</span></span> <span data-ttu-id="b6fb2-232">一般而言，這些是配置控制項的前面的清除函式。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-232">Typically, these are cleanup functions that precede disposition of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-233">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別和介面卡覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />方法中，配接器必須呼叫對應的基底類別方法接著會呼叫<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-233">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-234">如果<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />不會呼叫，<see cref="E:System.Web.UI.Control.Unload" />不會引發事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-234">If <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Unload" /> event will not be raised.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b6fb2-235">取得對頁面的參考 (與此配置器相關聯的控制項便存在於此頁面中)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-235">Gets a reference to the page where the control associated with this adapter resides.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b6fb2-236">
            <see cref="T:System.Web.UI.Page" />，可提供頁面執行個體的存取 (相關聯的控制項便存在於此執行個體中)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-236">A <see cref="T:System.Web.UI.Page" /> that provides access to the page instance where the associated control is situated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-237"><xref:System.Web.UI.Adapters.ControlAdapter.Page%2A>屬性可存取<xref:System.Web.UI.Page?displayProperty=nameWithType>控制項便存在於其中的物件。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-237">The <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> property provides access to the <xref:System.Web.UI.Page?displayProperty=nameWithType> object where the control is situated.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b6fb2-238">取得對此頁的頁面配置器的參考 (關聯的控制項便存在於此頁面中)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-238">Gets a reference to the page adapter for the page where the associated control resides.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b6fb2-239">頁面的 <see cref="T:System.Web.UI.Adapters.PageAdapter" />，與目前 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 相關聯的控制項便存在於此頁面中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-239">A <see cref="T:System.Web.UI.Adapters.PageAdapter" /> for the page where the control associated with the current <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> is situated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-240"><xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>屬性可存取<xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType>物件<xref:System.Web.UI.Page>物件位置<xref:System.Web.UI.Control>目前相關聯的物件<xref:System.Web.UI.Adapters.ControlAdapter>便存在於物件。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-240">The <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> property provides access to the <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> object for the <xref:System.Web.UI.Page> object where the <xref:System.Web.UI.Control> object associated with the current <xref:System.Web.UI.Adapters.ControlAdapter> object is situated.</span></span>  
  
 <span data-ttu-id="b6fb2-241"><xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>屬性可以用來存取層級頁面配接器，例如常見的特定目標函式可套用到頁面上的幾個控制項類型的其他項目。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-241">The <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> property can be used to access other items at the page adapter level, such as common target-specific functions that could apply to several control types on the page.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="b6fb2-242">
            <see cref="T:System.Web.UI.HtmlTextWriter" />，用來呈現特定目標的輸出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-242">The <see cref="T:System.Web.UI.HtmlTextWriter" /> to use to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-243">為附加控制項配接器的控制項，產生目標特定的標記。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-243">Generates the target-specific markup for the control to which the control adapter is attached.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-244">覆寫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法來產生特定目標的標記，將傳送至用戶端瀏覽器。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-244">Override the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method to generate target-specific markup to send to the client browser.</span></span> <span data-ttu-id="b6fb2-245"><xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法呼叫取代<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法如果<xref:System.Web.UI.Adapters.ControlAdapter>物件附加至<xref:System.Web.UI.Control>物件。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-245">The <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method is called in place of the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method if a <xref:System.Web.UI.Adapters.ControlAdapter> object is attached to a <xref:System.Web.UI.Control> object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-246">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別，<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基底方法呼叫<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-246">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-247">因此，覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法應該呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基底方法，只有其處理，而不是，<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-247">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-248">對於複合控制項，配接器開發人員必須確定會呈現子控制項。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-248">For a composite control, the adapter developer must ensure that the child controls are rendered.</span>
            </span>
            <span data-ttu-id="b6fb2-249">如果<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法會使子控制項呈現，但不會產生標記，它可能適用於<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />為了呼叫其基底方法的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-249">If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method.</span>
            </span>
            <span data-ttu-id="b6fb2-250">如果需要特定目標的子控制項的呈現，配接器應該實作<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法，並呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法從<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-250">If target-specific rendering of the child controls is necessary, the adapter should implement the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method and call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="b6fb2-251">
            <see cref="T:System.Web.UI.HtmlTextWriter" />，用來呈現特定目標的輸出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-251">The <see cref="T:System.Web.UI.HtmlTextWriter" /> to use to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b6fb2-252">為複合控制項中的子控制項產生特定目標的標記 (控制項配置器會附加至此複合控制項)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-252">Generates the target-specific markup for the child controls in a composite control to which the control adapter is attached.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-253">覆寫<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>時的個別子控制項的標記，另外產生複合控制項的子控制項集合的特定目標的標記所需的方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-253">Override the <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> method when it is necessary to generate target-specific markup for the child control set of a composite control, in addition to the markup for the individual child controls.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b6fb2-254">當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別，適用於複合控制項，配接器開發人員必須確定會呈現子控制項。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-254">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, for a composite control, the adapter developer must ensure that the child controls are rendered.</span>
            </span>
            <span data-ttu-id="b6fb2-255">如果配接器會覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法，它應該呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法的覆寫從<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-255">If the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method, it should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from an override of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
            <span data-ttu-id="b6fb2-256">如果<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法會使子控制項呈現，但本身不會產生標記，它可能適用於<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法來呼叫其基底方法，它會呼叫<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法，而不是實作的覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b6fb2-256">If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but itself does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method, which calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method, instead of implementing an override for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b6fb2-257">儲存控制項配置器的控制項狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-257">Saves control state information for the control adapter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b6fb2-258">
            <see cref="T:System.Object" />，包含做為 <see cref="T:System.Web.UI.StateBag" /> 的配置器控制狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-258">An <see cref="T:System.Object" /> that contains the adapter's control state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-259">控制項狀態是即使已停用檢視狀態所需的基本狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-259">Control state is the essential state information needed even if view state is disabled.</span></span> <span data-ttu-id="b6fb2-260">當配接器需要維護自己的控制項狀態資訊時，它可以覆寫<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-260">When an adapter needs to maintain its own control state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> methods.</span></span>  
  
 <span data-ttu-id="b6fb2-261">配接器可能需要維持控制項狀態資訊時需要有狀態要求相關聯控制項的狀態分開維護的功能。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-261">An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</span></span> <span data-ttu-id="b6fb2-262">例如，大型的文字顯示和一群組成複合控制項<xref:System.Web.UI.WebControls.RadioButton>控制項可能會呈現為桌上型電腦瀏覽器的單一檢視。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-262">For example, a composite control consisting of a large textual display and a group of <xref:System.Web.UI.WebControls.RadioButton> controls might render as a single view on desktop computer browsers.</span></span> <span data-ttu-id="b6fb2-263">在其他瀏覽器中，它可能會分割成其呈現方式，與另一個則用於選項按鈕群組的文字顯示的單一檢視。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-263">On other browsers, it might split its rendering—one view for the textual display and the other for the radio button group.</span></span> <span data-ttu-id="b6fb2-264">配接器必須維護其本身特定目標的相關資訊目前現用檢視表。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-264">The adapter would need to maintain its own target-specific information about the currently active view.</span></span>  
  
 <span data-ttu-id="b6fb2-265"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法之後，立即呼叫<xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType>方法中的`SaveState`生命週期階段。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-265">The <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> method is called immediately after the <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> method in the `SaveState` lifecycle stage.</span></span> <span data-ttu-id="b6fb2-266">配接器控制狀態是分開的且除了控制項的控制項狀態。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-266">The adapter control state is separate and in addition to the control state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b6fb2-267">儲存控制項配置器的檢視狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-267">Saves view state information for the control adapter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b6fb2-268">
            <see cref="T:System.Object" />，包含當做 <see cref="T:System.Web.UI.StateBag" /> 的配置器檢視狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b6fb2-268">An <see cref="T:System.Object" /> that contains the adapter view state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6fb2-269">當配接器需要維護自己的檢視狀態資訊時，它可以覆寫<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-269">When an adapter needs to maintain its own view state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> methods.</span></span>  
  
 <span data-ttu-id="b6fb2-270">配接器必須跨要求，獨立於控制項相關聯的檢視狀態，必須維護的資料時維持檢視狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-270">An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the associated view state of the control.</span></span> <span data-ttu-id="b6fb2-271">例如，桌上型電腦瀏覽器上的方格控制項可能會轉譯為單一檢視的資料列和資料行的值。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-271">For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</span></span> <span data-ttu-id="b6fb2-272">在其他瀏覽器中，它可能會分割成其轉譯成多個不同檢視的詳細資訊，例如資料列和詳細資料的單一資料列的清單。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-272">On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</span></span> <span data-ttu-id="b6fb2-273">配接器需要維護的資料不在檢視狀態中目前作用中的檢視。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-273">The adapter would need to maintain the data for the views that are not currently active in view state.</span></span>  
  
 <span data-ttu-id="b6fb2-274"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>方法之前，立即呼叫<xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType>方法中的`SaveState`生命週期階段。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-274">The <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> method is called immediately before the <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> method in the `SaveState` lifecycle stage.</span></span> <span data-ttu-id="b6fb2-275">配接器檢視狀態是分開的且除了控制項的檢視狀態。</span><span class="sxs-lookup"><span data-stu-id="b6fb2-275">The adapter view state is separate and in addition to the view state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>