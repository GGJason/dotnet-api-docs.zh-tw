<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="31e3a9db18b7cba85d5901fe816b3124d2f065ba" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30550472" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>為附加配置器的衍生控制項自訂呈現方式，以針對特定瀏覽器修改預設標記或行為，而且此類別為所有控制項配置器繼承來源的基底類別。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制項配接器是可覆寫特定元件<xref:System.Web.UI.Control>類別中，允許瀏覽器或標記特定處理其執行存留週期方法和事件。 .NET Framework 對應至單一衍生的控制項配接器<xref:System.Web.UI.Control>針對每個用戶端要求的物件。  
  
 配接器會修改特定瀏覽器或瀏覽器類別的控制項，或做為某些功能的任何篩選器。 通常由瀏覽器 （例如，XHTML 或 HTML 3.2） 所使用的標記語言定義配接器。 大部分的轉譯行為適應性可以封裝在特製化類別衍生自<xref:System.Web.UI.HtmlTextWriter>類別。 因此，很可能在單一配接器可以用於多個瀏覽器類別行為或在適應性該納入<xref:System.Web.UI.HtmlTextWriter>類別可以讓控制項配接器使用非必要。  
  
 控制項類別的配接器適用於所有控制項都繼承自該類別，除非更具特製化的介面卡。 例如，針對配接器<xref:System.Web.UI.WebControls.BaseValidator>類別可用於所有`Validator`物件。  
  
 配接器通常不會繼承直接從<xref:System.Web.UI.Adapters.ControlAdapter>但其中的目標特定配接器基底類別可提供其他功能的控制項類型和目標瀏覽器專用的類別，或需要特定的轉譯。  
  
 控制項本身不一定需要配接器。 如果控制項可以透過撰寫擴充，通常已足夠子控制項配接器。  
  
 每個控制項具有明確對應到配接器透過.browser 定義檔案。 因此，任何存取<xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType>屬性使用<xref:System.Web.HttpBrowserCapabilities>從對控制項的介面卡的對應執行查閱的瀏覽器定義檔案中擷取的物件。  
  
 在處理期間，.NET Framework 會攔截可能是特定目標控制項的可覆寫方法的呼叫。 如果附加控制項配接器，.NET Framework 會呼叫相關聯的配接器方法。  
  
 配接器會透過控制項執行轉譯<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法。 如果覆寫，<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>可能不應該呼叫基底類別實作，以回到上執行的呼叫，因為<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法。 這可能會發生兩次，一次是由配接器，另一次是由控制項的轉譯。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>基礎方法呼叫<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>控制項的方法。 因此，如果您覆寫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>，您不應該呼叫基底類別實作，除非您實作轉譯除了係由<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>的控制項。  
  
 您必須確定.NET Framework 執行攔截，介面卡的子控制項。 您可以藉由呼叫<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>基底方法，這個方法會呼叫<xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType>方法的控制項，從您<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>覆寫。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>由控制項呼叫方法之前和之後 （分別） 控制呼叫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法。 如果前置和後置轉譯唯一的瀏覽器特定處理工作所需使用<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>可能會導致不必要的覆寫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>。 預設行為<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法是呼叫的對應方法<xref:System.Web.UI.HtmlTextWriter>。  
  
 若要維持其本身的狀態資訊，可以覆寫控制項配接器<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法。 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>私用的控制項和檢視狀態儲存並分別載入時所呼叫。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>base 方法呼叫傳回在相對應<xref:System.Web.UI.Control>類別方法。 因此，任何一項都<xref:System.Web.UI.Adapters.ControlAdapter>會覆寫的方法必須呼叫其基底的方法; 否則此事件相關聯<xref:System.Web.UI.Control>類別方法不會引發。  
  
 選擇性地實作控制項和配接器<xref:System.Web.UI.IPostBackDataHandler>和<xref:System.Web.UI.IPostBackEventHandler>介面。 .NET Framework 會決定配接器是否存在以及是否配接器實作這些介面。 若是如此，配接器應該覆寫<xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>， <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>，和<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>視的方法。 如果無法辨識的回傳資料配接器中，它必須回呼來處理在控制項上。 後續的事件處理常式也必須回呼控制項上。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別，需要一般配接器功能的控制項應該有對應的配接器基底類別，在模式中名為<paramref name="ControlType" /><see langword="Adapter" /> (例如， <see langword="TextBoxAdapter" />)。 配接器應該至少傳回強型別執行個體控制透過其<see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" />屬性。  
  
1.  控制配接器，針對指定的控制項類型和標記語言，應該在模式中名為<paramref name="MarkupControlType" /><see langword="Adapter" /> (例如， <see langword="XhtmlTextBoxAdapter" />)。 控制項的配接器應該在實作<see langword="Adapters" />subnamespace。  
  
 控制項配接器應該繼承自適當的基底類別，並遵循相同的繼承模型為控制項。 例如，從繼承的控制項配接器<see cref="T:System.Web.UI.Control" />基底類別應該繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別或相關<paramref name="ControlType" /><see langword="Adapter" />類別。  
  
 特製化的控制項下的所有裝置節點.browser 組態檔中應定義任何特製化的介面卡。  
  
 確認已連接的介面卡，或附加配接器實作特定介面，不應該假設適當實作的控制項。 相反地，它應該先檢查這些呼叫。  
  
 很可能模擬這類覆寫在控制項中，受保護的事件方法<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法<see cref="T:System.Web.UI.WebControls.LinkButton" />。 首先，建立使用配接器類別<c>OnClick</c>方法。 然後建立新的控制項衍生自<see cref="T:System.Web.UI.WebControls.LinkButton" />並覆寫<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法。 已覆寫<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法呼叫<c>OnClick</c>配接器的方法。 配接器物件是透過受保護<see cref="P:System.Web.UI.Control.Adapter" />屬性<see cref="T:System.Web.UI.Control" />類別。 <see cref="P:System.Web.UI.Control.Adapter" />控制項的屬性是<see langword="null" />沒有相關聯的配接器時，因此任何程式碼應該檢查該條件才可以呼叫方法的介面卡。</para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 內部建構此配接器，它會建立對應時<xref:System.Web.UI.Control>物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">包含呈現特定目標輸出方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>在呈現控制項之前呼叫。 在衍生的配置器類別中，產生特定目標所需的開頭標記 (而非 HTML 瀏覽器所需)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法呼叫之前<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法，並用來執行特定目標的前置處理控制項的呈現之前。  
  
 使用<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法搭配<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法，以確保開頭和結尾標記的一致性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基底方法呼叫<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />方法。 因此，會覆寫的<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />方法應該呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基底方法，只有當它處理，而不是而不是<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />方法。</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得對用戶端瀏覽器功能的參考 (此用戶端是發出目前 HTTP 要求的用戶端)。</summary>
        <value>
          <see cref="T:System.Web.HttpBrowserCapabilities" />，指定用戶端瀏覽器和標記功能。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Web.UI.Adapters.ControlAdapter>物件可判斷從用戶端瀏覽器功能<xref:System.Web.HttpBrowserCapabilities>所傳回的物件<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>屬性。 這可讓<xref:System.Web.UI.Adapters.ControlAdapter>物件來呈現瀏覽器特定標記，或修改的行為<xref:System.Web.UI.Control>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>屬性來存取要求的瀏覽器的詳細資料。 在此範例中，程式碼會檢查以判斷是否瀏覽器相容於 JavaScript 中，然後讓開發人員在此情況下呈現自訂的輸出。  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得控制項的參考 (指控制項配置器附加的控制項)。</summary>
        <value>
          <see cref="T:System.Web.UI.Control" /> 所附加的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當在衍生的控制項配接器附加至控制項時，.NET Framework 會呼叫特定配接器成員，而不是控制項的成員。  
  
   
  
## Examples  
 下列程式碼範例示範如何衍生的自訂控制項<xref:System.Web.UI.Control>類別，並再建立對應的配接器，繼承自<xref:System.Web.UI.Adapters.ControlAdapter>類別。 配接器會覆寫<xref:System.Web.UI.Adapters.ControlAdapter.Control%2A>屬性，並傳回控制項的強型別參考。  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別，最少，您應該實作<see langword="Control" />屬性來傳回強型別執行個體控制項的範例 &gt; 一節中所示。</para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為複合控制項建立特定目標的子控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有衍生的控制項配接器會附加到<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>會覆寫方法，而不是呼叫覆寫<xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType>方法。 因此，<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>可以用來建立特定目標的子控制項集合。  
  
 如需結合控制項來建立新的控制項的詳細資訊，請參閱[複合控制項](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您建立繼承的類別並覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />方法時，請勿呼叫基底方法，除非您想要將控制項加入至這些方法所建立的基底。 否則您無法建立兩個集合的子控制項。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">包含呈現特定目標輸出方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>在呈現控制項之後呼叫。 在衍生的配置器類別中，產生特定目標所需的結尾標記 (而非 HTML 瀏覽器所需)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>之後立即呼叫方法<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法，以及用來呈現控制項之後，執行特定目標的後置處理。  
  
 使用<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法搭配<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法，以確保開頭和結尾標記的一致性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基底方法呼叫<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />方法。 因此，會覆寫的<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />方法應該呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基底方法，只有當它處理，而不是而不是<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />方法。</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" />，包含做為 <see cref="T:System.Web.UI.StateBag" /> 的配置器控制狀態資訊。</param>
        <summary>載入之前在對頁面發出要求的期間由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> 所儲存的配置器控制項狀態資訊 (與此控制項配置器相關聯的控制項便存在於此頁面中)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制項狀態是即使已停用檢視狀態所需的基本狀態資訊。 當配接器需要維護自己的控制項狀態資訊時，它可以覆寫<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法。  
  
 配接器可能需要的功能，必須先要求，針對關聯控制項的狀態分開維護的狀態時，維持控制項狀態資訊。 例如，大型的文字顯示和一群組成複合控制項<xref:System.Web.UI.WebControls.RadioButton>控制項可能會呈現為單一的桌上型電腦瀏覽器檢視。 在其他瀏覽器，它可能會分隔其轉譯，用於文字顯示，選項按鈕群組的另一個檢視。 配接器需要維護自己特定目標的相關資訊的目前作用中的檢視。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>方法之後，立即呼叫<xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType>方法，請在`LoadState`生命週期階段。 配接器控制狀態是分離的而且除了控制項的控制項狀態。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" />，包含當做 <see cref="T:System.Web.UI.StateBag" /> 的配置器檢視狀態資訊。</param>
        <summary>載入之前在對頁面發出要求的期間由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> 所儲存的配置器檢視狀態資訊 (與此控制項配置器相關聯的控制項便存在於此頁面中)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當配接器需要維護自己的檢視狀態資訊時，它可以覆寫<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>方法。  
  
 配接器必須維護資料所必須維持在要求中，獨立於針對關聯控制項的檢視狀態時的檢視狀態資訊。 比方說，在桌面的電腦瀏覽器上的方格控制項可能會呈現為單一檢視的資料列和資料行的值。 在其他瀏覽器，它可能會分隔其轉譯為多個不同的檢視，例如資料列和詳細資料的單一資料列的清單。 配接器必須維持的目前都沒有作用中檢視狀態的檢視資料。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法之前，立即呼叫<xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType>方法中的`LoadState`生命週期階段。 配接器檢視狀態是分離的而且除了控制項的檢視狀態。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>為關聯控制項覆寫 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有配接器會附加到<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>會覆寫方法，而不是呼叫覆寫方法<xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType>方法。  
  
 覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>執行中的特定目標處理`Initialize`控制項週期的階段。 一般來說，這些是在建立控制項時執行的函式。  
  
   
  
## Examples  
 下列程式碼範例是衍生的自訂控制項配接器從<xref:System.Web.UI.Adapters.ControlAdapter>類別。 它接著會覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>方法相關聯的控制項上設定屬性，並呼叫基底方法，以完成初始化控制項。  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別和介面卡覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />方法時，配接器必須呼叫對應的基底類別方法，也就會呼叫<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />方法。 如果<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />不會呼叫方法，<see cref="E:System.Web.UI.Control.Init" />不會引發事件。</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>為關聯控制項覆寫 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有配接器會附加到<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>會覆寫方法，而不是呼叫覆寫方法<xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType>方法。  
  
 覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>方法，以執行中的特定目標處理`Load`控制項週期的階段。 一般來說，這些是應該為每個用戶端要求執行的函式。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別和介面卡覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />方法時，配接器必須呼叫對應的基底類別方法，也就會呼叫<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />方法。 如果<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />不呼叫<see cref="E:System.Web.UI.Control.Load" />不會引發事件。</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>為關聯控制項覆寫 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有配接器會附加到<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>會覆寫方法，而不是呼叫覆寫方法<xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType>方法。  
  
 覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>方法，以執行中的特定目標處理`PreRender`控制項週期的階段。 一般來說，這些是緊接在之前的控制輸出轉譯的函式。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別和介面卡覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />方法時，配接器必須呼叫對應的基底類別方法，也就會呼叫<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />方法。 如果<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />不會呼叫方法，<see cref="E:System.Web.UI.Control.PreRender" />不會引發事件。</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>為關聯控制項覆寫 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有配接器會附加到<xref:System.Web.UI.Control>物件和<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>會覆寫方法，而不是呼叫覆寫方法<xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType>方法。  
  
 覆寫<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>方法執行特定目標處理`Unload`控制項週期的階段。 一般來說，這些是配置控制項的前面清除函式。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別和介面卡覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />方法時，配接器必須呼叫對應的基底類別方法，也就會呼叫<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />方法。 如果<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />不呼叫<see cref="E:System.Web.UI.Control.Unload" />不會引發事件。</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得對頁面的參考 (與此配置器相關聯的控制項便存在於此頁面中)。</summary>
        <value>
          <see cref="T:System.Web.UI.Page" />，可提供頁面執行個體的存取 (相關聯的控制項便存在於此執行個體中)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A>屬性可存取<xref:System.Web.UI.Page?displayProperty=nameWithType>其中平均分攤工作量控制項的物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得對此頁的頁面配置器的參考 (關聯的控制項便存在於此頁面中)。</summary>
        <value>頁面的 <see cref="T:System.Web.UI.Adapters.PageAdapter" />，與目前 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 相關聯的控制項便存在於此頁面中。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>屬性可存取<xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType>物件<xref:System.Web.UI.Page>物件其中<xref:System.Web.UI.Control>目前相關聯的物件<xref:System.Web.UI.Adapters.ControlAdapter>物件平均分攤工作量。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>屬性可以用來存取層級頁面配接器，例如可以套用到幾個頁面上的控制項類型的一般特定目標函數的其他項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" />，用來呈現特定目標的輸出。</param>
        <summary>為附加控制項配接器的控制項，產生目標特定的標記。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法來產生用戶端瀏覽器所傳送的特定目標的標記。 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法呼叫取代<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法如果<xref:System.Web.UI.Adapters.ControlAdapter>物件附加至<xref:System.Web.UI.Control>物件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基底方法呼叫<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法。 因此，會覆寫的<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法應該呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基底方法，只有當它處理，而不是而不是<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法。  
  
 複合控制項，配接器開發人員必須確定會轉譯子控制項。 如果<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法會使子系来呈現控制項，但不會產生標記，它可能適用於<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法來呼叫其基底的方法。 如果有必要的子控制項的特定目標的轉譯，配接器應該實作<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法，並呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法從<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" />，用來呈現特定目標的輸出。</param>
        <summary>為複合控制項中的子控制項產生特定目標的標記 (控制項配置器會附加至此複合控制項)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>方法時必須產生目標特定的標記，子控制項集合的複合控制項，此外至個別子控制項的標記。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您繼承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />類別，可用於複合控制項，配接器開發人員必須確定會轉譯子控制項。 如果配接器會覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法，它應該呼叫<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法的覆寫從<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法。  
  
 如果<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法會使子系来呈現控制項，但本身不會產生標記，它可能適用於<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法來呼叫其基底方法，呼叫<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法，而不是實作的覆寫<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>儲存控制項配置器的控制項狀態資訊。</summary>
        <returns>
          <see cref="T:System.Object" />，包含做為 <see cref="T:System.Web.UI.StateBag" /> 的配置器控制狀態資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制項狀態是即使已停用檢視狀態所需的基本狀態資訊。 當配接器需要維護自己的控制項狀態資訊時，它可以覆寫<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>方法。  
  
 配接器可能需要的功能，必須先要求，針對關聯控制項的狀態分開維護的狀態時，維持控制項狀態資訊。 例如，大型的文字顯示和一群組成複合控制項<xref:System.Web.UI.WebControls.RadioButton>控制項可能會呈現為單一的桌上型電腦瀏覽器檢視。 在其他瀏覽器，它可能會分隔其轉譯，用於文字顯示，選項按鈕群組的另一個檢視。 配接器需要維護自己特定目標的相關資訊的目前作用中的檢視。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法之後，立即呼叫<xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType>方法中的`SaveState`生命週期階段。 配接器控制狀態是分離的而且除了控制項的控制項狀態。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>儲存控制項配置器的檢視狀態資訊。</summary>
        <returns>
          <see cref="T:System.Object" />，包含當做 <see cref="T:System.Web.UI.StateBag" /> 的配置器檢視狀態資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當配接器需要維護自己的檢視狀態資訊時，它可以覆寫<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法。  
  
 配接器必須維護資料所必須維持在要求中，獨立於控制項的相關聯的檢視狀態時的檢視狀態資訊。 比方說，在桌面的電腦瀏覽器上的方格控制項可能會呈現為單一檢視的資料列和資料行的值。 在其他瀏覽器，它可能會分隔其轉譯為多個不同的檢視，例如資料列和詳細資料的單一資料列的清單。 配接器必須維持的目前都沒有作用中檢視狀態的檢視資料。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>方法之前，立即呼叫<xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType>方法中的`SaveState`生命週期階段。 配接器檢視狀態是分離的而且除了控制項的檢視狀態。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>