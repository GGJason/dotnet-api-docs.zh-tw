<Type Name="MulticastDelegate" FullName="System.MulticastDelegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6fdbedc3959661d0e9024fadaac7a16ec166238f" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39809630" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MulticastDelegate : Delegate" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MulticastDelegate extends System.Delegate" />
  <TypeSignature Language="DocId" Value="T:System.MulticastDelegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MulticastDelegate&#xA;Inherits Delegate" />
  <TypeSignature Language="C++ CLI" Value="public ref class MulticastDelegate abstract : Delegate" />
  <TypeSignature Language="F#" Value="type MulticastDelegate = class&#xA;    inherit Delegate" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="857af-101">表示多點傳送委派；也就是說，委派可以在它的引動過程清單中包含一個以上的項目。</span>
      <span class="sxs-lookup">
        <span data-stu-id="857af-101">Represents a multicast delegate; that is, a delegate that can have more than one element in its invocation list.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-102"><xref:System.MulticastDelegate> 是一個特殊的類別。</span><span class="sxs-lookup"><span data-stu-id="857af-102"><xref:System.MulticastDelegate> is a special class.</span></span> <span data-ttu-id="857af-103">編譯器和其他工具可以衍生自這個類別中，但無法從它衍生明確。</span><span class="sxs-lookup"><span data-stu-id="857af-103">Compilers and other tools can derive from this class, but you cannot derive from it explicitly.</span></span> <span data-ttu-id="857af-104">也是如此的<xref:System.Delegate>類別。</span><span class="sxs-lookup"><span data-stu-id="857af-104">The same is true of the <xref:System.Delegate> class.</span></span>  
  
 <span data-ttu-id="857af-105">除了委派類型的方法繼承自<xref:System.MulticastDelegate>，common language runtime 提供兩種特殊的方法：`BeginInvoke`和`EndInvoke`。</span><span class="sxs-lookup"><span data-stu-id="857af-105">In addition to the methods that delegate types inherit from <xref:System.MulticastDelegate>, the common language runtime provides two special methods: `BeginInvoke` and `EndInvoke`.</span></span> <span data-ttu-id="857af-106">如需這些方法的詳細資訊，請參閱[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="857af-106">For more information about these methods, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 <span data-ttu-id="857af-107">A<xref:System.MulticastDelegate>具有委派，呼叫的引動過程清單，其中包含一或多個項目連結的清單。</span><span class="sxs-lookup"><span data-stu-id="857af-107">A <xref:System.MulticastDelegate> has a linked list of delegates, called an invocation list, consisting of one or more elements.</span></span> <span data-ttu-id="857af-108">叫用多點傳送的委派時，引動過程清單中的委派會以同步方式呼叫它們出現的順序。</span><span class="sxs-lookup"><span data-stu-id="857af-108">When a multicast delegate is invoked, the delegates in the invocation list are called synchronously in the order in which they appear.</span></span> <span data-ttu-id="857af-109">如果在清單的執行期間發生的錯誤會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="857af-109">If an error occurs during execution of the list then an exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="857af-110">下列範例會定義一個類別， `StringContainer`，其中包含字串的集合。</span><span class="sxs-lookup"><span data-stu-id="857af-110">The following example defines a class, `StringContainer`, which includes a collection of strings.</span></span> <span data-ttu-id="857af-111">其中一個成員是`CheckAndDisplayDelegate`委派，用來顯示字串儲存在`StringContainer`符合特定準則的物件。</span><span class="sxs-lookup"><span data-stu-id="857af-111">One of its members is the `CheckAndDisplayDelegate` delegate, which is used to display strings stored in a `StringContainer` object that satisfy particular criteria.</span></span> <span data-ttu-id="857af-112">委派會接受單一字串做為參數，並傳回`void`(或在 Visual Basic 中是`Sub`程序)。</span><span class="sxs-lookup"><span data-stu-id="857af-112">The delegate takes a single string as a parameter and returns `void` (or, in Visual Basic, it's a `Sub` procedure).</span></span> <span data-ttu-id="857af-113">它也包含一個方法中， `DisplayAllQualified`，具有單一參數，`CheckAndDisplayDelegate`委派。</span><span class="sxs-lookup"><span data-stu-id="857af-113">It also includes a method, `DisplayAllQualified`, that has a single parameter, a `CheckAndDisplayDelegate` delegate.</span></span> <span data-ttu-id="857af-114">這可讓被呼叫的方法，並顯示一組經過篩選的字串以包含委派的方法。</span><span class="sxs-lookup"><span data-stu-id="857af-114">This allows the method to be called and to display a set of strings that are filtered based on the methods that the delegate contains.</span></span>  
  
 <span data-ttu-id="857af-115">此範例也會定義公用程式類別， `StringExtensions`，，有兩種方法：</span><span class="sxs-lookup"><span data-stu-id="857af-115">The example also defines a utility class, `StringExtensions`, that has two methods:</span></span>  
  
-   <span data-ttu-id="857af-116">`ConStart`其中顯示字串開頭的子音。</span><span class="sxs-lookup"><span data-stu-id="857af-116">`ConStart`, which displays strings that begin with a consonant.</span></span>  
  
-   <span data-ttu-id="857af-117">`VowelStart`其中顯示以母音開頭的字串。</span><span class="sxs-lookup"><span data-stu-id="857af-117">`VowelStart`, which displays strings that begin with a vowel.</span></span>  
  
 <span data-ttu-id="857af-118">請注意，這兩種方法包含單一字串參數，並傳回`void`。</span><span class="sxs-lookup"><span data-stu-id="857af-118">Note that both methods include a single string parameter and return `void`.</span></span> <span data-ttu-id="857af-119">換句話說，這兩種方法可以指派給`CheckAndDisplayDelegate`委派。</span><span class="sxs-lookup"><span data-stu-id="857af-119">In other words, both methods can be assigned to the  `CheckAndDisplayDelegate` delegate.</span></span>  
  
 <span data-ttu-id="857af-120">`Test.Main`方法是應用程式進入點。</span><span class="sxs-lookup"><span data-stu-id="857af-120">The `Test.Main` method is the application entry point.</span></span> <span data-ttu-id="857af-121">它會具現化`StringContainer`物件，填入該字串，且會建立兩個`CheckAndDisplayDelegate`委派`conStart`和`vowelStart`，叫用單一方法。</span><span class="sxs-lookup"><span data-stu-id="857af-121">It instantiates a `StringContainer` object, populates it with strings, and creates two `CheckAndDisplayDelegate` delegates, `conStart` and `vowelStart`, that invoke a single method.</span></span> <span data-ttu-id="857af-122">然後它會呼叫<xref:System.Delegate.Combine%2A?displayProperty=nameWithType>方法用來建立`multipleDelegates`委派，其中一開始包含`ConStart`和`VowelStart`委派。</span><span class="sxs-lookup"><span data-stu-id="857af-122">It then calls the <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> method to create the `multipleDelegates` delegate, which initially contains the `ConStart` and  `VowelStart` delegates.</span></span> <span data-ttu-id="857af-123">請注意，當`multipleDelegates`叫用委派時，它會顯示以原始順序集合中的所有字串。</span><span class="sxs-lookup"><span data-stu-id="857af-123">Note that when the `multipleDelegates` delegate is invoked, it displays all the strings in the collection in their original order.</span></span> <span data-ttu-id="857af-124">這是因為每個字母個別傳遞給每個委派，且每個字母符合篩選準則時的兩個委派的其中之一。</span><span class="sxs-lookup"><span data-stu-id="857af-124">This is because each letter is passed separately to each delegate, and each letter meets the filtering criteria of only one of the two delegates.</span></span> <span data-ttu-id="857af-125">最後，在呼叫<xref:System.Delegate.Remove%2A?displayProperty=nameWithType>並<xref:System.Delegate.Combine%2A?displayProperty=nameWithType>，`multipleDelegates`包含兩個`conStart`委派。</span><span class="sxs-lookup"><span data-stu-id="857af-125">Finally, after calls to <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> and <xref:System.Delegate.Combine%2A?displayProperty=nameWithType>, `multipleDelegates` contains two `conStart` delegates.</span></span> <span data-ttu-id="857af-126">它叫用時，在每個字串`StringContainer`物件會顯示兩次。</span><span class="sxs-lookup"><span data-stu-id="857af-126">When it is invoked, each string in the `StringContainer` object is displayed twice.</span></span>  
  
 [!code-cpp[Multicast Delegate Introduction#1](~/samples/snippets/cpp/VS_Snippets_CLR/Multicast Delegate Introduction/CPP/delegatestring.cpp#1)]
 [!code-csharp[Multicast Delegate Introduction#1](~/samples/snippets/csharp/VS_Snippets_CLR/Multicast Delegate Introduction/CS/delegatestring.cs#1)]
 [!code-vb[Multicast Delegate Introduction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Multicast Delegate Introduction/VB/delegatestring.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="857af-127">初始化 <see cref="T:System.MulticastDelegate" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-127">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MulticastDelegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MulticastDelegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new MulticastDelegate : obj * string -&gt; MulticastDelegate" Usage="new System.MulticastDelegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="857af-128">物件，在此定義「方法」<c></c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-128">The object on which <c>method</c> is defined.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="857af-129">建立委派的方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-129">The name of the method for which a delegate is created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="857af-130">初始化 <see cref="T:System.MulticastDelegate" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-130">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-131">這個建構函式不能在應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="857af-131">This constructor cannot be used in application code.</span></span> <span data-ttu-id="857af-132">若要建立委派，藉由指定的執行個體方法名稱，使用的多載<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>指定方法名稱和目標物件的方法。</span><span class="sxs-lookup"><span data-stu-id="857af-132">To create a delegate by specifying the name of an instance method, use an overload of the <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> method that specifies a method name and a target object.</span></span> <span data-ttu-id="857af-133">比方說，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29?displayProperty=nameWithType>方法多載會建立具有指定名稱的執行個體方法的委派。</span><span class="sxs-lookup"><span data-stu-id="857af-133">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29?displayProperty=nameWithType> method overload creates a delegate for an instance method with a specified name.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-134">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-134">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-135">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-135">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-136">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-136">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MulticastDelegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MulticastDelegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new MulticastDelegate : Type * string -&gt; MulticastDelegate" Usage="new System.MulticastDelegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="857af-137">物件類型，在此定義「方法」<c></c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-137">The type of object on which <c>method</c> is defined.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="857af-138">建立委派的靜態 (Static) 方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-138">The name of the static method for which a delegate is created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="857af-139">初始化 <see cref="T:System.MulticastDelegate" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-139">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-140">這個建構函式不能在應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="857af-140">This constructor cannot be used in application code.</span></span> <span data-ttu-id="857af-141">若要建立委派，藉由指定的靜態方法名稱，使用的多載<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>指定方法名稱，但未指定目標物件的方法。</span><span class="sxs-lookup"><span data-stu-id="857af-141">To create a delegate by specifying the name of a static method, use an overload of the <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> method that specifies a method name but does not specify a target object.</span></span> <span data-ttu-id="857af-142">比方說，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29?displayProperty=nameWithType>方法多載會建立具有指定名稱的靜態方法的委派。</span><span class="sxs-lookup"><span data-stu-id="857af-142">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29?displayProperty=nameWithType> method overload creates a static delegate for a method with a specified name.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-143">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-143">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-144">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-144">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-145">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-145">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected override sealed Delegate CombineImpl (Delegate follow);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Delegate CombineImpl(class System.Delegate follow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CombineImpl (follow As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Delegate ^ CombineImpl(Delegate ^ follow);" />
      <MemberSignature Language="F#" Value="override this.CombineImpl : Delegate -&gt; Delegate" Usage="multicastDelegate.CombineImpl follow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="follow" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="follow">
          <span data-ttu-id="857af-146">要和這個委派結合的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-146">The delegate to combine with this delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="857af-147">結合這個 <see cref="T:System.Delegate" /> 和指定的 <see cref="T:System.Delegate" />，形成新的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-147">Combines this <see cref="T:System.Delegate" /> with the specified <see cref="T:System.Delegate" /> to form a new delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="857af-148">委派，為 <see cref="T:System.MulticastDelegate" /> 引動過程清單的新根目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-148">A delegate that is the new root of the <see cref="T:System.MulticastDelegate" /> invocation list.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="857af-149">
            <paramref name="follow" /> 與這個執行個體的型別不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-149">
              <paramref name="follow" /> does not have the same type as this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-150">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-150">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-151">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-151">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-152">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-152">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected override sealed object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="multicastDelegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="multicastDelegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="857af-153">與這個執行個體相互比較的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-153">The object to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="857af-154">判斷這個多點傳送委派和指定的物件是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-154">Determines whether this multicast delegate and the specified object are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="857af-155">如果 <paramref name="obj" /> 和這個執行個體 (Instance) 具有相同的引動過程清單，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-155">
              <see langword="true" /> if <paramref name="obj" /> and this instance have the same invocation lists; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-156">兩個委派是否相等，如果沒有`null`而完全相同的類型，其引動過程清單包含相同數目的項目，而且每個項目中的第一個委派引動過程清單等於對應的項目引動過程中第二個委派的清單。</span><span class="sxs-lookup"><span data-stu-id="857af-156">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="857af-157">兩個引動過程清單項目相等，如果叫用相同的執行個體方法，在相同的目標執行個體，或叫用相同的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="857af-157">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-158">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-158">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-159">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-159">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-160">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-160">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="multicastDelegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="857af-161">傳回這個執行個體的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-161">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="857af-162">32 位元帶正負號的整數雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-162">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-163">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-163">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-164">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-164">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-165">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-165">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public override sealed Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="override this.GetInvocationList : unit -&gt; Delegate[]" Usage="multicastDelegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="857af-166">依照引動過程的順序，傳回這個多點傳送委派的引動過程清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-166">Returns the invocation list of this multicast delegate, in invocation order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="857af-167">委派陣列，其引動過程清單完全符合這個執行個體的引動過程清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-167">An array of delegates whose invocation lists collectively match the invocation list of this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-168">陣列包含一組代理人，各有一個項目引動過程清單。</span><span class="sxs-lookup"><span data-stu-id="857af-168">The array contains a set of delegates, each with an invocation list of one entry.</span></span> <span data-ttu-id="857af-169">在陣列中出現的順序以循序方式，叫用這些委派，會產生與叫用目前的執行個體相同的結果。</span><span class="sxs-lookup"><span data-stu-id="857af-169">Invoking these delegates sequentially, in the order they appear in the array, produces the same results as invoking the current instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-170">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-170">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-171">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-171">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-172">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-172">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="multicastDelegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="857af-173">傳回目前 <see cref="T:System.MulticastDelegate" /> 所表示的靜態方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-173">Returns a static method represented by the current <see cref="T:System.MulticastDelegate" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="857af-174">目前 <see cref="T:System.MulticastDelegate" /> 所表示的靜態方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-174">A static method represented by the current <see cref="T:System.MulticastDelegate" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-175">如果<xref:System.MulticastDelegate>代表多個方法，只有一個方法會傳回。</span><span class="sxs-lookup"><span data-stu-id="857af-175">If the <xref:System.MulticastDelegate> represents multiple methods, only one method is returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public override void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="multicastDelegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="857af-176">物件，其保有序列化或還原序列化這個執行個體所需的所有資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-176">An object that holds all the data needed to serialize or deserialize this instance.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="857af-177">(保留) 位置，序列化資料在此儲存和擷取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-177">(Reserved) The location where serialized data is stored and retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="857af-178">使用所有序列化這個執行個體所需的資料，填入 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-178">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with all the data needed to serialize this instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-179">此方法將儲存中的所有資訊`info`必要序列化這個執行個體。</span><span class="sxs-lookup"><span data-stu-id="857af-179">This method stores all the information in `info` necessary to serialize this instance.</span></span>  
  
 <span data-ttu-id="857af-180">`context`參數已保留，目前未使用這個方法的執行中。</span><span class="sxs-lookup"><span data-stu-id="857af-180">The `context` parameter is reserved and is not currently used in the execution of this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="857af-181">
            <paramref name="info" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-181">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-182">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-182">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <span data-ttu-id="857af-183">發生序列化錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-183">A serialization error occurred.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="857af-184">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-184">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="857af-185">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-185">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (MulticastDelegate d1, MulticastDelegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.MulticastDelegate d1, class System.MulticastDelegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As MulticastDelegate, d2 As MulticastDelegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(MulticastDelegate ^ d1, MulticastDelegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : MulticastDelegate * MulticastDelegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.MulticastDelegate" />
        <Parameter Name="d2" Type="System.MulticastDelegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="857af-186">左運算元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-186">The left operand.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="857af-187">右運算元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-187">The right operand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="857af-188">判斷兩個 <see cref="T:System.MulticastDelegate" /> 物件是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-188">Determines whether two <see cref="T:System.MulticastDelegate" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="857af-189">如果 <paramref name="d1" /> 和 <paramref name="d2" /> 具有相同的引動過程清單，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-189">
              <see langword="true" /> if <paramref name="d1" /> and <paramref name="d2" /> have the same invocation lists; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-190">兩個委派是否相等，如果沒有`null`而完全相同的類型，其引動過程清單包含相同數目的項目，而且每個項目中的第一個委派引動過程清單等於對應的項目引動過程中第二個委派的清單。</span><span class="sxs-lookup"><span data-stu-id="857af-190">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="857af-191">兩個引動過程清單項目相等，如果叫用相同的執行個體方法，在相同的目標執行個體，或叫用相同的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="857af-191">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 <span data-ttu-id="857af-192">這個運算子的對等方法是 <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="857af-192">The equivalent method for this operator is <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-193">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-193">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-194">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-194">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-195">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-195">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (MulticastDelegate d1, MulticastDelegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.MulticastDelegate d1, class System.MulticastDelegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As MulticastDelegate, d2 As MulticastDelegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(MulticastDelegate ^ d1, MulticastDelegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : MulticastDelegate * MulticastDelegate -&gt; bool" Usage="System.MulticastDelegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.MulticastDelegate" />
        <Parameter Name="d2" Type="System.MulticastDelegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="857af-196">左運算元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-196">The left operand.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="857af-197">右運算元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-197">The right operand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="857af-198">判斷兩個 <see cref="T:System.MulticastDelegate" /> 物件是否不相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-198">Determines whether two <see cref="T:System.MulticastDelegate" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="857af-199">如果 <paramref name="d1" /> 和 <paramref name="d2" /> 不具有相同的引動過程清單，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-199">
              <see langword="true" /> if <paramref name="d1" /> and <paramref name="d2" /> do not have the same invocation lists; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="857af-200">兩個委派是否相等，如果沒有`null`而完全相同的類型，其引動過程清單包含相同數目的項目，而且每個項目中的第一個委派引動過程清單等於對應的項目引動過程中第二個委派的清單。</span><span class="sxs-lookup"><span data-stu-id="857af-200">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="857af-201">兩個引動過程清單項目相等，如果叫用相同的執行個體方法，在相同的目標執行個體，或叫用相同的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="857af-201">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 <span data-ttu-id="857af-202">這個運算子的對等方法是 <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="857af-202">The equivalent method for this operator is <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-203">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-203">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-204">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-204">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-205">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-205">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected override sealed Delegate RemoveImpl (Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Delegate RemoveImpl(class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function RemoveImpl (value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Delegate ^ RemoveImpl(Delegate ^ value);" />
      <MemberSignature Language="F#" Value="override this.RemoveImpl : Delegate -&gt; Delegate" Usage="multicastDelegate.RemoveImpl value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="857af-206">要在引動過程清單中搜尋的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-206">The delegate to search for in the invocation list.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="857af-207">從這個 <see cref="T:System.MulticastDelegate" /> 的引動過程清單中，移除和指定委派相等的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-207">Removes an element from the invocation list of this <see cref="T:System.MulticastDelegate" /> that is equal to the specified delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="857af-208">如果在這個執行個體的引動過程清單中找到 <paramref name="value" />，則傳回引動過程清單中沒有 <paramref name="value" /> 的新 <see cref="T:System.Delegate" />，否則，傳回含有原始引動過程清單的這個執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-208">If <paramref name="value" /> is found in the invocation list for this instance, then a new <see cref="T:System.Delegate" /> without <paramref name="value" /> in its invocation list; otherwise, this instance with its original invocation list.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="857af-209">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-209">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="857af-210">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-210">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="857af-211">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="857af-211">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>