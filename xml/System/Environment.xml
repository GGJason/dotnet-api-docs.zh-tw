<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f389208b4c100fb447ca4f609328ce6c8e24ad11" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51923934" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供有關目前環境和平台的資訊，以及操作的方法。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Environment>類別來擷取自上次系統開機，以及通用語言執行平台版本命令列引數、 結束代碼、 環境變數設定、 內容的呼叫堆疊、 時間等資訊。  
  
   
  
## Examples  
 下列範例示範會顯示一份目前環境的相關資訊。  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理程序的命令列。</summary>
        <value>含有命令列引數的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性可存取的程式名稱和目前的處理序啟動時，在命令列上指定任何引數。  
  
 程式名稱可以包含路徑資訊，但不需要執行這項操作。 使用<xref:System.Environment.GetCommandLineArgs%2A>剖析方法來擷取命令列的資訊，並儲存在陣列中的字串。  
  
 指定的數字的字元; 未設定的命令列的緩衝區大小上限Windows 作業系統的電腦上執行而有所不同。  
  
   
  
## Examples  
 下列範例會顯示它自己的命令列。  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">針對至 PATH 環境變數的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前工作目錄的完整路徑。</summary>
        <value>含有目錄路徑的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據定義，如果此程序啟動的本機目錄的根目錄或網路磁碟機，此屬性的值是後面接著斜線的磁碟機名稱 (例如，"c:\\")。 如果此程序啟動的子目錄中，這個屬性的值會是磁碟機和子目錄的路徑，不含尾端斜線 (比方說，「 C:\mySubDirectory")。  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Environment.CurrentDirectory%2A>屬性。  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">嘗試設定為空字串 ("")。</exception>
        <exception cref="T:System.ArgumentNullException">嘗試設定為 <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">嘗試設定找不到的本機路徑。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有適當的權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用於寫入至檔案或設定作業中的目錄。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身在 get 作業中的資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 Managed 執行緒的唯一識別項。</summary>
        <value>整數，表示這個 Managed 執行緒的唯一識別項。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">要傳回作業系統的結束代碼。 使用 0 (零) 表示處理程序已順利完成。</param>
        <summary>結束這個處理序，並傳回結束代碼給作業系統。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對`exitCode`參數，使用非零數值則表示錯誤。 在您的應用程式中，您可以列舉型別，定義您自己的錯誤碼，並傳回根據案例的適當的錯誤程式碼。 例如，傳回值為 1，表示所需的檔案不存在，，值為 2，表示檔案是格式錯誤。 如需 Windows 作業系統所使用的結束代碼，請參閱[System Error Codes](https://msdn.microsoft.com/library/ms681381.aspx) Windows 文件中。  
  
 呼叫<xref:System.Environment.Exit%2A>方法不同於使用您的程式語言`return`如下的陳述式：  
  
-   <xref:System.Environment.Exit%2A> 一律會終止應用程式。 使用`return`陳述式可能會結束的應用程式，只有當它用於在應用程式的進入點，例如`Main`方法。  
  
-   <xref:System.Environment.Exit%2A> 應用程式會立即終止，即使其他執行緒正在執行。 如果`return`陳述式會呼叫應用程式進入點中，卻會導致應用程式只在所有前景執行緒都已都結束之後終止。  
  
-   <xref:System.Environment.Exit%2A> 呼叫者必須具備權限呼叫 unmanaged 程式碼。 `return`陳述式並不會。  
  
-   如果<xref:System.Environment.Exit%2A>會從呼叫`try`或是`catch`封鎖，請在任何程式碼`finally`區塊不會執行。 如果`return`陳述式使用時中的程式碼`finally`區塊未執行。  
  
-   如果<xref:System.Environment.Exit%2A>時，會呼叫中的程式碼[限制的執行區域](~/docs/framework/performance/constrained-execution-regions.md)(CER) 正在執行時，CER 無法完成執行。 如果`return`陳述式時，CER 完成執行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有足夠的安全性權限執行這項功能。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定處理程序的結束代碼。</summary>
        <value>含有結束代碼的 32 位元帶正負號的整數 (Signed Integer)。 預設值為 0 (零)，表示處理程序順利完成。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Main`方法會傳回`void`，您可以使用這個屬性，若要設定將會傳回給呼叫環境的結束代碼。 如果`Main`不會傳回`void`，會忽略這個屬性。 這個屬性的初始值為零。  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A>屬性是帶正負號的 32 位元整數。 若要避免屬性傳回非負數的結束代碼，您不應該使用值大於或等於為 0x80000000。  
  
 使用非零值表示錯誤。 在您的應用程式中，您可以列舉型別，定義您自己的錯誤碼，並傳回根據案例的適當的錯誤程式碼。 例如，傳回值為 1，表示所需的檔案不存在，值為 2，表示檔案是格式錯誤。 如需 Windows 作業系統所使用的結束代碼，請參閱[System Error Codes](https://msdn.microsoft.com/library/ms681381\(v=vs.85\)) Windows 文件中。  
  
   
  
## Examples  
 以下是簡單的應用程式，名為 Double.exe，做為命令列引數傳遞給它的整數值加倍。 值會指派到的錯誤代碼<xref:System.Environment.ExitCode%2A>屬性來指出錯誤情況。 請注意，您必須新增 System.Numerics.dll 組件，若要成功編譯範例的參考。  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 此範例可以接著叫用批次檔，如下所示，使用，讓其錯誤碼可存取`ERRORLEVEL`命令。  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 以下顯示某些產生叫用批次檔的範例輸出。  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Double.exe 為與下列範例中，函式相同，不同之處在於前者會定義名為進入點，請注意該程式碼`Main`，沒有任何傳回值，而這個範例會定義名為進入點`Main`，傳回一個整數。  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">含有零或多個環境變數名稱的字串。 每個環境變數會以百分比符號字元 (%) 括住。</param>
        <summary>用變數值的等值字串來取代內嵌於指定字串內的每個環境變數名稱，然後傳回結果字串。</summary>
        <returns>由字串值取代每個環境變數的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM interop 來從作業系統擷取環境變數。 如果無法擷取環境變數，因為 COM 錯誤，說明失敗的原因的 HRESULT 用來產生其中幾個可能的例外狀況;也就是例外狀況的 HRESULT 而定。 如需有關 HRESULT 的處理方式的詳細資訊，請參閱的 < 備註 > 一節<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType>方法。  
  
 取代作業只會設定環境變數。 例如，假設`name`是 「 MyENV = %myenv%"。 如果設定環境變數，MyENV，是為 42，則這個方法會傳回"MyENV = 42"。 如果未設定 MyENV，便會不發生任何變更;這個方法會傳回"MyENV = %myenv%"。  
  
 傳回值的大小會限制為 32 K。  
  
   
  
## Examples  
 下列範例示範如何取得系統磁碟機和系統根變數。  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">能夠存取中的環境變數<paramref name="name" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將訊息寫入 Windows 應用程式事件記錄檔後立即終止處理程序，然後在向 Microsoft 回報錯誤時，包含該訊息並選擇性包含例外狀況資訊。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">解釋處理程序結束原因的訊息；如果未提供任何解釋，則為 <see langword="null" />。</param>
        <summary>將訊息寫入 Windows 應用程式事件記錄檔後立即終止處理程序，然後在向 Microsoft 回報錯誤時包含該訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會結束處理程序，而不執行任何使用中`try` / `finally`區塊或完成項。  
  
 <xref:System.Environment.FailFast%2A>方法寫入`message`Windows 應用程式事件記錄檔中，字串會建立您的應用程式的傾印，並終止目前的處理序。 `message`字串也會包含在向 Microsoft 回報錯誤。  
  
 使用<xref:System.Environment.FailFast%2A>方法，而非<xref:System.Environment.Exit%2A>方法來終止您的應用程式，如果您的應用程式的狀態已損毀修復，並執行您的應用程式`try` / `finally`區塊和完成項會損毀程式資源。  
  
 使用 Windows 錯誤報告資訊回報給 Microsoft。 如需詳細資訊，請參閱 < [Windows 錯誤報告： 開始使用](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx)。  
  
   
  
## Examples  
 下列範例會寫入 Windows 應用程式事件記錄檔中的記錄項目，並終止目前的處理序。  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">解釋處理程序結束原因的訊息；如果未提供任何解釋，則為 <see langword="null" />。</param>
        <param name="exception">表示造成終止之錯誤的例外狀況。 這通常是 <see langword="catch" /> 區塊中的例外狀況。</param>
        <summary>將訊息寫入 Windows 應用程式事件記錄檔後立即終止處理程序，然後在向 Microsoft 回報錯誤時，包含該訊息和例外狀況資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會結束而不需要執行任何使用中的程序`try` / `finally`區塊或完成項。  
  
 <xref:System.Environment.FailFast%2A>方法寫入`message`Windows 應用程式事件記錄檔中，字串會建立您的應用程式的傾印，並終止目前的處理序。  
  
 使用 Windows 錯誤報告資訊回報給 Microsoft。 如需詳細資訊，請參閱 < [Windows 錯誤報告： 開始使用](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx)。 向 Microsoft 回報錯誤包括`message`和`exception`提供用來分類錯誤詳細資料的資訊。 雖然`exception`是未處理因為處理序終止，引發例外狀況的內容資訊仍然取得。  
  
 如果`exception`已`null`，或如果`exception`是此方法不會擲回，操作相同<xref:System.Environment.FailFast%28System.String%29>方法多載。  
  
 使用<xref:System.Environment.FailFast%2A>方法，而非<xref:System.Environment.Exit%2A>方法來終止您的應用程式，如果您的應用程式的狀態已損毀修復，並執行您的應用程式`try` / `finally`區塊和完成項會損毀程式資源。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回字串陣列，包含目前處理程序的命令列引數。</summary>
        <returns>字串的陣列，其中的每個元素都包含命令列引數。 第一個元素是可執行檔名稱，後面的零或多個元素包含其餘的命令列引數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列中的第一個項目包含的檔案名稱的執行中的程式。 如果無法使用的檔案名稱，第一個項目是否等於<xref:System.String.Empty?displayProperty=nameWithType>。 其餘的項目包含在命令列上輸入的任何其他權杖。  
  
 程式檔案名稱，但不是需要，包含路徑資訊。  
  
 命令列引數是以空格分隔。 您可以使用雙引號 （"），以引數中加入空格。 不過，單引號 （'），不提供這項功能。  
  
 如果雙引號後面兩個或偶數數目的反斜線，每個繼續反斜線配對會取代一個反斜線，並移除雙引號。 如果雙引號後面奇數數目的反斜線，包括只執行一個一個反斜線取代每個先前的配對，並移除其餘的反斜線;不過，在此情況下將雙引號不會移除。  
  
 下表顯示如何命令列引數可以是分隔，並假設`MyApp`為目前正在執行的應用程式。  
  
|在命令列輸入|產生的命令列引數|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 若要取得命令列以單一字串，請使用<xref:System.Environment.CommandLine%2A>屬性。  
  
   
  
## Examples  
 下列範例會顯示應用程式的命令列引數。  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">系統不支援命令列引數。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">針對至 PATH 環境變數的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>擷取環境變數的值。</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">環境變數的名稱。</param>
        <summary>從目前的處理程序中擷取環境變數的值。</summary>
        <returns>
          <paramref name="variable" /> 指定的環境變數的值；如果找不到環境變數，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.GetEnvironmentVariable%28System.String%29>方法會從目前的處理序的環境區塊來擷取環境變數。 它相當於呼叫<xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29>方法`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 

若要擷取所有環境變數，以及它們的值，請呼叫<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
環境變數名稱會區分大小寫，在 Linux 和 macOS 上，但在 Windows 上不區分大小寫。  
 
### <a name="on-windows-systems"></a>在 Windows 系統上

 在 Windows 系統上目前的處理序的環境區塊包含：
 
- 所有環境變數提供給它的父處理序中建立它。 例如，從主控台視窗中啟動.NET 應用程式會繼承所有的主控台視窗的環境變數。 

  如果沒有父處理序，會改用每台電腦和每個使用者環境變數。 比方說，新的主控台視窗會有在其啟動階段定義之所有每台電腦和每個使用者的環境變數。

- 新增至 process 區塊，藉由呼叫執行此程序時所有變數<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 這些環境變數會保存到.NET 應用程式終止為止。  
  
如果啟動處理程序之後，會建立環境變數，您可以使用這個方法來擷取只藉由呼叫所建立的變數<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法`target`的值。<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系統上

在 macOS 和 Linux 上，目前的處理序的環境區塊會包含下列環境變數：

- 所有環境變數提供給它的父處理序中建立它。 從殼層啟動.NET 應用程式，這包括在介面中定義的所有環境變數。

- 新增至 process 區塊，藉由呼叫執行此程序時所有變數<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 這些環境變數會保存到.NET 應用程式終止為止。  

在 macOS 上.NET core 和 Linux 不支援每台電腦或每位使用者的環境變數。   
  
## Examples  
 下列範例會使用<xref:System.Environment.GetEnvironmentVariable%2A>方法來擷取`windir`環境變數，其中包含 Windows 目錄的路徑。  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 下列範例會嘗試擷取名為環境變數的值`Test1`程序的環境區塊中。 如果變數不存在，此範例會建立它，並擷取其值。 此範例會顯示變數的值。 如果此範例會建立變數，它也會呼叫<xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29>方法的每個成員<xref:System.EnvironmentVariableTarget>列舉型別，以建立可以擷取只會從目前的處理程序的環境區塊的變數。 最後，如果此範例會建立變數，它會刪除它。  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有執行這項作業的必要權限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">能夠讀取的值<paramref name="variable" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">環境變數的名稱。</param>
        <param name="target">其中一個 <see cref="T:System.EnvironmentVariableTarget" /> 值。</param>
        <summary>從目前的處理程序或是目前使用者或本機電腦的 Windows 作業系統登錄機碼中，擷取環境變數的值。</summary>
        <returns>
          <paramref name="variable" /> 和 <paramref name="target" /> 參數指定之環境變數的值；如果找不到環境變數，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

若要擷取所有環境變數，以及它們的值，請呼叫<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
環境變數名稱會區分大小寫，在 Linux 和 macOS 上，但在 Windows 上不區分大小寫。 

### <a name="on-windows-systems"></a>在 Windows 系統上

在 Windows，`target`參數會指定是否要在從目前的處理序或目前的使用者或本機電腦的 Windows 作業系統登錄機碼，擷取環境變數。 正如其他任何環境變數可用來建立.NET 處理序父處理序，所有的每位使用者及每台電腦的環境變數會自動複製到目前的處理序的環境區塊。 不過，環境變數只能加入目前的處理序的環境區塊藉由呼叫<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>程序期間只會保存。  
  
### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系統上

在 macOS 和 Linux 上`GetEnvironmentVariable(String, EnvironmentVariableTarget)`方法可支援`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithtype>只。 呼叫具有`target`的值<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithtype>或是<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithtype>不支援，並傳回`null`。 

每個處理序環境變數為：

- 這些繼承自父處理序，通常用來叫用 shell`dotnet.exe`或啟動.NET 應用程式。

- 藉由呼叫定義<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 這些環境變數只會保存到`dotnet`程序或.NET 應用程式會終止。   
  
## Examples  
 下列範例會建立處理程序、 使用者和電腦目標的環境變數，然後檢查作業系統登錄是否包含使用者和電腦的環境變數，然後刪除環境變數。  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> 不是有效的 <see cref="T:System.EnvironmentVariableTarget" /> 值。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有執行這項作業的必要權限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">能夠讀取的值<paramref name="variable" />如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.Process" />(相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />)， 
或 
環境變數的完整存取如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.User" />或是<see cref="F:System.EnvironmentVariableTarget.Machine" />(相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />)。</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>擷取所有環境變數名稱及它們的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從目前的處理程序中擷取所有環境變數名稱及它們的值。</summary>
        <returns>包含所有環境變數名稱及其值的字典；如果找不到環境變數，則為空的字典。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名稱和環境變數的值會儲存在傳回的索引鍵 / 值組為<xref:System.Collections.IDictionary>。  
  
### <a name="on-windows-systems"></a>在 Windows 系統上

在 Windows 系統上`GetEnvironmentVariables`方法會傳回下列環境變數：
  
- 所有每台電腦在建立程序，以及它們的值所定義的環境變數。  
  
- 所有的每個使用者環境變數時所定義的程序隨即建立，以及它們的值。  

- 繼承自父處理序的.NET 應用程式已啟動，或加入 process 區塊，執行此程序時所有變數。 環境變數會加入程序執行時呼叫<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系統上

在 MacOS 和 Linux 上`GetEnvironmentVariables`方法會擷取名稱和值繼承自父處理序啟動的所有環境變數`dotnet`處理程序或所定義的範圍內`dotnet`程序本身。 一次`dotnet`不再存在於處理序結束，這些第二個環境變數。 

.NET core 不支援每台電腦或每位使用者的環境變數。   
  
## Examples  
 下列範例示範<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有執行這項作業的必要權限。</exception>
        <exception cref="T:System.OutOfMemoryException">緩衝區記憶體不足。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">能夠讀取的名稱和環境變數的值。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">其中一個 <see cref="T:System.EnvironmentVariableTarget" /> 值。</param>
        <summary>從目前的處理程序或是目前使用者或本機電腦的 Windows 作業系統登錄機碼中，擷取所有環境變數名稱和它們的值。</summary>
        <returns>包含 <paramref name="target" /> 參數指定之來源中所有環境變數名稱及其值的字典；如果找不到環境變數，則為空的字典。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

名稱和環境變數的值會儲存在傳回的索引鍵/值組為<xref:System.Collections.IDictionary>物件。  

### <a name="on-windows-systems"></a>在 Windows 系統上

在 Windows 系統上`target`參數會指定來源是目前的處理序、 登錄機碼，針對目前的使用者或在本機電腦的登錄機碼。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系統上

在 macOS 和 Linux，只有`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>支援。 每個處理序環境變數繼承自父處理序 （通常是殼層） 用來啟動`dotnet`處理，或所定義的範圍內`dotnet`程序本身。 一次 dotnet 處理序結束，這些第二個環境變數就會消失。  

不支援每台電腦和每個使用者環境變數。 A`target`的值<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>或<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>傳回空陣列。
  
## Examples  
 下列範例會建立處理程序、 使用者和電腦目標的環境變數，然後檢查作業系統登錄是否包含使用者和電腦的環境變數，然後刪除環境變數。  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有針對 <paramref name="target" /> 指定值執行這項作業的必要權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> 含有無效的值。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">能夠讀取的名稱和環境變數的值，如果<paramref name="target" />已<see cref="F:System.EnvironmentVariableTarget.Process" />(相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />)， 
或 
環境變數的完整存取如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.User" />或是<see cref="F:System.EnvironmentVariableTarget.Machine" />(相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />)。</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得由指定之列舉識別的系統特殊資料夾的路徑。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">列舉常數，識別系統特殊資料夾。</param>
        <summary>取得由指定之列舉識別的系統特殊資料夾的路徑。</summary>
        <returns>如果所指定的系統特殊資料夾實際存在您的電腦中，則為該資料夾的路徑，否則為空字串 ("")。  
  
如果作業系統沒有建立資料夾、現有資料夾被刪除或資料夾是沒有對應到實體路徑的虛擬目錄 (例如 [我的電腦])，則資料夾不會實際存在。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會擷取系統特殊資料夾，例如 Program Files、 程式、 系統或啟動時，可用來存取通用資訊的路徑。 特殊資料夾會設定依預設，系統，或由使用者明確安裝的 Windows 版本時。  
  
 `folder`參數指定要擷取的特殊資料夾，且必須在值的其中一個<xref:System.Environment.SpecialFolder>列舉; 任何其他值則會擲回例外狀況。  
  
 如需有關特殊資料夾的詳細資訊，請參閱[CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664)值主題。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Environment.GetFolderPath%2A>方法，傳回並顯示相關聯的路徑`folder`參數。  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> 不是 <see cref="T:System.Environment.SpecialFolder" /> 的成員。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支援目前的平台。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身中的資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">列舉常數，識別系統特殊資料夾。</param>
        <param name="option">指定用於存取特殊資料夾的選項。</param>
        <summary>取得由指定之列舉所識別之系統特殊資料夾的路徑，並使用指定的選項來存取特殊資料夾。</summary>
        <returns>如果所指定的系統特殊資料夾實際存在您的電腦中，則為該資料夾的路徑，否則為空字串 ("")。  
  
如果作業系統沒有建立資料夾、現有資料夾被刪除或資料夾是沒有對應到實體路徑的虛擬目錄 (例如 [我的電腦])，則資料夾不會實際存在。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會擷取系統特殊資料夾，例如 Program Files、 程式、 系統或啟動時，可用來存取通用資訊的路徑。 特殊資料夾會設定依預設，系統，或由使用者明確安裝的 Windows 版本時。  
  
 `folder`參數指定要擷取的特殊資料夾，且必須在值的其中一個<xref:System.Environment.SpecialFolder>列舉; 任何其他值則會擲回例外狀況。  
  
 如需有關特殊資料夾的詳細資訊，請參閱[CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664)值主題。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> 不是 <see cref="T:System.Environment.SpecialFolder" /> 的成員。</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身中的資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回包含目前電腦上邏輯磁碟名稱的字串陣列。</summary>
        <returns>字串的陣列，其中的每個元素都包含邏輯磁碟的名稱。 例如，如果電腦的硬碟是第一部邏輯磁碟，傳回的第一個項目就會是 "C:\\"。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何顯示目前的電腦使用的邏輯磁碟機<xref:System.Environment.GetLogicalDrives%2A>方法。  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">此權限所保護的資源的完整存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示正在卸載目前的應用程式定義域，或是正在關閉通用語言執行平台 (CLR)。</summary>
        <value>如果目前的應用程式定義域正在卸載或 CLR 正在關閉，則為 <see langword="true" />；否則為 <see langword="false." />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當 CLR 卸載應用程式定義域時，它會有完成項方法，該應用程式定義域中的所有物件上執行的完成項。 當 CLR 關閉時，它會首先完成項執行緒有完成項方法的所有物件上。 <xref:System.Environment.HasShutdownStarted%2A>屬性會傳回`true`只啟動完成項執行緒之後。 當屬性傳回`true`，您可以決定應用程式定義域正在卸載或 CLR 本身正在關機而關閉藉由呼叫<xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType>方法。 這個方法會傳回`true`因為應用程式定義域正在卸載，如果呼叫完成項或`false`如果 CLR 正在關閉。  
  
 <xref:System.Environment.HasShutdownStarted%2A>屬性會傳回`false`如果完成項執行緒未啟動。  
  
 藉由使用這個屬性，您可以判斷是否要存取您的最終處理程式碼中的靜態變數。 如果應用程式定義域或 CLR 正在關閉，您無法可靠地存取任何具有最終處理方法，且由靜態欄位所參考的物件。 這是因為這些物件可能已經結束。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>判斷目前作業系統是否為 64 位元作業系統。</summary>
        <value>如果作業系統是 64 位元則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>判斷目前處理程序是否為 64 位元處理程序。</summary>
        <value>如果處理程序是 64 位元則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個本機電腦的 NetBIOS 名稱。</summary>
        <value>含有這個電腦名稱的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從登錄讀取名稱時，則會在系統啟動建立此電腦的名稱。 如果此電腦是叢集中的節點，則會傳回節點的名稱。  
  
   
  
## Examples  
 下列範例會顯示執行的程式碼範例之電腦的名稱。 （基於安全性理由，範例輸出中會省略電腦名稱）。  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">無法取得這個電腦的名稱。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">讀取 COMPUTERNAME 的環境變數的存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得為這個環境定義的新行字串 (Newline String)。</summary>
        <value>如果是非 Unix 平台，則為包含 "\r\n" 的字串；如果是 Unix 平台，則為包含 "\n" 的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性值的<xref:System.Environment.NewLine%2A>是專為目前的平台和.NET Framework 實作自訂常數。 如需有關屬性值中逸出字元的詳細資訊，請參閱[逸出字元](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)。  
  
 所提供的功能<xref:System.Environment.NewLine%2A>通常是代表什麼意思條款新行字元、 換行字元、 換行、 歸位字元、 CRLF、 和行尾。  
  
 <xref:System.Environment.NewLine%2A> 可以用於搭配特定語言的新行字元的支援，例如逸出字元 '\r' 和 '\n' 在 Microsoft C# 和 C/c + +，或`vbCrLf`Microsoft Visual Basic 中。  
  
 <xref:System.Environment.NewLine%2A> 會自動附加至所處理的文字<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>和<xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會顯示三行以換行符號分隔。  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得含有目前平台識別項和版本號碼的 <see cref="T:System.OperatingSystem" /> 物件。</summary>
        <value>包含平台識別項和版本號碼的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`Environment.OSVersion`屬性不提供可靠的方式，來識別正確的作業系統和它的版本。 因此，我們不建議使用此方法。 改為： 

- 若要識別作業系統平台，請使用<xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType>方法。 

- 避免撰寫的程式碼回報的作業系統版本而定。 相反地，請檢查可用性的應用程式所需的功能。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個屬性過去無法取得系統版本。  
  
-或- 
取得的平台識別碼不是 <see cref="T:System.PlatformID" /> 的成員。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前電腦上的處理器數目。</summary>
        <value>32 位元帶正負號的整數，可指定目前電腦上的處理器數目。 沒有預設值。 如果目前電腦包含多個處理器群組，則這個屬性會傳回可供 Common Language Runtime (CLR) 使用的邏輯處理器數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理器群組與邏輯處理器的詳細資訊，請參閱[處理器群組](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx)。  
  
   
  
## Examples  
 下列範例示範<xref:System.Environment.ProcessorCount%2A>屬性。  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立、修改或刪除環境變數。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">環境變數的名稱。</param>
        <param name="value">要指派給 <c>variable</c> 的值。</param>
        <summary>建立、修改或刪除儲存在目前處理程序中的環境變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法就相當於呼叫<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>值是多載<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>如`target`引數。  
  
 如果`value`引數不是空白 （請參閱刪除環境變數來定義的值是空的本節稍後的討論） 命名的環境變數和`variable`參數不存在，環境建立並指派的內容變數`value`。 如果檔案存在，則會修改它的值。 目前的處理序的環境區塊中定義的環境變數，因為它不會保存之後的處理序已結束。  
  
 如果`variable`包含非初始十六進位零字元、 字元 「 零 」 字元會被視為環境變數名稱，並忽略所有後續的字元。  
  
 如果`value`包含非初始十六進位零字元，「 零 」 字元指派給環境變數，並忽略所有後續的字元之前的字元。  
  
 如果`value`是空值和命名的環境變數`variable`存在，會刪除環境變數。 如果`variable`不存在，就會發生任何錯誤即使無法執行此作業。 `value` 會被視為空任何下列的情況下：  
  
-   它是`null`。  
  
-   它是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   它包含單一字元，其值是 U + 0000。  
  
   
  
## Examples  
 下列範例會測試名為環境變數是否`APPDOMAIN`存在於目前的處理序。 如果不存在，它就會加以建立，並將它的值為"True"。 如果值`APPDOMAIN`環境變數為"True"，它會呼叫`Message.Display`新的應用程式定義域中的方法。 否則，它會執行`Message.Display`目前的應用程式定義域中的方法。  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 如果您是第一次執行範例，訊息就會有 「 執行中網域 Domain2"顯示到主控台中。 如果您設定環境變數，您可以從命令列使用命令：  
  
 `Set AppDomain=False`  
  
 此範例會顯示訊息 「 在定義域中執行*exeName*.exe"，其中*exeName*是可執行檔的名稱。  
  
 下列範例會嘗試擷取名為環境變數的值`Test1`程序的環境區塊中。 如果變數不存在，此範例會建立變數，並擷取其值。 此範例會顯示變數的值。 如果此範例會建立變數，它也會呼叫<xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29>方法的每個成員<xref:System.EnvironmentVariableTarget>列舉型別，以建立可以擷取只會從目前的處理程序的環境區塊的變數。 最後，如果此範例會建立變數，它會刪除它。  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> 包含零長度字串、初始十六進位零字元 (0x00) 或等號 ("=")。  
  
-或- 
<paramref name="variable" /> 或 <paramref name="value" /> 的長度大於或等於 32,767 個字元。  
  
-或- 
執行這項作業期間發生錯誤。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有執行這項作業的必要權限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">環境變數的完整存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">環境變數的名稱。</param>
        <param name="value">要指派給 <c>variable</c> 的值。</param>
        <param name="target">其中一個列舉值，指定環境變數的位置。</param>
        <summary>建立、修改或刪除儲存在目前的處理程序中，或是儲存在保留給目前使用者或本機電腦的 Windows 作業系統登錄機碼中的環境變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法可讓您定義環境變數提供給目前的處理序 (<xref:System.EnvironmentVariableTarget.Process>值)。 目前的處理程序的環境區塊獨有的環境變數會保存在程序結束時，才。

此外，Windows 系統上僅<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法可讓您定義環境變數所提供的機器上執行的所有處理程序 (<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>值) 和使用者執行的所有處理程序 (<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>值)。 每台電腦和每個使用者環境變數會複製到目前的處理序的環境區塊。  
 
MaxOS 和 Linux 系統上的.NET Core 上呼叫<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法的值<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>或<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>都會被忽略。 
  
 如果`value`引數不是空白 （請參閱刪除環境變數來定義的值是空的本節稍後的討論） 命名的環境變數和`variable`引數不存在，環境建立並指派的內容變數`value`。  如果檔案存在，則會修改它的值。  
  
 如果`variable`包含非初始十六進位零字元、 字元 「 零 」 字元會被視為環境變數名稱，並忽略所有後續的字元。  
  
 如果`value`包含非初始十六進位零字元，「 零 」 字元指派給環境變數，並忽略所有後續的字元之前的字元。  
  
 如果`value`是空值和命名的環境變數`variable`存在，會刪除環境變數。 `value` 會被視為空任何下列的情況下：  
  
-   它是`null`。  
  
-   它是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   它包含單一字元，其值是 U + 0000。  
  
 如果`variable`不存在，就會發生任何錯誤雖然無法執行此作業。 時請小心`target`是<xref:System.EnvironmentVariableTarget.Machine>，因為您可以不小心刪除環境變數會影響整個本機電腦，不只是目前的處理序或使用者。  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget.Machine 和 Windows 系統上的 EnvironmentVariableTarget.User

如果`target`是<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>，環境變數會儲存在 HKEY_CURRENT_USER\Environment 機碼的本機電腦的登錄。 它也會複製到檔案總管 的目前的使用者執行的執行個體。 環境變數接著會由使用者啟動檔案總管 中的任何新處理序繼承。  
  
 同樣地，如果`target`是<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>，環境變數會儲存在本機電腦的登錄 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment 索引鍵。 它也會複製到檔案總管 中的所有執行個體。 從檔案總管 中啟動任何新處理序會再繼承環境變數。  
  
 如果`target`已<xref:System.EnvironmentVariableTarget.User>或是<xref:System.EnvironmentVariableTarget.Machine>，其他應用程式都會收到通知，設定作業的 Windows`WM_SETTINGCHANGE`訊息。  
  
 如果`target`已<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>或是<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>，我們建議的長度`value`小於 2048年個字元。  
  
## Examples  
 下列範例會建立環境變數<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>， <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>，和<xref:System.EnvironmentVariableTarget.Machine>為目標時，會檢查作業系統登錄是否包含使用者和電腦的環境變數，然後刪除環境變數。  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> 包含零長度字串、初始十六進位零字元 (0x00) 或等號 ("=")。  
  
-或- 
<paramref name="variable" /> 的長度大於或等於 32,767 個字元。  
  
-或- 
 <paramref name="target" /> 不是 <see cref="T:System.EnvironmentVariableTarget" /> 列舉的成員。  
  
-或- 
 <paramref name="target" /> 為 <see cref="F:System.EnvironmentVariableTarget.Machine" /> 或 <see cref="F:System.EnvironmentVariableTarget.User" />，且 <paramref name="variable" /> 的長度大於等於 255。  
  
-或- 
 <paramref name="target" /> 為 <see cref="F:System.EnvironmentVariableTarget.Process" />，且 <paramref name="value" /> 的長度大於或等於 32,767 個字元。  
  
-或- 
執行這項作業期間發生錯誤。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有執行這項作業的必要權限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">環境變數的完整存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前的堆疊追蹤資訊。</summary>
        <value>含有堆疊追蹤資訊的字串。 這個值可以是 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A>屬性清單的相反時間順序的方法呼叫，也就是第一次，所述的最新的方法呼叫和一行的堆疊追蹤資訊會列在堆疊上每個方法呼叫。 不過，<xref:System.Environment.StackTrace%2A>屬性可能不會報告如預期般運作，因為發生在最佳化期間的程式碼轉換的多個方法呼叫。  
  
> [!NOTE]
>  針對由類別的堆疊追蹤資訊的階層式檢視，使用<xref:System.Diagnostics.StackTrace>類別。  
  
 <xref:System.Environment.StackTrace%2A>屬性格式化每個方法呼叫的堆疊追蹤資訊，如下所示：  
  
 「 在`FullClassName`。`MethodName`(`MethodParams`) 中`FileName`： 列`LineNumber`"  
  
 前面三個空格，加上"at"常值，如果無法使用的偵錯符號，則會忽略整個開頭為"in"的子字串。 預留位置`FullClassName`， `MethodName`， `MethodParams`， `FileName`，和`LineNumber`、 以實際的值，取代及定義，如下所示：  
  
 FullClassName  
 類別，包括命名空間的完整名稱。  
  
 `MethodName`  
 方法的名稱。  
  
 `MethodParams`  
 參數類型/名稱組的清單。 每一組以逗號分隔 （"，"）。 如果，則會忽略這項資訊`MethodName`不接受任何參數。  
  
 `FileName`  
 來源名稱檔`MethodName`方法宣告。 如果無法使用的偵錯符號，則會忽略這項資訊。  
  
 `LineNumber`  
 在 行號`FileName`包含從原始程式碼`MethodName`呼叫堆疊上的指示。 如果無法使用的偵錯符號，則會忽略這項資訊。  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>字串結束的堆疊追蹤的每一行。  
  
   
  
## Examples  
 下列範例示範<xref:System.Environment.StackTrace%2A>屬性。  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">取得的完整存取權限所保護的資源。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得系統目錄的完整路徑。</summary>
        <value>含有目錄路徑的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回值的範例是"C:\WinNT\System32"的字串。  
  
   
  
## Examples  
 下列範例會顯示執行的程式碼範例之電腦的系統目錄。 （系統目錄，基於安全性考量的範例輸出中省略）。  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身中的資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得作業系統記憶體分頁中的位元組數目。</summary>
        <value>系統記憶體分頁中的位元組數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這項資訊很有用，決定是否要使用<xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType>選項，當您使用的記憶體對應檔案。  
  
 在 Windows 中，這個值是`dwPageSize`中的成員`SYSTEM_INFO`結構。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用於存取系統和使用者的環境變數。 相關聯的例外狀況： 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得系統啟動後經過的毫秒數。</summary>
        <value>32 位元帶正負號的整數，包含自上一次電腦啟動後所經過的毫秒時間量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的值衍生自系統計時器，並會儲存為 32 位元帶正負號的整數。 請注意，因為它衍生自系統計時器解析度<xref:System.Environment.TickCount%2A>屬性僅限於系統計時器，通常是在 10 到 16 毫秒的範圍內的解析。  
  
> [!IMPORTANT]
>  因為值<xref:System.Environment.TickCount%2A>屬性值是 32 位元帶正負號的整數，系統會連續執行，<xref:System.Environment.TickCount%2A>會從零到遞增<xref:System.Int32.MaxValue?displayProperty=nameWithType>大約 24.9 天，然後跳至<xref:System.Int32.MinValue?displayProperty=nameWithType>，這是負數，然後遞增回下一個 24.9 指定天數內的零。 您可以暫時解決此問題，藉由呼叫 Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx)函式，這樣會重設為在大約 49.7 天的資料，或藉由呼叫零[GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx)函式。  
  
 <xref:System.Environment.TickCount%2A> 不同於<xref:System.DateTime.Ticks%2A?displayProperty=nameWithType>屬性，也就是 1/1/0001，12:00 am 起已經過 100 奈秒間隔數。  
  
 使用<xref:System.DateTime.Now%2A?displayProperty=nameWithType>屬性，以取得目前本機日期和時間，在此電腦上的。  
  
   
  
## Examples  
 下列範例示範如何擷取傳回值的正數範圍<xref:System.Environment.TickCount%2A>屬性。 <xref:System.Environment.TickCount%2A>屬性之間的循環<xref:System.Int32.MinValue?displayProperty=nameWithType>，這是負數，和<xref:System.Int32.MaxValue?displayProperty=nameWithType>每 49.8 天。 此程式碼範例會移除產生零之間循環的非負值數字的正負號位元和<xref:System.Int32.MaxValue>每 24.9 天。  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與目前使用者相關聯的網路網域名稱。</summary>
        <value>與目前使用者相關聯的網路網域名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用者的網域帳戶認證會格式化為使用者的網域名稱，'\\' 字元，以及使用者名稱。 使用<xref:System.Environment.UserDomainName%2A>屬性，以取得使用者的網域名稱，而不需要使用者名稱，而<xref:System.Environment.UserName%2A>屬性，以取得不含網域名稱的使用者名稱。  例如，如果使用者的網域名稱和使用者名稱 CORPORATENETWORK\john，<xref:System.Environment.UserDomainName%2A>屬性會傳回"CORPORATENETWORK 」。  
  
 <xref:System.Environment.UserDomainName%2A>屬性第一次嘗試取得目前使用者的 Windows 帳戶名稱的網域名稱元件。 如果該嘗試失敗時，這個屬性會嘗試取得所提供的使用者名稱相關聯的網域名稱<xref:System.Environment.UserName%2A>屬性。 如果該嘗試失敗，因為主機電腦未加入網域，則會傳回主機電腦的名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">作業系統不支援擷取網路網域名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法擷取網路網域名稱。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">USERDOMAIN 環境變數的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得數值，指示目前的處理程序是否正執行於使用者互動模式中。</summary>
        <value>如果目前處理序正執行於使用者互動模式中，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserInteractive%2A>屬性報告`false`Windows 處理程序或執行不含使用者介面的 IIS 之類的服務。 如果此屬性為`false`，不會顯示強制回應對話方塊或訊息方塊，因為沒有使用者互動的圖形化使用者介面。  
  
   
  
## Examples  
 下列範例會顯示目前的處理序是執行於使用者互動模式。  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前登入作業系統之人員的使用者名稱。</summary>
        <value>登入作業系統之人員的使用者名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Environment.UserName%2A>屬性來識別目前的執行緒，基於安全性或存取的應用程式與系統上的使用者。 也可用以自訂每位使用者的特定應用程式。  
 
 在 Windows 上<xref:System.Environment.UserName%2A>屬性會包裝 Windows 呼叫[GetUserName](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx)函式。 使用者的網域帳戶認證會格式化為使用者的網域名稱，'\\' 字元，以及使用者名稱。 使用<xref:System.Environment.UserDomainName%2A>屬性，以取得使用者的網域名稱和<xref:System.Environment.UserName%2A>屬性，以取得使用者名稱。  
 
 在 Unix 平台上<xref:System.Environment.UserName%2A>屬性會包裝對`getpwuid_r`函式。
 
 如果 ASP.NET 應用程式是在開發環境中，執行<xref:System.Environment.UserName%2A>屬性會傳回目前使用者的名稱。 已發行的 ASP.NET 應用程式中，這個屬性會傳回 （例如預設應用程式集區） 的應用程式集區帳戶的名稱。  
  
   
  
## Examples  
 下列範例會顯示啟動目前的執行緒之人員的使用者名稱。  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">USERNAME 的環境變數的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得描述通用語言執行平台的主要、次要、組建 (Build) 和修訂編號的 <see cref="T:System.Version" /> 物件。</summary>
        <value>顯示 Common Language Runtime 版本的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對 .NET Framework 4、4.5、4.5.1 和 4.5.2 版，<xref:System.Environment.Version%2A?displayProperty=nameWithType> 屬性會傳回 <xref:System.Version> 物件，其字串表示的格式為 `4.0.30319.xxxxx`。 .NET Framework 4.6 和更新版本，其形式`4.0.30319.42000`。  
  
> [!WARNING]
>  針對[!INCLUDE[net_v45](~/includes/net-v45-md.md)]和更新版本中，我們不建議使用<xref:System.Environment.Version%2A>屬性來偵測新版執行階段; 相反地，您可以透過查詢登錄判斷 common language runtime 的版本。 如需詳細資訊，請參閱 <<c0> [ 如何： 判斷安裝的.NET Framework 版本是](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md)。  
  
 如需安裝每個版本的.NET framework common language runtime 版本的詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下列範例會顯示 common language runtime 的版本。 （基於安全性理由，範例輸出中會省略版本）。  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得對應至處理程序內容的實體記憶體數量。</summary>
        <value>64 位元帶正負號的整數，包含對應至處理程序內容的實體記憶體位元組數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示執行的程式碼範例之電腦的工作集大小。  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">此權限所保護的資源的完整存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>