<Type Name="OutOfMemoryException" FullName="System.OutOfMemoryException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b4daef79d1d2e0ce916bd5b73af410e8c4e8adb9" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57941369" /></Metadata><TypeSignature Language="C#" Value="public class OutOfMemoryException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit OutOfMemoryException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.OutOfMemoryException" />
  <TypeSignature Language="VB.NET" Value="Public Class OutOfMemoryException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class OutOfMemoryException : SystemException" />
  <TypeSignature Language="F#" Value="type OutOfMemoryException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="9f269-101">當沒有足夠的記憶體繼續執行程式時，所擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9f269-101">The exception that is thrown when there is not enough memory to continue the execution of a program.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="9f269-102"><xref:System.OutOfMemoryException> 使用 HRESULT `COR_E_OUTOFMEMORY`，其中包含 0x8007000E 的值。</span><span class="sxs-lookup"><span data-stu-id="9f269-102"><xref:System.OutOfMemoryException> uses the HRESULT `COR_E_OUTOFMEMORY`, which has the value 0x8007000E.</span></span>  
  
<span data-ttu-id="9f269-103">如需執行個體的初始屬性值的清單<xref:System.OutOfMemoryException>，請參閱<xref:System.OutOfMemoryException.%23ctor%2A>建構函式。</span><span class="sxs-lookup"><span data-stu-id="9f269-103">For a list of initial property values for an instance of <xref:System.OutOfMemoryException>, see the <xref:System.OutOfMemoryException.%23ctor%2A> constructors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9f269-104">值繼承<xref:System.Exception.Data%2A>屬性一律會是`null`。</span><span class="sxs-lookup"><span data-stu-id="9f269-104">The value of the inherited <xref:System.Exception.Data%2A> property is always `null`.</span></span>  
  
<span data-ttu-id="9f269-105"><xref:System.OutOfMemoryException>例外狀況有兩個主要的原因：</span><span class="sxs-lookup"><span data-stu-id="9f269-105">An <xref:System.OutOfMemoryException> exception has two major causes:</span></span>  
  
-   <span data-ttu-id="9f269-106">您嘗試依序展開<xref:System.Text.StringBuilder>物件所定義的長度超過其<xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="9f269-106">You are attempting to expand a <xref:System.Text.StringBuilder> object beyond the length defined by its <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> property.</span></span>  
  
-   <span data-ttu-id="9f269-107">Common language runtime 無法配置連續記憶體不足，無法成功執行作業。</span><span class="sxs-lookup"><span data-stu-id="9f269-107">The common language runtime cannot allocate enough contiguous memory to successfully perform an operation.</span></span> <span data-ttu-id="9f269-108">需要記憶體配置任何屬性指派或方法呼叫會擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9f269-108">This exception can be thrown by any property assignment or method call that requires a memory allocation.</span></span> <span data-ttu-id="9f269-109">如需詳細資訊的原因<xref:System.OutOfMemoryException>例外狀況，請參閱 < [「 記憶體不足 」 不是指實體記憶體](https://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx)。</span><span class="sxs-lookup"><span data-stu-id="9f269-109">For more information on the cause of the <xref:System.OutOfMemoryException> exception, see ["Out of Memory" Does Not Refer to Physical Memory](https://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx).</span></span>  
  
     <span data-ttu-id="9f269-110">這種類型的<xref:System.OutOfMemoryException>例外狀況表示發生嚴重失敗。</span><span class="sxs-lookup"><span data-stu-id="9f269-110">This type of <xref:System.OutOfMemoryException> exception represents a catastrophic failure.</span></span> <span data-ttu-id="9f269-111">如果您選擇要處理的例外狀況，您應該包含`catch`呼叫區塊<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>終止您的應用程式和系統事件記錄檔中，新增項目，如下列範例所示的方法。</span><span class="sxs-lookup"><span data-stu-id="9f269-111">If you choose to handle the exception, you should include a `catch` block that calls the <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> method to terminate your app and add an entry to the system event log, as the following example does.</span></span>  
  
     [!code-csharp[System.OutOfMemoryException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/failfast1.cs#2)]
     [!code-vb[System.OutOfMemoryException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/failfast1.vb#2)]  
  
 <span data-ttu-id="9f269-112">某些情況下擲回例外狀況，並將它消除時可採取的動作包括下列：</span><span class="sxs-lookup"><span data-stu-id="9f269-112">Some of the conditions under which the exception is thrown and the actions you can take to eliminate it include the following:</span></span>  
  
<span data-ttu-id="9f269-113">**您要呼叫<xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType>方法。**</span><span class="sxs-lookup"><span data-stu-id="9f269-113">**You are calling the <xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType> method.**</span></span>  

<span data-ttu-id="9f269-114">您正嘗試將長度增加<xref:System.Text.StringBuilder>物件所指定的大小超過其<xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="9f269-114">You are attempting to increase the length of a <xref:System.Text.StringBuilder> object beyond the size specified by its <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="9f269-115">下列範例說明<xref:System.OutOfMemoryException>的呼叫所擲回的例外狀況<xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType>方法時的範例會嘗試將會導致物件的字串插入<xref:System.Text.StringBuilder.Length%2A>超過最大容量的屬性。</span><span class="sxs-lookup"><span data-stu-id="9f269-115">The following example illustrates the <xref:System.OutOfMemoryException> exception thrown by a call to the <xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType> method when the example tries to insert a string that would cause the object's <xref:System.Text.StringBuilder.Length%2A> property to exceed its maximum capacity.</span></span>  
  
[!code-csharp[System.OutOfMemoryException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/sb_example1.cs#1)]
[!code-vb[System.OutOfMemoryException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/sb_example1.vb#1)]  
  
<span data-ttu-id="9f269-116">您可以執行下列動作以解決錯誤：</span><span class="sxs-lookup"><span data-stu-id="9f269-116">You can do either of the following to address the error:</span></span>  
  
-   <span data-ttu-id="9f269-117">呼叫取代<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>建構函式呼叫任何其他<xref:System.Text.StringBuilder>建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="9f269-117">Replace the call to the <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructor with a call any other <xref:System.Text.StringBuilder> constructor overload.</span></span> <span data-ttu-id="9f269-118">最大容量為您<xref:System.Text.StringBuilder>物件會設為其預設值，亦即<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9f269-118">The maximum capacity of your <xref:System.Text.StringBuilder> object will be set to its default value, which is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  

-   <span data-ttu-id="9f269-119">呼叫<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>建構函式`maxCapacity`夠大，足以容納至任何展開的值<xref:System.Text.StringBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="9f269-119">Call the <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructor with a `maxCapacity` value that is large enough to accommodate any expansions to the <xref:System.Text.StringBuilder> object.</span></span>  
  
<span data-ttu-id="9f269-120">**32 位元處理序執行您的應用程式。**</span><span class="sxs-lookup"><span data-stu-id="9f269-120">**Your app runs as a 32-bit process.**</span></span>

<span data-ttu-id="9f269-121">32 位元處理序可以配置最多 2 GB 的 32 位元系統上的虛擬使用者模式記憶體和 4 GB 的 64 位元系統上的虛擬使用者模式記憶體。</span><span class="sxs-lookup"><span data-stu-id="9f269-121">32-bit processes can allocate a maximum of 2GB of virtual user-mode memory on 32-bit systems, and 4GB of virtual user-mode memory on 64-bit systems.</span></span> <span data-ttu-id="9f269-122">這可以讓 common language runtime 來配置足夠的連續記憶體需要大型的配置時更難。</span><span class="sxs-lookup"><span data-stu-id="9f269-122">This can make it more difficult for the common language runtime to allocate sufficient contiguous memory when a large allocation is needed.</span></span> <span data-ttu-id="9f269-123">相較之下，64 位元處理序可以配置最多 8 TB 的虛擬記憶體。</span><span class="sxs-lookup"><span data-stu-id="9f269-123">In contrast, 64-bit processes can allocate up to 8TB of virtual memory.</span></span> <span data-ttu-id="9f269-124">若要解決這個例外狀況，重新編譯您的 64 位元平台為目標的應用程式。</span><span class="sxs-lookup"><span data-stu-id="9f269-124">To address this exception, recompile your app to target a 64-bit platform.</span></span> <span data-ttu-id="9f269-125">如需在 Visual Studio 中的特定平台為目標的資訊，請參閱[How to:將專案設定到目標平台](https://msdn.microsoft.com/library/845302fc-273d-4f81-820a-7296ce91bd76)。</span><span class="sxs-lookup"><span data-stu-id="9f269-125">For information on targeting specific platforms in Visual Studio, see [How to: Configure Projects to Target Platforms](https://msdn.microsoft.com/library/845302fc-273d-4f81-820a-7296ce91bd76).</span></span>  
  
<span data-ttu-id="9f269-126">**應用程式正在流失 unmanaged 的資源**</span><span class="sxs-lookup"><span data-stu-id="9f269-126">**Your app is leaking unmanaged resources**</span></span> 

<span data-ttu-id="9f269-127">雖然記憶體回收行程能夠釋出配置給 managed 類型的記憶體，但是它不會管理記憶體配置給未受管理的資源，例如作業系統處理 （包括檔案、 記憶體對應檔案、 管道、 登錄機碼與等候控制代碼的控制代碼）直接由 Windows API 呼叫或配置記憶體的配置函式呼叫這類的記憶體區塊和`malloc`。</span><span class="sxs-lookup"><span data-stu-id="9f269-127">Although the garbage collector is able to free memory allocated to managed types, it does not manage memory allocated to unmanaged resources such as operating system handles (including handles to files, memory-mapped files, pipes, registry keys, and wait handles) and memory blocks allocated directly by Windows API calls or by calls to memory allocation functions such as `malloc`.</span></span> <span data-ttu-id="9f269-128">使用 unmanaged 的資源的型別會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="9f269-128">Types that consume unmanaged resources implement the <xref:System.IDisposable> interface.</span></span>  

<span data-ttu-id="9f269-129">如果您要使用一種類型，使用的 unmanaged 的資源，您應該確定呼叫其<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法，當您完成使用它。</span><span class="sxs-lookup"><span data-stu-id="9f269-129">If you are consuming a type that uses unmanaged resources, you should be sure to call its <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method when you have finished using it.</span></span> <span data-ttu-id="9f269-130">(某些類型也會實作`Close`函式中有相同的方法`Dispose`方法。)如需詳細資訊，請參閱 <<c0> [ 使用物件，實作 IDisposable](~/docs/standard/garbage-collection/using-objects.md)主題。</span><span class="sxs-lookup"><span data-stu-id="9f269-130">(Some types also implement a `Close` method that is identical in function to a `Dispose` method.) For more information, see the [Using Objects That Implement IDisposable](~/docs/standard/garbage-collection/using-objects.md) topic.</span></span>  

<span data-ttu-id="9f269-131">如果您已經建立使用的 unmanaged 的資源的類型，請確定您已實作 Dispose 模式和，必要時，提供完成項。</span><span class="sxs-lookup"><span data-stu-id="9f269-131">If you have created a type that uses unmanaged resources, make sure that you have implemented the Dispose pattern and, if necessary, supplied a finalizer.</span></span> <span data-ttu-id="9f269-132">如需詳細資訊，請參閱 <<c0> [ 實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)和<xref:System.Object.Finalize%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9f269-132">For more information, see  [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose.md) and <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>  
  
<span data-ttu-id="9f269-133">**您嘗試在 64 位元處理序中建立一個大型的陣列**</span><span class="sxs-lookup"><span data-stu-id="9f269-133">**You are attempting to create a large array in a 64-bit process**</span></span>

<span data-ttu-id="9f269-134">根據預設，.NET Framework 中的 common language runtime 不允許的大小超過 2 GB 的單一物件。</span><span class="sxs-lookup"><span data-stu-id="9f269-134">By default, the common language runtime in .NET Framework does not allow single objects whose size exceeds 2GB.</span></span> <span data-ttu-id="9f269-135">若要覆寫此預設值，您可以使用[ \<Gcallowverylargeobjects> >](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)組態檔設定，以啟用其總大小超過 2 GB 的陣列。</span><span class="sxs-lookup"><span data-stu-id="9f269-135">To override this default, you can use the [\<gcAllowVeryLargeObjects>](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration file setting to enable arrays whose total size exceeds 2 GB.</span></span> <span data-ttu-id="9f269-136">在.NET Core 上支援大於 2 GB 預設啟用的陣列。</span><span class="sxs-lookup"><span data-stu-id="9f269-136">On .NET Core, support for arrays of greater than 2 GB is enabled by default.</span></span> 
  
<span data-ttu-id="9f269-137">**在記憶體中，您會使用非常大量的資料 （例如陣列、 集合或資料庫的資料集）。**</span><span class="sxs-lookup"><span data-stu-id="9f269-137">**You are working with very large sets of data (such as arrays, collections, or database data sets) in memory.**</span></span>

<span data-ttu-id="9f269-138">當資料結構或位於記憶體中的資料集變得很大的 common language runtime 是無法配置足夠的連續記憶體，<xref:System.OutOfMemoryException>例外狀況結果。</span><span class="sxs-lookup"><span data-stu-id="9f269-138">When data structures or data sets that reside in memory become so large that the common language runtime is unable to allocate enough contiguous memory for them, an <xref:System.OutOfMemoryException> exception results.</span></span>  

<span data-ttu-id="9f269-139">若要避免<xref:System.OutOfMemoryException>例外狀況，您必須修改您的應用程式，讓較少的資料會駐留在記憶體中，或是將資料分成需要較少的記憶體配置的區段。</span><span class="sxs-lookup"><span data-stu-id="9f269-139">To prevent the <xref:System.OutOfMemoryException> exceptions, you must modify your application so that less data is resident in memory, or the data is divided into segments that require smaller memory allocations.</span></span> <span data-ttu-id="9f269-140">例如：</span><span class="sxs-lookup"><span data-stu-id="9f269-140">For example:</span></span>  

-   <span data-ttu-id="9f269-141">如果您是從資料庫擷取的所有資料，然後篩選您的應用程式，以減少往返伺服器中，您應該修改查詢並傳回您的應用程式需要的資料子集。</span><span class="sxs-lookup"><span data-stu-id="9f269-141">If you are retrieving all of the data from a database and then filtering it in your app to minimize trips to the server, you should modify your queries to return only the subset of data that your app needs.</span></span> <span data-ttu-id="9f269-142">處理大型資料表，當多個查詢通常都更有效率，比擷取所有的單一資料表中的資料，然後對它進行操作。</span><span class="sxs-lookup"><span data-stu-id="9f269-142">When working with large tables, multiple queries are almost always more efficient than retrieving all of the data in a single table and then manipulating it.</span></span>  

-   <span data-ttu-id="9f269-143">如果您正在執行的使用者動態建立的查詢，您應該確保查詢所傳回的記錄數目有限。</span><span class="sxs-lookup"><span data-stu-id="9f269-143">If you are executing queries that users create dynamically, you should ensure that the number of records returned by the query is limited.</span></span>  

-   <span data-ttu-id="9f269-144">如果您使用大型陣列或另一個集合物件的大小會導致<xref:System.OutOfMemoryException>例外狀況，您應該修改您的應用程式運作子集中的資料而不使用它全部一次。</span><span class="sxs-lookup"><span data-stu-id="9f269-144">If you are using large arrays or other collection objects whose size results in an <xref:System.OutOfMemoryException> exception, you should modify your application to work the data in subsets rather than to work with it all at once.</span></span>  
  
<span data-ttu-id="9f269-145">下列範例會取得 200 萬個浮點值所組成，，然後計算其平均值的陣列。</span><span class="sxs-lookup"><span data-stu-id="9f269-145">The following example gets a array that consists of 200 million floating-point values and then calculates their mean.</span></span> <span data-ttu-id="9f269-146">範例輸出顯示，因為此範例會儲存在記憶體中，整個陣列之前它會計算平均數，<xref:System.OutOfMemoryException>會擲回。</span><span class="sxs-lookup"><span data-stu-id="9f269-146">The output from the example shows that, because the example stores the entire array in memory before it calculates the mean, an <xref:System.OutOfMemoryException> is is thrown.</span></span>  

[!code-csharp[System.OutOfMemoryException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/data1.cs#3)]
[!code-vb[System.OutOfMemoryException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/data1.vb#3)]  
  
<span data-ttu-id="9f269-147">下列範例會消除<xref:System.OutOfMemoryException>藉由處理內送資料，而不將整個資料集儲存在記憶體中，以允許進一步處理 （這幾行標記為註解在範例中，必要時，序列化至檔案資料的例外狀況因為在此情況下它們產生其大小大於 1 GB 的檔案），然後返回呼叫常式中的導出的平均值和案例數目。</span><span class="sxs-lookup"><span data-stu-id="9f269-147">The following example eliminates the <xref:System.OutOfMemoryException> exception by processing the incoming data without storing the entire data set in memory, serializing the data to a file if necessary to permit further processing (these lines are commented out in the example, since in this case they produce a file whose size is greater than 1GB), and returning the calculated mean and the number of cases to the calling routine.</span></span>  

[!code-csharp[System.OutOfMemoryException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/data2.cs#4)]
[!code-vb[System.OutOfMemoryException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/data2.vb#4)]  
  
<span data-ttu-id="9f269-148">**您重複串連大型字串。**</span><span class="sxs-lookup"><span data-stu-id="9f269-148">**You are repeatedly concatenating large strings.**</span></span> 

<span data-ttu-id="9f269-149">字串是不可變的因為每個字串串連作業會建立新的字串。</span><span class="sxs-lookup"><span data-stu-id="9f269-149">Because strings are immutable, each string concatenation operation creates a new string.</span></span> <span data-ttu-id="9f269-150">對小型字串，或針對少數的串連作業的影響是微不足道。</span><span class="sxs-lookup"><span data-stu-id="9f269-150">The impact for small strings, or for a small number of concatenation operations, is negligible.</span></span> <span data-ttu-id="9f269-151">但對於大型字串或非常大量的串連作業，串連字串可能導致大量的記憶體配置和記憶體分散，效能不佳，而且可能<xref:System.OutOfMemoryException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9f269-151">But for large strings or a very large number of concatenation operations, string concatenation can lead to a large number of memory allocations and memory fragmentation, poor performance, and possibly <xref:System.OutOfMemoryException> exceptions.</span></span>  

<span data-ttu-id="9f269-152">當串連大型字串，或執行大量的串連作業，您應該使用<xref:System.Text.StringBuilder>類別而不是<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="9f269-152">When concatenating large strings or performing a large number of concatenation operations, you should use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class.</span></span> <span data-ttu-id="9f269-153">當您完成管理字串時，轉換<xref:System.Text.StringBuilder>執行個體，以藉由呼叫字串<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="9f269-153">When you have finished manipulating the string, convert the <xref:System.Text.StringBuilder> instance to a string by calling the <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
<span data-ttu-id="9f269-154">**您在記憶體中固定物件數目太大。**</span><span class="sxs-lookup"><span data-stu-id="9f269-154">**You pin a large number of objects in memory.**</span></span>  
 
<span data-ttu-id="9f269-155">在記憶體中固定物件數目太大，長時間，可能會使它的記憶體回收行程配置連續記憶體區塊的困難。</span><span class="sxs-lookup"><span data-stu-id="9f269-155">Pinning a large number of objects in memory for long periods can make it difficult for the garbage collector to allocate contiguous blocks of memory.</span></span> <span data-ttu-id="9f269-156">如果您已釘選大量物件在記憶體中，例如使用`fixed`陳述式在 C# 中，或藉由呼叫<xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType>方法控制代碼類型為<xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType>，您可以執行下列命令以位址<xref:System.OutOfMemoryException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9f269-156">If you've pinned a large number of objects in memory, for example by using the `fixed` statement in C# or by calling the <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> method with a handle type of <xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType>, you can do the following to address the <xref:System.OutOfMemoryException> exception.</span></span>  
  
-   <span data-ttu-id="9f269-157">評估是否真的需要釘選，每個物件</span><span class="sxs-lookup"><span data-stu-id="9f269-157">Evaluate whether each object really needs to be pinned,</span></span>  

-   <span data-ttu-id="9f269-158">請確定每個物件已取消釘選儘速。</span><span class="sxs-lookup"><span data-stu-id="9f269-158">Ensure that each object is unpinned as soon as possible.</span></span>  

-   <span data-ttu-id="9f269-159">請確定每個呼叫來<xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType>釘選記憶體的方法不會有對應呼叫<xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType>方法來取消釘選的記憶體。</span><span class="sxs-lookup"><span data-stu-id="9f269-159">Make sure that each call to the <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> method to pin memory has a corresponding call to the <xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType> method to unpin that memory.</span></span>  

<span data-ttu-id="9f269-160">中繼 (MSIL) 指令會擲回下列 Microsoft<xref:System.OutOfMemoryException>例外狀況：</span><span class="sxs-lookup"><span data-stu-id="9f269-160">The following Microsoft intermediate (MSIL) instructions throw an <xref:System.OutOfMemoryException> exception:</span></span>  
  
-   [<span data-ttu-id="9f269-161">box</span><span class="sxs-lookup"><span data-stu-id="9f269-161">box</span></span>](https://msdn.microsoft.com/library/system.reflection.emit.opcodes.box.aspx)  
-   [<span data-ttu-id="9f269-162">newarr</span><span class="sxs-lookup"><span data-stu-id="9f269-162">newarr</span></span>](https://msdn.microsoft.com/library/system.reflection.emit.opcodes.newarr.aspx)  

-   <span data-ttu-id="9f269-163">[newobj](https://msdn.microsoft.com/library/system.reflection.emit.opcodes.newobj.aspx)newobj</span><span class="sxs-lookup"><span data-stu-id="9f269-163">[newobj](https://msdn.microsoft.com/library/system.reflection.emit.opcodes.newobj.aspx)newobj</span></span>  


 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <related type="Article" href="~/docs/standard/exceptions/index.md"><span data-ttu-id="9f269-164">處理和擲回例外狀況</span><span class="sxs-lookup"><span data-stu-id="9f269-164">Handling and Throwing Exceptions</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9f269-165">初始化 <see cref="T:System.OutOfMemoryException" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="9f269-165">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9f269-166">初始化 <see cref="T:System.OutOfMemoryException" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="9f269-166">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f269-167">這個建構函式初始化<xref:System.Exception.Message%2A>屬性的新執行個體的系統提供的訊息，說明錯誤，例如 「 沒有足夠的記憶體可以繼續程式執行。 」</span><span class="sxs-lookup"><span data-stu-id="9f269-167">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance to a system-supplied message that describes the error, such as "There was not enough memory to continue the execution of the program."</span></span> <span data-ttu-id="9f269-168">此訊息會考量目前的系統文化特性。</span><span class="sxs-lookup"><span data-stu-id="9f269-168">This message takes into account the current system culture.</span></span>  
  
 <span data-ttu-id="9f269-169">下表顯示 <xref:System.OutOfMemoryException> 執行個體的初始屬性值。</span><span class="sxs-lookup"><span data-stu-id="9f269-169">The following table shows the initial property values for an instance of <xref:System.OutOfMemoryException>.</span></span>  
  
|<span data-ttu-id="9f269-170">屬性</span><span class="sxs-lookup"><span data-stu-id="9f269-170">Property</span></span>|<span data-ttu-id="9f269-171">值</span><span class="sxs-lookup"><span data-stu-id="9f269-171">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="9f269-172">`null`.</span><span class="sxs-lookup"><span data-stu-id="9f269-172">`null`.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="9f269-173">當地語系化的錯誤訊息字串。</span><span class="sxs-lookup"><span data-stu-id="9f269-173">The localized error message string.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : string -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="9f269-174">描述錯誤的訊息。</span><span class="sxs-lookup"><span data-stu-id="9f269-174">The message that describes the error.</span></span></param>
        <summary><span data-ttu-id="9f269-175">使用指定的錯誤訊息，初始化 <see cref="T:System.OutOfMemoryException" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="9f269-175">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class with a specified error message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f269-176">`message` 參數的內容必須能讓人了解。</span><span class="sxs-lookup"><span data-stu-id="9f269-176">The content of the `message` parameter is intended to be understood by humans.</span></span> <span data-ttu-id="9f269-177">這個建構函式的呼叫端必須確保這個字串已經被當地語系化 (為了目前系統的文化特性)。</span><span class="sxs-lookup"><span data-stu-id="9f269-177">The caller of this constructor is required to ensure that this string has been localized for the current system culture.</span></span>  
  
 <span data-ttu-id="9f269-178">下表顯示 <xref:System.OutOfMemoryException> 執行個體的初始屬性值。</span><span class="sxs-lookup"><span data-stu-id="9f269-178">The following table shows the initial property values for an instance of <xref:System.OutOfMemoryException>.</span></span>  
  
|<span data-ttu-id="9f269-179">屬性</span><span class="sxs-lookup"><span data-stu-id="9f269-179">Property</span></span>|<span data-ttu-id="9f269-180">值</span><span class="sxs-lookup"><span data-stu-id="9f269-180">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="9f269-181">null 參考 (在 Visual Basic 中為 `Nothing`)。</span><span class="sxs-lookup"><span data-stu-id="9f269-181">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="9f269-182">錯誤訊息字串。</span><span class="sxs-lookup"><span data-stu-id="9f269-182">The error message string.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected OutOfMemoryException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; OutOfMemoryException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="9f269-183">存放序列物件資料的物件。</span><span class="sxs-lookup"><span data-stu-id="9f269-183">The object that holds the serialized object data.</span></span></param>
        <param name="context"><span data-ttu-id="9f269-184">關於來源或目的端的內容資訊。</span><span class="sxs-lookup"><span data-stu-id="9f269-184">The contextual information about the source or destination.</span></span></param>
        <summary><span data-ttu-id="9f269-185">使用序列化資料，初始化 <see cref="T:System.OutOfMemoryException" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="9f269-185">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f269-186">進行還原序列化 (Deserialization) 期間會呼叫這個建構函式，以便重新構成經由資料流傳送的例外狀況物件。</span><span class="sxs-lookup"><span data-stu-id="9f269-186">This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</span></span> <span data-ttu-id="9f269-187">如需詳細資訊，請參閱 < [XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="9f269-187">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md"><span data-ttu-id="9f269-188">XML 和 SOAP 序列化</span><span class="sxs-lookup"><span data-stu-id="9f269-188">XML and SOAP Serialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : string * Exception -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="9f269-189">解釋例外狀況原因的錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="9f269-189">The error message that explains the reason for the exception.</span></span></param>
        <param name="innerException"><span data-ttu-id="9f269-190">做為目前例外狀況發生原因的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9f269-190">The exception that is the cause of the current exception.</span></span> <span data-ttu-id="9f269-191">如果 <paramref name="innerException" /> 參數不是 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，則會在處理內部例外的 <see langword="catch" /> 區塊中引發目前的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9f269-191">If the <paramref name="innerException" /> parameter is not a null reference (<see langword="Nothing" /> in Visual Basic), the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</span></span></param>
        <summary><span data-ttu-id="9f269-192">使用指定的錯誤訊息以及造成此例外狀況的內部例外狀況的參考，初始化 <see cref="T:System.OutOfMemoryException" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="9f269-192">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f269-193">直接因為前一個例外狀況而擲回的例外狀況可能包含對 <xref:System.Exception.InnerException%2A> 屬性中前一個例外狀況的參考。</span><span class="sxs-lookup"><span data-stu-id="9f269-193">An exception that is thrown as a direct result of a previous exception can include a reference to the previous exception in the <xref:System.Exception.InnerException%2A> property.</span></span> <span data-ttu-id="9f269-194"><xref:System.Exception.InnerException%2A> 屬性會傳回與傳入建構函式中相同的值；如果 `Nothing` 屬性不提供內部例外值給建構函式，則傳回 null 參考 (在 Visual Basic 中為 <xref:System.Exception.InnerException%2A>)。</span><span class="sxs-lookup"><span data-stu-id="9f269-194">The <xref:System.Exception.InnerException%2A> property returns the same value that is passed into the constructor, or a null reference (`Nothing` in Visual Basic) if the <xref:System.Exception.InnerException%2A> property does not supply the inner exception value to the constructor.</span></span>  
  
 <span data-ttu-id="9f269-195">下表顯示 <xref:System.OutOfMemoryException> 執行個體的初始屬性值。</span><span class="sxs-lookup"><span data-stu-id="9f269-195">The following table shows the initial property values for an instance of <xref:System.OutOfMemoryException>.</span></span>  
  
|<span data-ttu-id="9f269-196">屬性</span><span class="sxs-lookup"><span data-stu-id="9f269-196">Property</span></span>|<span data-ttu-id="9f269-197">值</span><span class="sxs-lookup"><span data-stu-id="9f269-197">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="9f269-198">內部例外狀況參考。</span><span class="sxs-lookup"><span data-stu-id="9f269-198">The inner exception reference.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="9f269-199">錯誤訊息字串。</span><span class="sxs-lookup"><span data-stu-id="9f269-199">The error message string.</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md"><span data-ttu-id="9f269-200">處理和擲回例外狀況</span><span class="sxs-lookup"><span data-stu-id="9f269-200">Handling and Throwing Exceptions</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>