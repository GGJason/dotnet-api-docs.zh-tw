<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a40925048dd06746d1e1cda2a76aa4ecaae1b916" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731512" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="b1857-101">代表類型宣告：類別類型、介面類型、陣列類型、值類型、列舉類型、類型參數、泛型類型定義，以及開放式或封閉式的建構泛型類型。</span>
      <span class="sxs-lookup">
        <span data-stu-id="b1857-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-102">`Type` 是的根<xref:System.Reflection>功能和主要的方式來存取中繼資料。</span><span class="sxs-lookup"><span data-stu-id="b1857-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="b1857-103">使用的成員<xref:System.Type>取得型別宣告，成員的類型 （例如建構函式、 方法、 欄位、 屬性和事件的類別） 的相關資訊以及模組和組件部署所在的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="b1857-104">不不使用反映來取得類型及成員的相關資訊，不論其存取層級的程式碼需要任何權限。</span><span class="sxs-lookup"><span data-stu-id="b1857-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="b1857-105">不不使用反映來存取公用成員或其存取層級會顯示它們在正常的編譯期間其他成員的程式碼需要任何權限。</span><span class="sxs-lookup"><span data-stu-id="b1857-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="b1857-106">不過，為了讓您的程式碼使用反映來存取成員，通常就是無法存取，例如使用私用或內部的方法，或受保護的類型的欄位不會繼承您的類別，您的程式碼必須<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="b1857-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="b1857-107">請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="b1857-108">`Type` 是可讓多個實作的抽象基底類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="b1857-109">系統一律會提供衍生的類別`RuntimeType`。</span><span class="sxs-lookup"><span data-stu-id="b1857-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="b1857-110">在反映中，執行階段的字為開頭的所有類別都建立一次，每個系統和支援的比較作業中的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-111">在多執行緒處理的情況下，不需要鎖定<xref:System.Type>物件才能同步處理存取具備`static`資料。</span><span class="sxs-lookup"><span data-stu-id="b1857-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="b1857-112">其他程式碼，透過它您有任何控制項，也可能會鎖定您的類別類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="b1857-113">這可能會導致死結。</span><span class="sxs-lookup"><span data-stu-id="b1857-113">This might result in a deadlock.</span></span> <span data-ttu-id="b1857-114">相反地，同步處理靜態資料的存取權鎖定私用`static`物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-115">在衍生的類別可以存取受保護的成員呼叫的程式碼基底類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="b1857-116">此外，允許存取至呼叫的程式碼組件成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="b1857-117">規則是，如果您允許存取在早期繫結程式碼，然後您也可以存取晚期繫結程式碼中。</span><span class="sxs-lookup"><span data-stu-id="b1857-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-118">擴充其他介面的介面不會繼承擴充介面中定義的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="b1857-119">本節內容：</span><span class="sxs-lookup"><span data-stu-id="b1857-119">In this section:</span></span>  
  
 <span data-ttu-id="b1857-120">[型別物件表示何種類型？](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="b1857-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="b1857-121">[擷取型別物件](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="b1857-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="b1857-122">比較相等的類型物件</span><span class="sxs-lookup"><span data-stu-id="b1857-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="b1857-123">型別物件表示何種類型？</span><span class="sxs-lookup"><span data-stu-id="b1857-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="b1857-124">這個類別具備執行緒安全。多個執行緒可以同時讀取此類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b1857-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="b1857-125">執行個體<xref:System.Type>類別可代表任何下列類型：</span><span class="sxs-lookup"><span data-stu-id="b1857-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="b1857-126">類別</span><span class="sxs-lookup"><span data-stu-id="b1857-126">Classes</span></span>  
  
-   <span data-ttu-id="b1857-127">值類型</span><span class="sxs-lookup"><span data-stu-id="b1857-127">Value types</span></span>  
  
-   <span data-ttu-id="b1857-128">陣列</span><span class="sxs-lookup"><span data-stu-id="b1857-128">Arrays</span></span>  
  
-   <span data-ttu-id="b1857-129">介面</span><span class="sxs-lookup"><span data-stu-id="b1857-129">Interfaces</span></span>  
  
-   <span data-ttu-id="b1857-130">列舉</span><span class="sxs-lookup"><span data-stu-id="b1857-130">Enumerations</span></span>  
  
-   <span data-ttu-id="b1857-131">委派</span><span class="sxs-lookup"><span data-stu-id="b1857-131">Delegates</span></span>  
  
-   <span data-ttu-id="b1857-132">建構泛型類型和泛型類型定義</span><span class="sxs-lookup"><span data-stu-id="b1857-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="b1857-133">型別引數與型別參數的建構泛型類型、 泛型類型定義與泛型方法定義</span><span class="sxs-lookup"><span data-stu-id="b1857-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="b1857-134">擷取型別物件</span><span class="sxs-lookup"><span data-stu-id="b1857-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="b1857-135"><xref:System.Type>與特定類型相關聯的物件可透過下列方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="b1857-136">執行個體<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法會傳回<xref:System.Type>物件，表示執行個體的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="b1857-137">因為所有的 managed 型別衍生自<xref:System.Object>、<xref:System.Object.GetType%2A>可以在任何類型的執行個體上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="b1857-138">下列範例會呼叫<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法，以判斷物件陣列中每個物件的執行階段類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="b1857-139">靜態<xref:System.Type.GetType%2A?displayProperty=nameWithType>方法會傳回<xref:System.Type>物件，代表指定其完整名稱的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="b1857-140"><xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>， <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType>方法會傳回`Type`表示模組中定義之類型的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="b1857-141">第一種方法可以用來取得陣列的<xref:System.Type>類型物件的所有公用和私用模組中定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="b1857-142">(您可以取得的執行個體`Module`透過<xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>方法，或透過<xref:System.Type.Module%2A?displayProperty=nameWithType>屬性。)</span><span class="sxs-lookup"><span data-stu-id="b1857-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="b1857-143"><xref:System.Reflection.Assembly?displayProperty=nameWithType>物件包含方法，以擷取中的組件，包含定義的類別數目<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>， <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b1857-144"><xref:System.Type.FindInterfaces%2A>方法會傳回已篩選的類型所支援的介面型別清單。</span><span class="sxs-lookup"><span data-stu-id="b1857-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="b1857-145"><xref:System.Type.GetElementType%2A>方法會傳回`Type`物件，表示項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="b1857-146"><xref:System.Type.GetInterfaces%2A>和<xref:System.Type.GetInterface%2A>方法會傳回<xref:System.Type>代表型別所支援的介面類型的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="b1857-147"><xref:System.Type.GetTypeArray%2A>方法傳回的陣列<xref:System.Type>代表任意一組物件所指定類型的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="b1857-148">物件會指定類型的陣列與<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="b1857-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="b1857-149"><xref:System.Type.GetTypeFromProgID%2A>和<xref:System.Type.GetTypeFromCLSID%2A>方法可供 COM 互通性。</span><span class="sxs-lookup"><span data-stu-id="b1857-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="b1857-150">它們會傳回<xref:System.Type>物件，代表所指定之類型`ProgID`或`CLSID`。</span><span class="sxs-lookup"><span data-stu-id="b1857-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="b1857-151"><xref:System.Type.GetTypeFromHandle%2A>方法會提供如互通性。</span><span class="sxs-lookup"><span data-stu-id="b1857-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="b1857-152">它會傳回`Type`代表類別的控制代碼所指定之類型的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="b1857-153">C#`typeof`運算子，c + +`typeid`運算子和 Visual Basic`GetType`運算子取得`Type`型別的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="b1857-154"><xref:System.Type.MakeGenericType%2A>方法會傳回<xref:System.Type>物件代表建構的泛型類型，也就是開放式建構的類型，如果其<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`，並關閉建構類型否則。</span><span class="sxs-lookup"><span data-stu-id="b1857-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="b1857-155">只有當它已關閉，可以具現化泛型類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="b1857-156"><xref:System.Type.MakeArrayType%2A>， <xref:System.Type.MakePointerType%2A>，和<xref:System.Type.MakeByRefType%2A>方法會傳回<xref:System.Type>分別表示指定的型別、 指定的型別，以及參考參數的類型的指標陣列的物件 (`ref`在 C# 中， `ByRef`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="b1857-157">比較相等的類型物件</span><span class="sxs-lookup"><span data-stu-id="b1857-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="b1857-158">A <xref:System.Type> ，代表類型是唯一的物件，也就是兩個<xref:System.Type>如果且只有它們代表相同的型別物件的參考會參考相同的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="b1857-159">這可讓如的比較<xref:System.Type>物件，使用參考相等。</span><span class="sxs-lookup"><span data-stu-id="b1857-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="b1857-160">下列範例會比較<xref:System.Type>表示的數字的整數值，以判斷它們是相同類型的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="b1857-161">下列範例示範少數代表性的功能<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-161">The following  example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="b1857-162">C#`typeof`運算子 (`GetType`在 Visual Basic 中的運算子`typeid`Visual c + + 運算子) 用來取得<xref:System.Type>物件，代表<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="b1857-162">The C# `typeof` operator (`GetType` operator in Visual Basic, `typeid` operator in Visual C++) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="b1857-163">從這個<xref:System.Type>物件<xref:System.Type.GetMethod%2A>方法用來取得<xref:System.Reflection.MethodInfo>代表<xref:System.String.Substring%2A>可接受的開始位置和長度的多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.</span></span>  
  
 <span data-ttu-id="b1857-164">若要識別多載簽章，程式碼範例會建立暫存陣列，包含兩個<xref:System.Type>物件代表`int`(`Integer`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-165">為了更精確，此陣列包含兩個執行個體的參考<xref:System.Type>表示`int`目前的應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="b1857-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="b1857-166">對於任何類型，沒有只有一個執行個體<xref:System.Type>每個應用程式網域。</span><span class="sxs-lookup"><span data-stu-id="b1857-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="b1857-167">此程式碼範例會使用<xref:System.Reflection.MethodInfo>叫用<xref:System.String.Substring%2A>方法在字串"Hello，World ！"，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="b1857-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="b1857-168">此型別具備執行緒安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="b1857-168">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="b1857-169">當您繼承自<see langword="Type" />，您必須覆寫下列成員：</span>
        <span class="sxs-lookup">
          <span data-stu-id="b1857-169">When you inherit from <see langword="Type" />, you must override the following members:</span>
        </span>  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <span data-ttu-id="b1857-170"><see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span><span class="sxs-lookup"><span data-stu-id="b1857-170"><see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span></span>  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-171">初始化 <see cref="T:System.Type" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-172">這個建構函式會由衍生類別類型物件的建構期間叫用。</span><span class="sxs-lookup"><span data-stu-id="b1857-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-173">取得宣告此類型的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span>
          </span>
          <span data-ttu-id="b1857-174">若為泛型類型，則取得定義此泛型類型的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-175">
            <see cref="T:System.Reflection.Assembly" /> 執行個體，描述包含目前類型的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span>
          </span>
          <span data-ttu-id="b1857-176">若為泛型類型，則此執行個體描述的是含有泛型類型定義的組件，而不是建立與使用特定建構類型的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-177">如果目前<xref:System.Type>物件代表建構的泛型型別，這個屬性會傳回包含泛型類型定義的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="b1857-178">例如，假設您建立名為 MyGenerics.dll 包含泛型類型定義的組件`MyGenericStack<T>`(`MyGenericStack(Of T)`在 Visual Basic 中`generic<T> ref class MyGenericStack`c + + 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="b1857-179">如果您建立的執行個體`MyGenericStack<int>`(`MyGenericStack(Of Integer)`在 Visual Basic 中) 中另一個組件，<xref:System.Type.Assembly%2A>建構類型的屬性會傳回<xref:System.Reflection.Assembly>表示 MyGenerics.dll 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="b1857-180">同樣地，如果目前<xref:System.Type>物件表示未指派的泛型參數`T`，這個屬性會傳回包含定義的泛型類型的組件`T`。</span><span class="sxs-lookup"><span data-stu-id="b1857-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="b1857-181">如果<xref:System.Type.Assembly%2A?displayProperty=nameWithType>屬性並不適用於特定的.NET 實作，例如.NET Core 或通用 Windows 平台，請使用<xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>屬性改為。</span><span class="sxs-lookup"><span data-stu-id="b1857-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="b1857-182">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-183">下列範例會顯示與類別相關聯的組件名稱和類型的完整的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-184">取得類型的組件限定名稱，包含載入 <see cref="T:System.Type" /> 的組件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-185">
            <see cref="T:System.Type" /> 的組件限定名稱，包含載入 <see cref="T:System.Type" /> 的組件名稱，如果目前的執行個體表示泛型類型參數，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-186">類型的組件限定名稱是由型別名稱，包括其命名空間，加上逗號，後面接著組件的顯示名稱所組成。</span><span class="sxs-lookup"><span data-stu-id="b1857-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="b1857-187">使用取得組件的顯示名稱<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-188">在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="b1857-189">例如，"ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="b1857-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="b1857-190">不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。</span><span class="sxs-lookup"><span data-stu-id="b1857-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="b1857-191">請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b1857-192">支援通用語言執行平台的所有編譯器都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="b1857-193">分隔符號</span><span class="sxs-lookup"><span data-stu-id="b1857-193">Delimiter</span></span>|<span data-ttu-id="b1857-194">意義</span><span class="sxs-lookup"><span data-stu-id="b1857-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="b1857-195">反斜線 (\\)</span><span class="sxs-lookup"><span data-stu-id="b1857-195">Backslash (\\)</span></span>|<span data-ttu-id="b1857-196">逸出字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-196">Escape character.</span></span>|  
|<span data-ttu-id="b1857-197">逗號 （，）</span><span class="sxs-lookup"><span data-stu-id="b1857-197">Comma (,)</span></span>|<span data-ttu-id="b1857-198">後面接著組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="b1857-199">加號 （+）</span><span class="sxs-lookup"><span data-stu-id="b1857-199">Plus sign (+)</span></span>|<span data-ttu-id="b1857-200">之前的巢狀的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="b1857-201">句號 （.）</span><span class="sxs-lookup"><span data-stu-id="b1857-201">Period (.)</span></span>|<span data-ttu-id="b1857-202">代表命名空間識別項。</span><span class="sxs-lookup"><span data-stu-id="b1857-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="b1857-203">括號 ([])</span><span class="sxs-lookup"><span data-stu-id="b1857-203">Brackets ([])</span></span>|<span data-ttu-id="b1857-204">類型名稱後面，表示該類型的陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="b1857-205">-或-</span><span class="sxs-lookup"><span data-stu-id="b1857-205">-or-</span></span><br /><br /> <span data-ttu-id="b1857-206">對於泛型類型，封入泛型型別引數清單。</span><span class="sxs-lookup"><span data-stu-id="b1857-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="b1857-207">-或-</span><span class="sxs-lookup"><span data-stu-id="b1857-207">-or-</span></span><br /><br /> <span data-ttu-id="b1857-208">在型別引數清單中，會封入組件限定的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="b1857-209">例如，類別的組件限定名稱可能看起來像這樣：</span><span class="sxs-lookup"><span data-stu-id="b1857-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="b1857-210">如果命名空間包含的加號，例如 TopNamespace.Sub+Namespace 則加號 （+） 會加上逸出字元 (\\) 以防止它被解譯為巢狀的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="b1857-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="b1857-211">反映會發出這個字串，如下所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="b1857-212">A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。</span><span class="sxs-lookup"><span data-stu-id="b1857-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="b1857-213">這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="b1857-214">搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="b1857-215"><xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="b1857-216"><xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="b1857-217">型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="b1857-218">若要擷取的型別名稱不含這些尾端字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="b1857-219">空格是相關組件名稱以外的所有型別名稱元件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="b1857-220">在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="b1857-221">泛型引數的泛型型別是由組件名稱所限定。</span><span class="sxs-lookup"><span data-stu-id="b1857-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="b1857-222">例如，在組件限定類型名稱`MyGenericClass<int>`(`MyGenericClass(Of Integer)`在 Visual Basic 中)，`int`展開到組件限定類型名稱<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="b1857-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="b1857-223">如果目前<xref:System.Type>物件代表泛型參數，則這個屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-224">下列範例會顯示與類別相關聯的組件名稱和類型的完整的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="b1857-225">下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-226">取得與 <see cref="T:System.Type" /> 關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-226">Gets the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-227">代表 <see cref="T:System.Reflection.TypeAttributes" /> 屬性集的 <see cref="T:System.Type" /> 物件；若 <see cref="T:System.Type" /> 代表的是泛型類型參數，則這個值就是未指定的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-227">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-228">某些成員<xref:System.Reflection.TypeAttributes>列舉型別會遮罩，代表一組的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-228">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="b1857-229">每個群組包含一個成員，其基礎值為零。</span><span class="sxs-lookup"><span data-stu-id="b1857-229">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="b1857-230">例如，基礎值的<xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType>中的成員<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>群組為零，因為<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>中的成員<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>群組。</span><span class="sxs-lookup"><span data-stu-id="b1857-230">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="b1857-231">因為這個緣故，您必須使用遮罩之前測試這些值。</span><span class="sxs-lookup"><span data-stu-id="b1857-231">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="b1857-232">這個範例將提供說明。</span><span class="sxs-lookup"><span data-stu-id="b1857-232">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="b1857-233">大部分用途而言，屬性例如<xref:System.Type.IsClass%2A>，<xref:System.Type.IsAutoLayout%2A>，和<xref:System.Type.IsSpecialName%2A>容易使用以外的類型屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-233">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="b1857-234">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性傳回的泛型類型定義的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-234">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="b1857-235">例如，針對傳回的屬性`MyGenericClass<int>`(`MyGenericClass(Of Integer)`在 Visual Basic 中) 的屬性是`MyGenericClass<T>`(`MyGenericClass(Of T)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-235">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="b1857-236">如果目前<xref:System.Type>代表泛型類型參數，也就是如果<xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`—<xref:System.Reflection.TypeAttributes>未指定這個屬性所傳回的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-236">If the current <xref:System.Type> represents a generic type parameter — that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` — the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-237">下列範例用途<xref:System.Type.Attributes%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-237">The following example usesthe <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-238">取得目前 <see cref="T:System.Type" /> 所直接繼承的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-238">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-239">目前 <see cref="T:System.Type" /> 直接繼承自的 <see cref="T:System.Type" />，如果目前 <see langword="null" /> 表示 <see langword="Type" /> 類別或介面，則為 <see cref="T:System.Object" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-239">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-240">基底型別是目前的類型直接繼承的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-240">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="b1857-241"><xref:System.Object> 是唯一的類型，但是沒有基底型別，因此`null`傳回基底型別<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="b1857-241"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="b1857-242">介面繼承自零或多個基底介面。因此，這個屬性會傳回`null`如果`Type`物件代表的介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-242">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="b1857-243">基底介面可以判斷與<xref:System.Type.GetInterfaces%2A>或<xref:System.Type.FindInterfaces%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-243">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="b1857-244">如果目前<xref:System.Type>代表建構的泛型類型，基底類型會反映的泛型引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-244">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="b1857-245">例如，請考慮下列宣告：</span><span class="sxs-lookup"><span data-stu-id="b1857-245">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="b1857-246">建構的類型`C<int>`(`C(Of Integer)`在 Visual Basic 中)，則<xref:System.Type.BaseType%2A>屬性會傳回`B<int>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-246">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="b1857-247">如果目前<xref:System.Type>表示泛型類型定義的型別參數<xref:System.Type.BaseType%2A>傳回類別條件約束，也就是將型別參數必須繼承的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-247">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="b1857-248">如果沒有類別條件約束，<xref:System.Type.BaseType%2A>傳回<xref:System.Object?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-248">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b1857-249">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-249">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-250">下列範例示範如何使用<xref:System.Type.BaseType%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-250">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="b1857-251">下列範例會使用遞迴列出完整的繼承階層架構的組件中找到的每個類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-251">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="b1857-252">此範例會定義名為類別`C`衍生自類別，名為`B`，它會接著，衍生自類別，名為`A`。</span><span class="sxs-lookup"><span data-stu-id="b1857-252">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-253">取得值，該值指出目前的 <see cref="T:System.Type" /> 物件是否有尚未被特定類型取代的類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-253">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-254">如果 <see langword="true" /> 物件本身為泛型類型參數或包含尚未提供特定類型的類型參數則為 <see cref="T:System.Type" />否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-254">
              <see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-255">若要建立類型的執行個體，必須有任何泛型類型定義 」 或 「 開放式建構的類型中的型別引數型別本身，在任何的封入泛型類型或任何項目中的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-255">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="b1857-256">另一個說法是，當檢查以遞迴方式，類型必須包含沒有泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-256">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="b1857-257">型別可以很複雜，因為並不容易進行這項判斷。</span><span class="sxs-lookup"><span data-stu-id="b1857-257">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="b1857-258">為了方便起見，並減少錯誤的機會<xref:System.Type.ContainsGenericParameters%2A>屬性提供的標準方式來區別封閉式的建構類型，可以具現化，並開啟建構類型，不能。</span><span class="sxs-lookup"><span data-stu-id="b1857-258">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="b1857-259">如果<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`，無法具現化類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-259">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="b1857-260"><xref:System.Type.ContainsGenericParameters%2A>以遞迴方式型別參數的屬性搜尋。</span><span class="sxs-lookup"><span data-stu-id="b1857-260">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="b1857-261">例如，它會傳回`true`陣列，其元素是型別`A<T>`(`A(Of T)`在 Visual Basic 中)，即使陣列不是泛型本身。</span><span class="sxs-lookup"><span data-stu-id="b1857-261">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="b1857-262">這和行為的<xref:System.Type.IsGenericType%2A>屬性，它會傳回`false`陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-262">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="b1857-263">範例類別和資料表顯示的值的一組<xref:System.Type.ContainsGenericParameters%2A>屬性，請參閱<xref:System.Type.IsGenericType%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-263">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-264">下列範例會定義具有兩個型別參數的泛型類別，然後定義 衍生自第一個類別中的第二個泛型類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-264">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="b1857-265">在衍生的類別的基底類別有兩個型別引數： 第一個是<xref:System.Int32>第二個是衍生型別的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-265">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="b1857-266">此範例會顯示這些泛型類別的相關資訊，包括位置回報<xref:System.Type.GenericParameterPosition%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-266">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-267">如果目前的 <see cref="T:System.Reflection.MethodBase" /> 表示泛型方法的類型參數，則取得表示宣告方法的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-267">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-268">如果目前的 <see cref="T:System.Type" /> 表示泛型方法的類型參數，則為表示宣告方法的 <see cref="T:System.Reflection.MethodBase" />否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-268">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-269">宣告的方法是泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-269">The declaring method is a generic method definition.</span></span> <span data-ttu-id="b1857-270">也就是說，如果<xref:System.Type.DeclaringMethod%2A>不會傳回`null`，然後`DeclaringMethod.IsGenericMethodDefinition`傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-270">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="b1857-271"><xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性識別的泛型類型定義或泛型型別參數原本定義所在的泛型方法定義：</span><span class="sxs-lookup"><span data-stu-id="b1857-271">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="b1857-272">如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件代表泛型方法定義的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-272">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="b1857-273">如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，然後在<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-273">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="b1857-274">取得<xref:System.Type.DeclaringMethod%2A>型別上的屬性其<xref:System.Type.IsGenericParameter%2A>屬性是`false`會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="b1857-274">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="b1857-275"><xref:System.Reflection.MethodBase>所傳回<xref:System.Type.DeclaringMethod%2A>屬性<xref:System.Reflection.MethodInfo>在泛型的方法，或<xref:System.Reflection.ConstructorInfo>在一般的建構函式的情況下。</span><span class="sxs-lookup"><span data-stu-id="b1857-275">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-276">在.NET Framework 2.0 版中，不支援泛型建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-276">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="b1857-277">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。</span><span class="sxs-lookup"><span data-stu-id="b1857-277">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-278">下列程式碼範例會定義具有泛型方法，將型別引數指派給此方法，並產生建構的泛型方法會叫用的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-278">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="b1857-279">它也會顯示該泛型方法定義的建構的方法的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="b1857-279">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="b1857-280">當顯示的相關資訊的型別參數的泛型方法定義中，在`DisplayGenericMethodInfo`方法，範例程式碼顯示的值<xref:System.Type.DeclaringMethod%2A>方法的泛型型別參數的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-280">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-281">取得宣告目前巢狀類型或泛型型別參數的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-281">Gets the type that declares the current nested type or generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-282">若目前的類型是巢狀類型，即為表示封入類型的 <see cref="T:System.Type" /> 物件，若目前的類型是泛型類型的類型參數，則為泛型類型定義，而若目前的類型是泛型方法的類型參數，則為宣告泛型方法的類型，若以上皆否，便為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-282">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-283">如果目前<xref:System.Type>物件代表泛型類型的型別參數，這個屬性會傳回泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-283">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="b1857-284">如果目前<xref:System.Type>物件代表泛型方法的型別參數，這個屬性會傳回包含泛型方法定義的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-284">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="b1857-285">如果類型是泛型，則會傳回泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-285">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="b1857-286">也就是說，下列程式碼傳回的泛型類型定義<xref:System.Collections.Generic.List%601>泛型類別，其中包含<xref:System.Collections.Generic.List%601.ConvertAll%2A>泛型的方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-286">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="b1857-287">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法定義中<xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性識別泛型型別參數的泛型類型定義或泛型方法定義原本定義：</span><span class="sxs-lookup"><span data-stu-id="b1857-287">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="b1857-288">如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件代表泛型方法定義的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-288">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="b1857-289">如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，然後在<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-289">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="b1857-290">取得<xref:System.Type.DeclaringType%2A>型別上的屬性其<xref:System.Type.IsGenericParameter%2A>屬性是`false`會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="b1857-290">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-291">這個範例會顯示在衍生類別中方法的宣告型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-291">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-292">取得預設繫結器 (Binder) 的參考，它會實作內部規則來選取由 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> 呼叫的適當成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-292">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-293">系統使用的預設繫結器之參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-293">A reference to the default binder used by the system.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-294">預設繫結器提供與 common language runtime 選項適用於所有最特殊的情況。</span><span class="sxs-lookup"><span data-stu-id="b1857-294">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="b1857-295">如果您需要不同於所提供的預設繫結器，如下所示規則定義的繫結器型別衍生自<xref:System.Reflection.Binder>類別，並將該型別使用的執行個體傳遞`binder`參數之一的<xref:System.Type.InvokeMember%2A>多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-295">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="b1857-296">反映模型一般類型系統的存取範圍的規則。</span><span class="sxs-lookup"><span data-stu-id="b1857-296">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="b1857-297">例如，如果呼叫端在相同的組件，呼叫端不需要特殊權限的內部成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-297">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="b1857-298">否則，呼叫端需要<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="b1857-298">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="b1857-299">這是一致的受保護的成員查閱、 private、 等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-299">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="b1857-300">一般原則是<xref:System.Reflection.Binder.ChangeType%2A>應該執行僅擴展轉換，不會遺失資料。</span><span class="sxs-lookup"><span data-stu-id="b1857-300">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="b1857-301">擴展轉換的範例將轉換為 64 位元帶正負號的整數值的 32 位元帶正負號的整數的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-301">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="b1857-302">這被區分縮小轉換，可能會遺失資料。</span><span class="sxs-lookup"><span data-stu-id="b1857-302">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="b1857-303">縮小轉換的範例 32 位元帶正負號的整數轉換為 64 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="b1857-303">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="b1857-304">下表列出預設的繫結器所支援的轉換。</span><span class="sxs-lookup"><span data-stu-id="b1857-304">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="b1857-305">來源類型</span><span class="sxs-lookup"><span data-stu-id="b1857-305">Source Type</span></span>|<span data-ttu-id="b1857-306">目標類型</span><span class="sxs-lookup"><span data-stu-id="b1857-306">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="b1857-307">任何型別</span><span class="sxs-lookup"><span data-stu-id="b1857-307">Any type</span></span>|<span data-ttu-id="b1857-308">其基底類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-308">Its base type.</span></span>|  
|<span data-ttu-id="b1857-309">任何型別</span><span class="sxs-lookup"><span data-stu-id="b1857-309">Any type</span></span>|<span data-ttu-id="b1857-310">它所實作的介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-310">The interface it implements.</span></span>|  
|<span data-ttu-id="b1857-311">Char</span><span class="sxs-lookup"><span data-stu-id="b1857-311">Char</span></span>|<span data-ttu-id="b1857-312">Unt16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double</span><span class="sxs-lookup"><span data-stu-id="b1857-312">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="b1857-313">Byte</span><span class="sxs-lookup"><span data-stu-id="b1857-313">Byte</span></span>|<span data-ttu-id="b1857-314">Char、 Unt16、 Int16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double</span><span class="sxs-lookup"><span data-stu-id="b1857-314">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="b1857-315">SByte</span><span class="sxs-lookup"><span data-stu-id="b1857-315">SByte</span></span>|<span data-ttu-id="b1857-316">Int16、Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="b1857-316">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="b1857-317">UInt16</span><span class="sxs-lookup"><span data-stu-id="b1857-317">UInt16</span></span>|<span data-ttu-id="b1857-318">UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="b1857-318">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="b1857-319">Int16</span><span class="sxs-lookup"><span data-stu-id="b1857-319">Int16</span></span>|<span data-ttu-id="b1857-320">Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="b1857-320">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="b1857-321">UInt32</span><span class="sxs-lookup"><span data-stu-id="b1857-321">UInt32</span></span>|<span data-ttu-id="b1857-322">UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="b1857-322">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="b1857-323">Int32</span><span class="sxs-lookup"><span data-stu-id="b1857-323">Int32</span></span>|<span data-ttu-id="b1857-324">Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="b1857-324">Int64, Single, Double</span></span>|  
|<span data-ttu-id="b1857-325">UInt64</span><span class="sxs-lookup"><span data-stu-id="b1857-325">UInt64</span></span>|<span data-ttu-id="b1857-326">Single、Double</span><span class="sxs-lookup"><span data-stu-id="b1857-326">Single, Double</span></span>|  
|<span data-ttu-id="b1857-327">Int64</span><span class="sxs-lookup"><span data-stu-id="b1857-327">Int64</span></span>|<span data-ttu-id="b1857-328">Single、Double</span><span class="sxs-lookup"><span data-stu-id="b1857-328">Single, Double</span></span>|  
|<span data-ttu-id="b1857-329">Single</span><span class="sxs-lookup"><span data-stu-id="b1857-329">Single</span></span>|<span data-ttu-id="b1857-330">Double</span><span class="sxs-lookup"><span data-stu-id="b1857-330">Double</span></span>|  
|<span data-ttu-id="b1857-331">非參考</span><span class="sxs-lookup"><span data-stu-id="b1857-331">Non-reference</span></span>|<span data-ttu-id="b1857-332">所參考。</span><span class="sxs-lookup"><span data-stu-id="b1857-332">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b1857-333">下列範例會取得預設繫結器從`DefaultBinder`屬性，並叫用 MyClass 的成員，藉由傳遞`DefaultBinder`當做參數值<xref:System.Type.InvokeMember%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-333">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-334">分隔 <see cref="T:System.Type" /> 的命名空間中的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-334">Separates names in the namespace of the <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-335">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-335">This field is read-only.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-336">表示 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-336">Represents an empty array of type <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-337">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-337">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b1857-338">下列程式碼範例示範`EmptyTypes`欄位使用其中一種`GetConstructor`方法，以取得不採用任何參數的建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-338">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-339">判斷目前 <see cref="T:System.Type" /> 的基礎系統類型，是否與指定的 <see cref="T:System.Object" /> 或 <see cref="T:System.Type" /> 的基礎系統類型相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-339">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="b1857-340">其基礎系統類型將與目前 <see cref="T:System.Type" /> 的基礎系統類型比較的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-340">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-341">為使比較成功，<c>o</c> 必須可以轉型或轉換為 <see cref="T:System.Type" /> 型別的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-341">For the comparison to succeed, <c>o</c> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-342">判斷目前 <see cref="T:System.Type" /> 物件的基礎系統類型，是否與指定的 <see cref="T:System.Object" /> 的基礎系統類型相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-342">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-343">如果 <paramref name="o" /> 的基礎系統型別與目前 <see cref="T:System.Type" /> 的基礎系統型別相同，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-343">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="b1857-344">下列條件成立時，此方法也會傳回 <see langword="false" />：</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-344">This method also returns <see langword="false" /> if: .</span>
          </span>  
  
-   <span data-ttu-id="b1857-345"><paramref name="o" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b1857-345"><paramref name="o" /> is <see langword="null" />.</span></span>  
  
-   <span data-ttu-id="b1857-346"><paramref name="o" /> 無法轉型或轉換為 <see cref="T:System.Type" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-346"><paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-347">這個方法覆寫 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-347">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1857-348">它會轉換為`o`物件的型別<xref:System.Type>呼叫<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-348">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-349">下列範例會使用<xref:System.Type.Equals%28System.Object%29>比較各種<xref:System.Type>物件執行個體與各種<xref:System.Object>執行個體。</span><span class="sxs-lookup"><span data-stu-id="b1857-349">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="b1857-350">特別值得注意的相關範例，是兩件事：</span><span class="sxs-lookup"><span data-stu-id="b1857-350">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="b1857-351">比較的<xref:System.Type>物件，表示整數<xref:System.Reflection.TypeInfo>物件，表示整數傳回`true`因為<xref:System.Reflection.TypeInfo>衍生自<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-351">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="b1857-352">比較的<xref:System.Type>物件，代表<xref:System.Collections.Generic.IList%601>物件 （開放式泛型類型） 與`List(Of String)`物件 （封閉式泛型類型） 會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-352">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="b1857-353">其基礎系統類型將與目前 <see cref="T:System.Type" /> 的基礎系統類型比較的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-353">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-354">判斷目前 <see cref="T:System.Type" /> 的基礎系統類型，是否與指定的 <see cref="T:System.Type" /> 之基礎系統類型相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-354">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-355">如果 <paramref name="o" /> 的基礎系統型別與目前 <see cref="T:System.Type" /> 的基礎系統型別相同，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-355">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b1857-356">下列範例會使用`Equals`比較兩個類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-356">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-357">表示用在屬性 (Attribute) 上的成員篩選條件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-357">Represents the member filter used on attributes.</span>
          </span>
          <span data-ttu-id="b1857-358">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-358">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-359">這個欄位會保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-359">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="b1857-360">這個委派所封裝的方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件和第二個是`Object`。</span><span class="sxs-lookup"><span data-stu-id="b1857-360">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="b1857-361">此方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。</span><span class="sxs-lookup"><span data-stu-id="b1857-361">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="b1857-362">`Object`可能任一類別上的欄位的值指派給<xref:System.Reflection.FieldAttributes>， <xref:System.Reflection.MethodAttributes>，或<xref:System.Reflection.MethodImplAttributes>。</span><span class="sxs-lookup"><span data-stu-id="b1857-362">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="b1857-363">例如，`Object`可以從欄位的值指派給`FieldAttributes`例如 Public。</span><span class="sxs-lookup"><span data-stu-id="b1857-363">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="b1857-364">在此情況下，當`FilterAttribute`叫用委派時，它會傳回`true`所代表的方法時，才`MemberInfo`物件都有公用欄位中的屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="b1857-364">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-365">下列範例會取得`FilterAttribute`委派、 將它當做參數傳遞<xref:System.Type.FindMembers%2A>方法，並顯示指定的成員和其屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-365">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-366">表示用於名稱上的有區分大小寫的成員篩選條件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-366">Represents the case-sensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="b1857-367">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-367">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-368">這個欄位會保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-368">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="b1857-369">這個委派所封裝的方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件和第二個是`Object`。</span><span class="sxs-lookup"><span data-stu-id="b1857-369">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="b1857-370">此方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。</span><span class="sxs-lookup"><span data-stu-id="b1857-370">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="b1857-371">`Object`指派字串值，可能會在結尾包含"\*"萬用字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-371">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="b1857-372">只有萬用字元結束字串支援比對。</span><span class="sxs-lookup"><span data-stu-id="b1857-372">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="b1857-373">例如，`Object`指派的值"位元組 \*"。</span><span class="sxs-lookup"><span data-stu-id="b1857-373">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="b1857-374">在此情況下，當`FilterName`叫用委派時，它會傳回`true`所代表的方法時，才`MemberInfo`物件具有開頭為 「 位元組 」 的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-374">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-375">下列程式碼範例會取得相關聯的使用者定義的方法`Application`型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-375">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-376">表示用在名稱上的不區分大小寫的成員篩選條件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-376">Represents the case-insensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="b1857-377">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-377">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-378">這個欄位會保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-378">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="b1857-379">這個委派所封裝的方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件和第二個是`Object`。</span><span class="sxs-lookup"><span data-stu-id="b1857-379">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="b1857-380">此方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。</span><span class="sxs-lookup"><span data-stu-id="b1857-380">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="b1857-381">`Object`指派字串值，可能會在結尾包含"\*"萬用字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-381">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="b1857-382">只有萬用字元結束字串支援比對。</span><span class="sxs-lookup"><span data-stu-id="b1857-382">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="b1857-383">例如，`Object`指派的值"位元組 \*"。</span><span class="sxs-lookup"><span data-stu-id="b1857-383">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="b1857-384">在此情況下，當`FilterName`叫用委派，它會傳回 true 只所代表的方法如果`MemberInfo`物件具有開頭為 「 位元組 」，忽略大小寫的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-384">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-385">下列範例會取得`MemberFilter`委派、 將它當做參數傳遞<xref:System.Type.FindMembers%2A>方法，並顯示方法和屬性的`String`開頭字母"c"，正在略過 大小寫的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-385">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="b1857-386">根據 <c>filterCriteria</c> 比較介面的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-386">The delegate that compares the interfaces against <c>filterCriteria</c>.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="b1857-387">判斷在傳回陣列中是否應包含介面的搜尋準則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-387">The search criteria that determines whether an interface should be included in the returned array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-388">傳回 <see cref="T:System.Type" /> 物件的陣列，表示由目前 <see cref="T:System.Type" /> 所實作或繼承的介面的篩選清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-388">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-389">
            <see cref="T:System.Type" /> 物件的陣列，表示由目前的 <see cref="T:System.Type" /> 所實作或繼承之介面的篩選清單，如果由目前的 <see cref="T:System.Type" /> 所實作或繼承之介面都不符合篩選器，則為 <see cref="T:System.Type" /> 的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-389">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-390">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-390">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="b1857-391"><xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>和<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>所提供的委派<xref:System.Reflection.Module?displayProperty=nameWithType>類別也可用於，lieu 的<xref:System.Reflection.TypeFilter?displayProperty=nameWithType>委派。</span><span class="sxs-lookup"><span data-stu-id="b1857-391">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="b1857-392">這個類別所實作之介面的考慮所有在搜尋期間，是否為基底類別或此類別本身所宣告。</span><span class="sxs-lookup"><span data-stu-id="b1857-392">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="b1857-393">這個方法會搜尋基底類別階層架構中，傳回每一個相符的介面，以及所有比對的每個類別會實作介面的實作 （亦即，會傳回相符的介面的遞移封閉）。</span><span class="sxs-lookup"><span data-stu-id="b1857-393">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="b1857-394">傳回不重複的介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-394">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="b1857-395">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法定義中<xref:System.Type.FindInterfaces%2A>搜尋所有介面宣告中的條件約束的型別參數，而且所有介面都繼承與介面宣告在條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-395">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="b1857-396">如果目前<xref:System.Type>代表型別引數的泛型型別，<xref:System.Type.FindInterfaces%2A>是否符合條件約束，搜尋所有類型所實作的介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-396">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-397"><xref:System.Type.FindInterfaces%2A> 可傳回泛型介面，即使在不是泛型類型上。</span><span class="sxs-lookup"><span data-stu-id="b1857-397"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="b1857-398">例如，可能會實作非泛型型別`IEnumerable<int>`(`IEnumerable(Of Integer)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-398">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-399">下列範例會尋找指定的介面實作或繼承之指定類型，並接著會顯示介面名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-399">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-400">
            <paramref name="filter" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-400">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-401">靜態初始設定式已叫用並擲回了例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-401">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">
          <span data-ttu-id="b1857-402">物件，表示要搜尋的成員類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-402">An object that indicates the type of member to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-403">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-403">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-404">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-404">-or-</span>
          </span>
          <span data-ttu-id="b1857-405">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-405">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="b1857-406">執行比較的委派，如果目前進行檢查的成員符合 <c>filterCriteria</c>，則傳回 <see langword="true" />；否則傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-406">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <c>filterCriteria</c> and <see langword="false" /> otherwise.</span>
          </span>
          <span data-ttu-id="b1857-407">您可以使用這個類別所提供的 <see langword="FilterAttribute" />、<see langword="FilterName" /> 和 <see langword="FilterNameIgnoreCase" /> 委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-407">You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class.</span>
          </span>
          <span data-ttu-id="b1857-408">第一個委派使用 <see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的欄位做為搜尋準則，而其他兩個委派則使用 <see langword="String" /> 物件做為搜尋準則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-408">The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="b1857-409">判斷在 <see langword="MemberInfo" /> 物件的陣列中是否傳回成員的搜尋準則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-409">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span>
          </span>
          <span data-ttu-id="b1857-410">
            <see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的欄位可以與這個類別所提供的 <see langword="FilterAttribute" /> 委派結合使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-410">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-411">傳回指定成員類型的 <see cref="T:System.Reflection.MemberInfo" /> 物件的篩選陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-411">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-412">指定之成員類型的 <see cref="T:System.Reflection.MemberInfo" /> 物件篩選陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-412">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
          <span data-ttu-id="b1857-413">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-413">-or-</span>
          </span>
          <span data-ttu-id="b1857-414">
            <see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列，如果目前 <see cref="T:System.Type" /> 沒有符合篩選條件的 <paramref name="memberType" /> 類型的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-414">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-415">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-415">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="b1857-416">成員包括屬性、 方法、 欄位、 事件等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-416">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="b1857-417">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：</span><span class="sxs-lookup"><span data-stu-id="b1857-417">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-418">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-418">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-419">指定`BindingFlags.Instance`来包含在搜尋中的執行個體成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-419">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-420">指定`BindingFlags.Static`来包含在搜尋中的靜態成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-420">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-421">指定`BindingFlags.Public`来包含在搜尋中的公用成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-421">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-422">指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</span><span class="sxs-lookup"><span data-stu-id="b1857-422">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="b1857-423">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-423">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-424">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-424">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-425">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-425">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-426">有效值<xref:System.Type.MemberType%2A>中定義<xref:System.Reflection.MemberInfo>。</span><span class="sxs-lookup"><span data-stu-id="b1857-426">Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>.</span></span> <span data-ttu-id="b1857-427">如果找不到任何這類成員，則會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-427">If no such members are found, an empty array is returned.</span></span>  
  
 <span data-ttu-id="b1857-428">若要取得使用此方法的類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-428">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-429">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-429">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-430">如果目前<xref:System.Type>表示泛型類型或泛型方法的型別參數<xref:System.Type.FindMembers%2A>處理任何由類別條件約束和介面條件約束的型別參數宣告的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-430">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-431">下列範例會尋找符合指定的搜尋條件中，在類別中的所有成員，然後顯示 符合的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-431">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-432">
            <paramref name="filter" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-432">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-433">取得類型的完整名稱 (包括其命名空間，但不包括其組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-433">Gets the fully qualified name of the type, including its namespace but not its assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-434">類型的完整名稱 (包括其命名空間，但不包括其組件)；如果目前執行個體代表泛型類型參數、陣列類型、指標類型、根據類型參數的 <see langword="null" /> 類型，或不是泛型類型定義但包含未解析類型參數的泛型類型，則為 <see langword="byref" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-434">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-435">例如，完整的名稱的<xref:System.String>型別是`System.String`。</span><span class="sxs-lookup"><span data-stu-id="b1857-435">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="b1857-436">這和所傳回的組件限定名稱<xref:System.Type.AssemblyQualifiedName%2A>屬性，其中包含的完整名稱加上完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-436">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="b1857-437">如果目前的型別代表封閉泛型類型，所傳回的字串中的型別引數<xref:System.Type.FullName%2A>屬性會以其完整的組件名稱限定，即使並未被其完整限定的泛型類型本身的字串表示組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-437">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="b1857-438">下列範例說明代表泛型類型定義的類型，另一個則代表封閉泛型類型的 FullName 屬性中的差異。</span><span class="sxs-lookup"><span data-stu-id="b1857-438">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="b1857-439">這個屬性會傳回`null`如果：</span><span class="sxs-lookup"><span data-stu-id="b1857-439">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="b1857-440">目前<xref:System.Type>物件代表泛型類型的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-440">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="b1857-441">下列範例會擷取的型別參數<xref:System.Nullable%601>型別，並嘗試顯示其<xref:System.Type.FullName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-441">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="b1857-442">目前<xref:System.Type>物件都代表陣列類型、 指標類型或`byref`泛型型別參數為基礎的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-442">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="b1857-443">下列範例會定義泛型類型， `Generictype1<T>`，三個方法： `Display(T[])`，傳遞的型別 T; 陣列`HandleT(T)`，T 的物件; 傳遞和`ChangeValue(ref T)`，這傳址方式傳遞 T 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-443">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="b1857-444">因為 C# 和 Visual Basic 不允許我們定義中的指標為 T`HandleT`方法，我們需要呼叫<xref:System.Type.MakePointerType%2A>方法<xref:System.Type>物件，代表方法的參數類型，若要建立泛型類型的指標。</span><span class="sxs-lookup"><span data-stu-id="b1857-444">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="b1857-445">範例輸出顯示在所有的三種情況下，<xref:System.Type.FullName%2A>屬性是`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-445">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="b1857-446">目前的類型包含有尚未被特定類型取代的泛型類型參數 (也就是<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`)，但類型不是泛型類型定義 (也就是<xref:System.Type.IsGenericTypeDefinition%2A>屬性會傳回 `false`</span><span class="sxs-lookup"><span data-stu-id="b1857-446">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="b1857-447">在下列範例中，`Derived<T>`繼承自`Base<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-447">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="b1857-448"><xref:System.Type.BaseType%2A>屬性會取得<xref:System.Type>物件，代表的基底類型`Derived<T>`，且其<xref:System.Type.FullName%2A>屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-448">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="b1857-449">若要取得<xref:System.Type.FullName%2A>不`null`，您可以使用<xref:System.Type.GetGenericTypeDefinition%2A>方法來取得泛型類型定義，如範例所示。</span><span class="sxs-lookup"><span data-stu-id="b1857-449">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="b1857-450">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-450">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-451">下列範例會顯示指定之類型的完整名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-451">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="b1857-452">下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-452">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-453">取得一組 <see cref="T:System.Reflection.GenericParameterAttributes" /> 旗標，敘述目前泛型類型參數的共變數與特殊條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-453">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-454">
            <see cref="T:System.Reflection.GenericParameterAttributes" /> 值的位元組合，描述目前泛型類型參數的共變數和特殊條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-454">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-455">這個屬性的值包含旗標，敘述目前泛型型別參數是否共變數和其他特殊條件約束的旗標。</span><span class="sxs-lookup"><span data-stu-id="b1857-455">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="b1857-456">使用<xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType>值加入選取的共變數旗標，並使用<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType>来選取的條件約束旗標值。</span><span class="sxs-lookup"><span data-stu-id="b1857-456">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="b1857-457">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。</span><span class="sxs-lookup"><span data-stu-id="b1857-457">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-458">下列程式碼範例會定義泛型型別`Test`具有兩個具有不同的條件約束的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-458">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="b1857-459">當程式執行時，條件約束會檢查使用<xref:System.Type.GenericParameterAttributes%2A>屬性和<xref:System.Type.GetGenericParameterConstraints%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-459">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-460">目前的 <see cref="T:System.Type" /> 物件不是泛型型別參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-460">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="b1857-461">亦即，<see cref="P:System.Type.IsGenericParameter" /> 屬性會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-461">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-462">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-462">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-463">當 <see cref="T:System.Type" /> 物件表示泛型類型或泛型方法的類型參數時，在宣告參數的泛型類型或泛型方法之類型參數清單中，取得類型參數的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-463">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-464">型別參數在宣告參數的泛型類型或方法之型別參數清單中的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-464">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span>
          </span>
          <span data-ttu-id="b1857-465">位置編號從 0 開始。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-465">Position numbers begin at 0.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-466"><xref:System.Type.GenericParameterPosition%2A>屬性會傳回型別參數的位置參數清單的泛型類型定義或泛型方法定義中的型別參數原本定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-466">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="b1857-467"><xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性識別的泛型類型或泛型方法定義：</span><span class="sxs-lookup"><span data-stu-id="b1857-467">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="b1857-468">如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件代表泛型方法定義的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-468">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="b1857-469">如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，然後在<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-469">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="b1857-470">若要提供正確的內容值的<xref:System.Type.GenericParameterPosition%2A>屬性，它會需要識別的泛型型別或型別參數所屬的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-470">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="b1857-471">例如，請考慮泛型方法的傳回值`GetSomething`下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="b1857-471">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="b1857-472">傳回的型別`GetSomething`取決於提供給類別的型別引數`A`和`GetSomething`本身。</span><span class="sxs-lookup"><span data-stu-id="b1857-472">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="b1857-473">您可以取得<xref:System.Reflection.MethodInfo>如`GetSomething`，而且可以從所取得的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-473">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="b1857-474">當您檢查型別參數的傳回型別，<xref:System.Type.GenericParameterPosition%2A>同時會傳回 0。</span><span class="sxs-lookup"><span data-stu-id="b1857-474">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="b1857-475">位置`V`為 0，因為`V`類別的型別參數清單中的第一個型別參數`A`。</span><span class="sxs-lookup"><span data-stu-id="b1857-475">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="b1857-476">位置`X`為 0，因為`X`是第一個型別參數的型別參數清單中`GetSomething`。</span><span class="sxs-lookup"><span data-stu-id="b1857-476">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-477">呼叫<xref:System.Type.GenericParameterPosition%2A>屬性造成例外狀況，如果目前<xref:System.Type>不代表型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-477">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="b1857-478">當您檢查開放式建構類型的類型引數時，使用<xref:System.Type.IsGenericParameter%2A>分辨哪些是型別參數，而這是類型的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-478">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="b1857-479"><xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`型別參數; 然後您可以使用<xref:System.Type.GenericParameterPosition%2A>方法來取得它的位置使用<xref:System.Type.DeclaringMethod%2A>和<xref:System.Type.DeclaringType%2A>內容來決定泛型方法或類型定義它的定義.</span><span class="sxs-lookup"><span data-stu-id="b1857-479">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-480">下列範例會定義具有兩個型別參數的泛型類別，並定義衍生自第一個類別中的第二個泛型類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-480">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="b1857-481">在衍生的類別的基底類別有兩個型別引數： 第一個是<xref:System.Int32>，第二個是衍生型別的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-481">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="b1857-482">此範例會顯示這些泛型類別的相關資訊，包括位置回報<xref:System.Type.GenericParameterPosition%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-482">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-483">目前類型不代表型別參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-483">The current type does not represent a type parameter.</span>
          </span>
          <span data-ttu-id="b1857-484">亦即，<see cref="P:System.Type.IsGenericParameter" /> 會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-484">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-485">取得此類型之泛型型別引數的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-485">Gets an array of the generic type arguments for this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-486">這個類型之泛型型別引數的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-486">An array of the generic type arguments for this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-487">這個屬性取得只的泛型型別引數;也就是說，已指定目前的型別之泛型型別參數的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-487">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="b1857-488">如果目前的類型是泛型類型定義，這個屬性會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-488">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-489">如果另一個泛型類型或泛型方法中使用泛型型別，則其泛型型別引數的某些可能封入方法或類型的泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-489">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="b1857-490">若要取得代表泛型類型定義的類型的泛型型別參數，請使用<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-490">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b1857-491">若要取得<xref:System.Reflection.TypeInfo>物件目前<xref:System.Type>物件，請使用<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>擴充方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-491">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-492">取得陣列中的維度數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-492">Gets the number of dimensions in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-493">包含目前類型中之維度數目的整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-493">An integer that contains the number of dimensions in the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b1857-494">下列範例會顯示在陣列中的維度數目。</span><span class="sxs-lookup"><span data-stu-id="b1857-494">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-495">這個方法的功能不受基底類別的支援，因此必須改為在衍生類別中實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-495">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-496">目前的類型不是陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-496">The current type is not an array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-497">在衍生類別中覆寫時，實作 <see cref="P:System.Type.Attributes" /> 屬性並取得位元遮罩，指示與 <see cref="T:System.Type" /> 關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-497">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-498">
            <see cref="T:System.Reflection.TypeAttributes" /> 物件，代表 <see cref="T:System.Type" /> 的屬性集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-498">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-499">取得目前 <see cref="T:System.Type" /> 的特定建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-499">Gets a specific constructor of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">
          <span data-ttu-id="b1857-500">由 <see cref="T:System.Type" /> 物件組成的陣列，表示所要建構函式參數的數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-500">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span>
          </span>
          <span data-ttu-id="b1857-501">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-501">-or-</span>
          </span>
          <span data-ttu-id="b1857-502">由 <see cref="T:System.Type" /> 物件組成的空陣列，用來取得不需任何參數的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-502">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="b1857-503">這種供陣列是由 <see langword="static" /> 欄位 <see cref="F:System.Type.EmptyTypes" /> 提供的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-503">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-504">搜尋其參數符合在指定陣列中的類型的公用執行個體建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-504">Searches for a public instance constructor whose parameters match the types in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-505">物件，表示其參數符合參數類型陣列中之類型的公用執行個體建構函式 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-505">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-506">這個方法多載尋找公用執行個體建構函式，無法用來取得類別初始設定式 (.cctor)。</span><span class="sxs-lookup"><span data-stu-id="b1857-506">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</span></span> <span data-ttu-id="b1857-507">若要取得的類別初始設定式，使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-507">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-508">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-508">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-509">如果要求的建構函式為非公用，則這個方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-509">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-510">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-510">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-511">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-511">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-512">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-512">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="b1857-513">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-513">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-514">下列範例會取得的型別`MyClass`，取得<xref:System.Reflection.ConstructorInfo>物件，並會顯示建構函式簽章。</span><span class="sxs-lookup"><span data-stu-id="b1857-514">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-515">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-515">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-516">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-516">-or-</span>
          </span>
          <span data-ttu-id="b1857-517">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-517">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-518">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-518">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-519">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-519">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-520">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-520">-or-</span>
          </span>
          <span data-ttu-id="b1857-521">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-521">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-522">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-522">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-523">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-523">-or-</span>
          </span>
          <span data-ttu-id="b1857-524">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-524">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-525">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-525">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="b1857-526">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-526">-or-</span>
          </span>
          <span data-ttu-id="b1857-527">用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-527">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="b1857-528">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-528">-or-</span>
          </span>
          <span data-ttu-id="b1857-529">
            <see cref="F:System.Type.EmptyTypes" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-529">
              <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-530">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，代表在參數類型陣列中與對應項目關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-530">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span>
          </span>
          <span data-ttu-id="b1857-531">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-531">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-532">使用指定的繫結條件約束 (Constraint) 搜尋其參數符合指定的引數類型和修飾詞 (Modifier) 的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-532">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-533">
            <see cref="T:System.Reflection.ConstructorInfo" /> 物件，代表符合指定之需求的建構函式 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-533">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-534">如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`陣列，就可以選取相符項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-534">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="b1857-535">如果`binder`無法選取相符項目，然後`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-535">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="b1857-536">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的建構函式：</span><span class="sxs-lookup"><span data-stu-id="b1857-536">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-537">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-537">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-538">指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-538">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="b1857-539">指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。</span><span class="sxs-lookup"><span data-stu-id="b1857-539">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="b1857-540">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-540">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-541">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-541">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-542">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-542">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-543">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-543">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-544">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-544">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-545">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-545">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="b1857-546">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-546">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-547">下列程式會取得的型別`MyClass1`類別，取得<xref:System.Reflection.ConstructorInfo>物件符合指定的繫結旗標，並顯示建構函式的簽章。</span><span class="sxs-lookup"><span data-stu-id="b1857-547">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-548">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-548">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-549">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-549">-or-</span>
          </span>
          <span data-ttu-id="b1857-550">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-550">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-551">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-551">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-552">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-552">-or-</span>
          </span>
          <span data-ttu-id="b1857-553">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-553">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-554">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-554">-or-</span>
          </span>
          <span data-ttu-id="b1857-555">
            <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-555">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-556">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-556">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-557">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-557">-or-</span>
          </span>
          <span data-ttu-id="b1857-558">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-558">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-559">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-559">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-560">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-560">-or-</span>
          </span>
          <span data-ttu-id="b1857-561">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-561">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="b1857-562">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及清除堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-562">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-563">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-563">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="b1857-564">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-564">-or-</span>
          </span>
          <span data-ttu-id="b1857-565">用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-565">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-566">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-566">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-567">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-567">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-568">使用指定的繫結條件約束和指定的呼叫慣例，搜尋其參數符合指定的引數類型和修飾詞的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-568">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-569">物件，代表符合指定之需求的建構函式 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-569">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-570">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-570">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-571">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-571">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-572">如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`陣列，就可以選取相符項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-572">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="b1857-573">如果`binder`無法選取相符項目，然後`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-573">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="b1857-574">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的建構函式：</span><span class="sxs-lookup"><span data-stu-id="b1857-574">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-575">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-575">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-576">指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-576">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="b1857-577">指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。</span><span class="sxs-lookup"><span data-stu-id="b1857-577">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="b1857-578">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-578">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-579">若要取得使用此方法的類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-579">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-580">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-580">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-581">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-581">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-582">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-582">Member Type</span></span>|<span data-ttu-id="b1857-583">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-583">Static</span></span>|<span data-ttu-id="b1857-584">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-584">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-585">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-585">Constructor</span></span>|<span data-ttu-id="b1857-586">否</span><span class="sxs-lookup"><span data-stu-id="b1857-586">No</span></span>|<span data-ttu-id="b1857-587">否</span><span class="sxs-lookup"><span data-stu-id="b1857-587">No</span></span>|  
|<span data-ttu-id="b1857-588">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-588">Field</span></span>|<span data-ttu-id="b1857-589">否</span><span class="sxs-lookup"><span data-stu-id="b1857-589">No</span></span>|<span data-ttu-id="b1857-590">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-590">Yes.</span></span> <span data-ttu-id="b1857-591">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-591">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-592">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-592">Event</span></span>|<span data-ttu-id="b1857-593">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-593">Not applicable</span></span>|<span data-ttu-id="b1857-594">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-594">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-595">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-595">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-596">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-596">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-597">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-597">Method</span></span>|<span data-ttu-id="b1857-598">否</span><span class="sxs-lookup"><span data-stu-id="b1857-598">No</span></span>|<span data-ttu-id="b1857-599">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-599">Yes.</span></span> <span data-ttu-id="b1857-600">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-600">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-601">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-601">Nested Type</span></span>|<span data-ttu-id="b1857-602">否</span><span class="sxs-lookup"><span data-stu-id="b1857-602">No</span></span>|<span data-ttu-id="b1857-603">否</span><span class="sxs-lookup"><span data-stu-id="b1857-603">No</span></span>|  
|<span data-ttu-id="b1857-604">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-604">Property</span></span>|<span data-ttu-id="b1857-605">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-605">Not applicable</span></span>|<span data-ttu-id="b1857-606">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-606">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-607">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-607">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-608">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-608">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-609">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-609">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-610">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-610">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-611">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-611">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-612">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-612">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-613">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-613">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-614">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-614">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-615">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-615">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-616">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-616">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="b1857-617">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-617">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-618">下列範例會取得的型別`MyClass1`，取得<xref:System.Reflection.ConstructorInfo>物件符合指定的繫結旗標，並會顯示建構函式簽章。</span><span class="sxs-lookup"><span data-stu-id="b1857-618">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-619">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-619">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-620">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-620">-or-</span>
          </span>
          <span data-ttu-id="b1857-621">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-621">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-622">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-622">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-623">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-623">-or-</span>
          </span>
          <span data-ttu-id="b1857-624">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-624">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-625">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-625">-or-</span>
          </span>
          <span data-ttu-id="b1857-626">
            <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-626">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-627">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-627">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-628">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-628">-or-</span>
          </span>
          <span data-ttu-id="b1857-629">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-629">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-630">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-630">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-631">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-631">-or-</span>
          </span>
          <span data-ttu-id="b1857-632">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-632">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="b1857-633">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及清除堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-633">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-634">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-634">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="b1857-635">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-635">-or-</span>
          </span>
          <span data-ttu-id="b1857-636">用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-636">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-637">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-637">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-638">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-638">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-639">在衍生類別中覆寫時，使用指定的繫結條件約束和指定的呼叫慣例，搜尋其參數符合指定的引數類型和修飾詞的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-639">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-640">
            <see cref="T:System.Reflection.ConstructorInfo" /> 物件，代表符合指定之需求的建構函式 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-640">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-641">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-641">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-642">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-642">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-643">如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`陣列，就可以選取相符項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-643">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="b1857-644">如果`binder`無法選取相符項目，然後`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-644">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="b1857-645">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的建構函式：</span><span class="sxs-lookup"><span data-stu-id="b1857-645">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-646">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-646">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-647">指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-647">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="b1857-648">指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。</span><span class="sxs-lookup"><span data-stu-id="b1857-648">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="b1857-649">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-649">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-650">這個方法會實作 <xref:System.Type.GetConstructor%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-650">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-651">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-651">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-652">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-652">-or-</span>
          </span>
          <span data-ttu-id="b1857-653">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-653">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-654">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-654">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-655">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-655">-or-</span>
          </span>
          <span data-ttu-id="b1857-656">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-656">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-657">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-657">-or-</span>
          </span>
          <span data-ttu-id="b1857-658">
            <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-658">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-659">目前的型別是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-659">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-660">取得目前 <see cref="T:System.Type" /> 的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-660">Gets the constructors of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-661">傳回所有定義給目前 <see cref="T:System.Type" /> 的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-661">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-662">由 <see cref="T:System.Reflection.ConstructorInfo" /> 物件組成的陣列，表示定義給目前 <see cref="T:System.Type" /> 的所有公用執行個體建構函式，但不含類型初始設定式 (靜態建構函式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-662">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span>
          </span>
          <span data-ttu-id="b1857-663">如果目前的 <see cref="T:System.Type" /> 沒有定義任何公用執行個體建構函式，或目前的 <see cref="T:System.Type" /> 表示泛型類型或泛型方法定義中的類型參數，則會傳回 <see cref="T:System.Reflection.ConstructorInfo" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-663">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-664"><xref:System.Type.GetConstructors%2A>方法不會建構函式傳回以特定順序，例如，按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-664">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="b1857-665">您的程式碼不得相依於建構函式會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-665">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-666">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-666">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-667">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-667">Member Type</span></span>|<span data-ttu-id="b1857-668">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-668">Static</span></span>|<span data-ttu-id="b1857-669">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-669">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-670">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-670">Constructor</span></span>|<span data-ttu-id="b1857-671">否</span><span class="sxs-lookup"><span data-stu-id="b1857-671">No</span></span>|<span data-ttu-id="b1857-672">否</span><span class="sxs-lookup"><span data-stu-id="b1857-672">No</span></span>|  
|<span data-ttu-id="b1857-673">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-673">Field</span></span>|<span data-ttu-id="b1857-674">否</span><span class="sxs-lookup"><span data-stu-id="b1857-674">No</span></span>|<span data-ttu-id="b1857-675">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-675">Yes.</span></span> <span data-ttu-id="b1857-676">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-676">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-677">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-677">Event</span></span>|<span data-ttu-id="b1857-678">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-678">Not applicable</span></span>|<span data-ttu-id="b1857-679">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-679">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-680">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-680">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-681">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-681">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-682">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-682">Method</span></span>|<span data-ttu-id="b1857-683">否</span><span class="sxs-lookup"><span data-stu-id="b1857-683">No</span></span>|<span data-ttu-id="b1857-684">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-684">Yes.</span></span> <span data-ttu-id="b1857-685">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-685">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-686">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-686">Nested Type</span></span>|<span data-ttu-id="b1857-687">否</span><span class="sxs-lookup"><span data-stu-id="b1857-687">No</span></span>|<span data-ttu-id="b1857-688">否</span><span class="sxs-lookup"><span data-stu-id="b1857-688">No</span></span>|  
|<span data-ttu-id="b1857-689">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-689">Property</span></span>|<span data-ttu-id="b1857-690">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-690">Not applicable</span></span>|<span data-ttu-id="b1857-691">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-691">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-692">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-692">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-693">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-693">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-694">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-694">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-695">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-695">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-696">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-696">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-697">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-697">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-698">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-698">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-699">這個方法多載呼叫<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>方法多載，與<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-699">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-700">將不會發現類別初始設定式 (.cctor)。</span><span class="sxs-lookup"><span data-stu-id="b1857-700">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="b1857-701">類別初始設定式，請使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-701">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-702">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-702">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-703">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-703">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="b1857-704">比方說，如果類別`C<T>`的建構函式`C(T t1)`(`Sub New(ByVal t1 As T)`在 Visual Basic 中)，則呼叫<xref:System.Type.GetConstructors%2A>上`C<int>`傳回<xref:System.Reflection.ConstructorInfo>表示`C(int t1)`C# 中 (`Sub New(ByVal t1 As Integer)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-704">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="b1857-705">如果目前<xref:System.Type>表示泛型型別參數時，<xref:System.Type.GetConstructors%2A>方法會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-705">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-706">此範例中顯示的輸出<xref:System.Type.GetConstructors%2A>從類別具有兩個執行個體建構函式和一個靜態建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-706">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="b1857-707">這個程式碼的輸出為：</span><span class="sxs-lookup"><span data-stu-id="b1857-707">The output of this code is:</span></span>  
  
 <span data-ttu-id="b1857-708">2</span><span class="sxs-lookup"><span data-stu-id="b1857-708">2</span></span>  
  
 <span data-ttu-id="b1857-709">False</span><span class="sxs-lookup"><span data-stu-id="b1857-709">False</span></span>  
  
 <span data-ttu-id="b1857-710">False</span><span class="sxs-lookup"><span data-stu-id="b1857-710">False</span></span>  
  
 <span data-ttu-id="b1857-711">因為<xref:System.Type.GetConstructors>多載只會使用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>和<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，靜態建構函式都不會計算由`for`運算式，也不會評估`IsStatic`。</span><span class="sxs-lookup"><span data-stu-id="b1857-711">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="b1857-712">靜態建構函式，請使用<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>多載，並傳遞組合 (邏輯`OR`) 的<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，如下列程式碼範例所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-712">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="b1857-713">現在的輸出為：</span><span class="sxs-lookup"><span data-stu-id="b1857-713">Now the output is:</span></span>  
  
 <span data-ttu-id="b1857-714">3</span><span class="sxs-lookup"><span data-stu-id="b1857-714">3</span></span>  
  
 <span data-ttu-id="b1857-715">False</span><span class="sxs-lookup"><span data-stu-id="b1857-715">False</span></span>  
  
 <span data-ttu-id="b1857-716">True</span><span class="sxs-lookup"><span data-stu-id="b1857-716">True</span></span>  
  
 <span data-ttu-id="b1857-717">False</span><span class="sxs-lookup"><span data-stu-id="b1857-717">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-718">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-718">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-719">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-719">-or-</span>
          </span>
          <span data-ttu-id="b1857-720">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-720">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-721">在衍生類別中覆寫時，使用指定的 <see cref="T:System.Type" />，搜尋定義給目前 <see langword="BindingFlags" /> 的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-721">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-722">
            <see cref="T:System.Reflection.ConstructorInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有建構函式，包括類型初始設定式 (如果已定義)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-722">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span>
          </span>
          <span data-ttu-id="b1857-723">如果目前的 <see cref="T:System.Reflection.ConstructorInfo" /> 沒有定義建構函式，或所定義的建構函式都不符合繫結條件約束，或目前的 <see cref="T:System.Type" /> 表示泛型類型或泛型方法定義中的類型參數，則傳回 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-723">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-724"><xref:System.Type.GetConstructors%2A>方法不會建構函式傳回以特定順序，例如，按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-724">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="b1857-725">您的程式碼不得相依於建構函式會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-725">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-726">`bindingAttr` 可以用於指定是否要傳回只有公用建構函式或公用和非公用建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-726">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
 <span data-ttu-id="b1857-727">如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`陣列，就可以選取相符項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-727">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="b1857-728">如果`binder`無法選取相符項目，然後`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-728">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="b1857-729">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的建構函式：</span><span class="sxs-lookup"><span data-stu-id="b1857-729">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-730">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-730">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-731">指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-731">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="b1857-732">指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。</span><span class="sxs-lookup"><span data-stu-id="b1857-732">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span> <span data-ttu-id="b1857-733">不會傳回基底類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-733">Constructors of base classes are not returned.</span></span>  
  
 <span data-ttu-id="b1857-734">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-734">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-735">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-735">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-736">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-736">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-737">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-737">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="b1857-738">比方說，如果類別`C<T>`的建構函式`C(T t1)`(`Sub New(ByVal t1 As T)`在 Visual Basic 中)，則呼叫<xref:System.Type.GetConstructors%2A>上`C<int>`傳回<xref:System.Reflection.ConstructorInfo>表示`C(int t1)`C# 中 (`Sub New(ByVal t1 As Integer)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-738">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="b1857-739">如果目前<xref:System.Type>表示泛型型別參數時，<xref:System.Type.GetConstructors%2A>方法會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-739">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-740">此範例中顯示的輸出<xref:System.Type.GetConstructors>從類別具有兩個執行個體建構函式和一個靜態建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-740">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="b1857-741">這個程式碼的輸出為：</span><span class="sxs-lookup"><span data-stu-id="b1857-741">The output of this code is:</span></span>  
  
 <span data-ttu-id="b1857-742">2</span><span class="sxs-lookup"><span data-stu-id="b1857-742">2</span></span>  
  
 <span data-ttu-id="b1857-743">False</span><span class="sxs-lookup"><span data-stu-id="b1857-743">False</span></span>  
  
 <span data-ttu-id="b1857-744">False</span><span class="sxs-lookup"><span data-stu-id="b1857-744">False</span></span>  
  
 <span data-ttu-id="b1857-745">因為<xref:System.Type.GetConstructors%2A>多載只會使用<xref:System.Reflection.BindingFlags.Public>和<xref:System.Reflection.BindingFlags.Instance>，靜態建構函式都不會計算由`for`運算式，也不會評估`IsStatic`。</span><span class="sxs-lookup"><span data-stu-id="b1857-745">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="b1857-746">靜態建構函式，請使用<xref:System.Type.GetConstructors%2A>多載，並將它傳遞的組合 (邏輯 OR) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，如下列程式碼範例所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-746">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="b1857-747">現在的輸出為：</span><span class="sxs-lookup"><span data-stu-id="b1857-747">Now the output is:</span></span>  
  
 <span data-ttu-id="b1857-748">3</span><span class="sxs-lookup"><span data-stu-id="b1857-748">3</span></span>  
  
 <span data-ttu-id="b1857-749">False</span><span class="sxs-lookup"><span data-stu-id="b1857-749">False</span></span>  
  
 <span data-ttu-id="b1857-750">True</span><span class="sxs-lookup"><span data-stu-id="b1857-750">True</span></span>  
  
 <span data-ttu-id="b1857-751">False</span><span class="sxs-lookup"><span data-stu-id="b1857-751">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-752">搜尋定義給目前 <see cref="T:System.Type" /> 的成員，而它的 <see cref="T:System.Reflection.DefaultMemberAttribute" /> 已設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-752">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-753">
            <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有預設成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-753">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-754">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-754">-or-</span>
          </span>
          <span data-ttu-id="b1857-755">
            <see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有預設成員)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-755">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-756"><xref:System.Type.GetDefaultMembers%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-756">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-757">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-757">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-758">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-758">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="b1857-759">成員包括屬性、 方法、 欄位、 事件等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-759">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="b1857-760">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-760">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-761">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-761">Member Type</span></span>|<span data-ttu-id="b1857-762">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-762">Static</span></span>|<span data-ttu-id="b1857-763">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-763">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-764">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-764">Constructor</span></span>|<span data-ttu-id="b1857-765">否</span><span class="sxs-lookup"><span data-stu-id="b1857-765">No</span></span>|<span data-ttu-id="b1857-766">否</span><span class="sxs-lookup"><span data-stu-id="b1857-766">No</span></span>|  
|<span data-ttu-id="b1857-767">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-767">Field</span></span>|<span data-ttu-id="b1857-768">否</span><span class="sxs-lookup"><span data-stu-id="b1857-768">No</span></span>|<span data-ttu-id="b1857-769">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-769">Yes.</span></span> <span data-ttu-id="b1857-770">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-770">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-771">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-771">Event</span></span>|<span data-ttu-id="b1857-772">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-772">Not applicable</span></span>|<span data-ttu-id="b1857-773">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-773">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-774">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-774">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-775">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-775">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-776">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-776">Method</span></span>|<span data-ttu-id="b1857-777">否</span><span class="sxs-lookup"><span data-stu-id="b1857-777">No</span></span>|<span data-ttu-id="b1857-778">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-778">Yes.</span></span> <span data-ttu-id="b1857-779">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-779">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-780">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-780">Nested Type</span></span>|<span data-ttu-id="b1857-781">否</span><span class="sxs-lookup"><span data-stu-id="b1857-781">No</span></span>|<span data-ttu-id="b1857-782">否</span><span class="sxs-lookup"><span data-stu-id="b1857-782">No</span></span>|  
|<span data-ttu-id="b1857-783">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-783">Property</span></span>|<span data-ttu-id="b1857-784">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-784">Not applicable</span></span>|<span data-ttu-id="b1857-785">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-785">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-786">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-786">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-787">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-787">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-788">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-788">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-789">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-789">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-790">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-790">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-791">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-791">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-792">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-792">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-793">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-793">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="b1857-794">比方說，如果類別`C<T>`屬性`P`傳回`T`，則呼叫<xref:System.Type.GetDefaultMembers%2A>上`C<int>`傳回`int P`C# 中 (`Property P As Integer`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-794">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="b1857-795">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-795">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-796">下列範例會取得的預設成員資訊`MyClass`並顯示預設成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-796">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-797">在衍生類別中覆寫時，傳回由目前陣列、指標或參考類型所包含或參考物件的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-797">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-798">目前的陣列、指標或參考類型所內含或參考之物件的 <see cref="T:System.Type" />，如果目前的 <see langword="null" /> 不是陣列或指標、未以傳址方式傳遞，或表示泛型類型或泛型類型或泛型方法定義中之類型參數，則為 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-798">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-799">這個方法會傳回`null`如<xref:System.Array>類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-799">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-800">下列範例示範如何使用`GetElementType`方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-800">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b1857-801">要擷取其名稱的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-801">The value whose name is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-802">針對目前的列舉類型，傳回具有指定值之常數的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-802">Returns the name of the constant that has the specified value, for the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-803">具有指定值之目前列舉類型的成員名稱，如果找不到這類常數，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-803">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-804">目前的類型不是列舉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-804">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="b1857-805">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-805">-or-</span>
          </span>
          <span data-ttu-id="b1857-806">
            <paramref name="value" /> 不是目前的型別，也沒有與目前型別相同的基礎型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-806">
              <paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-807">
            <paramref name="value" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-807">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-808">傳回目前列舉類型之成員的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-808">Returns the names of the members of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-809">包含列舉之成員名稱的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-809">An array that contains the names of the members of the enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-810">傳回值陣列的項目依列舉常數的二進位值 （也就是不帶正負號值） 排序。</span><span class="sxs-lookup"><span data-stu-id="b1857-810">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="b1857-811">如果陣列包含具有相同值的列舉的常數，其對應名稱的順序會是 unspecified。</span><span class="sxs-lookup"><span data-stu-id="b1857-811">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-812">目前的類型不是列舉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-812">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-813">傳回目前列舉類型的基礎類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-813">Returns the underlying type of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-814">目前列舉的基礎類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-814">The underlying type of the current enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-815">根據預設，在 C# 和 Visual Basic 中列舉的基礎類型是<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="b1857-815">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="b1857-816">您可以指定其他整數類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-816">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-817">目前的類型不是列舉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-817">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="b1857-818">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-818">-or-</span>
          </span>
          <span data-ttu-id="b1857-819">列舉類型無效，因為它包含一個以上的執行個體欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-819">The enumeration type is not valid, because it contains more than one instance field.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-820">傳回目前列舉類型中常數的值陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-820">Returns an array of the values of the constants in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-821">包含值的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-821">An array that contains the values.</span>
          </span>
          <span data-ttu-id="b1857-822">陣列的項目依列舉常數的二進位值 (也就是不帶正負號值) 排序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-822">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-823">目前的類型不是列舉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-823">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-824">取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的特定事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-824">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-825">字串，其中包含由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-825">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-826">傳回代表指定公用事件的 <see cref="T:System.Reflection.EventInfo" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-826">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-827">如果找到，則表示由目前 <see cref="T:System.Type" /> 所宣告或繼承之指定公用事件的物件；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-827">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-828">事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。</span><span class="sxs-lookup"><span data-stu-id="b1857-828">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="b1857-829">否則事件會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-829">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-830">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-830">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-831">搜尋包含 public static 和 public 的執行個體的事件。</span><span class="sxs-lookup"><span data-stu-id="b1857-831">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="b1857-832">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-832">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-833">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-833">Member Type</span></span>|<span data-ttu-id="b1857-834">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-834">Static</span></span>|<span data-ttu-id="b1857-835">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-835">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-836">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-836">Constructor</span></span>|<span data-ttu-id="b1857-837">否</span><span class="sxs-lookup"><span data-stu-id="b1857-837">No</span></span>|<span data-ttu-id="b1857-838">否</span><span class="sxs-lookup"><span data-stu-id="b1857-838">No</span></span>|  
|<span data-ttu-id="b1857-839">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-839">Field</span></span>|<span data-ttu-id="b1857-840">否</span><span class="sxs-lookup"><span data-stu-id="b1857-840">No</span></span>|<span data-ttu-id="b1857-841">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-841">Yes.</span></span> <span data-ttu-id="b1857-842">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-842">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-843">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-843">Event</span></span>|<span data-ttu-id="b1857-844">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-844">Not applicable</span></span>|<span data-ttu-id="b1857-845">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-845">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-846">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-846">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-847">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-847">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-848">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-848">Method</span></span>|<span data-ttu-id="b1857-849">否</span><span class="sxs-lookup"><span data-stu-id="b1857-849">No</span></span>|<span data-ttu-id="b1857-850">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-850">Yes.</span></span> <span data-ttu-id="b1857-851">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-851">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-852">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-852">Nested Type</span></span>|<span data-ttu-id="b1857-853">否</span><span class="sxs-lookup"><span data-stu-id="b1857-853">No</span></span>|<span data-ttu-id="b1857-854">否</span><span class="sxs-lookup"><span data-stu-id="b1857-854">No</span></span>|  
|<span data-ttu-id="b1857-855">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-855">Property</span></span>|<span data-ttu-id="b1857-856">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-856">Not applicable</span></span>|<span data-ttu-id="b1857-857">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-857">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-858">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-858">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-859">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-859">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-860">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-860">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-861">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-861">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-862">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-862">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-863">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-863">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-864">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-864">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-865">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-865">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-866">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-866">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-867">下列範例會建立<xref:System.Reflection.EventInfo>物件，並取得指定之事件按鈕類別事件。</span><span class="sxs-lookup"><span data-stu-id="b1857-867">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-868">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-868">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-869">字串，包含目前 <see cref="T:System.Type" /> 所宣告或繼承之事件的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-869">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-870">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-870">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-871">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-871">-or-</span>
          </span>
          <span data-ttu-id="b1857-872">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-872">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-873">在衍生類別中覆寫時，使用指定的繫結條件約束，傳回表示指定事件的 <see cref="T:System.Reflection.EventInfo" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-873">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-874">如果找到，則表示由目前 <see cref="T:System.Type" /> 所宣告或繼承之指定事件的物件；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-874">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-875">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的事件：</span><span class="sxs-lookup"><span data-stu-id="b1857-875">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-876">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-876">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-877">指定`BindingFlags.Public`来包含在搜尋中的公用事件。</span><span class="sxs-lookup"><span data-stu-id="b1857-877">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="b1857-878">指定`BindingFlags.NonPublic`要在搜尋中包含非公用事件 （也就是私用、 內部和受保護的事件）。</span><span class="sxs-lookup"><span data-stu-id="b1857-878">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-879">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-879">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-880">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-880">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-881">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-881">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-882">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的事件<xref:System.Type>，不只是繼承的事件。</span><span class="sxs-lookup"><span data-stu-id="b1857-882">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-883">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-883">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-884">事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。</span><span class="sxs-lookup"><span data-stu-id="b1857-884">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="b1857-885">否則事件會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-885">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-886">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-886">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-887">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-887">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-888">下列程式碼範例使用<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>方法來搜尋的公用或非公用事件名為 「 按一下 」 不是型別`static`(`Shared`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-888">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-889">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-889">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-890">取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-890">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-891">取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的所有公用事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-891">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-892">
            <see cref="T:System.Reflection.EventInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所宣告或繼承的所有公用事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-892">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-893">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-893">-or-</span>
          </span>
          <span data-ttu-id="b1857-894">
            <see cref="T:System.Reflection.EventInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有公用事件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-894">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-895">事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。</span><span class="sxs-lookup"><span data-stu-id="b1857-895">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="b1857-896">否則事件會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-896">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-897"><xref:System.Type.GetEvents%2A>方法沒有傳回事件以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-897">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-898">您的程式碼不得相依於事件會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-898">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-899">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-899">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="b1857-900">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-900">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-901">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-901">Member Type</span></span>|<span data-ttu-id="b1857-902">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-902">Static</span></span>|<span data-ttu-id="b1857-903">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-903">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-904">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-904">Constructor</span></span>|<span data-ttu-id="b1857-905">否</span><span class="sxs-lookup"><span data-stu-id="b1857-905">No</span></span>|<span data-ttu-id="b1857-906">否</span><span class="sxs-lookup"><span data-stu-id="b1857-906">No</span></span>|  
|<span data-ttu-id="b1857-907">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-907">Field</span></span>|<span data-ttu-id="b1857-908">否</span><span class="sxs-lookup"><span data-stu-id="b1857-908">No</span></span>|<span data-ttu-id="b1857-909">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-909">Yes.</span></span> <span data-ttu-id="b1857-910">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-910">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-911">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-911">Event</span></span>|<span data-ttu-id="b1857-912">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-912">Not applicable</span></span>|<span data-ttu-id="b1857-913">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-913">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-914">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-914">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-915">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-915">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-916">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-916">Method</span></span>|<span data-ttu-id="b1857-917">否</span><span class="sxs-lookup"><span data-stu-id="b1857-917">No</span></span>|<span data-ttu-id="b1857-918">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-918">Yes.</span></span> <span data-ttu-id="b1857-919">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-919">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-920">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-920">Nested Type</span></span>|<span data-ttu-id="b1857-921">否</span><span class="sxs-lookup"><span data-stu-id="b1857-921">No</span></span>|<span data-ttu-id="b1857-922">否</span><span class="sxs-lookup"><span data-stu-id="b1857-922">No</span></span>|  
|<span data-ttu-id="b1857-923">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-923">Property</span></span>|<span data-ttu-id="b1857-924">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-924">Not applicable</span></span>|<span data-ttu-id="b1857-925">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-925">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-926">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-926">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-927">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-927">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-928">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-928">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-929">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-929">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-930">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-930">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-931">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-931">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-932">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-932">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-933">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-933">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-934">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-934">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-935">下列範例會取得陣列的<xref:System.Reflection.EventInfo>物件資訊，請取得的所有事件`Button`類別，並顯示事件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-935">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="b1857-936">若要編譯 Visual Basic 範例，請使用下列命令列：</span><span class="sxs-lookup"><span data-stu-id="b1857-936">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-937">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-937">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-938">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-938">-or-</span>
          </span>
          <span data-ttu-id="b1857-939">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-939">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-940">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-940">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-941">
            <see cref="T:System.Reflection.EventInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所宣告或繼承之符合指定繫結條件約束的所有事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-941">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="b1857-942">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-942">-or-</span>
          </span>
          <span data-ttu-id="b1857-943">如果目前 <see cref="T:System.Reflection.EventInfo" /> 沒有事件，或沒有事件符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-943">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-944"><xref:System.Type.GetEvents%2A>方法沒有傳回事件以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-944">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-945">您的程式碼不得相依於事件會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-945">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-946">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的事件：</span><span class="sxs-lookup"><span data-stu-id="b1857-946">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-947">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-947">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-948">指定`BindingFlags.Public`来包含在搜尋中的公用事件。</span><span class="sxs-lookup"><span data-stu-id="b1857-948">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="b1857-949">指定`BindingFlags.NonPublic`要在搜尋中包含非公用事件 （也就是私用、 內部和受保護的事件）。</span><span class="sxs-lookup"><span data-stu-id="b1857-949">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="b1857-950">只保護，而且在基底類別上的內部事件都會傳回到;不會傳回基底類別上的私用事件。</span><span class="sxs-lookup"><span data-stu-id="b1857-950">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="b1857-951">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-951">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-952">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-952">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-953">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的事件<xref:System.Type>，不只是繼承的事件。</span><span class="sxs-lookup"><span data-stu-id="b1857-953">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-954">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-954">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-955">事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。</span><span class="sxs-lookup"><span data-stu-id="b1857-955">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="b1857-956">否則事件會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-956">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-957">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-957">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-958">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-958">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-959">下列範例會取得陣列的<xref:System.Reflection.EventInfo>符合指定的繫結旗標的物件取得的所有事件`Button`類別，並顯示事件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-959">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="b1857-960">若要編譯 Visual Basic 範例，請使用下列命令列：</span><span class="sxs-lookup"><span data-stu-id="b1857-960">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-961">取得目前 <see cref="T:System.Type" /> 的特定欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-961">Gets a specific field of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-962">字串，包含要取得的資料欄位的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-962">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-963">搜尋具有指定名稱的公用欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-963">Searches for the public field with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-964">物件，代表具有指定之名稱的公用欄位 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-964">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-965">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-965">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-966">搜尋包含 public static 和 public 的執行個體欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-966">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="b1857-967">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-967">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-968">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-968">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-969">下列範例會取得`Type`物件指定的類別，取得<xref:System.Reflection.FieldInfo>物件的欄位，並顯示欄位的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-969">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-970">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-970">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-971">此 <see cref="T:System.Type" /> 物件為尚未呼叫 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 方法的 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-971">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-972">字串，包含要取得的資料欄位的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-972">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-973">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-973">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-974">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-974">-or-</span>
          </span>
          <span data-ttu-id="b1857-975">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-975">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-976">使用指定的繫結條件約束搜尋指定的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-976">Searches for the specified field, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-977">代表符合指定之需求欄位的物件 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-977">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-978">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-978">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-979">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-979">Member Type</span></span>|<span data-ttu-id="b1857-980">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-980">Static</span></span>|<span data-ttu-id="b1857-981">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-981">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-982">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-982">Constructor</span></span>|<span data-ttu-id="b1857-983">否</span><span class="sxs-lookup"><span data-stu-id="b1857-983">No</span></span>|<span data-ttu-id="b1857-984">否</span><span class="sxs-lookup"><span data-stu-id="b1857-984">No</span></span>|  
|<span data-ttu-id="b1857-985">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-985">Field</span></span>|<span data-ttu-id="b1857-986">否</span><span class="sxs-lookup"><span data-stu-id="b1857-986">No</span></span>|<span data-ttu-id="b1857-987">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-987">Yes.</span></span> <span data-ttu-id="b1857-988">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-988">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-989">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-989">Event</span></span>|<span data-ttu-id="b1857-990">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-990">Not applicable</span></span>|<span data-ttu-id="b1857-991">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-991">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-992">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-992">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-993">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-993">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-994">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-994">Method</span></span>|<span data-ttu-id="b1857-995">否</span><span class="sxs-lookup"><span data-stu-id="b1857-995">No</span></span>|<span data-ttu-id="b1857-996">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-996">Yes.</span></span> <span data-ttu-id="b1857-997">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-997">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-998">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-998">Nested Type</span></span>|<span data-ttu-id="b1857-999">否</span><span class="sxs-lookup"><span data-stu-id="b1857-999">No</span></span>|<span data-ttu-id="b1857-1000">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1000">No</span></span>|  
|<span data-ttu-id="b1857-1001">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1001">Property</span></span>|<span data-ttu-id="b1857-1002">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1002">Not applicable</span></span>|<span data-ttu-id="b1857-1003">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1003">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1004">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1004">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1005">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1005">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1006">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1006">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1007">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1007">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1008">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1008">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1009">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1009">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1010">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1010">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-1011">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的欄位：</span><span class="sxs-lookup"><span data-stu-id="b1857-1011">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1012">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1012">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1013">指定`BindingFlags.Public`要在搜尋中包含公用欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-1013">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1014">指定`BindingFlags.NonPublic`要在搜尋中包含非公用欄位 （也就是私用、 內部和受保護欄位）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1014">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1015">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1015">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1016">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1016">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1017">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1017">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-1018">`BindingFlags.DeclaredOnly` 若要搜尋僅將宣告上的欄位<xref:System.Type>，不只是繼承的欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-1018">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1019">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1019">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1020">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1020">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1021">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-1021">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1022">下列範例會取得`Type`物件指定的類別，取得<xref:System.Reflection.FieldInfo>符合指定的繫結旗標，並顯示欄位的值之欄位的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1022">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1023">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1023">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1024">取得目前 <see cref="T:System.Type" /> 的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1024">Gets the fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1025">傳回目前 <see cref="T:System.Type" /> 的所有公用欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1025">Returns all the public fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1026">
            <see cref="T:System.Reflection.FieldInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義的所有公用欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1026">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-1027">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1027">-or-</span>
          </span>
          <span data-ttu-id="b1857-1028">
            <see cref="T:System.Reflection.FieldInfo" /> 類型的空陣列 (如果沒有為目前 <see cref="T:System.Type" /> 定義公用欄位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1028">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1029"><xref:System.Type.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1029">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1030">您的程式碼不得相依於欄位會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1030">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1031">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1031">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-1032">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1032">Member Type</span></span>|<span data-ttu-id="b1857-1033">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-1033">Static</span></span>|<span data-ttu-id="b1857-1034">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-1034">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-1035">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-1035">Constructor</span></span>|<span data-ttu-id="b1857-1036">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1036">No</span></span>|<span data-ttu-id="b1857-1037">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1037">No</span></span>|  
|<span data-ttu-id="b1857-1038">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-1038">Field</span></span>|<span data-ttu-id="b1857-1039">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1039">No</span></span>|<span data-ttu-id="b1857-1040">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1040">Yes.</span></span> <span data-ttu-id="b1857-1041">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1041">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1042">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-1042">Event</span></span>|<span data-ttu-id="b1857-1043">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1043">Not applicable</span></span>|<span data-ttu-id="b1857-1044">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1044">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1045">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1045">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1046">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1046">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-1047">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-1047">Method</span></span>|<span data-ttu-id="b1857-1048">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1048">No</span></span>|<span data-ttu-id="b1857-1049">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1049">Yes.</span></span> <span data-ttu-id="b1857-1050">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1050">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1051">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1051">Nested Type</span></span>|<span data-ttu-id="b1857-1052">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1052">No</span></span>|<span data-ttu-id="b1857-1053">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1053">No</span></span>|  
|<span data-ttu-id="b1857-1054">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1054">Property</span></span>|<span data-ttu-id="b1857-1055">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1055">Not applicable</span></span>|<span data-ttu-id="b1857-1056">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1056">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1057">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1057">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1058">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1058">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1059">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1059">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1060">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1060">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1061">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1061">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1062">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1062">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1063">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1063">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-1064">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1064">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1065">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的公用欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-1065">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1066">下列範例會示範搭配`GetFields()`方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1066">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1067">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1067">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1068">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1068">-or-</span>
          </span>
          <span data-ttu-id="b1857-1069">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1069">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1070">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1070">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1071">
            <see cref="T:System.Reflection.FieldInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1071">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="b1857-1072">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1072">-or-</span>
          </span>
          <span data-ttu-id="b1857-1073">如果沒有任何欄位定義給目前 <see cref="T:System.Reflection.FieldInfo" /> 的欄位，或沒有已定義的欄位符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1073">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1074"><xref:System.Type.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1074">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1075">您的程式碼不得相依於欄位會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1075">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1076">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的欄位：</span><span class="sxs-lookup"><span data-stu-id="b1857-1076">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1077">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1077">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1078">指定`BindingFlags.Public`要在搜尋中包含公用欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-1078">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1079">指定`BindingFlags.NonPublic`要在搜尋中包含非公用欄位 （也就是私用、 內部和受保護欄位）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1079">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="b1857-1080">只保護，而且會傳回基底類別上的內部欄位。不會傳回基底類別上的私用欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-1080">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="b1857-1081">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1081">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1082">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1082">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1083">`BindingFlags.DeclaredOnly` 若要搜尋僅將宣告上的欄位<xref:System.Type>，不只是繼承的欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-1083">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1084">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1084">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1085">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1085">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1086">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的公用欄位。</span><span class="sxs-lookup"><span data-stu-id="b1857-1086">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1087">下列範例會示範搭配`GetFields(BindingFlags)`方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1087">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1088">傳回 <see cref="T:System.Type" /> 物件的陣列，代表封閉泛型類型的類型引數，或泛型類型定義的類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1088">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1089">由 <see cref="T:System.Type" /> 物件組成的陣列，代表泛型類型的類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1089">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span>
          </span>
          <span data-ttu-id="b1857-1090">如果目前的類型不是泛型類型，則傳回空的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1090">Returns an empty array if the current type is not a generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1091">陣列項目會以其出現在泛型類型的型別引數清單中的順序傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1091">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="b1857-1092">如果目前的類型是封閉式的建構的類型 (也就是<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`false`)，所傳回的陣列<xref:System.Type.GetGenericArguments%2A>方法包含已指派給泛型類型定義的泛型類型參數的型別.</span><span class="sxs-lookup"><span data-stu-id="b1857-1092">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="b1857-1093">如果目前的類型是泛型類型定義，陣列會包含型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1093">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="b1857-1094">如果目前的類型是開放式建構的類型 (也就是<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`) 中的特定型別不已指派給所有型別參數與封入泛型類型或方法的型別參數，此陣列包含型別與型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1094">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="b1857-1095">使用<xref:System.Type.IsGenericParameter%2A>屬性來區分它們。</span><span class="sxs-lookup"><span data-stu-id="b1857-1095">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="b1857-1096">如需示範此案例中，請參閱的程式碼範例<xref:System.Type.ContainsGenericParameters%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1096">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-1097">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。</span><span class="sxs-lookup"><span data-stu-id="b1857-1097">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1098">下列程式碼範例使用<xref:System.Type.GetGenericArguments%2A>方法來顯示型別引數的建構類型和其泛型型別定義的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1098">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="b1857-1099">這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Type.IsGenericTypeDefinition%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1099">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="b1857-1100">請參閱範例輸出的較大範例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1100">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-1101">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1101">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="b1857-1102">衍生類別必須提供實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1102">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1103">傳回由 <see cref="T:System.Type" /> 物件組成的陣列，這些物件代表對目前泛型類型參數所設下的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1103">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1104">由 <see cref="T:System.Type" /> 物件組成的陣列，這些物件代表對目前泛型類型參數所設下的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1104">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1105">每個泛型型別參數的條件約束會表示為<xref:System.Type>物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1105">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="b1857-1106">使用<xref:System.Type.IsClass%2A>屬性來判斷條件約束是否是基底類別條件約束; 如果屬性傳回`false`，條件約束是介面條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1106">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="b1857-1107">如果類型參數沒有類別條件約束和介面條件約束，則會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-1107">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="b1857-1108">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。</span><span class="sxs-lookup"><span data-stu-id="b1857-1108">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1109">下列程式碼範例會定義泛型型別`Test`具有兩個具有不同的條件約束的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1109">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="b1857-1110">當程式執行時，條件約束會檢查使用<xref:System.Type.GenericParameterAttributes%2A>屬性和<xref:System.Type.GetGenericParameterConstraints%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1110">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-1111">目前的 <see cref="T:System.Type" /> 物件不是泛型型別參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1111">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="b1857-1112">亦即，<see cref="P:System.Type.IsGenericParameter" /> 屬性會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1112">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1113">傳回代表泛型類型定義的 <see cref="T:System.Type" /> 物件，利用此泛型類型定義就可以建構出目前的泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1113">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1114">代表泛型類型的 <see cref="T:System.Type" /> 物件，利用此泛型類型就可以建構出目前的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1114">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1115">泛型類型定義是用於建構其他類型的範本。</span><span class="sxs-lookup"><span data-stu-id="b1857-1115">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="b1857-1116">例如，從泛型類型定義`G<T>`（以表示 C# 語法。`G(Of T)`在 Visual Basic 或`generic <typename T> ref class G`c + + 中) 您可以建構並具現化類型`G<int>`(`G(Of Integer)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1116">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="b1857-1117">指定<xref:System.Type>物件，代表這個建構的型別，<xref:System.Type.GetGenericTypeDefinition%2A>方法傳回的泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-1117">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="b1857-1118">如果兩個建構的類型建立從相同泛型類型定義，使用相同的型別引數，<xref:System.Type.GetGenericTypeDefinition%2A>方法會傳回相同<xref:System.Type>這兩種類型的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1118">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="b1857-1119">如果您呼叫<xref:System.Type.GetGenericTypeDefinition%2A>方法<xref:System.Type>表示物件已是泛型類型定義，它會傳回目前<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1119">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b1857-1120">泛型類型的陣列不是泛型本身。</span><span class="sxs-lookup"><span data-stu-id="b1857-1120">An array of generic types is not itself generic.</span></span> <span data-ttu-id="b1857-1121">C# 程式碼`A<int>[] v;`或 Visual Basic 程式碼`Dim v() As A(Of Integer)`，變數的型別`v`不是泛型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1121">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="b1857-1122">使用<xref:System.Type.IsGenericType%2A>決定類型是否為泛型，然後再呼叫<xref:System.Type.GetGenericTypeDefinition%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1122">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="b1857-1123">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。</span><span class="sxs-lookup"><span data-stu-id="b1857-1123">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1124">下列程式碼範例會建構類型的執行個體建立使用一般的執行個體建立，並接著會使用<xref:System.Type.GetType%2A>和<xref:System.Type.GetGenericTypeDefinition%2A>方法來擷取建構的類型和泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-1124">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="b1857-1125">這個範例會使用泛型<xref:System.Collections.Generic.Dictionary%602>類型; 建構的類型代表<xref:System.Collections.Generic.Dictionary%602>的`Test`字串索引鍵的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1125">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-1126">目前的類型不是泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1126">The current type is not a generic type.</span>
          </span>
          <span data-ttu-id="b1857-1127">亦即，<see cref="P:System.Type.IsGenericType" /> 會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1127">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-1128">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1128">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="b1857-1129">衍生類別必須提供實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1129">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1130">傳回這個執行個體的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1130">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1131">這個執行個體的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1131">The hash code for this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1132">這個方法覆寫 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1132">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1133">下列範例顯示的雜湊碼`System.Windows.Forms.Button`類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1133">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1134">取得由目前 <see cref="T:System.Type" /> 所實作或繼承的特定介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1134">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1135">字串，包含要取得的介面名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1135">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="b1857-1136">若為泛型介面，則為 mangled 名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1136">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1137">搜尋具有指定名稱的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1137">Searches for the interface with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1138">物件，代表具有指定之名稱的介面是由目前 <see cref="T:System.Type" /> 所實作或繼承的 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1138">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1139">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-1139">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="b1857-1140">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1140">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1141">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-1141">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1142">若為泛型介面，`name`參數則為 mangled 的名稱，結尾抑音符號 (\`) 及型別參數數目。</span><span class="sxs-lookup"><span data-stu-id="b1857-1142">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="b1857-1143">這是為泛型介面定義與建構的泛型介面，則為 true。</span><span class="sxs-lookup"><span data-stu-id="b1857-1143">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="b1857-1144">例如，若要尋找`IExample<T>`(`IExample(Of T)`在 Visual Basic 中) 或`IExample<string>`(`IExample(Of String)`在 Visual Basic 中)，搜尋``"IExample`1"``。</span><span class="sxs-lookup"><span data-stu-id="b1857-1144">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1145">下列程式碼範例使用<xref:System.Type.GetInterface%28System.String%29>方法來搜尋<xref:System.Collections.Hashtable>類別<xref:System.Runtime.Serialization.IDeserializationCallback>介面，並列出介面的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1145">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="b1857-1146">程式碼範例也示範<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法多載而<xref:System.Type.GetInterfaceMap%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1146">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1147">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1147">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1148">目前的 <see cref="T:System.Type" /> 代表的型別有實作出相同的泛型介面，但型別引數不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1148">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1149">字串，包含要取得的介面名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1149">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="b1857-1150">若為泛型介面，則為 mangled 名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1150">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="b1857-1151">
            <see langword="true" />，便會忽略 <c>name</c> 中指定簡單介面名稱之該部分的大小寫 (指定命名空間的部分必須使用正確的大小寫)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1151">
              <see langword="true" /> to ignore the case of that part of <c>name</c> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span>
          </span>
          <span data-ttu-id="b1857-1152">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1152">-or-</span>
          </span>
          <span data-ttu-id="b1857-1153">
            <see langword="false" /> 表示對 <c>name</c> 的所有部分執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1153">
              <see langword="false" /> to perform a case-sensitive search for all parts of <c>name</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1154">在衍生類別中覆寫時，指定是否針對介面名稱以不區分大小寫的方式來搜尋指定的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1154">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1155">物件，代表具有指定之名稱的介面是由目前 <see cref="T:System.Type" /> 所實作或繼承的 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1155">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1156">`ignoreCase`參數只適用於簡單介面名稱，不到命名空間。</span><span class="sxs-lookup"><span data-stu-id="b1857-1156">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="b1857-1157">部分`name`指定命名空間必須包含正確的大小寫，或將找不到介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-1157">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="b1857-1158">例如，字串"System.icomparable"尋找<xref:System.IComparable>介面，但字串"system.icomparable"並不會。</span><span class="sxs-lookup"><span data-stu-id="b1857-1158">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="b1857-1159">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1159">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1160">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-1160">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1161">若為泛型介面，`name`參數則為 mangled 的名稱，結尾抑音符號 (\`) 及型別參數數目。</span><span class="sxs-lookup"><span data-stu-id="b1857-1161">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="b1857-1162">這是為泛型介面定義與建構的泛型介面，則為 true。</span><span class="sxs-lookup"><span data-stu-id="b1857-1162">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="b1857-1163">例如，若要尋找`IExample<T>`(`IExample(Of T)`在 Visual Basic 中) 或`IExample<string>`(`IExample(Of String)`在 Visual Basic 中)，搜尋`"IExample`1"'。</span><span class="sxs-lookup"><span data-stu-id="b1857-1163">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1164">下列程式碼範例使用<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法來執行不區分大小寫的搜尋<xref:System.Collections.Hashtable>類別<xref:System.Collections.IEnumerable>介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-1164">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="b1857-1165">程式碼範例也示範<xref:System.Type.GetInterface%28System.String%29>方法多載而<xref:System.Type.GetInterfaceMap%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1165">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1166">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1166">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1167">目前的 <see cref="T:System.Type" /> 代表的型別有實作出相同的泛型介面，但型別引數不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1167">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="b1857-1168">要擷取對應的介面類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1168">The interface type to retrieve a mapping for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1169">傳回指定介面類型的介面對應。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1169">Returns an interface mapping for the specified interface type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1170">物件，表示 <paramref name="interfaceType" /> 的介面對應。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1170">An object that represents the interface mapping for <paramref name="interfaceType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1171">介面對應會表示如何在介面對應到實際的成員上實作該介面的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1171">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="b1857-1172">如果目前<xref:System.Type>代表建構的泛型類型，類型的項目中的適當的型別引數會取代參數<xref:System.Reflection.InterfaceMapping>這個方法所傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1172">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1173">下列範例會呼叫<xref:System.Type.GetInterfaceMap%2A>方法，以判斷如何<xref:System.IFormatProvider>介面對應至<xref:System.Globalization.CultureInfo>方法，以及如何<xref:System.IAppDomainSetup>介面對應至<xref:System.AppDomainSetup>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1173">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="b1857-1174">請注意，因為<xref:System.IAppDomainSetup>介面會定義一組屬性，傳回<xref:System.Reflection.InterfaceMapping>物件包含個別<xref:System.Reflection.MethodInfo>屬性的 get 和 set 存取子的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1174">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-1175">
            <paramref name="interfaceType" /> 不是否由目前的類型所實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1175">
              <paramref name="interfaceType" /> is not implemented by the current type.</span>
          </span>
          <span data-ttu-id="b1857-1176">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1176">-or-</span>
          </span>
          <span data-ttu-id="b1857-1177">
            <paramref name="interfaceType" /> 參數不會參考介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1177">The <paramref name="interfaceType" /> parameter does not refer to an interface.</span>
          </span>
          <span data-ttu-id="b1857-1178">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1178">-or-</span>
          </span>
          <span data-ttu-id="b1857-1179">
            <paramref name="interfaceType" /> 是泛型介面，而且目前的型別是陣列型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1179">
              <paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1180">
            <paramref name="interfaceType" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1180">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-1181">目前的 <see cref="T:System.Type" /> 表示泛型型別參數，也就是說，<see cref="P:System.Type.IsGenericParameter" /> 為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1181">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-1182">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1182">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="b1857-1183">衍生類別必須提供實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1183">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1184">在衍生類別中覆寫時，取得由目前 <see cref="T:System.Type" /> 所實作或繼承的所有介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1184">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1185">
            <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所實作或繼承的所有介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1185">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-1186">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1186">-or-</span>
          </span>
          <span data-ttu-id="b1857-1187">
            <see cref="T:System.Type" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 未實作或繼承介面)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1187">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1188"><xref:System.Type.GetInterfaces%2A>方法不會傳回介面特定的順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1188">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1189">您的程式碼不得相依於介面會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1189">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1190">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1190">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1191">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-1191">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1192">下列範例會取得指定之類別的型別，並顯示型別所實作或繼承的所有介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-1192">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="b1857-1193">若要編譯 Visual Basic 範例，請使用下列編譯器命令：</span><span class="sxs-lookup"><span data-stu-id="b1857-1193">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-1194">靜態初始設定式已叫用並擲回了例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1194">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1195">取得目前 <see cref="T:System.Type" /> 的指定成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1195">Gets the specified members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1196">字串，包含要取得的公用成員名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1196">The string containing the name of the public members to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1197">搜尋具有指定名稱的公用成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1197">Searches for the public members with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1198">
            <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1198">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1199">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-1199">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-1200">搜尋包含 public static 和 public 的執行個體成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1200">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="b1857-1201">成員包括屬性、 方法、 欄位、 事件等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-1201">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="b1857-1202"><xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1202">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1203">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1203">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1204">這個方法多載不會尋找類別初始設定式 (.cctor)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1204">This method overload will not find class initializers (.cctor).</span></span> <span data-ttu-id="b1857-1205">類別初始設定式，請使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1205">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-1206">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1206">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-1207">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1207">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-1208">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1208">Member Type</span></span>|<span data-ttu-id="b1857-1209">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-1209">Static</span></span>|<span data-ttu-id="b1857-1210">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-1210">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-1211">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-1211">Constructor</span></span>|<span data-ttu-id="b1857-1212">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1212">No</span></span>|<span data-ttu-id="b1857-1213">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1213">No</span></span>|  
|<span data-ttu-id="b1857-1214">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-1214">Field</span></span>|<span data-ttu-id="b1857-1215">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1215">No</span></span>|<span data-ttu-id="b1857-1216">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1216">Yes.</span></span> <span data-ttu-id="b1857-1217">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1217">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1218">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-1218">Event</span></span>|<span data-ttu-id="b1857-1219">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1219">Not applicable</span></span>|<span data-ttu-id="b1857-1220">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1220">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1221">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1221">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1222">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1222">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-1223">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-1223">Method</span></span>|<span data-ttu-id="b1857-1224">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1224">No</span></span>|<span data-ttu-id="b1857-1225">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1225">Yes.</span></span> <span data-ttu-id="b1857-1226">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1226">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1227">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1227">Nested Type</span></span>|<span data-ttu-id="b1857-1228">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1228">No</span></span>|<span data-ttu-id="b1857-1229">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1229">No</span></span>|  
|<span data-ttu-id="b1857-1230">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1230">Property</span></span>|<span data-ttu-id="b1857-1231">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1231">Not applicable</span></span>|<span data-ttu-id="b1857-1232">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1232">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1233">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1233">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1234">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1234">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1235">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1235">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1236">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1236">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1237">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1237">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1238">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1238">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1239">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1239">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-1240">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1240">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1241">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1241">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1242">為泛型方法，不包括中的型別引數`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1242">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="b1857-1243">例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1243">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1244">下列範例顯示的所有成員`String`以字母 c 開頭的類別</span><span class="sxs-lookup"><span data-stu-id="b1857-1244">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1245">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1245">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1246">字串，包含要取得的成員名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1246">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1247">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1247">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1248">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1248">-or-</span>
          </span>
          <span data-ttu-id="b1857-1249">零，表示傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1249">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1250">使用指定的繫結條件約束搜尋指定的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1250">Searches for the specified members, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1251">
            <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1251">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1252">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1252">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="b1857-1253">成員包括屬性、 方法、 欄位、 事件等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-1253">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="b1857-1254"><xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1254">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1255">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1255">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1256">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：</span><span class="sxs-lookup"><span data-stu-id="b1857-1256">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1257">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1257">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1258">指定`BindingFlags.Public`来包含在搜尋中的公用成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1258">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1259">指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1259">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1260">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1260">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1261">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1261">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1262">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1262">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-1263">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1263">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1264">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1264">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1265">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定".cctor" `name`，和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中) 的`bindingAttr`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1265">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="b1857-1266">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1266">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-1267">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1267">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1268">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1268">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1269">為泛型方法，不包括中的型別引數`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1269">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="b1857-1270">例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1270">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1271">下列範例顯示的所有公用靜態成員`myString`以字母 c 開頭的類別</span><span class="sxs-lookup"><span data-stu-id="b1857-1271">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1272">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1272">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1273">字串，包含要取得的成員名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1273">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="b1857-1274">要搜尋的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1274">The value to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1275">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1275">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1276">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1276">-or-</span>
          </span>
          <span data-ttu-id="b1857-1277">零，表示傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1277">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1278">使用指定的繫結條件約束，搜尋指定成員類型的指定成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1278">Searches for the specified members of the specified member type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1279">
            <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1279">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1280">成員包括屬性、 方法、 欄位、 事件等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-1280">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="b1857-1281"><xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1281">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1282">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1282">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1283">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：</span><span class="sxs-lookup"><span data-stu-id="b1857-1283">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1284">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1284">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1285">指定`BindingFlags.Public`来包含在搜尋中的公用成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1285">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1286">指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1286">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1287">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1287">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1288">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1288">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1289">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1289">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-1290">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1290">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1291">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1291">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1292">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定".cctor" `name`，<xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType>如`type`，和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>中Visual Basic) 的`bindingAttr`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1292">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="b1857-1293">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1293">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-1294">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1294">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1295">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1295">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1296">為泛型方法，不包括中的型別引數`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1296">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="b1857-1297">例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1297">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1298">下列範例顯示的所有方法`myString`以字母 c 開頭的類別</span><span class="sxs-lookup"><span data-stu-id="b1857-1298">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1299">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1299">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-1300">衍生類別必須提供實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1300">A derived class must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1301">取得目前 <see cref="T:System.Type" /> 的成員 (屬性、方法、欄位、事件等等)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1301">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1302">傳回目前 <see cref="T:System.Type" /> 的所有公用成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1302">Returns all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1303">
            <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有公用成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1303">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-1304">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1304">-or-</span>
          </span>
          <span data-ttu-id="b1857-1305">
            <see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有公用成員)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1305">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1306">成員包括屬性、 方法、 欄位、 事件等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-1306">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="b1857-1307"><xref:System.Type.GetMembers%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1307">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1308">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1308">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1309">這個方法多載呼叫<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法多載，與<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1309">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-1310">將不會發現類別初始設定式 (.cctor)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1310">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="b1857-1311">類別初始設定式，請使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1311">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-1312">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1312">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-1313">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1313">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-1314">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1314">Member Type</span></span>|<span data-ttu-id="b1857-1315">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-1315">Static</span></span>|<span data-ttu-id="b1857-1316">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-1316">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-1317">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-1317">Constructor</span></span>|<span data-ttu-id="b1857-1318">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1318">No</span></span>|<span data-ttu-id="b1857-1319">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1319">No</span></span>|  
|<span data-ttu-id="b1857-1320">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-1320">Field</span></span>|<span data-ttu-id="b1857-1321">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1321">No</span></span>|<span data-ttu-id="b1857-1322">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1322">Yes.</span></span> <span data-ttu-id="b1857-1323">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1323">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1324">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-1324">Event</span></span>|<span data-ttu-id="b1857-1325">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1325">Not applicable</span></span>|<span data-ttu-id="b1857-1326">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1326">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1327">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1327">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1328">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1328">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-1329">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-1329">Method</span></span>|<span data-ttu-id="b1857-1330">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1330">No</span></span>|<span data-ttu-id="b1857-1331">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1331">Yes.</span></span> <span data-ttu-id="b1857-1332">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1332">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1333">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1333">Nested Type</span></span>|<span data-ttu-id="b1857-1334">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1334">No</span></span>|<span data-ttu-id="b1857-1335">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1335">No</span></span>|  
|<span data-ttu-id="b1857-1336">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1336">Property</span></span>|<span data-ttu-id="b1857-1337">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1337">Not applicable</span></span>|<span data-ttu-id="b1857-1338">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1338">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1339">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1339">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1340">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1340">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1341">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1341">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1342">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1342">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1343">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1343">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1344">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1344">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1345">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1345">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-1346">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1346">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1347">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1347">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1348">下列程式碼範例示範如何使用<xref:System.Type.GetMembers>方法多載來收集指定之類別的所有公用成員的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="b1857-1348">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1349">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1349">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1350">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1350">-or-</span>
          </span>
          <span data-ttu-id="b1857-1351">零 (<see cref="F:System.Reflection.BindingFlags.Default" />)，表示傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1351">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1352">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1352">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1353">
            <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1353">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="b1857-1354">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1354">-or-</span>
          </span>
          <span data-ttu-id="b1857-1355">如果沒有任何成員定義給目前的 <see cref="T:System.Reflection.MemberInfo" />，或沒有已定義的成員符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1355">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1356">成員包括屬性、 方法、 欄位、 事件等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-1356">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="b1857-1357"><xref:System.Type.GetMembers%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1357">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1358">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1358">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1359">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：</span><span class="sxs-lookup"><span data-stu-id="b1857-1359">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1360">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1360">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1361">指定`BindingFlags.Public`来包含在搜尋中的公用成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1361">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1362">指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1362">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span> <span data-ttu-id="b1857-1363">只保護，而且會傳回基底類別上的內部成員。不會傳回基底類別上的私用成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1363">Only protected and internal members on base classes are returned; private members on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="b1857-1364">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1364">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1365">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1365">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1366">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1366">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1367">呼叫這個方法只使用`Public`旗標] 或 [僅`NonPublic`旗標將會傳回指定的成員，而且不需要任何其他旗標。</span><span class="sxs-lookup"><span data-stu-id="b1857-1367">Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.</span></span>  
  
 <span data-ttu-id="b1857-1368">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1368">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1369">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1369">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="b1857-1370">您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1370">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-1371">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1371">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1372">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1372">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1373">下列程式碼範例示範如何使用<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法多載來收集指定之類別的所有公用執行個體成員的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="b1857-1373">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1374">取得目前 <see cref="T:System.Type" /> 的特定方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1374">Gets a specific method of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1375">字串，包含要取得的公用方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1375">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1376">搜尋具有指定名稱的公用方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1376">Searches for the public method with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1377">物件，代表具有指定之名稱的公用方法 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1377">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1378">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-1378">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-1379">搜尋包含 public static 和 public 的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1379">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="b1857-1380">如果方法多載，而且有一個以上的公用方法，<xref:System.Type.GetMethod%28System.String%29>方法會擲回<xref:System.Reflection.AmbiguousMatchException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-1380">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="b1857-1381">在下列範例中，例外狀況會擲回的多個公用的多載，因為<xref:System.Int32.ToString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1381">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="b1857-1382">相反地，因為`Person.ToString`方法覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>，因此未超載，<xref:System.Type.GetMethod%28System.String%29>方法是能夠擷取<xref:System.Reflection.MethodInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1382">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="b1857-1383">您可以執行下列命令來擷取特定方法的其中一個動作：</span><span class="sxs-lookup"><span data-stu-id="b1857-1383">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="b1857-1384">呼叫<xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29>方法並指定`bindingAttr`唯一識別該方法的引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1384">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="b1857-1385">例如，如果擲回例外狀況，因為類型都有靜態和執行個體的多載，您可以指定`bindingAttr`引數的<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1385">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b1857-1386">呼叫的多載<xref:System.Type.GetMethod%2A>方法包含`types`定義方法的參數型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1386">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="b1857-1387">呼叫<xref:System.Type.GetMethods>方法來擷取包含所有屬於類型的公用方法的陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-1387">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="b1857-1388">您可以再逐一查看以識別重複的方法，名為`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1388">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="b1857-1389">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1389">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1390">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1390">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1391">為泛型方法，不包括中的型別引數`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1391">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="b1857-1392">例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1392">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1393">下列範例會取得名為的方法`MethodA`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1393">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1394">找到一個以上具有指定名稱的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1394">More than one method is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1395">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1395">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1396">字串，包含要取得的方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1396">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1397">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1397">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1398">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1398">-or-</span>
          </span>
          <span data-ttu-id="b1857-1399">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1399">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1400">使用指定的繫結條件約束搜尋指定的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1400">Searches for the specified method, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1401">物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1401">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1402">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-1402">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1403">您必須指定<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1403">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1404">指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1404">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1405">指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1405">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1406">指定<xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType>包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1406">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1407">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1407">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1408"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1408"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-1409"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1409"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1410">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1410">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1411">如果多載的方法和一個以上多載符合所指定的條件約束`bindingAttr`引數，方法會擲回<xref:System.Reflection.AmbiguousMatchException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-1411">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="b1857-1412">在下列範例中，因為，會擲回例外狀況：</span><span class="sxs-lookup"><span data-stu-id="b1857-1412">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="b1857-1413">`TestClass`類型有兩個公用執行個體多載`DisplayValue`方法，`DisplayValue(String)`和`DisplayValue(String, Object[])`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1413">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="b1857-1414">`TestClass`類型有兩個公用執行個體多載`Equals`方法，其中繼承自<xref:System.Object>:`Equals(TestClass)`和`Equals(Object)`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1414">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="b1857-1415">您可以執行下列命令來擷取特定方法的其中一個動作：</span><span class="sxs-lookup"><span data-stu-id="b1857-1415">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="b1857-1416">變更繫結條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1416">Change the binding constraints.</span></span> <span data-ttu-id="b1857-1417">在上述範例中，嘗試擷取公用執行個體`Equals`類型所宣告，且不會成功繼承方法擷取`Equals(TestClass)`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1417">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="b1857-1418">呼叫的多載<xref:System.Type.GetMethod%2A>方法包含`types`定義方法的參數型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1418">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="b1857-1419">呼叫<xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>方法來擷取包含所有具有指定的繫結屬性的方法屬於類型的陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-1419">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="b1857-1420">您可以再逐一查看以識別重複的方法，名為`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1420">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="b1857-1421">這種方法如下所示的上一個範例處理常式<xref:System.Reflection.AmbiguousMatchException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-1421">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="b1857-1422">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1422">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1423">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1423">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1424">為泛型方法，不包括中的型別引數`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1424">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="b1857-1425">例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1425">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1426">下列範例會取得符合指定的繫結旗標的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1426">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1427">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1427">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1428">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1428">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1429">字串，包含要取得的公用方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1429">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-1430">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1430">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="b1857-1431">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1431">-or-</span>
          </span>
          <span data-ttu-id="b1857-1432">
            <see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1432">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1433">搜尋指定的公用方法，其參數符合指定的引數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1433">Searches for the specified public method whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1434">代表其參數符合指定之引數類型的公用方法物件 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1434">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1435">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-1435">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-1436">搜尋包含 public static 和 public 的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1436">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1437">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1437">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-1438">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1438">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-1439">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1439">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1440">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1440">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1441">`name`參數不能包含型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1441">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="b1857-1442">例如，C# 程式碼`GetMethod("MyGenericMethod<int>")`搜尋文字名稱的方法"`MyGenericMethod<int>`"，而不會針對名為的方法`MyGenericMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1442">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="b1857-1443">請改用`GetMethod("MyGenericMethod")`中適當的參數`types`陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-1443">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1444">下列範例會尋找特定的多載`MethodA`，指定各種不同的引數型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1444">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1445">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。</span><span class="sxs-lookup"><span data-stu-id="b1857-1445">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="b1857-1446">下列範例會擷取<xref:System.Reflection.MethodInfo>物件來代表`Add`非泛型型別的方法 (<xref:System.Collections.ArrayList>類別)，開放式泛型類型 (<xref:System.Collections.Generic.List%601>類別)，和已關閉的泛型型別 (`List(Of String)`型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1446">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="b1857-1447">此範例會定義`GetAddMethod`方法，可擷取適當<xref:System.Reflection.MethodInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1447">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="b1857-1448">若要提供`types`開放式的泛型型別引數，呼叫<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1448">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b1857-1449">若要提供`types`封閉泛型類型引數，它會擷取的值<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1449">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1450">找到一個以上具有指定名稱及指定參數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1450">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1451">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1451">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1452">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1452">-or-</span>
          </span>
          <span data-ttu-id="b1857-1453">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1453">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1454">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1454">-or-</span>
          </span>
          <span data-ttu-id="b1857-1455">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1455">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-1456">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1456">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1457">字串，包含要取得的公用方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1457">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-1458">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1458">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="b1857-1459">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1459">-or-</span>
          </span>
          <span data-ttu-id="b1857-1460">
            <see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1460">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-1461">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1461">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-1462">只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1462">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="b1857-1463">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1463">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1464">搜尋指定的公用方法，其參數符合指定的引數類型和修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1464">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1465">物件，代表符合指定之需求的公用方法 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1465">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1466">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1466">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-1467">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1467">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-1468">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-1468">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-1469">搜尋包含 public static 和 public 的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1469">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1470">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1470">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-1471">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1471">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-1472">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1472">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1473">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1473">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1474">為泛型方法，不包括中的型別引數`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1474">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="b1857-1475">例如，C# 程式碼`GetMethod("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1475">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="b1857-1476">請改用`GetMethod("MyMethod")`中適當的參數`types`陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-1476">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1477">找到一個以上具有指定名稱及指定參數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1477">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1478">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1478">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1479">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1479">-or-</span>
          </span>
          <span data-ttu-id="b1857-1480">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1480">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1481">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1481">-or-</span>
          </span>
          <span data-ttu-id="b1857-1482">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1482">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-1483">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1483">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-1484">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1484">-or-</span>
          </span>
          <span data-ttu-id="b1857-1485">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1485">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1486">字串，包含要取得的方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1486">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1487">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1487">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1488">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1488">-or-</span>
          </span>
          <span data-ttu-id="b1857-1489">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1489">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-1490">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1490">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-1491">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1491">-or-</span>
          </span>
          <span data-ttu-id="b1857-1492">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1492">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-1493">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1493">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="b1857-1494">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1494">-or-</span>
          </span>
          <span data-ttu-id="b1857-1495">
            <see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1495">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-1496">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1496">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-1497">只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1497">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="b1857-1498">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1498">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1499">使用指定的繫結條件約束搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1499">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1500">物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1500">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1501">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1501">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-1502">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1502">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-1503">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-1503">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1504">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1504">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1505">指定`BindingFlags.Public`来包含在搜尋中的公用方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1505">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1506">指定`BindingFlags.NonPublic`要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1506">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1507">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1507">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1508">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1508">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1509">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1509">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-1510">`BindingFlags.DeclaredOnly` 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1510">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1511">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1511">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1512">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1512">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-1513">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1513">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-1514">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1514">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1515">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1515">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1516">為泛型方法，不包括中的型別引數`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1516">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="b1857-1517">例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1517">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1518">下列範例會尋找特定的多載`MethodA`，指定繫結條件約束和各種不同的引數型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1518">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1519">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。</span><span class="sxs-lookup"><span data-stu-id="b1857-1519">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1520">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1520">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1521">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1521">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1522">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1522">-or-</span>
          </span>
          <span data-ttu-id="b1857-1523">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1523">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1524">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1524">-or-</span>
          </span>
          <span data-ttu-id="b1857-1525">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1525">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-1526">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1526">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-1527">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1527">-or-</span>
          </span>
          <span data-ttu-id="b1857-1528">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1528">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1529">字串，包含要取得的方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1529">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1530">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1530">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1531">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1531">-or-</span>
          </span>
          <span data-ttu-id="b1857-1532">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1532">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-1533">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-1534">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1534">-or-</span>
          </span>
          <span data-ttu-id="b1857-1535">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="b1857-1536">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及如何清除堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1536">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-1537">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1537">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="b1857-1538">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1538">-or-</span>
          </span>
          <span data-ttu-id="b1857-1539">
            <see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1539">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-1540">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1540">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-1541">只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1541">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="b1857-1542">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1542">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1543">使用指定的繫結條件約束和指定的呼叫慣例，來搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1543">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1544">物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1544">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1545">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1545">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-1546">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1546">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-1547">下表顯示基底類別成員會傳回由`GetXXX`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1547">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-1548">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1548">Member Type</span></span>|<span data-ttu-id="b1857-1549">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-1549">Static</span></span>|<span data-ttu-id="b1857-1550">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-1550">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-1551">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-1551">Constructor</span></span>|<span data-ttu-id="b1857-1552">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1552">No</span></span>|<span data-ttu-id="b1857-1553">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1553">No</span></span>|  
|<span data-ttu-id="b1857-1554">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-1554">Field</span></span>|<span data-ttu-id="b1857-1555">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1555">No</span></span>|<span data-ttu-id="b1857-1556">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1556">Yes.</span></span> <span data-ttu-id="b1857-1557">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1557">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1558">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-1558">Event</span></span>|<span data-ttu-id="b1857-1559">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1559">Not applicable</span></span>|<span data-ttu-id="b1857-1560">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1560">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1561">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1561">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1562">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1562">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-1563">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-1563">Method</span></span>|<span data-ttu-id="b1857-1564">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1564">No</span></span>|<span data-ttu-id="b1857-1565">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1565">Yes.</span></span> <span data-ttu-id="b1857-1566">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1566">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1567">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1567">Nested Type</span></span>|<span data-ttu-id="b1857-1568">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1568">No</span></span>|<span data-ttu-id="b1857-1569">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1569">No</span></span>|  
|<span data-ttu-id="b1857-1570">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1570">Property</span></span>|<span data-ttu-id="b1857-1571">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1571">Not applicable</span></span>|<span data-ttu-id="b1857-1572">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1572">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1573">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1573">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1574">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1574">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1575">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1575">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1576">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1576">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1577">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1577">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1578">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1578">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1579">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1579">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-1580">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-1580">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1581">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1581">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1582">指定`BindingFlags.Public`来包含在搜尋中的公用方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1582">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1583">指定`BindingFlags.NonPublic`要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1583">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1584">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1584">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1585">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1585">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1586">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1586">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-1587">`BindingFlags.DeclaredOnly` 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1587">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1588">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1588">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1589">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1589">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-1590">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1590">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-1591">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1591">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1592">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1592">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1593">為泛型方法，不包括中的型別引數`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1593">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="b1857-1594">例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1594">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1595">下列範例會尋找特定的多載`MethodA`、 指定繫結條件約束、 呼叫慣例和引數類型的不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1595">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1596">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。</span><span class="sxs-lookup"><span data-stu-id="b1857-1596">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1597">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1597">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1598">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1598">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1599">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1599">-or-</span>
          </span>
          <span data-ttu-id="b1857-1600">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1600">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1601">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1601">-or-</span>
          </span>
          <span data-ttu-id="b1857-1602">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1602">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-1603">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1603">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-1604">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1604">-or-</span>
          </span>
          <span data-ttu-id="b1857-1605">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1605">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1606">字串，包含要取得的方法名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1606">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1607">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1607">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1608">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1608">-or-</span>
          </span>
          <span data-ttu-id="b1857-1609">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1609">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-1610">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1610">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-1611">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1611">-or-</span>
          </span>
          <span data-ttu-id="b1857-1612">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1612">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="b1857-1613">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及哪一個處理程序清除堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1613">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-1614">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1614">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="b1857-1615">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1615">-or-</span>
          </span>
          <span data-ttu-id="b1857-1616">用以取得沒有參數的方法之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1616">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span>
          </span>
          <span data-ttu-id="b1857-1617">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1617">-or-</span>
          </span>
          <span data-ttu-id="b1857-1618">
            <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1618">
              <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-1619">如果 <c>types</c> 為 <see langword="null" />，則引數不相符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1619">If <c>types</c> is <see langword="null" />, arguments are not matched.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-1620">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1620">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-1621">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1621">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1622">在衍生類別中覆寫時，使用指定的繫結條件約束和指定的呼叫慣例搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1622">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1623">物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1623">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1624">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1624">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-1625">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1625">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-1626">如果 `types` 為 `null`，則引數不相符。</span><span class="sxs-lookup"><span data-stu-id="b1857-1626">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="b1857-1627">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-1627">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1628">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1628">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1629">指定`BindingFlags.Public`来包含在搜尋中的公用方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1629">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1630">指定`BindingFlags.NonPublic`要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1630">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1631">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1631">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1632">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1632">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1633">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1633">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-1634">`BindingFlags.DeclaredOnly` 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1634">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1635">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1635">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1636">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1636">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1637">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1637">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-1638">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1638">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-1639">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1639">-or-</span>
          </span>
          <span data-ttu-id="b1857-1640">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1640">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-1641">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1641">-or-</span>
          </span>
          <span data-ttu-id="b1857-1642">
            <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1642">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-1643">目前的型別是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1643">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1644">取得目前 <see cref="T:System.Type" /> 的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1644">Gets the methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1645">傳回目前 <see cref="T:System.Type" /> 的所有公用方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1645">Returns all the public methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1646">
            <see cref="T:System.Reflection.MethodInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義的所有公用方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1646">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-1647">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1647">-or-</span>
          </span>
          <span data-ttu-id="b1857-1648">
            <see cref="T:System.Reflection.MethodInfo" /> 類型的空陣列 (如果沒有為目前 <see cref="T:System.Type" /> 定義公用方法)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1648">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1649"><xref:System.Type.GetMethods%2A>方法不會傳回方法特定的順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1649">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1650">您的程式碼必須依賴方法會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1650">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1651">建構函式不包含陣列中的這個呼叫所傳回的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1651">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="b1857-1652">若要個別呼叫`GetConstructors()`以取得建構函式方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1652">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="b1857-1653">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1653">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-1654">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1654">Member Type</span></span>|<span data-ttu-id="b1857-1655">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-1655">Static</span></span>|<span data-ttu-id="b1857-1656">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-1656">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-1657">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-1657">Constructor</span></span>|<span data-ttu-id="b1857-1658">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1658">No</span></span>|<span data-ttu-id="b1857-1659">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1659">No</span></span>|  
|<span data-ttu-id="b1857-1660">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-1660">Field</span></span>|<span data-ttu-id="b1857-1661">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1661">No</span></span>|<span data-ttu-id="b1857-1662">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1662">Yes.</span></span> <span data-ttu-id="b1857-1663">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1663">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1664">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-1664">Event</span></span>|<span data-ttu-id="b1857-1665">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1665">Not applicable</span></span>|<span data-ttu-id="b1857-1666">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1666">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1667">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1667">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1668">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1668">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-1669">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-1669">Method</span></span>|<span data-ttu-id="b1857-1670">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1670">No</span></span>|<span data-ttu-id="b1857-1671">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1671">Yes.</span></span> <span data-ttu-id="b1857-1672">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1672">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1673">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1673">Nested Type</span></span>|<span data-ttu-id="b1857-1674">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1674">No</span></span>|<span data-ttu-id="b1857-1675">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1675">No</span></span>|  
|<span data-ttu-id="b1857-1676">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1676">Property</span></span>|<span data-ttu-id="b1857-1677">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1677">Not applicable</span></span>|<span data-ttu-id="b1857-1678">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1678">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1679">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1679">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1680">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1680">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1681">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1681">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1682">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1682">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1683">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1683">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1684">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1684">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1685">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1685">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1686">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1686">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-1687">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1687">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-1688">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1688">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1689">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1689">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1690">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1690">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1691">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1691">-or-</span>
          </span>
          <span data-ttu-id="b1857-1692">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1692">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1693">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1693">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1694">
            <see cref="T:System.Reflection.MethodInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1694">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="b1857-1695">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1695">-or-</span>
          </span>
          <span data-ttu-id="b1857-1696">如果沒有任何方法定義給目前的 <see cref="T:System.Reflection.MethodInfo" />，或沒有已定義的方法符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1696">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1697"><xref:System.Type.GetMethods%2A>方法不會傳回方法特定的順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1697">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1698">您的程式碼必須依賴方法會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1698">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1699">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-1699">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1700">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1700">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1701">指定`BindingFlags.Public`来包含在搜尋中的公用方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1701">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1702">指定`BindingFlags.NonPublic`要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1702">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="b1857-1703">只保護，而且會傳回基底類別上的內部方法。不會傳回基底類別上的私用方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1703">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="b1857-1704">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1704">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1705">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1705">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1706">`BindingFlags.DeclaredOnly` 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1706">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1707">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1707">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1708">查閱建構函式和方法時，無法省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1708">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="b1857-1709">叫用時，您只可以省略參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1709">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="b1857-1710">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1710">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1711">如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-1711">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1712">下列範例會建立具有兩個公用方法和一個受保護的方法的類別，然後建立`Type`物件對應至`MyTypeClass`、 取得所有的公用和非公用方法，並顯示其名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-1712">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1713">讓特定類型在目前的 <see cref="T:System.Type" /> 內變成巢狀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1713">Gets a specific type nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1714">包含要取得之巢狀類型名稱的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1714">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1715">搜尋具有指定名稱的公用巢狀類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1715">Searches for the public nested type with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1716">物件，代表具有指定名稱的巢狀類型 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1716">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1717">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-1717">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="b1857-1718">使用巢狀類別的簡單名稱`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1718">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="b1857-1719">切勿在外部類別的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-1719">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="b1857-1720">一般巢狀類別中，使用為 mangled 的名稱 — 也就是附加抑音符號以及泛型引數數目。</span><span class="sxs-lookup"><span data-stu-id="b1857-1720">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="b1857-1721">例如，使用字串"內部\`1"以取得泛型巢狀類別`Inner<T>`(`Inner(Of T)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1721">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="b1857-1722">不包含型別參數的特定語言的語法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1722">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="b1857-1723">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1723">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-1724">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1724">Member Type</span></span>|<span data-ttu-id="b1857-1725">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-1725">Static</span></span>|<span data-ttu-id="b1857-1726">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-1726">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-1727">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-1727">Constructor</span></span>|<span data-ttu-id="b1857-1728">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1728">No</span></span>|<span data-ttu-id="b1857-1729">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1729">No</span></span>|  
|<span data-ttu-id="b1857-1730">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-1730">Field</span></span>|<span data-ttu-id="b1857-1731">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1731">No</span></span>|<span data-ttu-id="b1857-1732">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1732">Yes.</span></span> <span data-ttu-id="b1857-1733">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1733">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1734">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-1734">Event</span></span>|<span data-ttu-id="b1857-1735">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1735">Not applicable</span></span>|<span data-ttu-id="b1857-1736">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1736">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1737">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1737">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1738">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1738">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-1739">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-1739">Method</span></span>|<span data-ttu-id="b1857-1740">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1740">No</span></span>|<span data-ttu-id="b1857-1741">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1741">Yes.</span></span> <span data-ttu-id="b1857-1742">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1742">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1743">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1743">Nested Type</span></span>|<span data-ttu-id="b1857-1744">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1744">No</span></span>|<span data-ttu-id="b1857-1745">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1745">No</span></span>|  
|<span data-ttu-id="b1857-1746">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1746">Property</span></span>|<span data-ttu-id="b1857-1747">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1747">Not applicable</span></span>|<span data-ttu-id="b1857-1748">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1748">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1749">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1749">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1750">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1750">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1751">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1751">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1752">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1752">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1753">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1753">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1754">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1754">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1755">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1755">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-1756">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1756">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="b1857-1757">如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-1757">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="b1857-1758">即使封入泛型型別是封閉式的建構的類型，也是如此。</span><span class="sxs-lookup"><span data-stu-id="b1857-1758">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1759">如果目前<xref:System.Type>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1759">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="b1857-1760">這不一定在動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1760">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="b1857-1761">巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1761">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1762">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1762">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1763">包含要取得之巢狀類型名稱的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1763">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1764">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1764">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1765">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1765">-or-</span>
          </span>
          <span data-ttu-id="b1857-1766">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1766">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1767">在衍生類別中覆寫時，使用指定的繫結條件約束搜尋指定的巢狀類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1767">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1768">物件，代表符合指定之需求的巢狀類型 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1768">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1769">使用巢狀類別的簡單名稱`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1769">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="b1857-1770">切勿在外部類別的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-1770">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="b1857-1771">一般巢狀類別中，使用為 mangled 的名稱 — 也就是附加抑音符號以及泛型參數的數目。</span><span class="sxs-lookup"><span data-stu-id="b1857-1771">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="b1857-1772">例如，使用字串"內部\`1"以取得泛型巢狀類別`Inner<T>`(`Inner(Of T)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1772">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="b1857-1773">不包含型別參數的特定語言的語法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1773">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="b1857-1774">下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：</span><span class="sxs-lookup"><span data-stu-id="b1857-1774">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1775">您必須指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1775">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1776">指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用巢狀型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1776">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1777">指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要在搜尋中包含非公用巢狀的類型 （也就是私用、 內部和受保護巢狀型別）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1777">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="b1857-1778">這個方法會傳回目前類型之巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1778">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="b1857-1779">它不會搜尋目前類型的基底類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1779">It does not search the base classes of the current type.</span></span> <span data-ttu-id="b1857-1780">若要尋找的巢狀類型，基底類別中，您必須逐步繼承階層中，呼叫<xref:System.Type.GetNestedType%2A>每個層級。</span><span class="sxs-lookup"><span data-stu-id="b1857-1780">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="b1857-1781"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>都會被忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-1781"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="b1857-1782">呼叫這個方法只使用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>旗標] 或 [僅<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>旗標將會傳回指定的巢狀類型，並不需要任何其他旗標。</span><span class="sxs-lookup"><span data-stu-id="b1857-1782">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="b1857-1783">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1783">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1784">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1784">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="b1857-1785">如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-1785">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="b1857-1786">即使封入泛型型別是封閉式的建構的類型，也是如此。</span><span class="sxs-lookup"><span data-stu-id="b1857-1786">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1787">如果目前<xref:System.Type>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1787">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="b1857-1788">這不一定在動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1788">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="b1857-1789">巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1789">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1790">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1790">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1791">讓其在目前的 <see cref="T:System.Type" /> 內變成巢狀之類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1791">Gets the types nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1792">傳回在目前 <see cref="T:System.Type" /> 內形成巢狀的公用類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1792">Returns the public types nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1793">
            <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中的巢狀公用類型 (搜尋不是遞迴的)；如果目前 <see cref="T:System.Type" /> 中沒有巢狀公用類型，則為 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1793">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1794"><xref:System.Type.GetNestedTypes%2A>方法沒有傳回型別特定的順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1794">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1795">您的程式碼不得相依於型別會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1795">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1796">只有在目前的類型中巢狀的公用型別會傳回。搜尋不是遞迴的。</span><span class="sxs-lookup"><span data-stu-id="b1857-1796">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="b1857-1797">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1797">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-1798">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1798">Member Type</span></span>|<span data-ttu-id="b1857-1799">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-1799">Static</span></span>|<span data-ttu-id="b1857-1800">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-1800">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-1801">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-1801">Constructor</span></span>|<span data-ttu-id="b1857-1802">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1802">No</span></span>|<span data-ttu-id="b1857-1803">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1803">No</span></span>|  
|<span data-ttu-id="b1857-1804">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-1804">Field</span></span>|<span data-ttu-id="b1857-1805">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1805">No</span></span>|<span data-ttu-id="b1857-1806">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1806">Yes.</span></span> <span data-ttu-id="b1857-1807">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1807">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1808">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-1808">Event</span></span>|<span data-ttu-id="b1857-1809">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1809">Not applicable</span></span>|<span data-ttu-id="b1857-1810">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1810">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1811">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1811">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1812">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1812">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-1813">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-1813">Method</span></span>|<span data-ttu-id="b1857-1814">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1814">No</span></span>|<span data-ttu-id="b1857-1815">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1815">Yes.</span></span> <span data-ttu-id="b1857-1816">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1816">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1817">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1817">Nested Type</span></span>|<span data-ttu-id="b1857-1818">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1818">No</span></span>|<span data-ttu-id="b1857-1819">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1819">No</span></span>|  
|<span data-ttu-id="b1857-1820">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1820">Property</span></span>|<span data-ttu-id="b1857-1821">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1821">Not applicable</span></span>|<span data-ttu-id="b1857-1822">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1822">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1823">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1823">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1824">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1824">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1825">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1825">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1826">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1826">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1827">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1827">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1828">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1828">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1829">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1829">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-1830">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1830">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="b1857-1831">如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-1831">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="b1857-1832">即使封入泛型型別是封閉式的建構的類型，也是如此。</span><span class="sxs-lookup"><span data-stu-id="b1857-1832">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1833">如果目前<xref:System.Type>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1833">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="b1857-1834">這不一定在動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1834">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="b1857-1835">巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1835">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1836">下列範例會定義巢狀的類別和`struct`中`MyClass`，然後取得使用的型別之巢狀類型的物件和`MyClass`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1836">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1837">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1837">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1838">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1838">-or-</span>
          </span>
          <span data-ttu-id="b1857-1839">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1839">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1840">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋在目前 <see cref="T:System.Type" /> 內形成巢狀的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1840">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1841">
            <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中符合指定繫結條件約束的所有巢狀類型 (搜尋不是遞迴的)；如果找不到符合繫結條件約束的巢狀類型，則為 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1841">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1842">搜尋巢狀類型不是遞迴的。</span><span class="sxs-lookup"><span data-stu-id="b1857-1842">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="b1857-1843"><xref:System.Type.GetNestedTypes%2A>方法沒有傳回型別特定的順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1843">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1844">您的程式碼不得相依於型別會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1844">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1845">下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：</span><span class="sxs-lookup"><span data-stu-id="b1857-1845">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1846">您必須指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1846">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1847">指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用巢狀型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1847">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1848">指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要在搜尋中包含非公用巢狀的類型 （也就是私用、 內部和受保護巢狀型別）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1848">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="b1857-1849">這個方法會傳回目前類型之巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1849">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="b1857-1850">它不會搜尋目前類型的基底類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-1850">It does not search the base classes of the current type.</span></span> <span data-ttu-id="b1857-1851">若要尋找的巢狀類型，基底類別中，您必須逐步繼承階層中，呼叫<xref:System.Type.GetNestedTypes%2A>每個層級。</span><span class="sxs-lookup"><span data-stu-id="b1857-1851">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="b1857-1852"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>都會被忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-1852"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="b1857-1853">呼叫這個方法只使用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>旗標] 或 [僅<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>旗標將會傳回指定的巢狀類型，並不需要任何其他旗標。</span><span class="sxs-lookup"><span data-stu-id="b1857-1853">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="b1857-1854">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1854">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1855">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1855">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="b1857-1856">如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-1856">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="b1857-1857">即使封入泛型型別是封閉式的建構的類型，也是如此。</span><span class="sxs-lookup"><span data-stu-id="b1857-1857">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-1858">如果目前<xref:System.Type>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1858">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="b1857-1859">這不一定在動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1859">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="b1857-1860">巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1860">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1861">下列範例會建立兩個巢狀公用類別和兩個巢狀的受保護的類別，並會顯示符合指定的繫結條件約束的類別資訊。</span><span class="sxs-lookup"><span data-stu-id="b1857-1861">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1862">取得目前 <see cref="T:System.Type" /> 的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1862">Gets the properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1863">傳回目前 <see cref="T:System.Type" /> 的所有公用屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1863">Returns all the public properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1864">
            <see cref="T:System.Reflection.PropertyInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有公用屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1864">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="b1857-1865">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1865">-or-</span>
          </span>
          <span data-ttu-id="b1857-1866">類型 <see cref="T:System.Reflection.PropertyInfo" /> 的空陣列，如果目前 <see cref="T:System.Type" /> 並沒有公用屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1866">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1867">呼叫這個多載就相當於呼叫<xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29>多載`bindingAttr`引數等於`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`在 C# 和`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-1867">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="b1857-1868">它會傳回所有公用執行個體和靜態屬性，表示由目前類型所定義兩個那些<xref:System.Type>物件以及繼承自一個基底類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1868">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="b1857-1869">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-1869">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-1870">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-1870">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-1871"><xref:System.Type.GetProperties%2A>方法不會傳回屬性以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1871">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1872">您的程式碼必須依賴屬性會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1872">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1873">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1873">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-1874">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1874">Member Type</span></span>|<span data-ttu-id="b1857-1875">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-1875">Static</span></span>|<span data-ttu-id="b1857-1876">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-1876">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-1877">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-1877">Constructor</span></span>|<span data-ttu-id="b1857-1878">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1878">No</span></span>|<span data-ttu-id="b1857-1879">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1879">No</span></span>|  
|<span data-ttu-id="b1857-1880">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-1880">Field</span></span>|<span data-ttu-id="b1857-1881">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1881">No</span></span>|<span data-ttu-id="b1857-1882">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1882">Yes.</span></span> <span data-ttu-id="b1857-1883">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1883">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1884">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-1884">Event</span></span>|<span data-ttu-id="b1857-1885">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1885">Not applicable</span></span>|<span data-ttu-id="b1857-1886">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1886">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1887">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1887">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1888">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1888">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-1889">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-1889">Method</span></span>|<span data-ttu-id="b1857-1890">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1890">No</span></span>|<span data-ttu-id="b1857-1891">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-1891">Yes.</span></span> <span data-ttu-id="b1857-1892">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1892">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-1893">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-1893">Nested Type</span></span>|<span data-ttu-id="b1857-1894">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1894">No</span></span>|<span data-ttu-id="b1857-1895">否</span><span class="sxs-lookup"><span data-stu-id="b1857-1895">No</span></span>|  
|<span data-ttu-id="b1857-1896">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1896">Property</span></span>|<span data-ttu-id="b1857-1897">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-1897">Not applicable</span></span>|<span data-ttu-id="b1857-1898">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1898">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-1899">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1899">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1900">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-1900">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-1901">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-1901">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-1902">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-1902">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-1903">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-1903">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-1904">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-1904">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-1905">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-1905">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-1906">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1906">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1907">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1907">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1908">下列範例示範 `GetProperties` 方法的用法。</span><span class="sxs-lookup"><span data-stu-id="b1857-1908">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1909">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1909">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1910">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1910">-or-</span>
          </span>
          <span data-ttu-id="b1857-1911">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1911">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1912">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋目前 <see cref="T:System.Type" /> 的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1912">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1913">
            <see cref="T:System.Reflection.PropertyInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中符合指定繫結條件約束的所有屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1913">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="b1857-1914">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1914">-or-</span>
          </span>
          <span data-ttu-id="b1857-1915">如果目前 <see cref="T:System.Reflection.PropertyInfo" /> 沒有屬性，或沒有屬性符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1915">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1916">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-1916">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-1917">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-1917">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-1918"><xref:System.Type.GetProperties%2A>方法不會傳回屬性以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-1918">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="b1857-1919">您的程式碼必須依賴屬性會傳回的順序，因為順序不同。</span><span class="sxs-lookup"><span data-stu-id="b1857-1919">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="b1857-1920">下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：</span><span class="sxs-lookup"><span data-stu-id="b1857-1920">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1921">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1921">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1922">指定`BindingFlags.Public`来包含在搜尋中的公用屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1922">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1923">指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1923">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="b1857-1924">只保護，而且會傳回基底類別上的內部屬性。不會傳回基底類別上的私用屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1924">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="b1857-1925">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1925">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1926">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1926">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1927">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的屬性<xref:System.Type>，不只是繼承的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1927">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1928">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1928">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1929">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-1929">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-1930">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-1930">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-1931">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數所取代的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-1931">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1932">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1932">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1933">下列範例會定義名為類別`PropertyClass`包含六個屬性： 兩個都是公用，一個是私用、 保護的其中一個，為內部 (`Friend`在 Visual Basic 中)，且其中一個受保護內部 (`Protected Friend`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1933">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="b1857-1934">接著會顯示一些基本的屬性資訊 (屬性名稱和型別，是否是讀取/寫入，以及是否可看到其`get`和`set`存取子) 符合指定的繫結條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1934">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-1935">取得目前 <see cref="T:System.Type" /> 的特定屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1935">Gets a specific property of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1936">字串，包含要取得的公用屬性名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1936">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1937">搜尋具有指定名稱的公用屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1937">Searches for the public property with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1938">物件，代表具有指定之名稱的公用屬性 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1938">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1939">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-1939">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-1940">搜尋包含 public static 和 public 的執行個體屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1940">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="b1857-1941">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-1941">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-1942">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-1942">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-1943">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1943">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1944">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1944">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="b1857-1945">情況<xref:System.Reflection.AmbiguousMatchException>發生如下：</span><span class="sxs-lookup"><span data-stu-id="b1857-1945">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="b1857-1946">類型包含兩個索引的屬性具有相同名稱但不同數量的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1946">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="b1857-1947">若要解決模稜兩可，使用的多載<xref:System.Type.GetProperty%2A>方法所指定的參數類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1947">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="b1857-1948">衍生的型別宣告會隱藏繼承的屬性具有相同的名稱，使用屬性`new`修飾詞 (`Shadows`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1948">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="b1857-1949">若要解決模稜兩可，請使用<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>方法多載，並新增<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>旗標將搜尋限制不會繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1949">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="b1857-1950">索引子和預設屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1950">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="b1857-1951">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="b1857-1951">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="b1857-1952">例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-1952">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="b1857-1953">您可以多載的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1953">You can overload the property.</span></span>  
  
 <span data-ttu-id="b1857-1954">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</span><span class="sxs-lookup"><span data-stu-id="b1857-1954">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="b1857-1955">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1955">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="b1857-1956">不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-1956">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="b1857-1957">例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1957">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="b1857-1958">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-1958">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="b1857-1959">若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1959">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="b1857-1960">如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-1960">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-1961">下列範例會擷取`Type`物件的使用者定義的類別，擷取該類別的屬性，並顯示屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-1961">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="b1857-1962">就內部而言，這個屬性是中繼資料中所參考的名稱 「 項目。 」</span><span class="sxs-lookup"><span data-stu-id="b1857-1962">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="b1857-1963">嘗試取得`PropertyInfo`使用反映必須指定此內部名稱才能正確地傳回`PropertyInfo`屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1963">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-1964">找到一個以上具有指定名稱的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1964">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-1965">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1965">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-1966">字串，包含要取得的屬性名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1966">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-1967">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1967">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-1968">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1968">-or-</span>
          </span>
          <span data-ttu-id="b1857-1969">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1969">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-1970">使用指定的繫結條件約束搜尋指定的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1970">Searches for the specified property, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-1971">代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-1971">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-1972">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-1972">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-1973">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-1973">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-1974">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含的屬性：</span><span class="sxs-lookup"><span data-stu-id="b1857-1974">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-1975">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-1975">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-1976">指定`BindingFlags.Public`来包含在搜尋中的公用屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1976">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1977">指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。</span><span class="sxs-lookup"><span data-stu-id="b1857-1977">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-1978">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-1978">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-1979">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-1979">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-1980">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-1980">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-1981">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的屬性<xref:System.Type>，不只是繼承的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1981">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-1982">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1982">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-1983">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1983">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-1984">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1984">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="b1857-1985">情況<xref:System.Reflection.AmbiguousMatchException>發生如下：</span><span class="sxs-lookup"><span data-stu-id="b1857-1985">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="b1857-1986">類型包含兩個索引的屬性具有相同名稱但不同數量的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-1986">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="b1857-1987">若要解決模稜兩可，使用的多載<xref:System.Type.GetProperty%2A>方法所指定的參數類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-1987">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="b1857-1988">衍生的型別宣告會隱藏繼承的屬性具有相同名稱的屬性使用`new`修飾詞 (`Shadows`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-1988">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="b1857-1989">若要解決模稜兩可，包括<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>將搜尋限制不會繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-1989">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="b1857-1990">索引子和預設屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-1990">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="b1857-1991">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="b1857-1991">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="b1857-1992">例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-1992">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="b1857-1993">您可以多載的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1993">You can overload the property.</span></span>  
  
 <span data-ttu-id="b1857-1994">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</span><span class="sxs-lookup"><span data-stu-id="b1857-1994">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="b1857-1995">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1995">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="b1857-1996">不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-1996">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="b1857-1997">例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-1997">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="b1857-1998">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-1998">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="b1857-1999">若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-1999">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="b1857-2000">如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2000">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-2001">下列範例擷取的使用者定義的類別類型、 擷取該類別的屬性，並顯示根據指定的繫結條件約束的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2001">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-2002">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2002">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2003">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2003">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-2004">字串，包含要取得的公用屬性名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2004">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="b1857-2005">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2005">The return type of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2006">搜尋具有指定名稱和傳回型別的公用屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2006">Searches for the public property with the specified name and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2007">物件，代表具有指定之名稱的公用屬性 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2007">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2008">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-2008">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-2009">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-2009">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-2010">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-2010">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-2011">搜尋包含 public static 和 public 的執行個體屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2011">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="b1857-2012">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2012">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-2013">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2013">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="b1857-2014">索引子和預設屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2014">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="b1857-2015">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="b1857-2015">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="b1857-2016">例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2016">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="b1857-2017">您可以多載的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2017">You can overload the property.</span></span>  
  
 <span data-ttu-id="b1857-2018">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</span><span class="sxs-lookup"><span data-stu-id="b1857-2018">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="b1857-2019">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2019">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="b1857-2020">不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2020">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="b1857-2021">例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2021">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="b1857-2022">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2022">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="b1857-2023">若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2023">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="b1857-2024">如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2024">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-2025">下列範例會定義具有一個屬性的類別，並擷取名稱和屬性的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2025">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-2026">找到一個以上具有指定名稱的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2026">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2027">
            <paramref name="name" /> 為 <see langword="null" /> 或 <paramref name="returnType" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2027">
              <paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-2028">字串，包含要取得的公用屬性名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2028">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-2029">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2029">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="b1857-2030">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2030">-or-</span>
          </span>
          <span data-ttu-id="b1857-2031">用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2031">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2032">搜尋指定的公用屬性，其參數符合指定的引數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2032">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2033">代表其參數符合指定之引數類型的公用屬性物件 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2033">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2034">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-2034">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-2035">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-2035">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-2036">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-2036">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-2037">搜尋包含 public static 和 public 的執行個體屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2037">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="b1857-2038">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2038">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-2039">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2039">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="b1857-2040">索引子和預設屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2040">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="b1857-2041">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="b1857-2041">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="b1857-2042">例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2042">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="b1857-2043">您可以多載的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2043">You can overload the property.</span></span>  
  
 <span data-ttu-id="b1857-2044">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</span><span class="sxs-lookup"><span data-stu-id="b1857-2044">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="b1857-2045">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2045">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="b1857-2046">不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2046">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="b1857-2047">例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2047">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="b1857-2048">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2048">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="b1857-2049">若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2049">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="b1857-2050">如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2050">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-2051">下列範例會擷取`Type`物件的使用者定義的類別，擷取該類別的屬性，並顯示屬性名稱和屬性的型別所傳遞的引數指定`GetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2051">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-2052">找到一個以上具有指定名稱，且符合指定引數類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2052">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2053">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2053">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2054">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2054">-or-</span>
          </span>
          <span data-ttu-id="b1857-2055">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2055">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2056">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2056">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="b1857-2057">
            <paramref name="types" /> 的項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2057">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-2058">字串，包含要取得的公用屬性名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2058">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="b1857-2059">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2059">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-2060">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2060">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="b1857-2061">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2061">-or-</span>
          </span>
          <span data-ttu-id="b1857-2062">用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2062">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2063">搜尋指定的公用屬性，其參數符合指定的引數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2063">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2064">代表其參數符合指定之引數類型的公用屬性物件 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2064">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2065">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-2065">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-2066">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-2066">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-2067">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-2067">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-2068">搜尋包含 public static 和 public 的執行個體屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2068">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="b1857-2069">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2069">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-2070">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2070">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="b1857-2071">索引子和預設屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2071">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="b1857-2072">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="b1857-2072">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="b1857-2073">例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2073">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="b1857-2074">您可以多載的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2074">You can overload the property.</span></span>  
  
 <span data-ttu-id="b1857-2075">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</span><span class="sxs-lookup"><span data-stu-id="b1857-2075">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="b1857-2076">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2076">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="b1857-2077">不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2077">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="b1857-2078">例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2078">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="b1857-2079">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2079">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="b1857-2080">若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2080">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="b1857-2081">如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2081">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-2082">找到一個以上具有指定名稱，且符合指定引數類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2082">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2083">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2083">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2084">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2084">-or-</span>
          </span>
          <span data-ttu-id="b1857-2085">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2085">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2086">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2086">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="b1857-2087">
            <paramref name="types" /> 的項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2087">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-2088">字串，包含要取得的公用屬性名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2088">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="b1857-2089">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2089">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-2090">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2090">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="b1857-2091">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2091">-or-</span>
          </span>
          <span data-ttu-id="b1857-2092">用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2092">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-2093">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2093">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-2094">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2094">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2095">搜尋指定的公用屬性，其參數符合指定的引數類型和修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2095">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2096">物件，代表符合指定之需求的公用屬性 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2096">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2097">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-2097">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-2098">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-2098">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-2099">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2099">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-2100">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2100">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-2101">搜尋`name`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="b1857-2101">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="b1857-2102">搜尋包含 public static 和 public 的執行個體屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2102">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="b1857-2103">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2103">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-2104">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2104">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="b1857-2105">索引子和預設屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2105">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="b1857-2106">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="b1857-2106">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="b1857-2107">例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2107">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="b1857-2108">您可以多載的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2108">You can overload the property.</span></span>  
  
 <span data-ttu-id="b1857-2109">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</span><span class="sxs-lookup"><span data-stu-id="b1857-2109">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="b1857-2110">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2110">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="b1857-2111">不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2111">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="b1857-2112">例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2112">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="b1857-2113">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2113">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="b1857-2114">若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2114">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="b1857-2115">如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2115">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-2116">下列範例會取得`Type`物件對應至`MyPropertyClass`，並使用引數傳遞給擷取之索引的屬性，這個類別的`GetProperty`方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2116">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-2117">找到一個以上具有指定名稱，且符合指定引數類型和修飾詞的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2117">More than one property is found with the specified name and matching the specified argument types and modifiers.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2118">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2118">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2119">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2119">-or-</span>
          </span>
          <span data-ttu-id="b1857-2120">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2120">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2121">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2121">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-2122">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2122">-or-</span>
          </span>
          <span data-ttu-id="b1857-2123">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2123">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-2124">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2124">-or-</span>
          </span>
          <span data-ttu-id="b1857-2125">
            <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2125">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="b1857-2126">
            <paramref name="types" /> 的項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2126">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-2127">字串，包含要取得的屬性名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2127">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-2128">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2128">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-2129">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2129">-or-</span>
          </span>
          <span data-ttu-id="b1857-2130">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2130">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-2131">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2131">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-2132">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2132">-or-</span>
          </span>
          <span data-ttu-id="b1857-2133">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2133">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="b1857-2134">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2134">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-2135">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2135">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="b1857-2136">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2136">-or-</span>
          </span>
          <span data-ttu-id="b1857-2137">用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2137">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-2138">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2138">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-2139">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2139">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2140">使用指定的繫結條件約束搜尋指定的屬性，而該屬性的參數符合指定的引數類型和修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2140">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2141">代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2141">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2142">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</span><span class="sxs-lookup"><span data-stu-id="b1857-2142">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="b1857-2143">否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。</span><span class="sxs-lookup"><span data-stu-id="b1857-2143">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="b1857-2144">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2144">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-2145">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2145">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-2146">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2146">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-2147">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2147">Member Type</span></span>|<span data-ttu-id="b1857-2148">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-2148">Static</span></span>|<span data-ttu-id="b1857-2149">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-2149">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-2150">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-2150">Constructor</span></span>|<span data-ttu-id="b1857-2151">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2151">No</span></span>|<span data-ttu-id="b1857-2152">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2152">No</span></span>|  
|<span data-ttu-id="b1857-2153">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-2153">Field</span></span>|<span data-ttu-id="b1857-2154">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2154">No</span></span>|<span data-ttu-id="b1857-2155">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-2155">Yes.</span></span> <span data-ttu-id="b1857-2156">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2156">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-2157">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-2157">Event</span></span>|<span data-ttu-id="b1857-2158">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-2158">Not applicable</span></span>|<span data-ttu-id="b1857-2159">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2159">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-2160">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2160">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2161">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-2161">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-2162">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-2162">Method</span></span>|<span data-ttu-id="b1857-2163">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2163">No</span></span>|<span data-ttu-id="b1857-2164">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-2164">Yes.</span></span> <span data-ttu-id="b1857-2165">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2165">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-2166">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2166">Nested Type</span></span>|<span data-ttu-id="b1857-2167">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2167">No</span></span>|<span data-ttu-id="b1857-2168">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2168">No</span></span>|  
|<span data-ttu-id="b1857-2169">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2169">Property</span></span>|<span data-ttu-id="b1857-2170">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-2170">Not applicable</span></span>|<span data-ttu-id="b1857-2171">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2171">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-2172">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2172">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2173">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-2173">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-2174">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-2174">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-2175">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-2175">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-2176">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2176">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2177">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-2177">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-2178">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-2178">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-2179">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含的屬性：</span><span class="sxs-lookup"><span data-stu-id="b1857-2179">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-2180">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-2180">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-2181">指定`BindingFlags.Public`来包含在搜尋中的公用屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2181">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="b1857-2182">指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。</span><span class="sxs-lookup"><span data-stu-id="b1857-2182">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-2183">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-2183">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-2184">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-2184">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-2185">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2185">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-2186">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的屬性<xref:System.Type>，不只是繼承的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2186">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-2187">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2187">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-2188">如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2188">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="b1857-2189">如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2189">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="b1857-2190">索引子和預設屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2190">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="b1857-2191">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="b1857-2191">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="b1857-2192">例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2192">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="b1857-2193">您可以多載的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2193">You can overload the property.</span></span>  
  
 <span data-ttu-id="b1857-2194">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</span><span class="sxs-lookup"><span data-stu-id="b1857-2194">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="b1857-2195">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2195">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="b1857-2196">不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2196">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="b1857-2197">例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2197">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="b1857-2198">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2198">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="b1857-2199">若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2199">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="b1857-2200">如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2200">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-2201">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2201">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2202">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2202">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2203">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2203">-or-</span>
          </span>
          <span data-ttu-id="b1857-2204">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2204">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2205">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2205">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-2206">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2206">-or-</span>
          </span>
          <span data-ttu-id="b1857-2207">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2207">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-2208">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2208">-or-</span>
          </span>
          <span data-ttu-id="b1857-2209">
            <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2209">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="b1857-2210">
            <paramref name="types" /> 的項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2210">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-2211">字串，包含要取得的屬性名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2211">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="b1857-2212">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2212">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-2213">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2213">-or-</span>
          </span>
          <span data-ttu-id="b1857-2214">零，傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2214">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-2215">定義一組屬性並啟用繫結的物件，可包含多載成員的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2215">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-2216">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2216">-or-</span>
          </span>
          <span data-ttu-id="b1857-2217">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2217">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="b1857-2218">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2218">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="b1857-2219">
            <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2219">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="b1857-2220">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2220">-or-</span>
          </span>
          <span data-ttu-id="b1857-2221">用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2221">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-2222">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2222">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="b1857-2223">預設的繫結器不會處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2223">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2224">在衍生類別中覆寫時，使用指定的繫結條件約束搜尋指定的屬性，而該屬性的參數符合指定的引數類型和修飾詞的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2224">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2225">代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2225">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2226">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2226">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="b1857-2227">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2227">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-2228">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含的屬性：</span><span class="sxs-lookup"><span data-stu-id="b1857-2228">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-2229">您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。</span><span class="sxs-lookup"><span data-stu-id="b1857-2229">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="b1857-2230">指定`BindingFlags.Public`来包含在搜尋中的公用屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2230">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="b1857-2231">指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。</span><span class="sxs-lookup"><span data-stu-id="b1857-2231">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-2232">指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。</span><span class="sxs-lookup"><span data-stu-id="b1857-2232">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="b1857-2233">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-2233">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-2234">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2234">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-2235">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的屬性<xref:System.Type>，不只是繼承的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2235">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-2236">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2236">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-2237">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2237">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2238">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2238">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2239">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2239">-or-</span>
          </span>
          <span data-ttu-id="b1857-2240">
            <paramref name="types" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2240">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2241">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2241">-or-</span>
          </span>
          <span data-ttu-id="b1857-2242">
            <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2242">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2243">
            <paramref name="types" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2243">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-2244">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2244">-or-</span>
          </span>
          <span data-ttu-id="b1857-2245">
            <paramref name="modifiers" /> 是多維的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2245">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="b1857-2246">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2246">-or-</span>
          </span>
          <span data-ttu-id="b1857-2247">
            <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2247">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-2248">目前的型別是 <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2248">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-2249">取得代表指定類型的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2249">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-2250">取得目前的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2250">Gets the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2251">目前的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2251">The current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-2252">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2252">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="b1857-2253">要取得之類型的組件限定名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2253">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="b1857-2254">請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2254">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="b1857-2255">如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2255">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2256">取得具有指定名稱的 <see cref="T:System.Type" />，執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2256">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2257">具有指定名稱的類型 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2257">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2258">您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2258">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its namespace-qualified name.</span></span> <span data-ttu-id="b1857-2259"><xref:System.Type.GetType%2A> 引起指定的組件載入`typeName`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2259"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="b1857-2260">您也可以載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法，這個方法，然後使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>方法來取得<xref:System.Type>物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2260">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="b1857-2261">如果類型是在編譯時期已知程式組件中，它是在 C# 中，使用更有效率<xref:System.Type.GetType%2A>在 Visual Basic 或 c + + 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2261">If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2262">如果`typeName`找不到，呼叫<xref:System.Type.GetType%28System.String%29>方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2262">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="b1857-2263">它不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-2263">It does not throw an exception.</span></span> <span data-ttu-id="b1857-2264">若要控制是否擲回例外狀況，請呼叫的多載<xref:System.Type.GetType%2A>方法`throwOnError`參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2264">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="b1857-2265"><xref:System.Type.GetType%2A> 只適用於從磁碟載入的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2265"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="b1857-2266">如果您呼叫<xref:System.Type.GetType%2A>查閱來定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會發生不一致的行為。</span><span class="sxs-lookup"><span data-stu-id="b1857-2266">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="b1857-2267">行為取決於動態組件是持續性，也就是，建立使用`RunAndSave`或`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2267">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="b1857-2268">如果在動態組件會持續，並寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2268">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="b1857-2269">如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2269">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="b1857-2270">`GetType` 不了解暫時性動態組件。因此，呼叫`GetType`擷取型別中的暫時性動態組件傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2270">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="b1857-2271">若要使用`GetType`上動態模組中，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件和呼叫`GetType`之後再儲存。</span><span class="sxs-lookup"><span data-stu-id="b1857-2271">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="b1857-2272">否則，您會得到兩個組件的複本在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2272">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="b1857-2273">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2273">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-2274">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2274">Member Type</span></span>|<span data-ttu-id="b1857-2275">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-2275">Static</span></span>|<span data-ttu-id="b1857-2276">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-2276">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-2277">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-2277">Constructor</span></span>|<span data-ttu-id="b1857-2278">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2278">No</span></span>|<span data-ttu-id="b1857-2279">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2279">No</span></span>|  
|<span data-ttu-id="b1857-2280">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-2280">Field</span></span>|<span data-ttu-id="b1857-2281">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2281">No</span></span>|<span data-ttu-id="b1857-2282">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-2282">Yes.</span></span> <span data-ttu-id="b1857-2283">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2283">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-2284">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-2284">Event</span></span>|<span data-ttu-id="b1857-2285">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-2285">Not applicable</span></span>|<span data-ttu-id="b1857-2286">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2286">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-2287">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2287">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2288">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-2288">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-2289">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-2289">Method</span></span>|<span data-ttu-id="b1857-2290">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2290">No</span></span>|<span data-ttu-id="b1857-2291">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-2291">Yes.</span></span> <span data-ttu-id="b1857-2292">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2292">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-2293">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2293">Nested Type</span></span>|<span data-ttu-id="b1857-2294">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2294">No</span></span>|<span data-ttu-id="b1857-2295">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2295">No</span></span>|  
|<span data-ttu-id="b1857-2296">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2296">Property</span></span>|<span data-ttu-id="b1857-2297">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-2297">Not applicable</span></span>|<span data-ttu-id="b1857-2298">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2298">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-2299">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2299">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2300">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-2300">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-2301">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-2301">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-2302">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-2302">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-2303">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2303">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2304">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-2304">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-2305">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-2305">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-2306">陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。</span><span class="sxs-lookup"><span data-stu-id="b1857-2306">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="b1857-2307">`typeName` 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。</span><span class="sxs-lookup"><span data-stu-id="b1857-2307">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="b1857-2308">請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2308">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="b1857-2309">如果`typeName`包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-2309">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="b1857-2310">如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2310">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="b1857-2311">如果組件具有強式名稱，是完整組件名稱是必要。</span><span class="sxs-lookup"><span data-stu-id="b1857-2311">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="b1857-2312"><xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱和泛型型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2312">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="b1857-2313">支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2313">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2314">在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-2314">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="b1857-2315">例如，"ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="b1857-2315">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="b1857-2316">不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2316">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="b1857-2317">您也可以藉由建立載入型別<xref:System.Reflection.AssemblyName>物件並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2317">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="b1857-2318">然後您可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2318">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="b1857-2319">請參閱<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2319">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="b1857-2320">分隔符號</span><span class="sxs-lookup"><span data-stu-id="b1857-2320">Delimiter</span></span>|<span data-ttu-id="b1857-2321">意義</span><span class="sxs-lookup"><span data-stu-id="b1857-2321">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="b1857-2322">反斜線 (\\)</span><span class="sxs-lookup"><span data-stu-id="b1857-2322">Backslash (\\)</span></span>|<span data-ttu-id="b1857-2323">逸出字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2323">Escape character.</span></span>|  
|<span data-ttu-id="b1857-2324">倒單引號 （'）</span><span class="sxs-lookup"><span data-stu-id="b1857-2324">Backtick (\`)</span></span>|<span data-ttu-id="b1857-2325">前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-2325">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="b1857-2326">括號 ([])</span><span class="sxs-lookup"><span data-stu-id="b1857-2326">Brackets ([])</span></span>|<span data-ttu-id="b1857-2327">將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2327">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="b1857-2328">逗號 （，）</span><span class="sxs-lookup"><span data-stu-id="b1857-2328">Comma (,)</span></span>|<span data-ttu-id="b1857-2329">後面接著組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2329">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="b1857-2330">句號 （.）</span><span class="sxs-lookup"><span data-stu-id="b1857-2330">Period (.)</span></span>|<span data-ttu-id="b1857-2331">代表命名空間識別項。</span><span class="sxs-lookup"><span data-stu-id="b1857-2331">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="b1857-2332">加號 （+）</span><span class="sxs-lookup"><span data-stu-id="b1857-2332">Plus sign (+)</span></span>|<span data-ttu-id="b1857-2333">之前的巢狀的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2333">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="b1857-2334">例如，類別的完整限定的名稱可能看起來像這樣：</span><span class="sxs-lookup"><span data-stu-id="b1857-2334">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="b1857-2335">如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (\\) 以防止它被解譯為巢狀的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="b1857-2335">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="b1857-2336">反映會發出這個字串，如下所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-2336">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="b1857-2337">A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。</span><span class="sxs-lookup"><span data-stu-id="b1857-2337">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="b1857-2338">這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2338">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="b1857-2339">搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2339">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="b1857-2340"><xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2340"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="b1857-2341"><xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2341"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="b1857-2342">型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2342">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="b1857-2343">若要擷取的型別名稱不含這些尾端字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2343">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="b1857-2344">空格是相關組件名稱以外的所有型別名稱元件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2344">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="b1857-2345">在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-2345">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="b1857-2346">泛型類型的名稱結尾是反單引號 (\`) 後面接著數字，代表泛型型別引數數目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2346">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="b1857-2347">此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。</span><span class="sxs-lookup"><span data-stu-id="b1857-2347">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="b1857-2348">比方說，反映傳回 mangled 的名稱`Tuple`1` and `Tuple`2`泛型的方法從`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2348">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="b1857-2349">為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2349">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="b1857-2350">例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2350">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="b1857-2351">A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能會表示如下：</span><span class="sxs-lookup"><span data-stu-id="b1857-2351">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="b1857-2352">若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2352">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="b1857-2353">否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2353">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="b1857-2354">例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`fromMyAssembly.dll，類型的索引鍵聯<xref:System.String>，可能會以下面方式指定：</span><span class="sxs-lookup"><span data-stu-id="b1857-2354">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2355">組件限定型別可以括在方括號，它必須出現在型別參數清單中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2355">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="b1857-2356">在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2356">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="b1857-2357">可為 null 的類型是泛型類型的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="b1857-2357">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="b1857-2358">例如，可為 null<xref:System.Int32>由 「 System.Nullable'1[System.Int32]"的字串。</span><span class="sxs-lookup"><span data-stu-id="b1857-2358">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2359">您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2359">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="b1857-2360">例如，可為 null<xref:System.Boolean>類型由`typeof(Nullable<bool>)`在 C# 中，由`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2360">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="b1857-2361">下表顯示您使用的語法`GetType`各種類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2361">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="b1857-2362">若要取得</span><span class="sxs-lookup"><span data-stu-id="b1857-2362">To Get</span></span>|<span data-ttu-id="b1857-2363">使用</span><span class="sxs-lookup"><span data-stu-id="b1857-2363">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="b1857-2364">可為 null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="b1857-2364">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="b1857-2365">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2365">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="b1857-2366">若要將 unmanaged 的指標 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2366">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="b1857-2367">將 unmanaged 的指標的指標 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2367">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="b1857-2368">Managed 的指標或參考 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2368">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="b1857-2369">`Type.GetType("MyType&")`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2369">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="b1857-2370">請注意，參考與指標不同，僅限一個層級。</span><span class="sxs-lookup"><span data-stu-id="b1857-2370">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="b1857-2371">父類別和巢狀的類別</span><span class="sxs-lookup"><span data-stu-id="b1857-2371">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="b1857-2372">一維陣列，其下限為 0</span><span class="sxs-lookup"><span data-stu-id="b1857-2372">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="b1857-2373">一維陣列，未知的下限</span><span class="sxs-lookup"><span data-stu-id="b1857-2373">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="b1857-2374">N 維陣列</span><span class="sxs-lookup"><span data-stu-id="b1857-2374">An n-dimensional array</span></span>|<span data-ttu-id="b1857-2375">逗號 （，） 的 n-1 次數總計的括號內。</span><span class="sxs-lookup"><span data-stu-id="b1857-2375">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="b1857-2376">例如，`System.Object[,,]`代表三維`Object`陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-2376">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="b1857-2377">陣列的一維陣列</span><span class="sxs-lookup"><span data-stu-id="b1857-2377">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="b1857-2378">矩形的二維陣列下限未知</span><span class="sxs-lookup"><span data-stu-id="b1857-2378">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="b1857-2379">具有一個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2379">A generic type with one type argument</span></span>|<span data-ttu-id="b1857-2380">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2380">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="b1857-2381">具有兩個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2381">A generic type with two type arguments</span></span>|<span data-ttu-id="b1857-2382">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2382">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="b1857-2383">具有兩個組件限定型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2383">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="b1857-2384">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2384">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="b1857-2385">組件限定泛型型別與組件限定型別引數</span><span class="sxs-lookup"><span data-stu-id="b1857-2385">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="b1857-2386">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2386">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="b1857-2387">泛型型別，其型別引數是兩個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2387">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="b1857-2388">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="b1857-2388">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b1857-2389">下列範例會擷取的型別`System.Int32`並使用該類型的物件顯示<xref:System.Type.FullName%2A>屬性`System.Int32`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2389">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2390">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2390">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-2391">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2391">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2392">
            <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2392">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2393">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2393">-or-</span>
          </span>
          <span data-ttu-id="b1857-2394">
            <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2394">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2395">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2395">-or-</span>
          </span>
          <span data-ttu-id="b1857-2396">
            <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2396">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-2397">
            <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2397">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="b1857-2398">在[適用於 Windows 市集應用程式的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或是[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。</span>
              <span class="sxs-lookup">
                <span data-stu-id="b1857-2398">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="b1857-2399">找到組件或其相依性的其中一個，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2399">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="b1857-2400">組件或組件的其中一個相依性無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2400">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="b1857-2401">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2401">-or-</span>
          </span>
          <span data-ttu-id="b1857-2402">目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2402">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="b1857-2403">要取得之類型的組件限定名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2403">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="b1857-2404">請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2404">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="b1857-2405">如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2405">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="b1857-2406">
            <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2406">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2407">指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2407">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="b1857-2408">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2408">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2409">取得具有指定名稱的 <see cref="T:System.Type" />，執行區分大小寫的搜尋，並設定找不到該類型時，是否應擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2409">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2410">具有指定名稱的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2410">The type with the specified name.</span>
          </span>
          <span data-ttu-id="b1857-2411">如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2411">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="b1857-2412">在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2412">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="b1857-2413">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2413">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2414">您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2414">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name.</span></span> <span data-ttu-id="b1857-2415"><xref:System.Type.GetType%2A> 引起指定的組件載入`typeName`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2415"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="b1857-2416">您也可以載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法，這個方法，然後使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>方法來取得<xref:System.Type>物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2416">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="b1857-2417">如果類型是在編譯時期已知程式組件中，會更有效率使用`typeof`在 C# 中，<xref:System.Type.GetType%2A>在 Visual Basic 中，或`typeid`c + + 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2417">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="b1857-2418">`GetType` 只適用於從磁碟載入的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2418">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="b1857-2419">如果您呼叫`GetType`查閱來定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會發生不一致的行為。</span><span class="sxs-lookup"><span data-stu-id="b1857-2419">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="b1857-2420">行為取決於動態組件是持續性，也就是，建立使用`RunAndSave`或`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2420">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="b1857-2421">如果在動態組件會持續，並寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2421">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="b1857-2422">如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2422">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="b1857-2423">`GetType` 不了解暫時性動態組件。因此，呼叫`GetType`擷取型別中的暫時性動態組件傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2423">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="b1857-2424">若要使用`GetType`上動態模組中，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件和呼叫`GetType`之後再儲存。</span><span class="sxs-lookup"><span data-stu-id="b1857-2424">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="b1857-2425">否則，您會得到兩個組件的複本在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2425">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="b1857-2426">`throwOnError`參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 > 一節中所述。</span><span class="sxs-lookup"><span data-stu-id="b1857-2426">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="b1857-2427">某些例外狀況的值為何`throwOnError`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2427">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="b1857-2428">例如，如果找到的類型，但無法載入，<xref:System.TypeLoadException>就會擲回即使`throwOnError`是`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2428">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="b1857-2429">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2429">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-2430">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2430">Member Type</span></span>|<span data-ttu-id="b1857-2431">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-2431">Static</span></span>|<span data-ttu-id="b1857-2432">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-2432">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-2433">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-2433">Constructor</span></span>|<span data-ttu-id="b1857-2434">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2434">No</span></span>|<span data-ttu-id="b1857-2435">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2435">No</span></span>|  
|<span data-ttu-id="b1857-2436">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-2436">Field</span></span>|<span data-ttu-id="b1857-2437">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2437">No</span></span>|<span data-ttu-id="b1857-2438">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-2438">Yes.</span></span> <span data-ttu-id="b1857-2439">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2439">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-2440">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-2440">Event</span></span>|<span data-ttu-id="b1857-2441">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-2441">Not applicable</span></span>|<span data-ttu-id="b1857-2442">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2442">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-2443">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2443">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2444">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-2444">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-2445">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-2445">Method</span></span>|<span data-ttu-id="b1857-2446">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2446">No</span></span>|<span data-ttu-id="b1857-2447">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-2447">Yes.</span></span> <span data-ttu-id="b1857-2448">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2448">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-2449">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2449">Nested Type</span></span>|<span data-ttu-id="b1857-2450">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2450">No</span></span>|<span data-ttu-id="b1857-2451">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2451">No</span></span>|  
|<span data-ttu-id="b1857-2452">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2452">Property</span></span>|<span data-ttu-id="b1857-2453">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-2453">Not applicable</span></span>|<span data-ttu-id="b1857-2454">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2454">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-2455">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2455">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2456">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-2456">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-2457">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-2457">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-2458">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-2458">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-2459">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2459">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2460">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-2460">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-2461">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-2461">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-2462">陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。</span><span class="sxs-lookup"><span data-stu-id="b1857-2462">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="b1857-2463">`typeName` 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。</span><span class="sxs-lookup"><span data-stu-id="b1857-2463">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="b1857-2464">請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2464">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="b1857-2465">如果`typeName`包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-2465">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="b1857-2466">如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2466">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="b1857-2467">如果組件具有強式名稱，是完整組件名稱是必要。</span><span class="sxs-lookup"><span data-stu-id="b1857-2467">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="b1857-2468"><xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱，以及泛型引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2468">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="b1857-2469">支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2469">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2470">在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-2470">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="b1857-2471">例如，"ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="b1857-2471">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="b1857-2472">不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2472">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="b1857-2473">您也可以藉由建立載入型別<xref:System.Reflection.AssemblyName>物件並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2473">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="b1857-2474">然後您可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2474">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="b1857-2475">請參閱<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2475">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="b1857-2476">分隔符號</span><span class="sxs-lookup"><span data-stu-id="b1857-2476">Delimiter</span></span>|<span data-ttu-id="b1857-2477">意義</span><span class="sxs-lookup"><span data-stu-id="b1857-2477">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="b1857-2478">反斜線 (\\)</span><span class="sxs-lookup"><span data-stu-id="b1857-2478">Backslash (\\)</span></span>|<span data-ttu-id="b1857-2479">逸出字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2479">Escape character.</span></span>|  
|<span data-ttu-id="b1857-2480">倒單引號 （'）</span><span class="sxs-lookup"><span data-stu-id="b1857-2480">Backtick (\`)</span></span>|<span data-ttu-id="b1857-2481">前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-2481">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="b1857-2482">括號 ([])</span><span class="sxs-lookup"><span data-stu-id="b1857-2482">Brackets ([])</span></span>|<span data-ttu-id="b1857-2483">將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2483">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="b1857-2484">逗號 （，）</span><span class="sxs-lookup"><span data-stu-id="b1857-2484">Comma (,)</span></span>|<span data-ttu-id="b1857-2485">後面接著組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2485">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="b1857-2486">句號 （.）</span><span class="sxs-lookup"><span data-stu-id="b1857-2486">Period (.)</span></span>|<span data-ttu-id="b1857-2487">代表命名空間識別項。</span><span class="sxs-lookup"><span data-stu-id="b1857-2487">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="b1857-2488">加號 （+）</span><span class="sxs-lookup"><span data-stu-id="b1857-2488">Plus sign (+)</span></span>|<span data-ttu-id="b1857-2489">之前的巢狀的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2489">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="b1857-2490">例如，類別的完整限定的名稱可能看起來像這樣：</span><span class="sxs-lookup"><span data-stu-id="b1857-2490">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="b1857-2491">如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (\\) 以防止它被解譯為巢狀的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="b1857-2491">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="b1857-2492">反映會發出這個字串，如下所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-2492">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="b1857-2493">A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。</span><span class="sxs-lookup"><span data-stu-id="b1857-2493">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="b1857-2494">這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2494">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="b1857-2495">搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2495">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="b1857-2496"><xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2496"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="b1857-2497"><xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2497"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="b1857-2498">型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2498">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="b1857-2499">若要擷取的型別名稱不含這些尾端字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2499">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="b1857-2500">空格是相關組件名稱以外的所有型別名稱元件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2500">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="b1857-2501">在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-2501">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="b1857-2502">泛型類型的名稱結尾是反單引號 (\`) 後面接著數字，代表泛型型別引數數目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2502">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="b1857-2503">此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。</span><span class="sxs-lookup"><span data-stu-id="b1857-2503">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="b1857-2504">比方說，反映傳回 mangled 的名稱`Tuple`1` and `Tuple`2`泛型的方法從`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2504">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="b1857-2505">為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2505">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="b1857-2506">例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2506">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="b1857-2507">A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能會表示如下：</span><span class="sxs-lookup"><span data-stu-id="b1857-2507">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="b1857-2508">若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2508">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="b1857-2509">否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2509">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="b1857-2510">例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`MyAssembly.dll，具有索引鍵的類型從<xref:System.String>，可能會以下面方式指定：</span><span class="sxs-lookup"><span data-stu-id="b1857-2510">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2511">組件限定型別可以括在方括號，它必須出現在型別參數清單中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2511">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="b1857-2512">在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2512">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="b1857-2513">可為 null 的類型是泛型類型的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="b1857-2513">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="b1857-2514">例如，可為 null<xref:System.Int32>由 「 System.Nullable'1[System.Int32]"的字串。</span><span class="sxs-lookup"><span data-stu-id="b1857-2514">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2515">您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2515">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="b1857-2516">例如，可為 null<xref:System.Boolean>類型由`typeof(Nullable<bool>)`在 C# 中，由`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2516">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="b1857-2517">下表顯示您使用的語法`GetType`各種類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2517">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="b1857-2518">若要取得</span><span class="sxs-lookup"><span data-stu-id="b1857-2518">To Get</span></span>|<span data-ttu-id="b1857-2519">使用</span><span class="sxs-lookup"><span data-stu-id="b1857-2519">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="b1857-2520">可為 null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="b1857-2520">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="b1857-2521">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2521">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="b1857-2522">若要將 unmanaged 的指標 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2522">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="b1857-2523">將 unmanaged 的指標的指標 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2523">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="b1857-2524">Managed 的指標或參考 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2524">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="b1857-2525">`Type.GetType("MyType&")`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2525">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="b1857-2526">請注意，參考與指標不同，僅限一個層級。</span><span class="sxs-lookup"><span data-stu-id="b1857-2526">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="b1857-2527">父類別和巢狀的類別</span><span class="sxs-lookup"><span data-stu-id="b1857-2527">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="b1857-2528">一維陣列，其下限為 0</span><span class="sxs-lookup"><span data-stu-id="b1857-2528">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="b1857-2529">一維陣列，未知的下限</span><span class="sxs-lookup"><span data-stu-id="b1857-2529">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="b1857-2530">N 維陣列</span><span class="sxs-lookup"><span data-stu-id="b1857-2530">An n-dimensional array</span></span>|<span data-ttu-id="b1857-2531">逗號 （，） 的 n-1 次數總計的括號內。</span><span class="sxs-lookup"><span data-stu-id="b1857-2531">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="b1857-2532">例如，`System.Object[,,]`代表三維`Object`陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-2532">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="b1857-2533">二維陣列的陣列</span><span class="sxs-lookup"><span data-stu-id="b1857-2533">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="b1857-2534">矩形的二維陣列下限未知</span><span class="sxs-lookup"><span data-stu-id="b1857-2534">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="b1857-2535">具有一個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2535">A generic type with one type argument</span></span>|<span data-ttu-id="b1857-2536">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2536">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="b1857-2537">具有兩個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2537">A generic type with two type arguments</span></span>|<span data-ttu-id="b1857-2538">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2538">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="b1857-2539">具有兩個組件限定型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2539">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="b1857-2540">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2540">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="b1857-2541">組件限定泛型型別與組件限定型別引數</span><span class="sxs-lookup"><span data-stu-id="b1857-2541">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="b1857-2542">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2542">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="b1857-2543">泛型型別，其型別引數是兩個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2543">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="b1857-2544">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="b1857-2544">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b1857-2545">下列範例會擷取的型別`System.Int32`並使用該類型的物件顯示<xref:System.Type.FullName%2A>屬性`System.Int32`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2545">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="b1857-2546">如果型別物件參考不存在的組件，這個範例會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-2546">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2547">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2547">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-2548">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2548">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-2549">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2549">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="b1857-2550">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2550">-or-</span>
          </span>
          <span data-ttu-id="b1857-2551">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2551">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="b1857-2552">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2552">-or-</span>
          </span>
          <span data-ttu-id="b1857-2553">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2553">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b1857-2554">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2554">-or-</span>
          </span>
          <span data-ttu-id="b1857-2555">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2555">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="b1857-2556">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2556">-or-</span>
          </span>
          <span data-ttu-id="b1857-2557">
            <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2557">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2558">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效的語法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2558">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="b1857-2559">例如，"MyType[,\*,]"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2559">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="b1857-2560">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2560">-or-</span>
          </span>
          <span data-ttu-id="b1857-2561">
            <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2561">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2562">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2562">-or-</span>
          </span>
          <span data-ttu-id="b1857-2563">
            <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2563">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2564">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2564">-or-</span>
          </span>
          <span data-ttu-id="b1857-2565">
            <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2565">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b1857-2566">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2566">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="b1857-2567">在[適用於 Windows 市集應用程式的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或是[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。</span>
              <span class="sxs-lookup">
                <span data-stu-id="b1857-2567">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="b1857-2568">找到組件或其相依性的其中一個，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2568">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="b1857-2569">組件或組件的其中一個相依性無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2569">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="b1857-2570">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2570">-or-</span>
          </span>
          <span data-ttu-id="b1857-2571">目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2571">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="b1857-2572">要取得之類型的組件限定名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2572">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="b1857-2573">請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2573">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="b1857-2574">如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2574">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="b1857-2575">
            <see langword="true" /> 表示找不到該型別時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。指定 <see langword="false" /> 還會隱藏一些其他例外情況，但不是全部。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2575">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="b1857-2576">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2576">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="b1857-2577">
            <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2577">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2578">取得具有指定名稱的 <see cref="T:System.Type" />，指定找不到類型時是否要擲回例外狀況，以及是否要執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2578">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2579">具有指定名稱的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2579">The type with the specified name.</span>
          </span>
          <span data-ttu-id="b1857-2580">如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2580">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="b1857-2581">在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2581">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="b1857-2582">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2582">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2583">您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2583">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name.</span></span> <span data-ttu-id="b1857-2584"><xref:System.Type.GetType%2A> 引起指定的組件載入`typeName`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2584"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="b1857-2585">您也可以載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法，這個方法，然後使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>方法來取得<xref:System.Type>物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2585">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="b1857-2586">如果類型是在編譯時期已知程式組件中，會更有效率使用`typeof`在 C# 中，<xref:System.Type.GetType%2A>在 Visual Basic 中，或`typeid`c + + 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2586">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="b1857-2587">`GetType` 只適用於從磁碟載入的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2587">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="b1857-2588">如果您呼叫`GetType`查閱來定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會發生不一致的行為。</span><span class="sxs-lookup"><span data-stu-id="b1857-2588">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="b1857-2589">行為取決於動態組件是持續性，也就是，建立使用`RunAndSave`或`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2589">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="b1857-2590">如果在動態組件會持續，並寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2590">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="b1857-2591">如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2591">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="b1857-2592">`GetType` 不了解暫時性動態組件。因此，呼叫`GetType`擷取型別中的暫時性動態組件傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2592">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="b1857-2593">若要使用`GetType`上動態模組中，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件和呼叫`GetType`之後再儲存。</span><span class="sxs-lookup"><span data-stu-id="b1857-2593">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="b1857-2594">否則，您會得到兩個組件的複本在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2594">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="b1857-2595">`throwOnError`參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 > 一節中所述。</span><span class="sxs-lookup"><span data-stu-id="b1857-2595">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="b1857-2596">某些例外狀況的值為何`throwOnError`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2596">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="b1857-2597">例如，如果找到的類型，但無法載入，<xref:System.TypeLoadException>就會擲回即使`throwOnError`是`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2597">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="b1857-2598">下表顯示基底類別成員會傳回由`Get`反映型別上的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2598">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="b1857-2599">成員類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2599">Member Type</span></span>|<span data-ttu-id="b1857-2600">Static</span><span class="sxs-lookup"><span data-stu-id="b1857-2600">Static</span></span>|<span data-ttu-id="b1857-2601">非靜態</span><span class="sxs-lookup"><span data-stu-id="b1857-2601">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="b1857-2602">建構函式</span><span class="sxs-lookup"><span data-stu-id="b1857-2602">Constructor</span></span>|<span data-ttu-id="b1857-2603">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2603">No</span></span>|<span data-ttu-id="b1857-2604">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2604">No</span></span>|  
|<span data-ttu-id="b1857-2605">欄位</span><span class="sxs-lookup"><span data-stu-id="b1857-2605">Field</span></span>|<span data-ttu-id="b1857-2606">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2606">No</span></span>|<span data-ttu-id="b1857-2607">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-2607">Yes.</span></span> <span data-ttu-id="b1857-2608">欄位一律是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2608">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-2609">Event - 事件</span><span class="sxs-lookup"><span data-stu-id="b1857-2609">Event</span></span>|<span data-ttu-id="b1857-2610">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-2610">Not applicable</span></span>|<span data-ttu-id="b1857-2611">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2611">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-2612">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2612">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2613">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-2613">See note 2 below.</span></span>|  
|<span data-ttu-id="b1857-2614">方法</span><span class="sxs-lookup"><span data-stu-id="b1857-2614">Method</span></span>|<span data-ttu-id="b1857-2615">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2615">No</span></span>|<span data-ttu-id="b1857-2616">可以。</span><span class="sxs-lookup"><span data-stu-id="b1857-2616">Yes.</span></span> <span data-ttu-id="b1857-2617">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2617">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="b1857-2618">巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2618">Nested Type</span></span>|<span data-ttu-id="b1857-2619">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2619">No</span></span>|<span data-ttu-id="b1857-2620">否</span><span class="sxs-lookup"><span data-stu-id="b1857-2620">No</span></span>|  
|<span data-ttu-id="b1857-2621">屬性</span><span class="sxs-lookup"><span data-stu-id="b1857-2621">Property</span></span>|<span data-ttu-id="b1857-2622">不適用</span><span class="sxs-lookup"><span data-stu-id="b1857-2622">Not applicable</span></span>|<span data-ttu-id="b1857-2623">一般類型系統規則會是繼承實作屬性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2623">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="b1857-2624">反映會將屬性視為依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2624">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2625">請參閱附註 2 下方。</span><span class="sxs-lookup"><span data-stu-id="b1857-2625">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="b1857-2626">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="b1857-2626">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="b1857-2627">這是二進位比較。</span><span class="sxs-lookup"><span data-stu-id="b1857-2627">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="b1857-2628">進行反映，屬性和事件是依名稱和簽章隱藏。</span><span class="sxs-lookup"><span data-stu-id="b1857-2628">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="b1857-2629">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</span><span class="sxs-lookup"><span data-stu-id="b1857-2629">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="b1857-2630">自訂屬性不是一般類型系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-2630">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="b1857-2631">陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。</span><span class="sxs-lookup"><span data-stu-id="b1857-2631">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="b1857-2632">`typeName` 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。</span><span class="sxs-lookup"><span data-stu-id="b1857-2632">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="b1857-2633">請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2633">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="b1857-2634">如果`typeName`包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-2634">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="b1857-2635">如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2635">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="b1857-2636">如果組件具有強式名稱，是完整組件名稱是必要。</span><span class="sxs-lookup"><span data-stu-id="b1857-2636">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="b1857-2637"><xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱和型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2637">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="b1857-2638">支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2638">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2639">在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-2639">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="b1857-2640">例如，"ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="b1857-2640">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="b1857-2641">不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2641">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="b1857-2642">您也可以藉由建立載入型別<xref:System.Reflection.AssemblyName>物件並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2642">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="b1857-2643">然後您可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2643">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="b1857-2644">請參閱<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2644">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="b1857-2645">分隔符號</span><span class="sxs-lookup"><span data-stu-id="b1857-2645">Delimiter</span></span>|<span data-ttu-id="b1857-2646">意義</span><span class="sxs-lookup"><span data-stu-id="b1857-2646">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="b1857-2647">反斜線 (\\)</span><span class="sxs-lookup"><span data-stu-id="b1857-2647">Backslash (\\)</span></span>|<span data-ttu-id="b1857-2648">逸出字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2648">Escape character.</span></span>|  
|<span data-ttu-id="b1857-2649">倒單引號 （'）</span><span class="sxs-lookup"><span data-stu-id="b1857-2649">Backtick (\`)</span></span>|<span data-ttu-id="b1857-2650">前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-2650">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="b1857-2651">括號 ([])</span><span class="sxs-lookup"><span data-stu-id="b1857-2651">Brackets ([])</span></span>|<span data-ttu-id="b1857-2652">將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2652">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="b1857-2653">逗號 （，）</span><span class="sxs-lookup"><span data-stu-id="b1857-2653">Comma (,)</span></span>|<span data-ttu-id="b1857-2654">後面接著組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2654">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="b1857-2655">句號 （.）</span><span class="sxs-lookup"><span data-stu-id="b1857-2655">Period (.)</span></span>|<span data-ttu-id="b1857-2656">代表命名空間識別項。</span><span class="sxs-lookup"><span data-stu-id="b1857-2656">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="b1857-2657">加號 （+）</span><span class="sxs-lookup"><span data-stu-id="b1857-2657">Plus sign (+)</span></span>|<span data-ttu-id="b1857-2658">之前的巢狀的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2658">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="b1857-2659">例如，類別的完整限定的名稱可能看起來像這樣：</span><span class="sxs-lookup"><span data-stu-id="b1857-2659">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="b1857-2660">如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (\\) 以防止它被解譯為巢狀的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="b1857-2660">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="b1857-2661">反映會發出這個字串，如下所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-2661">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="b1857-2662">A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。</span><span class="sxs-lookup"><span data-stu-id="b1857-2662">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="b1857-2663">這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2663">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="b1857-2664">搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2664">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="b1857-2665"><xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2665"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="b1857-2666"><xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2666"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="b1857-2667">型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2667">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="b1857-2668">若要擷取的型別名稱不含這些尾端字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2668">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="b1857-2669">空格是相關組件名稱以外的所有型別名稱元件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2669">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="b1857-2670">在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-2670">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="b1857-2671">泛型類型的名稱結尾是反單引號 (\`) 後面接著數字，代表泛型型別引數數目。</span><span class="sxs-lookup"><span data-stu-id="b1857-2671">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="b1857-2672">此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。</span><span class="sxs-lookup"><span data-stu-id="b1857-2672">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="b1857-2673">比方說，反映傳回 mangled 的名稱`Tuple`1` and `Tuple`2`泛型的方法從`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2673">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="b1857-2674">為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2674">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="b1857-2675">例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2675">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="b1857-2676">A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能會表示如下：</span><span class="sxs-lookup"><span data-stu-id="b1857-2676">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="b1857-2677">若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2677">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="b1857-2678">否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2678">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="b1857-2679">例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`MyAssembly.dll，具有索引鍵的類型從<xref:System.String>，可能會以下面方式指定：</span><span class="sxs-lookup"><span data-stu-id="b1857-2679">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2680">組件限定型別可以括在方括號，它必須出現在型別參數清單中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2680">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="b1857-2681">在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-2681">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="b1857-2682">可為 null 的類型是泛型類型的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="b1857-2682">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="b1857-2683">例如，可為 null<xref:System.Int32>由 「 System.Nullable'1[System.Int32]"的字串。</span><span class="sxs-lookup"><span data-stu-id="b1857-2683">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2684">您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2684">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="b1857-2685">例如，可為 null<xref:System.Boolean>類型由`typeof(Nullable<bool>)`在 C# 中，由`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2685">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="b1857-2686">下表顯示您使用的語法`GetType`各種類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2686">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="b1857-2687">若要取得</span><span class="sxs-lookup"><span data-stu-id="b1857-2687">To Get</span></span>|<span data-ttu-id="b1857-2688">使用</span><span class="sxs-lookup"><span data-stu-id="b1857-2688">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="b1857-2689">可為 null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="b1857-2689">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="b1857-2690">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2690">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="b1857-2691">若要將 unmanaged 的指標 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2691">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="b1857-2692">將 unmanaged 的指標的指標 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2692">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="b1857-2693">Managed 的指標或參考 `MyType`</span><span class="sxs-lookup"><span data-stu-id="b1857-2693">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="b1857-2694">`Type.GetType("MyType&")`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2694">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="b1857-2695">請注意，參考與指標不同，僅限一個層級。</span><span class="sxs-lookup"><span data-stu-id="b1857-2695">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="b1857-2696">父類別和巢狀的類別</span><span class="sxs-lookup"><span data-stu-id="b1857-2696">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="b1857-2697">一維陣列，其下限為 0</span><span class="sxs-lookup"><span data-stu-id="b1857-2697">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="b1857-2698">一維陣列，未知的下限</span><span class="sxs-lookup"><span data-stu-id="b1857-2698">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="b1857-2699">N 維陣列</span><span class="sxs-lookup"><span data-stu-id="b1857-2699">An n-dimensional array</span></span>|<span data-ttu-id="b1857-2700">逗號 （，） 的 n-1 次數總計的括號內。</span><span class="sxs-lookup"><span data-stu-id="b1857-2700">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="b1857-2701">例如，`System.Object[,,]`代表三維`Object`陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-2701">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="b1857-2702">二維陣列的陣列</span><span class="sxs-lookup"><span data-stu-id="b1857-2702">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="b1857-2703">矩形的二維陣列下限未知</span><span class="sxs-lookup"><span data-stu-id="b1857-2703">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="b1857-2704">具有一個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2704">A generic type with one type argument</span></span>|<span data-ttu-id="b1857-2705">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2705">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="b1857-2706">具有兩個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2706">A generic type with two type arguments</span></span>|<span data-ttu-id="b1857-2707">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2707">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="b1857-2708">具有兩個組件限定型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2708">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="b1857-2709">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2709">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="b1857-2710">組件限定泛型型別與組件限定型別引數</span><span class="sxs-lookup"><span data-stu-id="b1857-2710">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="b1857-2711">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="b1857-2711">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="b1857-2712">泛型型別，其型別引數是兩個型別引數的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2712">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="b1857-2713">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="b1857-2713">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2714">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2714">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-2715">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2715">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-2716">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2716">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="b1857-2717">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2717">-or-</span>
          </span>
          <span data-ttu-id="b1857-2718">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2718">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="b1857-2719">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2719">-or-</span>
          </span>
          <span data-ttu-id="b1857-2720">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2720">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b1857-2721">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2721">-or-</span>
          </span>
          <span data-ttu-id="b1857-2722">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2722">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="b1857-2723">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2723">-or-</span>
          </span>
          <span data-ttu-id="b1857-2724">
            <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2724">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2725">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效的語法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2725">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="b1857-2726">例如，"MyType[,\*,]"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2726">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="b1857-2727">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2727">-or-</span>
          </span>
          <span data-ttu-id="b1857-2728">
            <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2728">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2729">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2729">-or-</span>
          </span>
          <span data-ttu-id="b1857-2730">
            <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2730">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2731">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2731">-or-</span>
          </span>
          <span data-ttu-id="b1857-2732">
            <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2732">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b1857-2733">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2733">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="b1857-2734">找到組件或其相依性的其中一個，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2734">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="b1857-2735">組件或組件的其中一個相依性無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2735">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="b1857-2736">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2736">-or-</span>
          </span>
          <span data-ttu-id="b1857-2737">目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2737">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="b1857-2738">要取得之類型的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2738">The name of the type to get.</span>
          </span>
          <span data-ttu-id="b1857-2739">如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2739">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="b1857-2740">如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2740">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="b1857-2741">方法，會找出並傳回 <c>typeName</c> 中指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2741">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="b1857-2742">組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2742">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="b1857-2743">如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2743">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="b1857-2744">如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2744">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="b1857-2745">注意：不要從未知或未受信任的呼叫端傳遞方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2745">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="b1857-2746">這樣做可能會提高惡意程式碼的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2746">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="b1857-2747">只使用您所提供或熟悉的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2747">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="b1857-2748">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2748">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="b1857-2749">如果未提供任何組件，<c>typeResolver</c> 方法會提供一個組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2749">If no assembly is provided, the <c>typeResolver</c> method can provide one.</span>
          </span>
          <span data-ttu-id="b1857-2750">這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <see langword="false" /> 至該參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2750">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="b1857-2751">注意：不要從未知或未受信任的呼叫端傳遞方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2751">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2752">取得具有指定名稱的類型，並選擇性提供自訂方法來解析組件和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2752">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2753">具有指定名稱的類型；如果找不到類型，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2753">The type with the specified name, or <see langword="null" /> if the type is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2754">這個方法，以及詳細資料的使用方式案例`assemblyResolver`和`typeResolver`參數位於<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-2754">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2755">如果`typeName`找不到，呼叫<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2755">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="b1857-2756">它不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-2756">It does not throw an exception.</span></span> <span data-ttu-id="b1857-2757">若要控制是否擲回例外狀況，請呼叫的多載<xref:System.Type.GetType%2A>方法`throwOnError`參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2757">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="b1857-2758">呼叫這個方法多載會呼叫相同<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，並指定`false`如`throwOnError`和`ignoreCase`參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2758">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2759">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2759">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-2760">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2760">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2761">將 <paramref name="typeName" /> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2761">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="b1857-2762">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2762">-or-</span>
          </span>
          <span data-ttu-id="b1857-2763">
            <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2763">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2764">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2764">-or-</span>
          </span>
          <span data-ttu-id="b1857-2765">
            <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2765">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2766">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2766">-or-</span>
          </span>
          <span data-ttu-id="b1857-2767">
            <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2767">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-2768">
            <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2768">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="b1857-2769">找到組件或組件的其中一個相依性，但無法加以載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2769">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="b1857-2770">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2770">-or-</span>
          </span>
          <span data-ttu-id="b1857-2771">
            <paramref name="typeName" /> 包含無效的組件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2771">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="b1857-2772">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2772">-or-</span>
          </span>
          <span data-ttu-id="b1857-2773">
            <paramref name="typeName" /> 是有效的組件名稱，沒有型別名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2773">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="b1857-2774">組件或組件的其中一個相依性無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2774">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="b1857-2775">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2775">-or-</span>
          </span>
          <span data-ttu-id="b1857-2776">用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2776">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="b1857-2777">要取得之類型的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2777">The name of the type to get.</span>
          </span>
          <span data-ttu-id="b1857-2778">如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2778">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="b1857-2779">如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2779">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="b1857-2780">方法，會找出並傳回 <c>typeName</c> 中指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2780">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="b1857-2781">組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2781">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="b1857-2782">如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2782">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="b1857-2783">如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2783">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="b1857-2784">注意：不要從未知或未受信任的呼叫端傳遞方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2784">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="b1857-2785">這樣做可能會提高惡意程式碼的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2785">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="b1857-2786">只使用您所提供或熟悉的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2786">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="b1857-2787">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2787">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="b1857-2788">如果未提供任何組件，方法會提供一個組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2788">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="b1857-2789">這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <see langword="false" /> 至該參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2789">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="b1857-2790">注意：不要從未知或未受信任的呼叫端傳遞方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2790">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="b1857-2791">
            <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2791">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2792">指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2792">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="b1857-2793">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2793">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2794">取得具有指定名稱的類型，指定找不到類型時是否擲回例外狀況，同時選擇性提供自訂方法來解析組件和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2794">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2795">具有指定名稱的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2795">The type with the specified name.</span>
          </span>
          <span data-ttu-id="b1857-2796">如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2796">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="b1857-2797">在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2797">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="b1857-2798">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2798">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2799">這個方法，以及詳細資料的使用方式案例`assemblyResolver`和`typeResolver`參數位於<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-2799">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="b1857-2800">呼叫這個方法多載會呼叫相同<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，並指定`false`如`ignoreCase`參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2800">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2801">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2801">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-2802">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2802">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-2803">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2803">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="b1857-2804">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2804">-or-</span>
          </span>
          <span data-ttu-id="b1857-2805">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2805">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="b1857-2806">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2806">-or-</span>
          </span>
          <span data-ttu-id="b1857-2807">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2807">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b1857-2808">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2808">-or-</span>
          </span>
          <span data-ttu-id="b1857-2809">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2809">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="b1857-2810">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2810">-or-</span>
          </span>
          <span data-ttu-id="b1857-2811">
            <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2811">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-2812">將 <paramref name="typeName" /> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2812">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="b1857-2813">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2813">-or-</span>
          </span>
          <span data-ttu-id="b1857-2814">
            <paramref name="throwOnError" /> 為 <see langword="true" />，且 <paramref name="typeName" /> 包含無效的語法 (例如 "MyType[,\*,]")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2814">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="b1857-2815">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2815">-or-</span>
          </span>
          <span data-ttu-id="b1857-2816">
            <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2816">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2817">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2817">-or-</span>
          </span>
          <span data-ttu-id="b1857-2818">
            <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2818">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="b1857-2819">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2819">-or-</span>
          </span>
          <span data-ttu-id="b1857-2820">
            <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2820">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b1857-2821">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2821">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
          <span data-ttu-id="b1857-2822">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2822">-or-</span>
          </span>
          <span data-ttu-id="b1857-2823">
            <paramref name="typeName" /> 包含無效的組件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2823">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="b1857-2824">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2824">-or-</span>
          </span>
          <span data-ttu-id="b1857-2825">
            <paramref name="typeName" /> 是有效的組件名稱，沒有型別名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2825">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="b1857-2826">找到組件或其相依性的其中一個，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2826">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="b1857-2827">組件或組件的其中一個相依性無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2827">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="b1857-2828">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2828">-or-</span>
          </span>
          <span data-ttu-id="b1857-2829">用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2829">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="b1857-2830">要取得之類型的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2830">The name of the type to get.</span>
          </span>
          <span data-ttu-id="b1857-2831">如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2831">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="b1857-2832">如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2832">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="b1857-2833">方法，會找出並傳回 <c>typeName</c> 中指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2833">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="b1857-2834">組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2834">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="b1857-2835">如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2835">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="b1857-2836">如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2836">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="b1857-2837">注意：不要從未知或未受信任的呼叫端傳遞方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2837">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="b1857-2838">這樣做可能會提高惡意程式碼的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2838">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="b1857-2839">只使用您所提供或熟悉的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2839">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="b1857-2840">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2840">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="b1857-2841">如果未提供任何組件，方法會提供一個組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2841">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="b1857-2842">這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <c>ignoreCase</c> 的值至該參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2842">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <c>ignoreCase</c> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="b1857-2843">注意：不要從未知或未受信任的呼叫端傳遞方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2843">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="b1857-2844">
            <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2844">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-2845">指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2845">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="b1857-2846">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2846">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="b1857-2847">
            <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2847">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-2848">取得具有指定名稱的類型，指定是否執行區分大小寫的搜尋以及找不到類型時是否擲回例外狀況，同時選擇性提供自訂方法來解析組件和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2848">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-2849">具有指定名稱的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2849">The type with the specified name.</span>
          </span>
          <span data-ttu-id="b1857-2850">如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2850">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="b1857-2851">在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2851">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="b1857-2852">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2852">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-2853">使用這個方法多載，以及其相關聯的多載 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>和<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) 來取代的預設實作<xref:System.Type.GetType%2A>與更有彈性的實作方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2853">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="b1857-2854">您可以藉由提供您自己解析型別名稱和包含它們的組件名稱的方法，執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="b1857-2854">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="b1857-2855">控制項類型從載入的組件的版本。</span><span class="sxs-lookup"><span data-stu-id="b1857-2855">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="b1857-2856">提供查閱不包含組件名稱的型別名稱的另一個位置。</span><span class="sxs-lookup"><span data-stu-id="b1857-2856">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="b1857-2857">載入組件使用部分的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2857">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="b1857-2858">傳回的子類別<xref:System.Type?displayProperty=nameWithType>，不由 common language runtime (CLR) 建立。</span><span class="sxs-lookup"><span data-stu-id="b1857-2858">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="b1857-2859">比方說，在版本相容序列化這個方法可讓您使用的部分名稱來搜尋"best fit"的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2859">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="b1857-2860">其他多載<xref:System.Type.GetType%2A>方法需要組件限定類型名稱，其中包含的版本號碼。</span><span class="sxs-lookup"><span data-stu-id="b1857-2860">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="b1857-2861">型別系統的替代實作可能要傳回的子類別<xref:System.Type?displayProperty=nameWithType>，不會建立由 CLR; 所有類型的其他多載會傳回<xref:System.Type.GetType%2A>方法屬於執行階段類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2861">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="b1857-2862">使用注意事項</span><span class="sxs-lookup"><span data-stu-id="b1857-2862">Usage Notes</span></span>  
 <span data-ttu-id="b1857-2863">這個方法多載，以及其相關聯的多載剖析`typeName`成的型別和組件名稱的名稱，再解析名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2863">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="b1857-2864">組件名稱的解析就會發生型別名稱，解析之前，因為型別名稱必須解析組件的內容中。</span><span class="sxs-lookup"><span data-stu-id="b1857-2864">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2865">如果您不熟悉的組件限定類型名稱的概念，請參閱<xref:System.Type.AssemblyQualifiedName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-2865">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="b1857-2866">如果`typeName`不是組件限定名稱，則會略過組件解析。</span><span class="sxs-lookup"><span data-stu-id="b1857-2866">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="b1857-2867">可以 Mscorlib.dll 或目前正在執行的組件的內容中解析不合格的型別名稱，或您可以選擇性地提供中的組件`typeResolver`參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2867">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="b1857-2868">要包含或省略不同種類的名稱解析會顯示為資料表中的組件名稱的效果[混合的名稱解析](#mixed_name_resolution)> 一節。</span><span class="sxs-lookup"><span data-stu-id="b1857-2868">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="b1857-2869">一般使用方式附註：</span><span class="sxs-lookup"><span data-stu-id="b1857-2869">General usage notes:</span></span>  
  
-   <span data-ttu-id="b1857-2870">不要傳遞至方法`assemblyResolver`或`typeResolver`他們是來自未知或不受信任的呼叫端。</span><span class="sxs-lookup"><span data-stu-id="b1857-2870">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="b1857-2871">只使用您所提供或熟悉的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2871">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="b1857-2872">使用來自未知或未受信任的呼叫者方法可能會導致提高權限的惡意程式碼。</span><span class="sxs-lookup"><span data-stu-id="b1857-2872">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="b1857-2873">如果您省略`assemblyResolver`及/或`typeResolver`參數、 值`throwOnError`參數傳遞至此執行預設解析的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2873">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="b1857-2874">如果`throwOnError`是`true`，這個方法會擲回<xref:System.TypeLoadException>時`typeResolver`傳回`null`，和<xref:System.IO.FileNotFoundException>時`assemblyResolver`傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2874">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="b1857-2875">這個方法不會攔截擲回例外狀況`assemblyResolver`和`typeResolver`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2875">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="b1857-2876">您必須負責解析程式方法所擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-2876">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="b1857-2877">解析組件</span><span class="sxs-lookup"><span data-stu-id="b1857-2877">Resolving Assemblies</span></span>  
 <span data-ttu-id="b1857-2878">`assemblyResolver`方法會接收<xref:System.Reflection.AssemblyName>物件，它會藉由剖析字串組件名稱包含在產生`typeName`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2878">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="b1857-2879">如果`typeName`不包含組件名稱，`assemblyResolver`則不會呼叫和`null`傳遞至`typeResolver`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2879">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="b1857-2880">如果`assemblyResolver`不提供標準的組件探查用來找出組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2880">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="b1857-2881">如果`assemblyResolver`提供，則<xref:System.Type.GetType%2A>方法不會進行一般探查; 在此情況下您必須確定您`assemblyResolver`可以處理傳遞給它的所有組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2881">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="b1857-2882">`assemblyResolver`方法應傳回`null`如果無法解析的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2882">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="b1857-2883">如果`assemblyResolver`傳回`null`，`typeResolver`則不會呼叫並不進行任何處理就會發生; 此外，如果`throwOnError`是`true`、<xref:System.IO.FileNotFoundException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="b1857-2883">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="b1857-2884">如果<xref:System.Reflection.AssemblyName>傳遞至`assemblyResolver`是部分名稱、 一或多個其各部分的`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2884">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="b1857-2885">例如，如果不有任何版本，<xref:System.Reflection.AssemblyName.Version%2A>屬性是`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2885">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="b1857-2886">如果<xref:System.Reflection.AssemblyName.Version%2A>屬性，<xref:System.Reflection.AssemblyName.CultureInfo%2A>屬性，而<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>方法都會傳回`null`，然後提供組件的簡單名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2886">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="b1857-2887">`assemblyResolver`方法可以使用或忽略所有組件的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2887">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="b1857-2888">不同的組件解析選項的效果會顯示為資料表中[混合的名稱解析](#mixed_name_resolution)區段中的，簡單且組件限定類型名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2888">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="b1857-2889">解析型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2889">Resolving Types</span></span>  
 <span data-ttu-id="b1857-2890">如果`typeName`未指定組件名稱，`typeResolver`一律會呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1857-2890">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="b1857-2891">如果`typeName`指定組件名稱，`typeResolver`只有順利解析組件名稱時，才會呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1857-2891">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="b1857-2892">如果`assemblyResolver`或標準的組件探查傳回`null`，`typeResolver`則不會呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1857-2892">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="b1857-2893">`typeResolver`方法會接收三個引數：</span><span class="sxs-lookup"><span data-stu-id="b1857-2893">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="b1857-2894">要搜尋的組件或`null`如果`typeName`不包含組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2894">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="b1857-2895">簡單類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2895">The simple name of the type.</span></span> <span data-ttu-id="b1857-2896">當巢狀型別，這是最外層包含型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2896">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="b1857-2897">當泛型型別，這是泛型類型的簡單名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2897">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="b1857-2898">布林值，是`true`如果型別名稱的情況下會被忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-2898">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="b1857-2899">實作可決定使用這些引數的方式。</span><span class="sxs-lookup"><span data-stu-id="b1857-2899">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="b1857-2900">`typeResolver`方法應傳回`null`若無法解析型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2900">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="b1857-2901">如果`typeResolver`傳回`null`和`throwOnError`是`true`的這個多載<xref:System.Type.GetType%2A>會擲回<xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2901">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="b1857-2902">不同的型別解析選項的效果會顯示為資料表中[混合的名稱解析](#mixed_name_resolution)區段中的，簡單且組件限定類型名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2902">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="b1857-2903">解析巢狀的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2903">Resolving Nested Types</span></span>  
 <span data-ttu-id="b1857-2904">如果`typeName`是巢狀型別名稱的最外層包含型別傳遞至`typeResolver`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2904">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="b1857-2905">當`typeResolver`傳回此型別，<xref:System.Type.GetNestedType%2A>之前已解決的最內層的巢狀的類型，方法稱為遞迴運作。</span><span class="sxs-lookup"><span data-stu-id="b1857-2905">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="b1857-2906">正在解析的泛型型別</span><span class="sxs-lookup"><span data-stu-id="b1857-2906">Resolving Generic Types</span></span>  
 <span data-ttu-id="b1857-2907"><xref:System.Type.GetType%2A>稱為遞迴解析泛型型別： 首先要解決泛型類型本身，然後解決它的型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2907">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="b1857-2908">如果型別引數是泛型，<xref:System.Type.GetType%2A>稱為遞迴解析其型別引數，等等。</span><span class="sxs-lookup"><span data-stu-id="b1857-2908">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="b1857-2909">組合`assemblyResolver`和`typeResolver`您提供必須能夠解決這類遞迴的所有層級。</span><span class="sxs-lookup"><span data-stu-id="b1857-2909">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="b1857-2910">例如，假設您提供`assemblyResolver`所控制的載入`MyAssembly`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2910">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="b1857-2911">假設您想要解決的泛型型別`Dictionary<string, MyType>`(`Dictionary(Of String, MyType)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-2911">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="b1857-2912">您可能會傳遞下列泛型類型名稱：</span><span class="sxs-lookup"><span data-stu-id="b1857-2912">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="b1857-2913">請注意，`MyType`是只有組件限定型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-2913">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="b1857-2914">名稱<xref:System.Collections.Generic.Dictionary%602>和<xref:System.String>類別不是組件限定。</span><span class="sxs-lookup"><span data-stu-id="b1857-2914">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="b1857-2915">您`typeResolver`必須能夠處理其中任一組件或`null`，因為它會接收`null`如<xref:System.Collections.Generic.Dictionary%602>和<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="b1857-2915">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="b1857-2916">它可以處理此情況下所呼叫的多載<xref:System.Type.GetType%2A>取用一個字串，因為這兩個不合格的類型名稱都 Mscorlib.dll 中的方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-2916">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="b1857-2917">`assemblyResolver`不會呼叫方法的字典類型和字串類型，因為這些型別名稱不是組件限定。</span><span class="sxs-lookup"><span data-stu-id="b1857-2917">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="b1857-2918">現在假設，而不是`System.String`，第一個泛型引數類型是`YourType`，從`YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="b1857-2918">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="b1857-2919">這個組件是目前執行的組件都 Mscorlib.dll，因為無法解析`YourType`沒有組件限定名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2919">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="b1857-2920">因為您`assemblyResolve`會遞迴呼叫，它必須能夠處理這種情況。</span><span class="sxs-lookup"><span data-stu-id="b1857-2920">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="b1857-2921">而不是傳回`null`以外的組件`MyAssembly`，它現在會執行使用提供的組件載入<xref:System.Reflection.AssemblyName>物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2921">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="b1857-2922">回到[使用注意事項](#usage_notes)。</span><span class="sxs-lookup"><span data-stu-id="b1857-2922">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="b1857-2923">正在解析的型別名稱，含有特殊字元</span><span class="sxs-lookup"><span data-stu-id="b1857-2923">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="b1857-2924">某些字元有特殊意義，在組件限定名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2924">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="b1857-2925">如果是簡單類型名稱包含這些字元，字元的簡單名稱是組件限定名稱的一部分時，就會造成剖析錯誤。</span><span class="sxs-lookup"><span data-stu-id="b1857-2925">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="b1857-2926">若要避免剖析錯誤，您必須逸出特殊字元以反斜線之前您可以將傳遞的組件限定名稱<xref:System.Type.GetType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2926">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="b1857-2927">例如，如果型別為`Strange]Type`，逸出字元必須加入晚於方括號，如下所示： `Strange\]Type`。</span><span class="sxs-lookup"><span data-stu-id="b1857-2927">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-2928">無法在 Visual Basic 或 C# 中，建立具有這類特殊字元的名稱，但可由使用 Microsoft intermediate language (MSIL)，或發出動態組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2928">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="b1857-2929">下表顯示類型名稱的特殊字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2929">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="b1857-2930">字元</span><span class="sxs-lookup"><span data-stu-id="b1857-2930">Character</span></span>|<span data-ttu-id="b1857-2931">意義</span><span class="sxs-lookup"><span data-stu-id="b1857-2931">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="b1857-2932">`,` （逗號）</span><span class="sxs-lookup"><span data-stu-id="b1857-2932">`,` (comma)</span></span>|<span data-ttu-id="b1857-2933">分隔符號組件限定名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2933">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="b1857-2934">`[]` （方括號）</span><span class="sxs-lookup"><span data-stu-id="b1857-2934">`[]` (square brackets)</span></span>|<span data-ttu-id="b1857-2935">做成對的後置詞，指出陣列型別。分隔符號組中，為封入泛型引數清單和組件限定名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2935">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="b1857-2936">`&` （連字號）</span><span class="sxs-lookup"><span data-stu-id="b1857-2936">`&` (ampersand)</span></span>|<span data-ttu-id="b1857-2937">做為尾碼，表示型別是參考型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-2937">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="b1857-2938">`*` （星號）</span><span class="sxs-lookup"><span data-stu-id="b1857-2938">`*` (asterisk)</span></span>|<span data-ttu-id="b1857-2939">做為尾碼，表示型別是指標類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2939">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="b1857-2940">`+` （加號）</span><span class="sxs-lookup"><span data-stu-id="b1857-2940">`+` (plus)</span></span>|<span data-ttu-id="b1857-2941">巢狀類型的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="b1857-2941">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="b1857-2942">`\` （反斜線）</span><span class="sxs-lookup"><span data-stu-id="b1857-2942">`\` (backslash)</span></span>|<span data-ttu-id="b1857-2943">逸出字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2943">Escape character.</span></span>|  
  
 <span data-ttu-id="b1857-2944">屬性，例如<xref:System.Type.AssemblyQualifiedName%2A>傳回正確逸出字串。</span><span class="sxs-lookup"><span data-stu-id="b1857-2944">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="b1857-2945">您必須傳遞正確逸出的字串<xref:System.Type.GetType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2945">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="b1857-2946">接著，<xref:System.Type.GetType%2A>方法會傳遞至的正確逸出的名稱`typeResolver`以及預設的型別解析方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-2946">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="b1857-2947">如果您要比較的名稱中的未逸出名稱`typeResolver`，您必須移除逸出字元。</span><span class="sxs-lookup"><span data-stu-id="b1857-2947">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="b1857-2948">回到[使用注意事項](#usage_notes)。</span><span class="sxs-lookup"><span data-stu-id="b1857-2948">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="b1857-2949">混合的名稱解析</span><span class="sxs-lookup"><span data-stu-id="b1857-2949">Mixed Name Resolution</span></span>  
 <span data-ttu-id="b1857-2950">下表摘要說明之間的互動`assemblyResolver`， `typeResolver`，和型別名稱和組件名稱中的所有組合的預設名稱解析`typeName`:</span><span class="sxs-lookup"><span data-stu-id="b1857-2950">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="b1857-2951">型別名稱的內容</span><span class="sxs-lookup"><span data-stu-id="b1857-2951">Contents of type name</span></span>|<span data-ttu-id="b1857-2952">組件解析程式方法</span><span class="sxs-lookup"><span data-stu-id="b1857-2952">Assembly resolver method</span></span>|<span data-ttu-id="b1857-2953">型別解析程式方法</span><span class="sxs-lookup"><span data-stu-id="b1857-2953">Type resolver method</span></span>|<span data-ttu-id="b1857-2954">結果</span><span class="sxs-lookup"><span data-stu-id="b1857-2954">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="b1857-2955">型別，組件</span><span class="sxs-lookup"><span data-stu-id="b1857-2955">type, assembly</span></span>|<span data-ttu-id="b1857-2956">null</span><span class="sxs-lookup"><span data-stu-id="b1857-2956">null</span></span>|<span data-ttu-id="b1857-2957">null</span><span class="sxs-lookup"><span data-stu-id="b1857-2957">null</span></span>|<span data-ttu-id="b1857-2958">相當於呼叫<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-2958">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="b1857-2959">型別，組件</span><span class="sxs-lookup"><span data-stu-id="b1857-2959">type, assembly</span></span>|<span data-ttu-id="b1857-2960">提供</span><span class="sxs-lookup"><span data-stu-id="b1857-2960">provided</span></span>|<span data-ttu-id="b1857-2961">null</span><span class="sxs-lookup"><span data-stu-id="b1857-2961">null</span></span>|<span data-ttu-id="b1857-2962">`assemblyResolver` 傳回的組件，或傳回`null`若無法解析組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2962">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="b1857-2963">如果組件解析，<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載用來從組件載入的型別; 否則就不會嘗試解析類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2963">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="b1857-2964">型別，組件</span><span class="sxs-lookup"><span data-stu-id="b1857-2964">type, assembly</span></span>|<span data-ttu-id="b1857-2965">null</span><span class="sxs-lookup"><span data-stu-id="b1857-2965">null</span></span>|<span data-ttu-id="b1857-2966">提供</span><span class="sxs-lookup"><span data-stu-id="b1857-2966">provided</span></span>|<span data-ttu-id="b1857-2967">相當於組件名稱，以轉換<xref:System.Reflection.AssemblyName>物件並呼叫<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>方法多載，以取得組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2967">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="b1857-2968">如果組件已解決，將它傳遞至`typeResolver`，否則`typeResolver`則不會呼叫，而且沒有任何進一步嘗試解析類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2968">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="b1857-2969">型別，組件</span><span class="sxs-lookup"><span data-stu-id="b1857-2969">type, assembly</span></span>|<span data-ttu-id="b1857-2970">提供</span><span class="sxs-lookup"><span data-stu-id="b1857-2970">provided</span></span>|<span data-ttu-id="b1857-2971">提供</span><span class="sxs-lookup"><span data-stu-id="b1857-2971">provided</span></span>|<span data-ttu-id="b1857-2972">`assemblyResolver` 傳回的組件，或傳回`null`若無法解析組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2972">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="b1857-2973">如果組件已解決，將它傳遞至`typeResolver`，否則`typeResolver`則不會呼叫，而且沒有任何進一步嘗試解析類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2973">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="b1857-2974">類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2974">type</span></span>|<span data-ttu-id="b1857-2975">提供 null</span><span class="sxs-lookup"><span data-stu-id="b1857-2975">null, provided</span></span>|<span data-ttu-id="b1857-2976">null</span><span class="sxs-lookup"><span data-stu-id="b1857-2976">null</span></span>|<span data-ttu-id="b1857-2977">相當於呼叫<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-2977">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="b1857-2978">因為未提供組件名稱，會搜尋才 Mscorlib.dll 和目前執行的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2978">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="b1857-2979">如果`assemblyResolver`提供，則會忽略它。</span><span class="sxs-lookup"><span data-stu-id="b1857-2979">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="b1857-2980">類型</span><span class="sxs-lookup"><span data-stu-id="b1857-2980">type</span></span>|<span data-ttu-id="b1857-2981">提供 null</span><span class="sxs-lookup"><span data-stu-id="b1857-2981">null, provided</span></span>|<span data-ttu-id="b1857-2982">提供</span><span class="sxs-lookup"><span data-stu-id="b1857-2982">provided</span></span>|<span data-ttu-id="b1857-2983">`typeResolver` 呼叫時，和`null`傳遞的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-2983">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="b1857-2984">`typeResolver` 可以從任何組件，包括它的目的會自動載入的組件提供的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-2984">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="b1857-2985">如果`assemblyResolver`提供，則會忽略它。</span><span class="sxs-lookup"><span data-stu-id="b1857-2985">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="b1857-2986">組件</span><span class="sxs-lookup"><span data-stu-id="b1857-2986">assembly</span></span>|<span data-ttu-id="b1857-2987">提供 null</span><span class="sxs-lookup"><span data-stu-id="b1857-2987">null, provided</span></span>|<span data-ttu-id="b1857-2988">提供 null</span><span class="sxs-lookup"><span data-stu-id="b1857-2988">null, provided</span></span>|<span data-ttu-id="b1857-2989">A<xref:System.IO.FileLoadException>擲回，因為組件名稱會剖析如同一般組件限定類型名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2989">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="b1857-2990">這會導致無效的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-2990">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="b1857-2991">回到：[使用注意事項](#usage_notes)，[解析組件](#resolving_assemblies)，[解析型別的](#resolving_types)。</span><span class="sxs-lookup"><span data-stu-id="b1857-2991">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-2992">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2992">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-2993">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2993">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-2994">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2994">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="b1857-2995">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2995">-or-</span>
          </span>
          <span data-ttu-id="b1857-2996">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2996">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="b1857-2997">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2997">-or-</span>
          </span>
          <span data-ttu-id="b1857-2998">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2998">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b1857-2999">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-2999">-or-</span>
          </span>
          <span data-ttu-id="b1857-3000">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3000">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="b1857-3001">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3001">-or-</span>
          </span>
          <span data-ttu-id="b1857-3002">
            <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3002">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3003">將 <paramref name="typeName" /> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3003">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="b1857-3004">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3004">-or-</span>
          </span>
          <span data-ttu-id="b1857-3005">
            <paramref name="throwOnError" /> 為 <see langword="true" />，且 <paramref name="typeName" /> 包含無效的語法 (例如 "MyType[,\*,]")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3005">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="b1857-3006">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3006">-or-</span>
          </span>
          <span data-ttu-id="b1857-3007">
            <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3007">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="b1857-3008">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3008">-or-</span>
          </span>
          <span data-ttu-id="b1857-3009">
            <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3009">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="b1857-3010">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3010">-or-</span>
          </span>
          <span data-ttu-id="b1857-3011">
            <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3011">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b1857-3012">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3012">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="b1857-3013">找到組件或其相依性的其中之一，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3013">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="b1857-3014">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3014">-or-</span>
          </span>
          <span data-ttu-id="b1857-3015">
            <paramref name="typeName" /> 包含無效的組件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3015">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="b1857-3016">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3016">-or-</span>
          </span>
          <span data-ttu-id="b1857-3017">
            <paramref name="typeName" /> 是有效的組件名稱，沒有型別名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3017">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="b1857-3018">組件或組件的其中一個相依性無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3018">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="b1857-3019">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3019">-or-</span>
          </span>
          <span data-ttu-id="b1857-3020">用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3020">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="b1857-3021">要決定類型之物件的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3021">An array of objects whose types to determine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3022">取得指定陣列中物件的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3022">Gets the types of the objects in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3023">
            <see cref="T:System.Type" /> 物件的陣列，代表 <paramref name="args" /> 中對應項目的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3023">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b1857-3024">下列程式碼範例示範如何使用<xref:System.Type.GetTypeArray%2A>列出陣列的項目類型的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3024">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-3025">
            <paramref name="args" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3025">
              <paramref name="args" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-3026">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3026">-or-</span>
          </span>
          <span data-ttu-id="b1857-3027">
            <paramref name="args" /> 的其中一或多個項目為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3027">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-3028">叫用了類別初始設定式，並至少有一個會擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3028">The class initializers are invoked and at least one throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="b1857-3029">要取得其基礎類型程式碼的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3029">The type whose underlying type code to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3030">取得指定的 <see cref="T:System.Type" /> 的基礎類型程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3030">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3031">基礎類型程式碼，如果 <see cref="F:System.TypeCode.Empty" /> 是 <paramref name="type" /> 則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3031">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3032">當您繼承自<xref:System.Type>，您可以藉由覆寫來變更此方法的行為<xref:System.Type.GetTypeCodeImpl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3032">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3033">下列程式碼範例示範如何<xref:System.TypeCode>可以用於列舉型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3033">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="b1857-3034">在決策區塊`WriteObjectInfo`方法，<xref:System.TypeCode>的<xref:System.Object>參數會檢查，並有適當錯誤訊息寫入至主控台。</span><span class="sxs-lookup"><span data-stu-id="b1857-3034">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3035">傳回此 <see cref="T:System.Type" /> 執行個體的基礎型別碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3035">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3036">基礎類型的型別碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3036">The type code of the underlying type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3037">這個方法提供實作`static`（C# 中） 或`Shared`（在 Visual Basic)<xref:System.Type.GetTypeCode%28System.Type%29>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3037">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="b1857-3038">當您繼承自<xref:System.Type>，您可以覆寫這個方法以提供您自己實作<xref:System.Type.GetTypeCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3038">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3039">取得與指定的類別識別項 (CLSID) 關聯的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3039">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="b1857-3040">要取得之類型的 CLSID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3040">The CLSID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3041">取得與指定的類別識別項 (CLSID) 關聯的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3041">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3042">
            <see langword="System.__ComObject" />，不論 CLSID 是否有效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3042">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3043"><xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3043">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="b1857-3044">COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="b1857-3044">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="b1857-3045">您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3045">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="b1857-3046">您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。</span><span class="sxs-lookup"><span data-stu-id="b1857-3046">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="b1857-3047">具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：</span><span class="sxs-lookup"><span data-stu-id="b1857-3047">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="b1857-3048">取得<xref:System.Type>物件，代表`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3048">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="b1857-3049">呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法來具現化 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3049">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="b1857-3050">如需範例，請參閱。</span><span class="sxs-lookup"><span data-stu-id="b1857-3050">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="b1857-3051"><xref:System.Type.GetTypeFromCLSID%28System.Guid%29>多載會忽略任何會具現化時，可能會發生例外狀況<xref:System.Type>物件根據`clsid`引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3051">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="b1857-3052">請注意，如果將會擲回任何例外狀況`clsid`登錄中找不到。</span><span class="sxs-lookup"><span data-stu-id="b1857-3052">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3053">下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](http://msdn.microsoft.com/library/office/ff838565.aspx)擷取代表 Microsoft Word 應用程式的 COM 類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3053">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="b1857-3054">它接著會執行個體化類型呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3054">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="b1857-3055">使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3055">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="b1857-3056">所有受管理的物件，包括為 COM 可見的 (也就是其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3056">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="b1857-3057">雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件以建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3057">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="b1857-3058">相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3058">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="b1857-3059">要取得之類型的 CLSID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3059">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="b1857-3060">
            <see langword="true" />，擲回任何會發生的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3060">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="b1857-3061">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3061">-or-</span>
          </span>
          <span data-ttu-id="b1857-3062">
            <see langword="false" /> 則忽略任何會發生的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3062">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3063">取得與指定的類別識別項 (CLSID) 關聯的類型，並指定如果載入類型時發生錯誤是否擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3063">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3064">
            <see langword="System.__ComObject" />，不論 CLSID 是否有效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3064">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3065"><xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3065">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="b1857-3066">COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="b1857-3066">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="b1857-3067">您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3067">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="b1857-3068">您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。</span><span class="sxs-lookup"><span data-stu-id="b1857-3068">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="b1857-3069">具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：</span><span class="sxs-lookup"><span data-stu-id="b1857-3069">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="b1857-3070">取得<xref:System.Type>物件，代表`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3070">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="b1857-3071">呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法來具現化 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3071">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="b1857-3072">如需範例，請參閱。</span><span class="sxs-lookup"><span data-stu-id="b1857-3072">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="b1857-3073">例外狀況，例如<xref:System.OutOfMemoryException>指定時就會擲回`true`如`throwOnError`，但不是將取消登錄 Clsid 的失敗。</span><span class="sxs-lookup"><span data-stu-id="b1857-3073">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3074">下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](http://msdn.microsoft.com/library/office/ff838565.aspx)擷取代表 Microsoft Word 應用程式的 COM 類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3074">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="b1857-3075">它接著會執行個體化類型呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3075">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span> <span data-ttu-id="b1857-3076">如果在載入類型時發生錯誤，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-3076">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="b1857-3077">使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3077">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="b1857-3078">所有受管理的物件，包括為 COM 可見的 (也就是其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3078">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="b1857-3079">雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件以建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3079">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="b1857-3080">相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3080">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="b1857-3081">要取得之類型的 CLSID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3081">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="b1857-3082">要載入類型的伺服器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3082">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="b1857-3083">如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3083">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3084">從指定的伺服器中，取得與指定的類別識別項 (CLSID) 相關聯的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3084">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3085">
            <see langword="System.__ComObject" />，不論 CLSID 是否有效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3085">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3086"><xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3086">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="b1857-3087">COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="b1857-3087">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="b1857-3088">您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3088">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="b1857-3089">您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。</span><span class="sxs-lookup"><span data-stu-id="b1857-3089">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="b1857-3090">具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：</span><span class="sxs-lookup"><span data-stu-id="b1857-3090">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="b1857-3091">取得<xref:System.Type>物件，代表`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3091">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="b1857-3092">呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法來具現化 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3092">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3093">下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](http://msdn.microsoft.com/library/office/ff838565.aspx)擷取代表從名為 computer17.central.contoso.com 伺服器的 Microsoft Word 應用程式的 COM 類型。它接著會執行個體化類型呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3093">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="b1857-3094">使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3094">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="b1857-3095">所有受管理的物件，包括為 COM 可見的 (也就是其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3095">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="b1857-3096">雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件以建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3096">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="b1857-3097">相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3097">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="b1857-3098">要取得之類型的 CLSID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3098">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="b1857-3099">要載入類型的伺服器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3099">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="b1857-3100">如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3100">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="b1857-3101">
            <see langword="true" />，擲回任何會發生的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3101">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="b1857-3102">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3102">-or-</span>
          </span>
          <span data-ttu-id="b1857-3103">
            <see langword="false" /> 則忽略任何會發生的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3103">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3104">從指定的伺服器中，取得與指定的類別識別項 (CLSID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3104">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3105">
            <see langword="System.__ComObject" />，不論 CLSID 是否有效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3105">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3106"><xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3106">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="b1857-3107">COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="b1857-3107">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="b1857-3108">您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3108">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="b1857-3109">您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。</span><span class="sxs-lookup"><span data-stu-id="b1857-3109">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="b1857-3110">具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：</span><span class="sxs-lookup"><span data-stu-id="b1857-3110">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="b1857-3111">取得<xref:System.Type>物件，代表`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3111">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="b1857-3112">呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法來具現化 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3112">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="b1857-3113">例外狀況，例如<xref:System.OutOfMemoryException>指定時就會擲回`true`如`throwOnError`，但不是將取消登錄 Clsid 的失敗。</span><span class="sxs-lookup"><span data-stu-id="b1857-3113">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3114">下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](http://msdn.microsoft.com/library/office/ff838565.aspx)擷取代表從名為 computer17.central.contoso.com 伺服器的 Microsoft Word 應用程式的 COM 類型。它接著會執行個體化類型呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3114">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span> <span data-ttu-id="b1857-3115">如果在載入類型時發生錯誤，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-3115">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="b1857-3116">使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3116">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="b1857-3117">所有受管理的物件，包括為 COM 可見的 (也就是其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3117">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="b1857-3118">雖然<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />方法會傳回<see cref="T:System.Type" />對應於特定的受管理物件 GUID 的物件不能使用該<see cref="T:System.Type" />物件以建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例顯示。</span>
            <span class="sxs-lookup">
              <span data-stu-id="b1857-3118">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="b1857-3119">相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3119">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="b1857-3120">參考類型的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3120">The object that refers to the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3121">取得指定的類型控制代碼所參考的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3121">Gets the type referenced by the specified type handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3122">由指定 <see cref="T:System.RuntimeTypeHandle" /> 參考的類型，如果 <see langword="null" /> 的 <see cref="P:System.RuntimeTypeHandle.Value" /> 屬性為 <paramref name="handle" /> 則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3122">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3123">控制代碼是有效的只有在所取得的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="b1857-3123">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3124">下列範例會使用<xref:System.Type.GetTypeFromHandle%2A>方法來取得<xref:System.Type>物件從<xref:System.RuntimeTypeHandle>提供<xref:System.Type.GetTypeHandle%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3124">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-3125">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3125">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3126">取得與指定的程式識別項 (ProgID) 相關聯的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3126">Gets the type associated with the specified program identifier (ProgID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="b1857-3127">要取得之類型的 ProgID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3127">The ProgID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3128">取得與指定的程式識別項 (ProgID) 相關聯的類型；如果在載入 <see cref="T:System.Type" /> 時發生錯誤，則傳回 null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3128">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3129">如果 <paramref name="progID" /> 在登錄中是有效項目，而且有類型與它相關聯，則為與指定的 ProgID 相關聯的類型，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3129">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3130">這個方法會提供用於 COM 支援。</span><span class="sxs-lookup"><span data-stu-id="b1857-3130">This method is provided for COM support.</span></span> <span data-ttu-id="b1857-3131">因為已取代的命名空間概念 Progid 不會使用 Microsoft.NET Framework 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-3131">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3132">
            <paramref name="progID" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3132">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b1857-3133">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3133">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b1857-3134">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3134">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="b1857-3135">要取得之類型的 ProgID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3135">The ProgID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="b1857-3136">
            <see langword="true" />，擲回任何會發生的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3136">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="b1857-3137">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3137">-or-</span>
          </span>
          <span data-ttu-id="b1857-3138">
            <see langword="false" /> 則忽略任何會發生的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3138">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3139">取得與指定的程式識別項 (ProgID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3139">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3140">如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3140">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3141">這個方法會提供用於 COM 支援。</span><span class="sxs-lookup"><span data-stu-id="b1857-3141">This method is provided for COM support.</span></span> <span data-ttu-id="b1857-3142">因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-3142">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3143">下列範例會擷取藉由傳遞 ProgID，指定是否要擲回例外狀況，如果是無效的 ProgID 的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3143">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="b1857-3144">此範例接著會顯示相關的 ProgID，以及任何適用的例外狀況的訊息，ClassID。</span><span class="sxs-lookup"><span data-stu-id="b1857-3144">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3145">
            <paramref name="progID" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3145">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="b1857-3146">指定的 ProgID 未註冊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3146">The specified ProgID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b1857-3147">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3147">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b1857-3148">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3148">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="b1857-3149">要取得之類型的 progID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3149">The progID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="b1857-3150">要載入類型的伺服器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3150">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="b1857-3151">如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3151">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3152">從指定的伺服器中，取得與指定的程式識別項 (progID) 相關聯的類型；如果在載入類型時發生錯誤，則傳回 null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3152">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3153">如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3153">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3154">這個方法會提供用於 COM 支援。</span><span class="sxs-lookup"><span data-stu-id="b1857-3154">This method is provided for COM support.</span></span> <span data-ttu-id="b1857-3155">因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-3155">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3156">下列範例會擷取藉由傳遞的 ProgID 和伺服器名稱的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3156">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="b1857-3157">然後範例會顯示 ProgID 與 ClassID，或如果的 ProgID 或伺服器名稱無效，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b1857-3157">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3158">
            <paramref name="prodID" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3158">
              <paramref name="prodID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b1857-3159">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3159">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b1857-3160">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3160">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="b1857-3161">要取得之 <see cref="T:System.Type" /> 的 progID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3161">The progID of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="b1857-3162">要載入類型的伺服器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3162">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="b1857-3163">如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3163">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="b1857-3164">
            <see langword="true" />，擲回任何會發生的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3164">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="b1857-3165">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3165">-or-</span>
          </span>
          <span data-ttu-id="b1857-3166">
            <see langword="false" /> 則忽略任何會發生的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3166">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3167">從指定的伺服器中，取得與指定的程式識別項 (progID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3167">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3168">如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3168">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3169">這個方法會提供用於 COM 支援。</span><span class="sxs-lookup"><span data-stu-id="b1857-3169">This method is provided for COM support.</span></span> <span data-ttu-id="b1857-3170">因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-3170">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3171">下列範例會擷取藉由傳遞的 ProgID 和伺服器名稱的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3171">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="b1857-3172">此範例接著會顯示相關的 ProgID，指定是否要擲回例外狀況的 ProgID 或伺服器名稱不正確的 ClassID。</span><span class="sxs-lookup"><span data-stu-id="b1857-3172">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3173">
            <paramref name="progID" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3173">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="b1857-3174">未註冊指定的 progID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3174">The specified progID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b1857-3175">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3175">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b1857-3176">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3176">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="b1857-3177">要取得其類型控制代碼的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3177">The object for which to get the type handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3178">取得指定物件的 <see cref="T:System.Type" /> 的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3178">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3179">指定 <see cref="T:System.Type" /> 之 <see cref="T:System.Object" /> 的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3179">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3180">控制代碼是有效的只有在所取得的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="b1857-3180">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3181">下列範例會定義類別`MyClass1`、 取得其執行個體，和擷取之物件的執行階段控制代碼。</span><span class="sxs-lookup"><span data-stu-id="b1857-3181">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-3182">
            <paramref name="o" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3182">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3183">取得與 <see cref="T:System.Type" /> 相關聯的 GUID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3183">Gets the GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3184">與 <see cref="T:System.Type" /> 相關聯的 GUID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3184">The GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3185">GUID 是與使用類型相關聯<xref:System.Runtime.InteropServices.GuidAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3185">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3186">下列範例會建立類別`MyClass1`的公用方法，建立`Type`物件對應至`MyClass1`，並取得<xref:System.Guid>結構使用`GUID`屬性`Type`類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3186">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3187">取得值，指出目前 <see cref="T:System.Type" /> 是否內含或參考其他類型；也就是說，目前 <see cref="T:System.Type" /> 是否為陣列、指標或以傳址方式傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3187">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3188">如果 <see langword="true" /> 是陣列、指標或以傳址方式傳遞，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3188">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3189">例如，Type.GetType("Int32[]")。傳回 HasElementType `true`，但 Type.GetType("Int32")。傳回 HasElementType `false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3189">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="b1857-3190">HasElementType 也會傳回`true`如"Int32 \*"和"Int32 （& s) 」。</span><span class="sxs-lookup"><span data-stu-id="b1857-3190">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="b1857-3191">如果目前<xref:System.Type>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3191">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3192">下列範例會傳回`true`或`false`根據物件是否為陣列、 參考類型或指標。</span><span class="sxs-lookup"><span data-stu-id="b1857-3192">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3193">在衍生類別中覆寫時，實作 <see cref="P:System.Type.HasElementType" /> 屬性並判斷目前 <see cref="T:System.Type" /> 是否內含或參考其他類型；也就是說，目前 <see cref="T:System.Type" /> 是否為陣列、指標或以傳址方式傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3193">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3194">如果 <see langword="true" /> 是陣列、指標或以傳址方式傳遞，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3194">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3195">例如，Type.GetType("Int32[]")。傳回 HasElementTypeImpl `true`，但 Type.GetType("Int32")。傳回 HasElementTypeImpl `false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3195">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="b1857-3196">HasElementTypeImpl 也會傳回`true`如"Int32 \*"和"Int32 （& s) 」。</span><span class="sxs-lookup"><span data-stu-id="b1857-3196">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3197">下列範例會定義類別`MyTypeDelegator`，它會覆寫`HasElementTypeImpl`方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3197">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="b1857-3198">主要的類別會檢查`HasElementType`屬性，並顯示型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3198">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3199">叫用目前 <see cref="T:System.Type" /> 的特定成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3199">Invokes a specific member of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-3200">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3200">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="b1857-3201">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3201">-or-</span>
          </span>
          <span data-ttu-id="b1857-3202">空字串 ("")，要叫用預設成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3202">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="b1857-3203">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3203">-or-</span>
          </span>
          <span data-ttu-id="b1857-3204">對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3204">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="b1857-3205">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3205">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-3206">該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3206">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="b1857-3207">不需要指定查閱的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3207">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="b1857-3208">如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3208">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-3209">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3209">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-3210">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3210">-or-</span>
          </span>
          <span data-ttu-id="b1857-3211">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3211">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="b1857-3212">請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3212">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="b1857-3213">要在其上叫用指定成員的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3213">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="b1857-3214">包含引數的陣列，這些引數會傳遞給要叫用的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3214">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3215">使用指定的繫結條件約束並符合指定的引數清單，來叫用指定的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3215">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3216">表示叫用的成員之傳回值的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3216">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3217">您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3217">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="b1857-3218">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：</span><span class="sxs-lookup"><span data-stu-id="b1857-3218">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-3219">指定`BindingFlags.Public`来包含在搜尋中的公用成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3219">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-3220">指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是 private 和 protected 成員）。</span><span class="sxs-lookup"><span data-stu-id="b1857-3220">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-3221">指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3221">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="b1857-3222">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-3222">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-3223">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3223">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-3224">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3224">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-3225">下列<xref:System.Reflection.BindingFlags>引動過程旗標可以用來代表要與成員採取什麼動作：</span><span class="sxs-lookup"><span data-stu-id="b1857-3225">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="b1857-3226">`CreateInstance` 叫用建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3226">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="b1857-3227">`name` 已忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-3227">`name` is ignored.</span></span> <span data-ttu-id="b1857-3228">與其他引動過程旗標無效。</span><span class="sxs-lookup"><span data-stu-id="b1857-3228">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="b1857-3229">`InvokeMethod` 叫用方法，但不是建構函式或類型初始設定式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3229">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="b1857-3230">不適用於`SetField`或`SetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3230">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="b1857-3231">如果`InvokeMethod`單獨使用時，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動加入。</span><span class="sxs-lookup"><span data-stu-id="b1857-3231">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="b1857-3232">`GetField` 若要取得欄位的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3232">`GetField` to get the value of a field.</span></span> <span data-ttu-id="b1857-3233">不適用於`SetField`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3233">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="b1857-3234">`SetField` 若要設定欄位的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3234">`SetField` to set the value of a field.</span></span> <span data-ttu-id="b1857-3235">不適用於`GetField`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3235">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="b1857-3236">`GetProperty` 若要取得的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3236">`GetProperty` to get a property.</span></span> <span data-ttu-id="b1857-3237">不適用於`SetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3237">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="b1857-3238">`SetProperty` 若要設定屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3238">`SetProperty` to set a property.</span></span> <span data-ttu-id="b1857-3239">不適用於`GetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3239">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="b1857-3240">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3240">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-3241">如果兩個下列條件成立，就會叫用方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-3241">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="b1857-3242">方法宣告中的參數數目等於引數在數目`args`陣列 (除非在成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3242">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="b1857-3243">每個引數的類型可以轉換型別參數的繫結器。</span><span class="sxs-lookup"><span data-stu-id="b1857-3243">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="b1857-3244">繫結器將會尋找所有相符的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3244">The binder will find all of the matching methods.</span></span> <span data-ttu-id="b1857-3245">這些方法找到要求的繫結的類型為基礎 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3245">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="b1857-3246">方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。</span><span class="sxs-lookup"><span data-stu-id="b1857-3246">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="b1857-3247">選取方法之後，它會叫用。</span><span class="sxs-lookup"><span data-stu-id="b1857-3247">After the method is selected, it is invoked.</span></span> <span data-ttu-id="b1857-3248">協助工具會在該點檢查。</span><span class="sxs-lookup"><span data-stu-id="b1857-3248">Accessibility is checked at that point.</span></span> <span data-ttu-id="b1857-3249">搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3249">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="b1857-3250"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>類別會負責選取方法被叫用。</span><span class="sxs-lookup"><span data-stu-id="b1857-3250">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="b1857-3251">預設繫結器選取最適合的相符項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-3251">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="b1857-3252">完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和叫用透過<xref:System.Reflection>每當程式碼受到完全信任。</span><span class="sxs-lookup"><span data-stu-id="b1857-3252">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="b1857-3253">您可以使用`Type.InvokeMember`將欄位設定為特定值，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3253">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1857-3254">例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是`String`，您可以使用程式碼，例如：</span><span class="sxs-lookup"><span data-stu-id="b1857-3254">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="b1857-3255">如果 F `String[]`，您可以使用程式碼，例如：</span><span class="sxs-lookup"><span data-stu-id="b1857-3255">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="b1857-3256">這將會初始化欄位 F 此新陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-3256">which will initialize the field F to this new array.</span></span> <span data-ttu-id="b1857-3257">您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：</span><span class="sxs-lookup"><span data-stu-id="b1857-3257">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="b1857-3258">這會變更陣列 F 保留字串"b"中的字串"z"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3258">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="b1857-3259">當您叫用`IDispatch`成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3259">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="b1857-3260">例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3260">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="b1857-3261">叫用成員的 DispID 的速度比依名稱查閱的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3261">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="b1857-3262">在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3262">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3263">從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3263">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="b1857-3264">(請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="b1857-3264">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="b1857-3265">若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="b1857-3265">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3266">下列範例會使用`InvokeMember`存取類型的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3266">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-3267">
            <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3267">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3268">
            <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3268">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="b1857-3269">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3269">-or-</span>
          </span>
          <span data-ttu-id="b1857-3270">
            <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3270">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3271">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3271">-or-</span>
          </span>
          <span data-ttu-id="b1857-3272">
            <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3272">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3273">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3273">-or-</span>
          </span>
          <span data-ttu-id="b1857-3274">
            <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3274">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="b1857-3275">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3275">-or-</span>
          </span>
          <span data-ttu-id="b1857-3276">
            <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3276">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3277">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3277">-or-</span>
          </span>
          <span data-ttu-id="b1857-3278">
            <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3278">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3279">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3279">-or-</span>
          </span>
          <span data-ttu-id="b1857-3280">
            <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3280">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="b1857-3281">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3281">-or-</span>
          </span>
          <span data-ttu-id="b1857-3282">已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3282">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3283">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3283">-or-</span>
          </span>
          <span data-ttu-id="b1857-3284">其中一個具名參數陣列包含的字串是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3284">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="b1857-3285">指定的成員是類別初始設定式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3285">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="b1857-3286">找不到欄位或屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3286">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="b1857-3287">找不到符合 <paramref name="args" /> 中之引數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3287">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="b1857-3288">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3288">-or-</span>
          </span>
          <span data-ttu-id="b1857-3289">目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3289">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="b1857-3290">無法在 <paramref name="target" /> 上叫用指定的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3290">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-3291">有一個以上的方法符合繫結準則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3291">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-3292">.NET Compact Framework 目前不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3292">The .NET Compact Framework does not currently support this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-3293">
            <paramref name="name" /> 所表示的方法有一或多個未指定的泛型類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3293">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="b1857-3294">亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3294">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b1857-3295">用於存取非公用成員，不論其授權集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3295">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="b1857-3296">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3296">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="b1857-3297">呼叫 unmanaged 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3297">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="b1857-3298">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-3299">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3299">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="b1857-3300">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3300">-or-</span>
          </span>
          <span data-ttu-id="b1857-3301">空字串 ("")，要叫用預設成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3301">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="b1857-3302">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3302">-or-</span>
          </span>
          <span data-ttu-id="b1857-3303">對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3303">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="b1857-3304">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3304">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-3305">該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3305">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="b1857-3306">不需要指定查閱的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3306">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="b1857-3307">如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3307">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-3308">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3308">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-3309">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3309">-or-</span>
          </span>
          <span data-ttu-id="b1857-3310">Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3310">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="b1857-3311">請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3311">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="b1857-3312">要在其上叫用指定成員的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3312">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="b1857-3313">包含引數的陣列，這些引數會傳遞給要叫用的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3313">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="b1857-3314">表示要使用之全球化地區設定的物件，它可能是地區設定特性轉換所需要的，例如將數值 <see cref="T:System.String" /> 轉換成 <see cref="T:System.Double" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3314">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span>
          </span>
          <span data-ttu-id="b1857-3315">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3315">-or-</span>
          </span>
          <span data-ttu-id="b1857-3316">Null 參考 (Visual Basic 中的 <see langword="Nothing" />)，可使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3316">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3317">使用指定的繫結條件約束並符合指定的引數清單和文化特性 (Culture) 來叫用指定的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3317">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3318">表示叫用的成員之傳回值的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3318">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3319">雖然預設繫結器不會處理<xref:System.Globalization.CultureInfo>(`culture`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`culture`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3319">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3320">您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3320">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="b1857-3321">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：</span><span class="sxs-lookup"><span data-stu-id="b1857-3321">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-3322">指定`BindingFlags.Public`来包含在搜尋中的公用成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3322">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-3323">指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</span><span class="sxs-lookup"><span data-stu-id="b1857-3323">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-3324">指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3324">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="b1857-3325">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-3325">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-3326">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3326">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-3327">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3327">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-3328">下列<xref:System.Reflection.BindingFlags>引動過程旗標可以用來代表要與成員採取什麼動作：</span><span class="sxs-lookup"><span data-stu-id="b1857-3328">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="b1857-3329">`CreateInstance` 叫用建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3329">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="b1857-3330">`name` 已忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-3330">`name` is ignored.</span></span> <span data-ttu-id="b1857-3331">與其他引動過程旗標無效。</span><span class="sxs-lookup"><span data-stu-id="b1857-3331">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="b1857-3332">`InvokeMethod` 叫用方法，但不是建構函式或類型初始設定式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3332">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="b1857-3333">不適用於`SetField`或`SetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3333">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="b1857-3334">如果`InvokeMethod`單獨使用時，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動加入。</span><span class="sxs-lookup"><span data-stu-id="b1857-3334">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="b1857-3335">`GetField` 若要取得欄位的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3335">`GetField` to get the value of a field.</span></span> <span data-ttu-id="b1857-3336">不適用於`SetField`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3336">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="b1857-3337">`SetField` 若要設定欄位的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3337">`SetField` to set the value of a field.</span></span> <span data-ttu-id="b1857-3338">不適用於`GetField`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3338">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="b1857-3339">`GetProperty` 若要取得的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3339">`GetProperty` to get a property.</span></span> <span data-ttu-id="b1857-3340">不適用於`SetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3340">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="b1857-3341">`SetProperty` 若要設定屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3341">`SetProperty` to set a property.</span></span> <span data-ttu-id="b1857-3342">不適用於`GetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3342">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="b1857-3343">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3343">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-3344">如果兩個下列條件成立，就會叫用方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-3344">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="b1857-3345">方法宣告中的參數數目等於引數在數目`args`陣列 (除非在成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3345">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="b1857-3346">每個引數的類型可以轉換型別參數的繫結器。</span><span class="sxs-lookup"><span data-stu-id="b1857-3346">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="b1857-3347">繫結器將會尋找所有相符的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3347">The binder will find all of the matching methods.</span></span> <span data-ttu-id="b1857-3348">這些方法找到要求的繫結的類型為基礎 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3348">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="b1857-3349">方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。</span><span class="sxs-lookup"><span data-stu-id="b1857-3349">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="b1857-3350">選取方法之後，它會叫用。</span><span class="sxs-lookup"><span data-stu-id="b1857-3350">After the method is selected, it is invoked.</span></span> <span data-ttu-id="b1857-3351">協助工具會在該點檢查。</span><span class="sxs-lookup"><span data-stu-id="b1857-3351">Accessibility is checked at that point.</span></span> <span data-ttu-id="b1857-3352">搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3352">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="b1857-3353"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>類別會負責選取方法被叫用。</span><span class="sxs-lookup"><span data-stu-id="b1857-3353">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="b1857-3354">預設繫結器選取最適合的相符項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-3354">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="b1857-3355">完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和每當程式碼受到完全信任時，透過反映來叫用。</span><span class="sxs-lookup"><span data-stu-id="b1857-3355">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="b1857-3356">您可以使用`Type.InvokeMember`將欄位設定為特定值，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3356">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1857-3357">例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是`String`您可以使用程式碼，例如：</span><span class="sxs-lookup"><span data-stu-id="b1857-3357">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="b1857-3358">如果 F `String[]`，您可以使用程式碼，例如：</span><span class="sxs-lookup"><span data-stu-id="b1857-3358">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="b1857-3359">這將會初始化欄位 F 此新陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-3359">which will initialize the field F to this new array.</span></span> <span data-ttu-id="b1857-3360">您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：</span><span class="sxs-lookup"><span data-stu-id="b1857-3360">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="b1857-3361">這會變更陣列 F 保留字串"b"中的字串"z"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3361">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="b1857-3362">當您叫用`IDispatch`成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3362">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="b1857-3363">例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3363">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="b1857-3364">叫用成員的 DispID 的速度比依名稱查閱的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3364">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="b1857-3365">在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3365">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3366">從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3366">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="b1857-3367">(請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="b1857-3367">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="b1857-3368">若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="b1857-3368">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-3369">
            <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3369">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3370">
            <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3370">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="b1857-3371">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3371">-or-</span>
          </span>
          <span data-ttu-id="b1857-3372">
            <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3372">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3373">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3373">-or-</span>
          </span>
          <span data-ttu-id="b1857-3374">
            <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3374">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3375">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3375">-or-</span>
          </span>
          <span data-ttu-id="b1857-3376">
            <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3376">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="b1857-3377">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3377">-or-</span>
          </span>
          <span data-ttu-id="b1857-3378">
            <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3378">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3379">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3379">-or-</span>
          </span>
          <span data-ttu-id="b1857-3380">
            <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3380">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3381">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3381">-or-</span>
          </span>
          <span data-ttu-id="b1857-3382">
            <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3382">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="b1857-3383">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3383">-or-</span>
          </span>
          <span data-ttu-id="b1857-3384">已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3384">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3385">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3385">-or-</span>
          </span>
          <span data-ttu-id="b1857-3386">其中一個具名參數陣列包含的字串是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3386">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="b1857-3387">指定的成員是類別初始設定式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3387">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="b1857-3388">找不到欄位或屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3388">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="b1857-3389">找不到符合 <paramref name="args" /> 中之引數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3389">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="b1857-3390">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3390">-or-</span>
          </span>
          <span data-ttu-id="b1857-3391">目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3391">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="b1857-3392">無法在 <paramref name="target" /> 上叫用指定的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3392">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-3393">有一個以上符合繫結準則的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3393">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-3394">
            <paramref name="name" /> 所表示的方法有一或多個未指定的泛型類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3394">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="b1857-3395">亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3395">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b1857-3396">用於存取非公用成員，不論其授權集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3396">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="b1857-3397">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3397">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="b1857-3398">呼叫 unmanaged 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3398">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="b1857-3399">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3399">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b1857-3400">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3400">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="b1857-3401">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3401">-or-</span>
          </span>
          <span data-ttu-id="b1857-3402">空字串 ("")，要叫用預設成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3402">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="b1857-3403">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3403">-or-</span>
          </span>
          <span data-ttu-id="b1857-3404">對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3404">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="b1857-3405">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3405">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="b1857-3406">該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3406">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="b1857-3407">不需要指定查閱的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3407">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="b1857-3408">如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3408">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b1857-3409">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3409">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="b1857-3410">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3410">-or-</span>
          </span>
          <span data-ttu-id="b1857-3411">Null 參考 (在 Visual Basic 中為 Nothing)，可使用 <see cref="P:System.Type.DefaultBinder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3411">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="b1857-3412">請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3412">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="b1857-3413">要在其上叫用指定成員的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3413">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="b1857-3414">包含引數的陣列，這些引數會傳遞給要叫用的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3414">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="b1857-3415">
            <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>args</c> 陣列中與對應元素產生關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3415">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="b1857-3416">參數的關聯屬性儲存在成員的簽章中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3416">A parameter's associated attributes are stored in the member's signature.</span>
          </span>
          <span data-ttu-id="b1857-3417">預設繫結器只會在呼叫 COM 元件時處理這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3417">The default binder processes this parameter only when calling a COM component.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="b1857-3418">
            <see cref="T:System.Globalization.CultureInfo" /> 物件，代表要使用的全球化地區設定，進行特定地區設定轉換時可能需要這個物件，例如將數值的 String 轉換成 Double。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3418">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span>
          </span>
          <span data-ttu-id="b1857-3419">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3419">-or-</span>
          </span>
          <span data-ttu-id="b1857-3420">Null 參考 (Visual Basic 中的 <see langword="Nothing" />)，可使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3420">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="b1857-3421">陣列，包含 <c>args</c> 陣列中的值所要傳遞之目標參數的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3421">An array containing the names of the parameters to which the values in the <c>args</c> array are passed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3422">在衍生類別中覆寫時，使用指定的繫結條件約束並符合指定的引數清單、修飾詞和文化特性，來叫用指定的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3422">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3423">表示叫用的成員之傳回值的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3423">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3424">`InvokeMember` 呼叫建構函式或方法成員、 取得或設定之屬性成員，取得或設定資料欄位成員，或取得或設定陣列成員的項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-3424">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3425">您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3425">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="b1857-3426">當您叫用`IDispatch`成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3426">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="b1857-3427">例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3427">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="b1857-3428">叫用成員的 DispID 的速度比依名稱查閱的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3428">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="b1857-3429">在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3429">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="b1857-3430">雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>或<xref:System.Globalization.CultureInfo>(`modifiers`和`culture`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`和`culture`.</span><span class="sxs-lookup"><span data-stu-id="b1857-3430">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="b1857-3431">`ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3431">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="b1857-3432">每個 `namedParameters` 中的參數都取得 `args` 陣列中對應元素的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3432">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="b1857-3433">如果 `args` 的長度大於 `namedParameters` 的長度，剩餘的引數值會依順序傳遞。</span><span class="sxs-lookup"><span data-stu-id="b1857-3433">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="b1857-3434">`namedParameters`陣列可以用來變更輸入陣列中的引數的順序。</span><span class="sxs-lookup"><span data-stu-id="b1857-3434">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="b1857-3435">例如，給定方法`M(string a, int b)`(`M(ByVal a As String, ByVal b As Integer)`在 Visual Basic 中) 並輸入的陣列`{ 42, "x" }`，輸入的陣列可以傳遞至不變`args`如果陣列`{ "b", "a" }`提供給`namedParameters`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3435">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="b1857-3436">下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：</span><span class="sxs-lookup"><span data-stu-id="b1857-3436">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="b1857-3437">指定`BindingFlags.Public`来包含在搜尋中的公用成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3437">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="b1857-3438">指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</span><span class="sxs-lookup"><span data-stu-id="b1857-3438">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="b1857-3439">指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3439">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="b1857-3440">下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：</span><span class="sxs-lookup"><span data-stu-id="b1857-3440">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="b1857-3441">`BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3441">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="b1857-3442">`BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="b1857-3442">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="b1857-3443">下列<xref:System.Reflection.BindingFlags>引動過程旗標可以用來代表要與成員採取什麼動作：</span><span class="sxs-lookup"><span data-stu-id="b1857-3443">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="b1857-3444">`CreateInstance` 叫用建構函式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3444">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="b1857-3445">`name` 已忽略。</span><span class="sxs-lookup"><span data-stu-id="b1857-3445">`name` is ignored.</span></span> <span data-ttu-id="b1857-3446">與其他引動過程旗標無效。</span><span class="sxs-lookup"><span data-stu-id="b1857-3446">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="b1857-3447">`InvokeMethod` 叫用方法，但不是建構函式或類型初始設定式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3447">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="b1857-3448">不適用於`SetField`或`SetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3448">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="b1857-3449">如果`InvokeMethod`單獨使用時，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動加入。</span><span class="sxs-lookup"><span data-stu-id="b1857-3449">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="b1857-3450">`GetField` 若要取得欄位的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3450">`GetField` to get the value of a field.</span></span> <span data-ttu-id="b1857-3451">不適用於`SetField`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3451">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="b1857-3452">`SetField` 若要設定欄位的值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3452">`SetField` to set the value of a field.</span></span> <span data-ttu-id="b1857-3453">不適用於`GetField`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3453">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="b1857-3454">`GetProperty` 若要取得的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3454">`GetProperty` to get a property.</span></span> <span data-ttu-id="b1857-3455">不適用於`SetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3455">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="b1857-3456">`SetProperty` 若要設定屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3456">`SetProperty` to set a property.</span></span> <span data-ttu-id="b1857-3457">不適用於`GetProperty`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3457">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="b1857-3458">如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3458">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="b1857-3459">如果兩個下列條件成立，就會叫用方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-3459">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="b1857-3460">方法宣告中的參數數目等於引數在數目`args`陣列 (除非在成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3460">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="b1857-3461">每個引數的類型可以轉換型別參數的繫結器。</span><span class="sxs-lookup"><span data-stu-id="b1857-3461">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="b1857-3462">繫結器將會尋找所有相符的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3462">The binder will find all of the matching methods.</span></span> <span data-ttu-id="b1857-3463">這些方法找到要求的繫結的類型為基礎 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3463">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="b1857-3464">方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。</span><span class="sxs-lookup"><span data-stu-id="b1857-3464">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="b1857-3465">選取方法之後，它會叫用。</span><span class="sxs-lookup"><span data-stu-id="b1857-3465">After the method is selected, it is invoked.</span></span> <span data-ttu-id="b1857-3466">協助工具會在該點檢查。</span><span class="sxs-lookup"><span data-stu-id="b1857-3466">Accessibility is checked at that point.</span></span> <span data-ttu-id="b1857-3467">搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3467">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="b1857-3468"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>類別會負責選取方法被叫用。</span><span class="sxs-lookup"><span data-stu-id="b1857-3468">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="b1857-3469">預設繫結器選取最適合的相符項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-3469">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="b1857-3470">`InvokeMember` 可用來叫用其參數具有預設值的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3470">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="b1857-3471">若要繫結至這些方法，需要反映<xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>指定。</span><span class="sxs-lookup"><span data-stu-id="b1857-3471">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="b1857-3472">預設值是參數，您可以提供不同的值，或提供<xref:System.Reflection.Missing.Value?displayProperty=nameWithType>使用預設值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3472">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="b1857-3473">例如，請考慮方法，例如 MyMethod (x，float y int = 2.0)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3473">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="b1857-3474">要叫用這個方法，只有第一個引數為 MyMethod(4)，需傳遞其中一個以上的繫結旗標，並將兩個引數，也就是 4 的第一個引數傳遞和`Missing.Value`第二個引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3474">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="b1857-3475">除非您使用`Missing.Value`，您不可以省略選擇性參數與`Invoke`方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3475">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="b1857-3476">如果您必須這麼做，使用`InvokeMember`改為。</span><span class="sxs-lookup"><span data-stu-id="b1857-3476">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="b1857-3477">完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和叫用透過<xref:System.Reflection>每當程式碼受到完全信任。</span><span class="sxs-lookup"><span data-stu-id="b1857-3477">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="b1857-3478">您可以使用`Type.InvokeMember`將欄位設定為特定值，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3478">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1857-3479">例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是`String`，您可以使用程式碼，例如：</span><span class="sxs-lookup"><span data-stu-id="b1857-3479">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="b1857-3480">如果 F `String[]`，您可以使用程式碼，例如：</span><span class="sxs-lookup"><span data-stu-id="b1857-3480">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="b1857-3481">這將會初始化欄位 F 此新陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-3481">which will initialize the field F to this new array.</span></span> <span data-ttu-id="b1857-3482">您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：</span><span class="sxs-lookup"><span data-stu-id="b1857-3482">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="b1857-3483">這會變更陣列 F 保留字串"b"中的字串"z"。</span><span class="sxs-lookup"><span data-stu-id="b1857-3483">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3484">從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3484">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="b1857-3485">(請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="b1857-3485">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="b1857-3486">若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="b1857-3486">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-3487">
            <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3487">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3488">
            <paramref name="args" /> 和 <paramref name="modifiers" /> 的長度不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3488">
              <paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
          <span data-ttu-id="b1857-3489">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3489">-or-</span>
          </span>
          <span data-ttu-id="b1857-3490">
            <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3490">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="b1857-3491">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3491">-or-</span>
          </span>
          <span data-ttu-id="b1857-3492">
            <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3492">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3493">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3493">-or-</span>
          </span>
          <span data-ttu-id="b1857-3494">
            <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3494">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3495">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3495">-or-</span>
          </span>
          <span data-ttu-id="b1857-3496">
            <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3496">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="b1857-3497">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3497">-or-</span>
          </span>
          <span data-ttu-id="b1857-3498">
            <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3498">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3499">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3499">-or-</span>
          </span>
          <span data-ttu-id="b1857-3500">
            <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3500">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3501">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3501">-or-</span>
          </span>
          <span data-ttu-id="b1857-3502">
            <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3502">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="b1857-3503">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3503">-or-</span>
          </span>
          <span data-ttu-id="b1857-3504">具名參數陣列大於引數陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3504">The named parameter array is larger than the argument array.</span>
          </span>
          <span data-ttu-id="b1857-3505">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3505">-or-</span>
          </span>
          <span data-ttu-id="b1857-3506">已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3506">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="b1857-3507">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3507">-or-</span>
          </span>
          <span data-ttu-id="b1857-3508">其中一個具名參數陣列包含的字串是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3508">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="b1857-3509">指定的成員是類別初始設定式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3509">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="b1857-3510">找不到欄位或屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3510">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="b1857-3511">找不到符合 <paramref name="args" /> 中之引數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3511">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="b1857-3512">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3512">-or-</span>
          </span>
          <span data-ttu-id="b1857-3513">找不到具有 <paramref name="namedParameters" /> 中所提供引數名稱的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3513">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span>
          </span>
          <span data-ttu-id="b1857-3514">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3514">-or-</span>
          </span>
          <span data-ttu-id="b1857-3515">目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3515">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="b1857-3516">無法在 <paramref name="target" /> 上叫用指定的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3516">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="b1857-3517">有一個以上符合繫結準則的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3517">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-3518">
            <paramref name="name" /> 所表示的方法有一或多個未指定的泛型類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3518">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="b1857-3519">亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3519">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b1857-3520">用於存取非公用成員，不論其授權集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3520">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="b1857-3521">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3521">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="b1857-3522">呼叫 unmanaged 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3522">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="b1857-3523">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3523">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3524">取得值，指出 <see cref="T:System.Type" /> 是否為抽象並且必須被覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3524">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3525">如果 <see cref="T:System.Type" /> 是抽象，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3525">
              <see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3526"><xref:System.Type.IsAbstract%2A>屬性會傳回`true`在下列情況：</span><span class="sxs-lookup"><span data-stu-id="b1857-3526">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="b1857-3527">目前的類型是抽象的。也就是說，它無法具現化，但只可做為衍生類別的基底類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3527">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="b1857-3528">在 C# 中，抽象類別會以標記[抽象](~/docs/csharp/language-reference/keywords/abstract.md)關鍵字; 在 Visual Basic 中，它們會標示[MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)關鍵字。</span><span class="sxs-lookup"><span data-stu-id="b1857-3528">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="b1857-3529">目前的類型是介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-3529">The current type is an interface.</span></span>  
  
 <span data-ttu-id="b1857-3530">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3530">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3531">下列範例會建立的陣列<xref:System.Type>代表下列類型的物件： 包含類型傳回`true`的指定的物件是否`abstract`; 否則它會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3531">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="b1857-3532">`AbstractClass`抽象類別 (類別標示為`abstract`在 C# 和`MustInherit`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3532">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="b1857-3533">`DerivedClass`繼承自一個類別`AbstractClass`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3533">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="b1857-3534">`SingleClass`不可繼承的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3534">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="b1857-3535">它定義為`sealed`在 C# 和`NotInheritable`在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="b1857-3535">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="b1857-3536">`ITypeInfo`介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-3536">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="b1857-3537">`ImplementingClass`實作的類別`ITypeInfo`介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-3537">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="b1857-3538">方法會傳回`true`僅適用於`AbstractClass`，抽象類別，和`ITypeInfo`，介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-3538">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3539">取得值，指出是否為 <see langword="AnsiClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3539">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3540">如果為 <see langword="true" /> 選取字串格式屬性 <see langword="AnsiClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3540">
              <see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3541"><xref:System.Reflection.TypeAttributes.StringFormatMask>選取字串格式屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3541">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="b1857-3542">字串格式屬性定義如何解譯字串增強互通性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3542">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="b1857-3543">如果目前<xref:System.Type>代表泛型型別，這個屬性與從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3543">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3544">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3544">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3545">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3545">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3546">下列範例會取得欄位資訊，並檢查`AnsiClass`屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3546">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3547">取得值，以表示類型是否為陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3547">Gets a value that indicates whether the type is an array.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3548">如果目前的類型是陣列則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3548">
              <see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3549"><xref:System.Type.IsArray%2A>屬性會傳回`false`如<xref:System.Array>類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3549">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="b1857-3550">它也會傳回`false`如果目前的執行個體<xref:System.Type>物件，表示集合型別或設計來搭配集合，例如介面<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3550">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="b1857-3551">若要檢查的陣列，使用程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-3551">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="b1857-3552">如果目前的型別代表泛型類型或類型參數的泛型類型或泛型方法定義中，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3552">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3553">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-3553">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3554">下列範例示範如何使用<xref:System.Type.IsArray%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3554">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3555">在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsArray" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3555">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3556">如果 <see langword="true" /> 是陣列，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3556">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3557">執行個體<xref:System.Array>類別必須傳回`false`因為它是一個物件，而非陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-3557">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3558">下列範例會覆寫`IsArrayImpl`方法中的`MyTypeDelegator`類別，如果變數是陣列，並顯示結果的檢查。</span><span class="sxs-lookup"><span data-stu-id="b1857-3558">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="b1857-3559">要與目前的類型比較的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3559">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3560">判斷指定類型的執行個體是否可以指派給目前類型的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3560">Determines whether an instance of a specified type can be assigned to an instance of the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3561">
            <see langword="true" /> (下列任何條件成立時)：</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3561">
              <see langword="true" /> if any of the following conditions is true:</span>
          </span>  
  
-   <span data-ttu-id="b1857-3562"><paramref name="c" /> 和目前執行個體代表相同類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3562"><paramref name="c" /> and the current instance represent the same type.</span></span>  
  
-   <span data-ttu-id="b1857-3563"><paramref name="c" /> 直接或間接衍生自目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="b1857-3563"><paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span><span data-ttu-id="b1857-3564"><paramref name="c" /> 會直接衍生自目前的執行個體 (如果它繼承自目前的執行個體)，<paramref name="c" /> 會間接衍生自目前的執行個體 (如果它繼承自目前的執行個體所繼承的一或多個一連串類別)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3564"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
-   <span data-ttu-id="b1857-3565">目前執行個體是 <paramref name="c" /> 實作的介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-3565">The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  
-   <span data-ttu-id="b1857-3566"><paramref name="c" /> 是泛型類型參數，而且目前執行個體代表 <paramref name="c" /> 的其中一個條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-3566"><paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span><span data-ttu-id="b1857-3567">在下列範例中，目前的執行個體是 <see cref="T:System.Type" /> 物件，代表 <see cref="T:System.IO.Stream" /> 類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3567">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span><span data-ttu-id="b1857-3568"><c>GenericWithConstraint</c> 泛型型別，其泛型型別參數必須是型別 <see cref="T:System.IO.Stream" />。</span><span class="sxs-lookup"><span data-stu-id="b1857-3568"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span><span data-ttu-id="b1857-3569">傳遞其泛型型別參數至 <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> 表示泛型型別參數的執行個體可以指派給 <see cref="T:System.IO.Stream" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3569">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <span data-ttu-id="b1857-3570"><paramref name="c" /> 代表實值類型，而且目前執行個體代表 <c>Nullable&lt;c&gt;</c> (在 Visual Basic 中為 <c>Nullable(Of c)</c>)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3570"><paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span><span data-ttu-id="b1857-3571">如果以上條件都不成立，或者 <paramref name="c" /> 為 <see langword="false" />，則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b1857-3571"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3572"><xref:System.Type.IsAssignableFrom%2A>方法可以用來判斷執行個體是否`c`可以指派至目前型別的執行個體，方法當處理的物件在設計階段未知的型別便最有用並允許條件式指派，如下列範例會顯示。</span><span class="sxs-lookup"><span data-stu-id="b1857-3572">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="b1857-3573">這個方法因此可確保一行程式碼，如下列會在執行階段執行而不擲回<xref:System.InvalidCastException>或類似的例外狀況的例外狀況：</span><span class="sxs-lookup"><span data-stu-id="b1857-3573">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="b1857-3574">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3574">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3575">無法從封閉式的建構類型可指派的泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3575">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="b1857-3576">也就是說，您無法將指派封閉式的建構的類型`MyGenericList<int>`(`MyGenericList(Of Integer)`在 Visual Basic 中) 類型的變數至`MyGenericList<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3576">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3577">如果`c`參數的類型是<xref:System.Reflection.Emit.TypeBuilder>，結果根據用來建立的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3577">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="b1857-3578">下列程式碼範例示範此使用名為內建型別`B`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3578">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3579">下列範例會示範`IsAssignableFrom`類別、 整數陣列，與泛型方法使用定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3579">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3580">取得值，指出是否為 <see langword="AutoClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3580">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3581">如果為 <see langword="true" /> 選取字串格式屬性 <see langword="AutoClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3581">
              <see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3582"><xref:System.Reflection.TypeAttributes.StringFormatMask>選取字串格式屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3582">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="b1857-3583">字串格式屬性定義如何解譯字串增強互通性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3583">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="b1857-3584">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3584">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3585">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3585">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3586">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3586">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3587">取得表示目前類型的欄位是否已由 Common Language Runtime 自動配置版面的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3587">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3588">如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3588">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3589">為了方便起見，已提供這個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3589">This property is provided as a convenience.</span></span> <span data-ttu-id="b1857-3590">或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取型別配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>設定。</span><span class="sxs-lookup"><span data-stu-id="b1857-3590">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="b1857-3591"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>，<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值會指出類型的欄位配置記憶體中的方式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3591">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="b1857-3592">動態類型，您可以指定<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>當您建立的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3592">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="b1857-3593">在程式碼，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性附帶<xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType>列舉值的型別，可讓執行階段判斷適當的方式來配置的類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3593">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3594">您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3594">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="b1857-3595">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3595">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3596">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由 `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="b1857-3596">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="b1857-3597">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3597">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3598">下列範例會建立類型的執行個體，並顯示<xref:System.Type.IsAutoLayout%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3598">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3599">取得值，指出 <see cref="T:System.Type" /> 是否以傳址方式傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3599">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3600">如果 <see cref="T:System.Type" /> 是以傳址方式傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3600">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3601">若要取得實際的型別，由參考所傳遞的型別取值 （dereference），然後呼叫<xref:System.Type.GetElementType%2A>該型別上。</span><span class="sxs-lookup"><span data-stu-id="b1857-3601">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3602">下列範例會示範使用`IsByRef`屬性檢查指定的型別傳址方式傳遞。</span><span class="sxs-lookup"><span data-stu-id="b1857-3602">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="b1857-3603">此範例會定義類別`MyTypeDelegator`，它會覆寫`HasElementTypeImpl`方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3603">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="b1857-3604">主要的類別會檢查`HasElementType`屬性，並顯示型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3604">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3605">在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsByRef" /> 屬性並判斷 <see cref="T:System.Type" /> 是否以傳址方式傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3605">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3606">如果 <see cref="T:System.Type" /> 是以傳址方式傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3606">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3607">取得值，表示 <see cref="T:System.Type" /> 是類別或委派，也就是非實值類型或介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3607">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3608">如果 <see cref="T:System.Type" /> 是類別，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3608">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3609">這個屬性會傳回`true`類別，以及委派。</span><span class="sxs-lookup"><span data-stu-id="b1857-3609">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="b1857-3610">它會傳回`false`實值型別 （適用於結構和列舉型別） 即使 boxing 處理。</span><span class="sxs-lookup"><span data-stu-id="b1857-3610">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="b1857-3611">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`true`。如果目前<xref:System.Type>代表建構的泛型型別，這個屬性會傳回`true`如果泛型類型定義為類別定義; 也就是說，它不會定義介面或實值類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3612">這個屬性會傳回`true`如`Type`執行個體表示<xref:System.Enum>和<xref:System.ValueType>類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3612">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="b1857-3613">這兩個類別列舉的基底類型和實值類型，分別是，但不是列舉型別或值型別本身。</span><span class="sxs-lookup"><span data-stu-id="b1857-3613">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="b1857-3614">如需詳細資訊，請參閱<xref:System.Type.IsValueType%2A>和<xref:System.Type.IsEnum%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3614">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="b1857-3615"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>列舉值區分型別宣告為類別或介面。不過，類別和實值類型會標示<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3615">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="b1857-3616">如果您在擷取值的型別屬性屬性然後使用<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>值，以判斷是否為類別，而不是實值類型的類型，您也必須呼叫<xref:System.Type.IsValueType%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3616">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="b1857-3617">如範例<xref:System.Reflection.TypeAttributes>列舉包含的其他資訊，以及 anexample。</span><span class="sxs-lookup"><span data-stu-id="b1857-3617">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="b1857-3618">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-3618">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3619">下列範例會建立類型的執行個體，並指出類型是否為類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3619">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3620">取得值，指出 <see cref="T:System.Type" /> 是否為 COM 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3620">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3621">如果 <see langword="true" /> 是 COM 物件，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3621">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3622">這個方法會傳回`false`的 COM 介面，因為它們不是物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3622">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="b1857-3623">可以由 Microsoft.NET Framework 物件實作 COM 介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-3623">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="b1857-3624">您也可以載入 COM 類別，並取得`Type`使用該 COM 類別的物件[Tlbimp.exe （類型程式庫匯入工具）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具。</span><span class="sxs-lookup"><span data-stu-id="b1857-3624">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="b1857-3625">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3625">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3626">例如，如果目前<xref:System.Type>代表`MyGenericType<int`> (`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3626">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3627">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3627">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3628">在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsCOMObject" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為 COM 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3628">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3629">如果 <see langword="true" /> 是 COM 物件，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3629">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3630">這個方法會傳回`false`的 COM 介面，因為它們不是物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3630">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="b1857-3631">可以由 Microsoft.NET Framework 物件實作 COM 介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-3631">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3632">取得值，指出這個物件是否表示建構的泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3632">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
          <span data-ttu-id="b1857-3633">您可以建立已建構之泛型類型的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3633">You can create instances of a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3634">如果這個物件代表建構的泛型類型，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3634">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3635">建構的泛型類型已明確提供給所有泛型型別參數的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3635">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="b1857-3636">它也稱為封閉泛型類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3636">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="b1857-3637">當這個屬性是`true`，您可以建立執行個體目前的類型; 當它是`false`，您不能。</span><span class="sxs-lookup"><span data-stu-id="b1857-3637">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3638">取得值，指出在內容中是否可以裝載 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3638">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3639">如果在內容中可以裝載 <see cref="T:System.Type" />，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3639">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3640">內容會攔截呼叫類別的成員，並強制執行原則會套用至類別，例如同步處理。</span><span class="sxs-lookup"><span data-stu-id="b1857-3640">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="b1857-3641">如需詳細遠端內容的詳細資訊，請參閱<xref:System.Runtime.Remoting.Contexts.Context>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3641">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="b1857-3642">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3642">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3643">下列範例會示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>屬性<xref:System.Type>類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3643">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="b1857-3644">它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3644">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3645">實作 <see cref="P:System.Type.IsContextful" /> 屬性並判斷在內容中是否可以裝載 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3645">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3646">如果在內容中可以裝載 <see cref="T:System.Type" />，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3646">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3647">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3647">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="b1857-3648">內容會攔截呼叫類別的成員，並強制執行原則會套用至類別，例如同步處理。</span><span class="sxs-lookup"><span data-stu-id="b1857-3648">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3649">下列範例會示範使用`IsContextfulImpl`方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3649">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3650">取得值，指出目前的 <see cref="T:System.Type" /> 是否表示列舉類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3650">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3651">如果目前 <see langword="true" /> 代表列舉，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3651">
              <see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3652">這個屬性會傳回`true`列舉型別，但不是適合用於<xref:System.Enum>型別本身。</span><span class="sxs-lookup"><span data-stu-id="b1857-3652">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="b1857-3653">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3653">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3654">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3654">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3655">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3655">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3656">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-3656">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3657">下列範例示範如何使用`IsEnum`屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3657">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b1857-3658">要測試的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3658">The value to be tested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3659">傳回值，這個值表示指定的值是否存在於目前的列舉類型中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3659">Returns a value that indicates whether the specified value exists in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3660">如果指定的值是目前列舉型別的成員，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3660">
              <see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-3661">目前的類型不是列舉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3661">The current type is not an enumeration.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-3662">
            <paramref name="value" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3662">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-3663">
            <paramref name="value" /> 屬於的型別不得為列舉的基礎型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3663">
              <paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="b1857-3664">進行測試以確定是否和目前類型等價的 COM 類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3664">The COM type that is tested for equivalence with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3665">判斷兩個 COM 類型是否具有相同的識別以及是否適合類型等價。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3665">Determines whether two COM types have the same identity and are eligible for type equivalence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3666">如果 COM 類型相等，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3666">
              <see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="b1857-3667">如果一個類型位於已載入來執行的組件中，而另一個類型位於已載入至純反映性的內容的組件中，這個方法也會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3667">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3668">開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，通用語言執行平台支援的 managed 組件，而不需要 managed 組件，以取得 interop 從 COM 類型的型別資訊直接將 COM 類型的類型資訊內嵌組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3668">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="b1857-3669">因為內嵌類型資訊僅包含 Managed 組件實際所使用的類型和成員，所以兩個 Managed 組件可能對於相同的 COM 類型會有非常不同的檢視。</span><span class="sxs-lookup"><span data-stu-id="b1857-3669">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="b1857-3670">每個 Managed 組件有不同的 <xref:System.Type> 物件以代表其 COM 類型檢視。</span><span class="sxs-lookup"><span data-stu-id="b1857-3670">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="b1857-3671">通用語言執行平台支援介面、結構、列舉和委派等這些不同檢視之間的類型等價。</span><span class="sxs-lookup"><span data-stu-id="b1857-3671">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="b1857-3672">類型等價表示從一個 Managed 組件傳到另一個的 COM 物件，可以在接收的組件中轉換成適當的 Managed 類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3672">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="b1857-3673"><xref:System.Type.IsEquivalentTo%2A>方法可讓以判斷 COM 物件取得另一個組件具有相同的 COM 識別做為第一個組件的自己內嵌 interop 類型，其中的組件，因此可以轉換成該類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3673">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="b1857-3674">如需詳細資訊，請參閱[類型等價和內嵌 Interop 類型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3674">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3675">取得表示目前類型的欄位是否已在明確指定之位移配置版面的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3675">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3676">如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3676">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3677">為了方便起見，已提供這個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3677">This property is provided as a convenience.</span></span> <span data-ttu-id="b1857-3678">或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取型別配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>設定。</span><span class="sxs-lookup"><span data-stu-id="b1857-3678">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="b1857-3679"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>， <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值會指出類型的欄位配置記憶體中的方式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3679">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="b1857-3680">動態類型，您可以指定<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>當您建立的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3680">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="b1857-3681">在程式碼，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性附帶<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>的型別，來指定欄位開始的位移會明確指定的列舉值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3681">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3682">您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3682">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="b1857-3683">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3683">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3684">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3684">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3685">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3685">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3686">下列範例會建立類型的執行個體，並顯示的值及其<xref:System.Type.IsExplicitLayout%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3686">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="b1857-3687">它會使用`MySystemTime`類別，這也是在程式碼範例中為<xref:System.Runtime.InteropServices.StructLayoutAttribute>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3687">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3688">取得值，指出目前的 <see cref="T:System.Type" /> 是否表示泛型類型或泛型方法定義中的類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3688">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3689">如果 <see cref="T:System.Type" /> 物件表示泛型型別或泛型方法定義中的型別參數，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3689">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3690"><xref:System.Type> 您可以取得物件，代表泛型型別參數呼叫<xref:System.Type.GetGenericArguments%2A>方法<xref:System.Type>物件，代表泛型類型定義，或<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>方法<xref:System.Reflection.MethodInfo>物件，代表泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3690"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="b1857-3691">泛型類型或方法定義<xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`結果陣列的每一個元素。</span><span class="sxs-lookup"><span data-stu-id="b1857-3691">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="b1857-3692">封閉式建構的類型或方法，如<xref:System.Type.IsGenericParameter%2A>屬性會傳回`false`所傳回之陣列的每個項目的<xref:System.Type.GetGenericArguments%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3692">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="b1857-3693">對於開放式建構的類型或方法，陣列的某些項目可能是特定類型，而且其他人可能型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3693">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="b1857-3694"><xref:System.Type.IsGenericParameter%2A> 傳回`false`類型和`true`的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3694"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="b1857-3695">程式碼範例<xref:System.Type.ContainsGenericParameters%2A>屬性示範具有混合型別與型別參數的泛型類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3695">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="b1857-3696">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。</span><span class="sxs-lookup"><span data-stu-id="b1857-3696">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3697">下列範例會使用<xref:System.Type.IsGenericParameter%2A>以測試是否為泛型類型的泛型型別參數的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3697">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3698">取得值，指出目前類型是否為泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3698">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3699">
            <see langword="true" /> 如果目前的類型是泛型型別。否則， <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3699">
              <see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3700">使用<xref:System.Type.IsGenericType%2A>屬性來判斷是否<xref:System.Type>物件代表泛型類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3700">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="b1857-3701">使用<xref:System.Type.ContainsGenericParameters%2A>屬性來判斷是否<xref:System.Type>物件都代表開放式建構的類型或封閉式的建構的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3701">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3702"><xref:System.Type.IsGenericType%2A>屬性會傳回`false`如果立即的型別不是泛型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3702">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="b1857-3703">例如，其項目屬於型別陣列`A<int>`(`A(Of Integer)`在 Visual Basic 中) 是本身不是泛型類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3703">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="b1857-3704">下表摘要說明在反映中泛型使用的通用詞彙的非變異條件。</span><span class="sxs-lookup"><span data-stu-id="b1857-3704">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="b1857-3705">詞彙</span><span class="sxs-lookup"><span data-stu-id="b1857-3705">Term</span></span>|<span data-ttu-id="b1857-3706">非變異值</span><span class="sxs-lookup"><span data-stu-id="b1857-3706">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="b1857-3707">Generic Type Definition - 泛型類型定義</span><span class="sxs-lookup"><span data-stu-id="b1857-3707">generic type definition</span></span>|<span data-ttu-id="b1857-3708"><xref:System.Type.IsGenericTypeDefinition%2A> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3708">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3709">定義泛型類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3709">Defines a generic type.</span></span> <span data-ttu-id="b1857-3710">建構的類型由呼叫<xref:System.Type.MakeGenericType%2A>方法<xref:System.Type>物件，代表泛型類型定義，並指定型別引數的陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-3710">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="b1857-3711"><xref:System.Type.MakeGenericType%2A> 只有在泛型類型定義上，可以被呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1857-3711"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="b1857-3712">任何泛型類型定義為泛型類型 (<xref:System.Type.IsGenericType%2A>屬性是`true`)，但反之不然，則為 true。</span><span class="sxs-lookup"><span data-stu-id="b1857-3712">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="b1857-3713">Generic Type - 泛型類型</span><span class="sxs-lookup"><span data-stu-id="b1857-3713">generic type</span></span>|<span data-ttu-id="b1857-3714"><xref:System.Type.IsGenericType%2A> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3714">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3715">可以是泛型類型定義、 開放式建構的類型或封閉式的建構的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3715">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="b1857-3716">請注意，陣列類型的項目型別為泛型本身並不是泛型型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3716">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="b1857-3717">也是如此的<xref:System.Type>物件，代表泛型類型的指標。</span><span class="sxs-lookup"><span data-stu-id="b1857-3717">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="b1857-3718">開放式建構的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-3718">open constructed type</span></span>|<span data-ttu-id="b1857-3719"><xref:System.Type.ContainsGenericParameters%2A> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3719">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3720">範例包括有未指派的型別參數的泛型型別、 開放式建構類型，或泛型類型定義中巢狀類型或泛型類型具有其型別引數<xref:System.Type.ContainsGenericParameters%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3720">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3721">您不可能建立開放式建構類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b1857-3721">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="b1857-3722">請注意，並非所有開放式建構的類型的泛型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3722">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="b1857-3723">例如，其項目類型是泛型類型定義陣列不是泛型，而開放式建構類型的指標不是泛型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3723">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="b1857-3724">封閉式建構的類型</span><span class="sxs-lookup"><span data-stu-id="b1857-3724">closed constructed type</span></span>|<span data-ttu-id="b1857-3725"><xref:System.Type.ContainsGenericParameters%2A> 屬性為 `false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3725">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="b1857-3726">當遞迴檢查，型別沒有任何未指派的泛型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3726">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="b1857-3727">Generic Type Parameter - 泛型型別參數</span><span class="sxs-lookup"><span data-stu-id="b1857-3727">generic type parameter</span></span>|<span data-ttu-id="b1857-3728"><xref:System.Type.IsGenericParameter%2A> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3728">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3729"><xref:System.Type.ContainsGenericParameters%2A> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3729">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3730">在泛型類型定義中，將於之後指定類型的預留位置。</span><span class="sxs-lookup"><span data-stu-id="b1857-3730">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="b1857-3731">Generic Type Argument - 泛型類型引數</span><span class="sxs-lookup"><span data-stu-id="b1857-3731">generic type argument</span></span>|<span data-ttu-id="b1857-3732">可以是任何類型，包括泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3732">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="b1857-3733">型別引數所指定的陣列為<xref:System.Type>物件傳遞至<xref:System.Type.MakeGenericType%2A>方法建立已建構的泛型型別時。</span><span class="sxs-lookup"><span data-stu-id="b1857-3733">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="b1857-3734">如果執行個體的產生的型別建立，<xref:System.Type.ContainsGenericParameters%2A>屬性必須是`false`所有型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3734">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="b1857-3735">下列程式碼範例及下表說明部分這些條款及非變異值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3735">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="b1857-3736">`Derived`類別是特別感興趣的因為其基底類型是具有型別和型別參數的混合，其型別引數清單中的建構的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3736">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="b1857-3737">下表顯示範例會使用的類別上建立`Base`， `Derived`，和`G`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3737">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="b1857-3738">當 c + + 和 C# 程式碼都相同時，則會顯示只有一個項目。</span><span class="sxs-lookup"><span data-stu-id="b1857-3738">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="b1857-3739">範例</span><span class="sxs-lookup"><span data-stu-id="b1857-3739">Example</span></span>|<span data-ttu-id="b1857-3740">非變異值</span><span class="sxs-lookup"><span data-stu-id="b1857-3740">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="b1857-3741">此型別：</span><span class="sxs-lookup"><span data-stu-id="b1857-3741">For this type:</span></span><br /><br /> <span data-ttu-id="b1857-3742"><xref:System.Type.IsGenericType%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3742"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3743"><xref:System.Type.IsGenericTypeDefinition%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3743"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3744"><xref:System.Type.ContainsGenericParameters%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3744"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="b1857-3745">此型別：</span><span class="sxs-lookup"><span data-stu-id="b1857-3745">For this type:</span></span><br /><br /> <span data-ttu-id="b1857-3746"><xref:System.Type.IsGenericType%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3746"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3747"><xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3747"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="b1857-3748"><xref:System.Type.ContainsGenericParameters%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3748"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="b1857-3749">類型的變數`d`:</span><span class="sxs-lookup"><span data-stu-id="b1857-3749">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="b1857-3750"><xref:System.Type.IsGenericType%2A> 是`false`因為`d`是陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-3750"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="b1857-3751"><xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3751"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="b1857-3752"><xref:System.Type.ContainsGenericParameters%2A> 為 `false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3752"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="b1857-3753">`T``U`，和`V`（everywhere 它們會顯示）</span><span class="sxs-lookup"><span data-stu-id="b1857-3753">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="b1857-3754"><xref:System.Type.IsGenericParameter%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3754"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3755"><xref:System.Type.IsGenericType%2A> 是`false`因為沒有任何方法來限制泛型類型的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3755"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="b1857-3756"><xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3756"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="b1857-3757"><xref:System.Type.ContainsGenericParameters%2A> 是`true`因為`T`， `U`，和`V`本身也是泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3757"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="b1857-3758">這不表示任何關於稍後指派給它們的型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3758">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="b1857-3759">欄位的類型 `F`</span><span class="sxs-lookup"><span data-stu-id="b1857-3759">The type of field `F`</span></span>|<span data-ttu-id="b1857-3760"><xref:System.Type.IsGenericType%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3760"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="b1857-3761"><xref:System.Type.IsGenericTypeDefinition%2A> 是`false`因為型別已被指派至類型參數的`G`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3761"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="b1857-3762">請注意，這相當於呼叫<xref:System.Type.MakeGenericType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3762">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="b1857-3763"><xref:System.Type.ContainsGenericParameters%2A> 是`true`因為欄位的型別`F`已是開放式建構的類型的型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3763"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="b1857-3764">建構的類型為開放式因為其型別引數 (也就是`Base`) 是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3764">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="b1857-3765">下列說明處理遞迴性質<xref:System.Type.IsGenericType%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3765">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="b1857-3766">巢狀的類別 `Nested`</span><span class="sxs-lookup"><span data-stu-id="b1857-3766">The nested class `Nested`</span></span>|<span data-ttu-id="b1857-3767"><xref:System.Type.IsGenericType%2A> 是`true`，即使`Nested`類別具有自己的任何泛型類型參數，因為它巢狀在泛型型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3767"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="b1857-3768"><xref:System.Type.IsGenericTypeDefinition%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3768"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="b1857-3769">也就是說，您可以呼叫<xref:System.Type.MakeGenericType%2A>方法並提供封入類型的型別參數`Derived`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3769">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="b1857-3770"><xref:System.Type.ContainsGenericParameters%2A> 是`true`封入類型，因為`Derived`，泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-3770"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="b1857-3771">下列說明處理遞迴性質<xref:System.Type.ContainsGenericParameters%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3771">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3772">下列程式碼範例顯示的值<xref:System.Type.IsGenericType%2A>， <xref:System.Type.IsGenericTypeDefinition%2A>， <xref:System.Type.IsGenericParameter%2A>，和<xref:System.Type.ContainsGenericParameters%2A>< 備註 > 一節所述之類型的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3772">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="b1857-3773">屬性值的說明，請參閱 < 備註 > 中的表格。</span><span class="sxs-lookup"><span data-stu-id="b1857-3773">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3774">取得值，指出目前的 <see cref="T:System.Type" /> 是否表示可用於建構其他泛型類型的泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3774">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3775">如果 <see langword="true" /> 物件表示泛型類型定義，則為 <see cref="T:System.Type" />否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3775">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3776">泛型類型定義是用於建構其他類型的範本。</span><span class="sxs-lookup"><span data-stu-id="b1857-3776">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="b1857-3777">例如，從泛型類型定義`G<T>`（以表示 C# 語法。`G(Of T)`在 Visual Basic 或`generic <typename T> ref class G`c + + 中) 您可以建構並具現化類型`G<int>`(`G(Of Integer)`在 Visual Basic 中)，藉由呼叫<xref:System.Type.MakeGenericType%2A>與包含泛型引數清單的方法<xref:System.Int32>型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3777">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="b1857-3778">指定<xref:System.Type>物件，代表這個建構的型別，<xref:System.Type.GetGenericTypeDefinition%2A>方法會取得泛型類型定義傳回一次。</span><span class="sxs-lookup"><span data-stu-id="b1857-3778">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="b1857-3779">使用<xref:System.Type.IsGenericTypeDefinition%2A>屬性來判斷您是否可以從目前的型別來建立新的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3779">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="b1857-3780">如果<xref:System.Type.IsGenericTypeDefinition%2A>屬性會傳回`true`，您可以呼叫<xref:System.Type.MakeGenericType%2A>方法來建立新的泛型型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3780">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="b1857-3781">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。</span><span class="sxs-lookup"><span data-stu-id="b1857-3781">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3782">下列範例會顯示類型，包括這是泛型類型定義的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="b1857-3782">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="b1857-3783">建構的類型、 其泛型型別定義，以及一般型別，會顯示資訊。</span><span class="sxs-lookup"><span data-stu-id="b1857-3783">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3784">取得值，指出 <see cref="T:System.Type" /> 是否套用了 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 屬性 (Attribute)，亦即其是否從 COM 類型程式庫匯入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3784">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3785">如果 <see langword="true" /> 具有 <see cref="T:System.Type" />，則為 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3785">
              <see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3786">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3786">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3787">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由 `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="b1857-3787">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="b1857-3788">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3788">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="b1857-3789">要與目前的類型比較的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3789">The object to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-3790">判斷指定的物件是否為目前 <see cref="T:System.Type" /> 的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3790">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3791">如果在目前 <see langword="Type" /> 位於 <paramref name="o" /> 所代表之物件的階層架構中，或者目前 <see langword="Type" /> 位於 <paramref name="o" /> 支援的介面中，則為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3791">
              <see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span>
          </span>
          <span data-ttu-id="b1857-3792">如果都不是這些情況，或者如果 <paramref name="o" /> 為 <see langword="null" />，又或者如果目前 <see langword="Type" /> 為開放式泛型類型 (亦即 <see cref="P:System.Type.ContainsGenericParameters" /> 會傳回 <see langword="true" />)，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3792">
              <see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3793">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3793">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3794">建構的類型不是其泛型型別定義的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b1857-3794">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="b1857-3795">也就是說， `MyGenericList<int>` (`MyGenericList(Of Integer)`在 Visual Basic 中) 不是執行個體的`MyGenericList<T>`(`MyGenericList(Of T)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3795">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3796">下列範例示範 `IsInstanceOfType` 方法的用法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3796">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3797">取得值，指出 <see cref="T:System.Type" /> 是否為介面；也就是說，不是類別或實值類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3797">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3798">如果 <see langword="true" /> 是介面，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3798">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3799"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask>區分型別宣告為類別、 介面或實值類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3799">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="b1857-3800">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3800">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3801">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-3801">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3802">下列範例會建立一個介面、 檢查介面類型，並指出類別是否具有`IsInterface`屬性集。</span><span class="sxs-lookup"><span data-stu-id="b1857-3802">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3803">取得表示目前類型的欄位是否已依為其定義或發出至中繼資料之順序，循序配置版面的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3803">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3804">如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3804">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3805">為了方便起見，已提供這個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3805">This property is provided as a convenience.</span></span> <span data-ttu-id="b1857-3806">或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取型別配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>設定。</span><span class="sxs-lookup"><span data-stu-id="b1857-3806">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="b1857-3807"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>， <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值會指出類型的欄位配置記憶體中的方式。</span><span class="sxs-lookup"><span data-stu-id="b1857-3807">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="b1857-3808">動態類型，您可以指定<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>當您建立的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3808">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="b1857-3809">在程式碼，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性附帶<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>的型別，以指定該版面配置是循序的列舉值。</span><span class="sxs-lookup"><span data-stu-id="b1857-3809">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3810">您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3810">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="b1857-3811">如需詳細資訊，請參閱章節 9.1.2 通用語言基礎結構 (CLI) 文件 < 磁碟分割第二部分： 中繼資料定義和語意 > 規格。</span><span class="sxs-lookup"><span data-stu-id="b1857-3811">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="b1857-3812">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3812">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="b1857-3813">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3813">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3814">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3814">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3815">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3815">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3816">下列範例會建立類別的執行個體的<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>中的列舉值<xref:System.Runtime.InteropServices.StructLayoutAttribute>類別已設定，會檢查是否有<xref:System.Type.IsLayoutSequential%2A>屬性，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="b1857-3816">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3817">取得值，指出 <see cref="T:System.Type" /> 是否以傳址方式封送處理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3817">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3818">如果 <see langword="true" /> 是以傳址方式進行封送處理，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3818">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b1857-3819">下列範例會示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>屬性<xref:System.Type>類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3819">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="b1857-3820">它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3820">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3821">實作 <see cref="P:System.Type.IsMarshalByRef" /> 屬性，判斷 <see cref="T:System.Type" /> 是否以傳址方式封送處理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3821">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3822">如果 <see langword="true" /> 是以傳址方式進行封送處理，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3822">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3823">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-3823">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3824">下列範例會判斷是否會依參考封送處理指定的型別，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="b1857-3824">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3825">取得值，表示目前的 <see cref="T:System.Type" /> 物件代表的類型之定義是否位於另一個類型的定義內部。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3825">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3826">如果 <see langword="true" /> 巢狀於另一個類型中，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3826">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3827"><xref:System.Type.IsNested%2A>屬性會傳回`true`所有巢狀類型，不論可見性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3827">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="b1857-3828">若要同時測試巢狀結構和可見性，使用 相關的屬性<xref:System.Type.IsNestedAssembly%2A>， <xref:System.Type.IsNestedFamily%2A>， <xref:System.Type.IsNestedFamANDAssem%2A>， <xref:System.Type.IsNestedFamORAssem%2A>， <xref:System.Type.IsNestedPrivate%2A>，或<xref:System.Type.IsNestedPublic%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3828">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3829"><xref:System.Reflection.TypeAttributes.VisibilityMask>列舉成員選取類型的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3829">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3830">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-3830">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="b1857-3831">然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3831">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3832">取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只在它自己的組件內為可見。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3832">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3833">如果 <see langword="true" /> 是巢狀並只在它自己的組件內為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3833">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3834">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3834">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3835"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3835"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3836">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-3836">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="b1857-3837">然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3837">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3838">取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只對同時屬於它自己家族和它自己組件的類別為可見。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3838">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3839">如果 <see cref="T:System.Type" /> 是巢狀並只對同時屬於它自己家族和它自己組件的類別為可見，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3839">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3840">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3840">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3841"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3841"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-3842">C# 和 Visual Basic 語言不包含可讓您定義的巢狀的類型，是只在它自己組件中受保護的類型為可見的語意。</span><span class="sxs-lookup"><span data-stu-id="b1857-3842">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="b1857-3843">`protected internal` 在 C# 中的可見性和`Protected Friend`可見性，在 Visual Basic 中的定義的巢狀的類型，會顯示受保護的類型和相同的組件中的型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3843">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="b1857-3844">A<xref:System.Type>物件的系列會定義為相同的所有物件<xref:System.Type>和及其子型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3844">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3845">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-3845">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="b1857-3846">然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3846">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3847">取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只在它自己的系列內為可見。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3847">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3848">如果 <see langword="true" /> 是巢狀並只在它自己的家族內為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3848">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3849">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3849">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3850"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3850"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="b1857-3851">A<xref:System.Type>物件的系列定義為所有物件的完全相同<xref:System.Type>和及其子型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3851">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3852">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-3852">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="b1857-3853">然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3853">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3854">取得值，指出 <see cref="T:System.Type" /> 是否為巢狀並只對屬於它自己家族或它自己組件的類別為可見。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3854">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3855">如果 <see langword="true" /> 是巢狀並只對屬於它自己家族或它自己組件的類別為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3855">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3856">如果類型的可見性會`protected internal`在 C# 或`Protected Friend`在 Visual Basic 中<xref:System.Type.IsNestedFamORAssem%2A>屬性會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3856">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="b1857-3857">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3857">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="b1857-3859">A<xref:System.Type>物件的系列定義為所有物件的完全相同<xref:System.Type>和及其子型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3859">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3860">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-3860">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="b1857-3861">然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3861">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3862">取得值，指出 <see cref="T:System.Type" /> 是否為巢狀並且宣告為私用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3862">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3863">如果 <see langword="true" /> 是巢狀並且宣告為私用，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3863">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3864">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3864">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3865"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3865"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3866">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-3866">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="b1857-3867">然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3867">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3868">取得值，指出類別是否為巢狀 (Nest) 並且宣告為公用 (Public)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3868">Gets a value indicating whether a class is nested and declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3869">如果類別是巢狀並且宣告為公用，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3869">
              <see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3870">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3870">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3871"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3871"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3872">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</span><span class="sxs-lookup"><span data-stu-id="b1857-3872">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="b1857-3873">然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3873">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3874">取得值，指出 <see cref="T:System.Type" /> 是否未宣告為公用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3874">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3875">如果 <see langword="true" /> 尚未宣告為公用而且不是巢狀類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3875">
              <see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3876">請勿使用這個屬性與巢狀類型;使用<xref:System.Type.IsNestedPublic%2A>屬性改為。</span><span class="sxs-lookup"><span data-stu-id="b1857-3876">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="b1857-3877">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3877">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3878">此範例用途`IsNotPublic`来取得之類型的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3878">This example usesthe `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="b1857-3879">下列程式碼範例示範為何無法使用`IsPublic`和`IsNotPublic`巢狀類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3879">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="b1857-3880">巢狀類別，略過的結果`IsPublic`和`IsNotPublic`和結果的注意`IsNestedPublic`和`IsNestedPrivate`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3880">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="b1857-3881">此程式碼片段的反映輸出應如下所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-3881">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="b1857-3882">類別</span><span class="sxs-lookup"><span data-stu-id="b1857-3882">Class</span></span>|<span data-ttu-id="b1857-3883">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="b1857-3883">IsNotPublic</span></span>|<span data-ttu-id="b1857-3884">IsPublic</span><span class="sxs-lookup"><span data-stu-id="b1857-3884">IsPublic</span></span>|<span data-ttu-id="b1857-3885">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="b1857-3885">IsNestedPublic</span></span>|<span data-ttu-id="b1857-3886">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="b1857-3886">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="b1857-3887">A</span><span class="sxs-lookup"><span data-stu-id="b1857-3887">A</span></span>|<span data-ttu-id="b1857-3888">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3888">FALSE</span></span>|<span data-ttu-id="b1857-3889">true</span><span class="sxs-lookup"><span data-stu-id="b1857-3889">TRUE</span></span>|<span data-ttu-id="b1857-3890">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3890">FALSE</span></span>|<span data-ttu-id="b1857-3891">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3891">FALSE</span></span>|  
|<span data-ttu-id="b1857-3892">B</span><span class="sxs-lookup"><span data-stu-id="b1857-3892">B</span></span>|<span data-ttu-id="b1857-3893">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3893">FALSE</span></span>|<span data-ttu-id="b1857-3894">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3894">FALSE</span></span>|<span data-ttu-id="b1857-3895">true</span><span class="sxs-lookup"><span data-stu-id="b1857-3895">TRUE</span></span>|<span data-ttu-id="b1857-3896">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3896">FALSE</span></span>|  
|<span data-ttu-id="b1857-3897">C</span><span class="sxs-lookup"><span data-stu-id="b1857-3897">C</span></span>|<span data-ttu-id="b1857-3898">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3898">FALSE</span></span>|<span data-ttu-id="b1857-3899">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3899">FALSE</span></span>|<span data-ttu-id="b1857-3900">false</span><span class="sxs-lookup"><span data-stu-id="b1857-3900">FALSE</span></span>|<span data-ttu-id="b1857-3901">true</span><span class="sxs-lookup"><span data-stu-id="b1857-3901">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3902">取得值，指出 <see cref="T:System.Type" /> 是否為指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3902">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3903">如果 <see cref="T:System.Type" /> 是指標，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3903">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3904">如果目前<xref:System.Type>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3904">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="b1857-3905">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-3905">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3906">下列範例會示範搭配`IsPointer`屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3906">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3907">在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsPointer" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3907">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3908">如果 <see cref="T:System.Type" /> 是指標，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3908">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3909">取得值，指出 <see cref="T:System.Type" /> 是否為其中一個基本類型 (Primitive Type)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3909">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3910">如果 <see langword="true" /> 是其中一個基本類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3910">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3911">基本類型為<xref:System.Boolean>， <xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.IntPtr>， <xref:System.UIntPtr>， <xref:System.Char>，<xref:System.Double>，和<xref:System.Single>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3911">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="b1857-3912">如果目前<xref:System.Type>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3912">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3913">下列範例會示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>屬性<xref:System.Type>類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-3913">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="b1857-3914">它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3914">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3915">在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsPrimitive" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為其中一個基本類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3915">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-3916">如果 <see langword="true" /> 是其中一個基本類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3916">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3917">基本類型為<xref:System.Boolean>， <xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.Char>， <xref:System.Double>，和<xref:System.Single>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3917">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3918">下列範例會判斷指定的型別是否為基本類型，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="b1857-3918">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3919">取得值，指出 <see cref="T:System.Type" /> 是否宣告為公用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3919">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3920">如果 <see langword="true" /> 已宣告為公用而且不是巢狀類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3920">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3921">請勿使用巢狀型別。使用<xref:System.Type.IsNestedPublic%2A>改為。</span><span class="sxs-lookup"><span data-stu-id="b1857-3921">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="b1857-3922">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3922">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="b1857-3923"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3923"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3924">下列範例會建立的執行個體`MyTestClass`，檢查是否有`IsPublic`屬性，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="b1857-3924">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="b1857-3925">巢狀類別，略過的結果`IsPublic`和`IsNotPublic`和結果的注意<xref:System.Type.IsNestedPublic%2A>和<xref:System.Type.IsNestedPrivate%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3925">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3926">取得值，指出 <see cref="T:System.Type" /> 是否宣告為密封。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3926">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3927">如果 <see langword="true" /> 宣告為密封，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3927">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3928">如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3928">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3929">下列範例會建立的執行個體`sealed`類別，檢查有無`IsSealed`屬性，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="b1857-3929">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3930">取得值，這個值表示目前類型在目前信任層級上是否為安全性關鍵或安全性安全關鍵，因而可以執行重要的作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3930">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3931">如果目前類型在目前信任層級上為安全性關鍵或安全性安全關鍵，則為 <see langword="true" />，如果是安全性透明，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3931">
              <see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3932"><xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。</span><span class="sxs-lookup"><span data-stu-id="b1857-3932">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="b1857-3933">這些屬性的組合是下表所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-3933">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="b1857-3934">安全性層級</span><span class="sxs-lookup"><span data-stu-id="b1857-3934">Security level</span></span>|<span data-ttu-id="b1857-3935">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="b1857-3935">IsSecurityCritical</span></span>|<span data-ttu-id="b1857-3936">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="b1857-3936">IsSecuritySafeCritical</span></span>|<span data-ttu-id="b1857-3937">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="b1857-3937">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="b1857-3938">Critical</span><span class="sxs-lookup"><span data-stu-id="b1857-3938">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="b1857-3939">安全關鍵</span><span class="sxs-lookup"><span data-stu-id="b1857-3939">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="b1857-3940">透明</span><span class="sxs-lookup"><span data-stu-id="b1857-3940">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="b1857-3941">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="b1857-3941">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b1857-3942">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-3942">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="b1857-3943">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。</span><span class="sxs-lookup"><span data-stu-id="b1857-3943">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="b1857-3944">組件和其所有類型都視為透明的。</span><span class="sxs-lookup"><span data-stu-id="b1857-3944">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="b1857-3945">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</span><span class="sxs-lookup"><span data-stu-id="b1857-3945">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="b1857-3946">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</span><span class="sxs-lookup"><span data-stu-id="b1857-3946">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="b1857-3947">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3947">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="b1857-3948">如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3948">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="b1857-3949">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3949">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3950">取得值，這個值表示目前類型在目前信任層級上是否為安全性安全關鍵，也就是說，它是否能執行重要作業並由安全性透明的程式碼存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3950">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3951">如果目前類型在目前信任層級上為安全性安全關鍵，則為 <see langword="true" />；如果為安全性關鍵或安全性透明，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3951">
              <see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3952"><xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。</span><span class="sxs-lookup"><span data-stu-id="b1857-3952">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="b1857-3953">這些屬性的組合是下表所示：</span><span class="sxs-lookup"><span data-stu-id="b1857-3953">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="b1857-3954">安全性層級</span><span class="sxs-lookup"><span data-stu-id="b1857-3954">Security level</span></span>|<span data-ttu-id="b1857-3955">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="b1857-3955">IsSecurityCritical</span></span>|<span data-ttu-id="b1857-3956">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="b1857-3956">IsSecuritySafeCritical</span></span>|<span data-ttu-id="b1857-3957">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="b1857-3957">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="b1857-3958">Critical</span><span class="sxs-lookup"><span data-stu-id="b1857-3958">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="b1857-3959">安全關鍵</span><span class="sxs-lookup"><span data-stu-id="b1857-3959">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="b1857-3960">透明</span><span class="sxs-lookup"><span data-stu-id="b1857-3960">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="b1857-3961">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="b1857-3961">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b1857-3962">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-3962">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="b1857-3963">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。</span><span class="sxs-lookup"><span data-stu-id="b1857-3963">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="b1857-3964">組件和其所有類型都視為透明的。</span><span class="sxs-lookup"><span data-stu-id="b1857-3964">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="b1857-3965">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</span><span class="sxs-lookup"><span data-stu-id="b1857-3965">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="b1857-3966">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</span><span class="sxs-lookup"><span data-stu-id="b1857-3966">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="b1857-3967">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3967">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="b1857-3968">如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3968">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="b1857-3969">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3969">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3970">取得值，這個值表示目前類型在目前信任層級上是否為透明，因此無法執行重要作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3970">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3971">如果型別在目前信任層級上為安全性透明，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3971">
              <see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3972">如果這個屬性會傳回`true`、<xref:System.Type.IsSecurityCritical%2A>和<xref:System.Type.IsSecuritySafeCritical%2A>屬性傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3972">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="b1857-3973"><xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。</span><span class="sxs-lookup"><span data-stu-id="b1857-3973">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="b1857-3974">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="b1857-3974">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b1857-3975">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</span><span class="sxs-lookup"><span data-stu-id="b1857-3975">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="b1857-3976">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。</span><span class="sxs-lookup"><span data-stu-id="b1857-3976">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="b1857-3977">組件和其所有類型都視為透明的。</span><span class="sxs-lookup"><span data-stu-id="b1857-3977">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="b1857-3978">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</span><span class="sxs-lookup"><span data-stu-id="b1857-3978">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="b1857-3979">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</span><span class="sxs-lookup"><span data-stu-id="b1857-3979">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="b1857-3980">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-3980">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="b1857-3981">如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3981">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="b1857-3982">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3982">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3983">取得值，指出 <see cref="T:System.Type" /> 是否可序列化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3983">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3984">如果 <see cref="T:System.Type" /> 可序列化，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3984">
              <see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="b1857-3985">在.NET 標準所定義的類型未標示有<xref:System.SerializableAttribute>。</span><span class="sxs-lookup"><span data-stu-id="b1857-3985">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="b1857-3986">相反地，每個.NET 實作可決定是否可序列化類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-3986">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="b1857-3987">在執行階段，您可以使用<xref:System.Type.IsSerializable%2A>屬性來決定是否該實作會支援序列化之型別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b1857-3987">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="b1857-3988">如需詳細資訊和範例，請參閱[如何判斷是否可序列化的.NET 標準物件](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-3988">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="b1857-3989">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3989">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3990">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3990">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3991">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3991">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-3992">下列範例會建立的執行個體`MyTestClass`類別，設定 [Serializable] 屬性，並檢查`IsSerializable`屬性`true`或`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3992">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-3993">取得值，表示類型是否具有需要特殊處理的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3993">Gets a value indicating whether the type has a name that requires special handling.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-3994">如果類型具有需要特殊處理的名稱，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3994">
              <see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-3995">開頭或包含底線字元 (_)、 屬性存取子和運算子多載方法的名稱是由某些編譯器需要特殊處理的類型的範例。</span><span class="sxs-lookup"><span data-stu-id="b1857-3995">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="b1857-3996">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-3996">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-3997">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3997">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-3998">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-3998">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="b1857-3999">要與目前的類型比較的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-3999">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4000">判斷目前 <see cref="T:System.Type" /> 是否衍生自指定的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4000">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4001">如果目前 <see langword="true" /> 衍生自 <see langword="Type" />，則為 <paramref name="c" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4001">
              <see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="b1857-4002">如果 <see langword="false" /> 和目前 <paramref name="c" /> 相等，這個方法也會傳回 <see langword="Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4002">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4003">您可以呼叫<xref:System.Type.IsSubclassOf%2A>方法，以判斷下列任一項：</span><span class="sxs-lookup"><span data-stu-id="b1857-4003">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="b1857-4004">是否從另一個衍生一個類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4004">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="b1857-4005">型別是否衍生自<xref:System.ValueType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4005">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="b1857-4006">不過，<xref:System.Type.IsValueType%2A>是更有效率的方式來決定類型是否為實值類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4006">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="b1857-4007">型別是否衍生自<xref:System.Enum>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4007">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="b1857-4008">不過，<xref:System.Type.IsEnum%2A>方法是更有效率的方式來決定類型是否為列舉型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4008">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="b1857-4009">是否為型別是一種委派，也就是是否從它衍生<xref:System.Delegate>或<xref:System.MulticastDelegate>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4009">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="b1857-4010"><xref:System.Type.IsSubclassOf%2A>方法無法用來判斷是否介面衍生自另一個介面，或者類別是否實作介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-4010">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="b1857-4011">使用<xref:System.Type.IsAssignableFrom%2A>基於這個目的，如下列範例所示的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-4011">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="b1857-4012">如果目前<xref:System.Type>表示型別參數中的泛型類型或泛型方法定義，其衍生自其類別條件約束，或從<xref:System.Object?displayProperty=nameWithType>如果它沒有類別條件約束。</span><span class="sxs-lookup"><span data-stu-id="b1857-4012">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-4013">介面，搭配使用時，除非<xref:System.Type.IsSubclassOf%2A>是反向<xref:System.Type.IsAssignableFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4013">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="b1857-4014">也就是說，如果`t1.IsSubclassOf(t2)`是`true`，然後`t2.IsAssignableFrom(t1)`也`true`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4014">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="b1857-4015">在衍生類別可以覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-4015">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4016">下列範例會建立名為類別`Class1`和衍生的類別，名為`DerivedC1`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4016">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="b1857-4017">它會呼叫<xref:System.Type.IsSubclassOf%2A>方法，以顯示，`DerivedC1`是子類別的`Class1`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4017">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-4018">
            <paramref name="c" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4018">
              <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4019">取得值，指出是否為 <see langword="UnicodeClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4019">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4020">如果為 <see langword="true" /> 選取字串格式屬性 <see langword="UnicodeClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4020">
              <see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4021"><xref:System.Reflection.TypeAttributes.StringFormatMask>用來選取字串格式屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-4021">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="b1857-4022">字串格式屬性定義如何解譯字串增強互通性。</span><span class="sxs-lookup"><span data-stu-id="b1857-4022">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="b1857-4023">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-4023">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-4024">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4024">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-4025">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4025">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4026">取得值，指出 <see cref="T:System.Type" /> 是否為實值類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4026">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4027">如果 <see langword="true" /> 是實值類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4027">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4028">實值型別會表示為位元; 順序的型別實值類型不是類別或介面。</span><span class="sxs-lookup"><span data-stu-id="b1857-4028">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="b1857-4029">實值型別稱為 「 結構 」 中的某些程式設計語言。</span><span class="sxs-lookup"><span data-stu-id="b1857-4029">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="b1857-4030">列舉是特殊案例的實值類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4030">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="b1857-4031">這個屬性會傳回`false`如<xref:System.ValueType>類別，因為<xref:System.ValueType>不是實值型別本身。</span><span class="sxs-lookup"><span data-stu-id="b1857-4031">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="b1857-4032">它是所有的實值類型的基底類別，因此任何實值類型，可以指派給它。</span><span class="sxs-lookup"><span data-stu-id="b1857-4032">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="b1857-4033">這並不是可能如果<xref:System.ValueType>本身是實值類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4033">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="b1857-4034">會在指派給欄位的類型時，會進行 boxed 處理實值類型<xref:System.ValueType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4034">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="b1857-4035">這個屬性會傳回`true`列舉型別，但不是適合用於<xref:System.Enum>型別本身。</span><span class="sxs-lookup"><span data-stu-id="b1857-4035">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="b1857-4036">如需示範此行為的範例，請參閱<xref:System.Type.IsEnum%2A>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4036">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="b1857-4037">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b1857-4037">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4038">下列範例會建立類型的變數`MyEnum`，檢查是否有`IsValueType`屬性，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="b1857-4038">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4039">實作 <see cref="P:System.Type.IsValueType" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為實值類型；也就是說，不是類別或介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4039">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4040">如果 <see langword="true" /> 是實值類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4040">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4041">這個方法被提供來啟用其他的型別系統的實作。</span><span class="sxs-lookup"><span data-stu-id="b1857-4041">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="b1857-4042">它是不通常用於應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="b1857-4042">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4043">取得一個值，表示位於組件之外的程式碼是否能存取 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4043">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4044">如果目前 <see langword="true" /> 是公用類型或公用巢狀類型 (所有封入類型均為公用)，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4044">
              <see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4045">使用這個屬性來決定類型是否為公用介面的元件組件的一部分。</span><span class="sxs-lookup"><span data-stu-id="b1857-4045">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4046">下列程式碼範例會測試兩個類別，其中只有一個外部是可見的組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-4046">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4047">傳回代表目前類型之陣列的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4047">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4048">傳回 <see cref="T:System.Type" /> 物件，代表由目前類型組成的一維陣列，其下限為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4048">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4049">
            <see cref="T:System.Type" /> 物件，代表由目前類型組成的一維陣列，其下限為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4049">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4050"><xref:System.Type.MakeArrayType%2A>方法可用來產生執行階段計算其項目類型的陣列型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4050">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="b1857-4051">**請注意**common language runtime 會區別向量 （也就是一維陣列，都以零為起始） 和多維度陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-4051">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="b1857-4052">Vector 中，永遠只有一個維度，其不是剛好只有一個維度的多維陣列相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-4052">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="b1857-4053">這個方法多載只可用來建立的向量類型，這是唯一的方式建立的向量類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4053">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="b1857-4054">使用<xref:System.Type.MakeArrayType%28System.Int32%29>方法多載來建立多維陣列型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4054">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4055">下列程式碼範例會建立陣列， `ref` (`ByRef`在 Visual Basic 中)，以及指標的類型`Test`類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4055">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-4056">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4056">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="b1857-4057">衍生類別必須提供實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4057">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-4058">目前的類型為 <see cref="T:System.TypedReference" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4058">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="b1857-4059">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4059">-or-</span>
          </span>
          <span data-ttu-id="b1857-4060">目前的類型為 <see langword="ByRef" /> 類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4060">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="b1857-4061">亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4061">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="b1857-4062">陣列的維度數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4062">The number of dimensions for the array.</span>
          </span>
          <span data-ttu-id="b1857-4063">這個數字必須小於或等於 32。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4063">This number must be less than or equal to 32.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4064">傳回 <see cref="T:System.Type" /> 物件，代表由目前類型組成且為指定維度個數的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4064">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4065">物件，代表由目前類型組成且為指定維度個數的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4065">An object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4066"><xref:System.Type.MakeArrayType%2A>方法可用來產生執行階段計算其項目類型的陣列型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4066">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-4067">Common language runtime 會區別向量 （也就是一維陣列，都以零為起始） 和多維度陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-4067">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="b1857-4068">Vector 中，永遠只有一個維度，其不是剛好只有一個維度的多維陣列相同。</span><span class="sxs-lookup"><span data-stu-id="b1857-4068">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="b1857-4069">您無法使用這個方法多載來建立的向量類型。如果`rank`為 1，這個方法多載會傳回剛好有一個維度的多維陣列類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4069">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="b1857-4070">使用<xref:System.Type.MakeArrayType>方法多載來建立的向量類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4070">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4071">下列程式碼範例會建立陣列， `ref` (`ByRef`在 Visual Basic 中)，以及指標的類型`Test`類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4071">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="b1857-4072">
            <paramref name="rank" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4072">
              <paramref name="rank" /> is invalid.</span>
          </span>
          <span data-ttu-id="b1857-4073">例如，0 或負數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4073">For example, 0 or negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-4074">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4074">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-4075">目前的類型為 <see cref="T:System.TypedReference" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4075">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="b1857-4076">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4076">-or-</span>
          </span>
          <span data-ttu-id="b1857-4077">目前的類型為 <see langword="ByRef" /> 類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4077">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="b1857-4078">亦即，<see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4078">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
          <span data-ttu-id="b1857-4079">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4079">-or-</span>
          </span>
          <span data-ttu-id="b1857-4080">
            <paramref name="rank" /> 大於 32。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4080">
              <paramref name="rank" /> is greater than 32.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4081">傳回 <see cref="T:System.Type" /> 物件，當做 <see langword="ref" /> (Visual Basic 中的 <see langword="ByRef" />) 參數傳遞時，代表目前的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4081">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4082">
            <see cref="T:System.Type" /> 物件，當做 <see langword="ref" /> 參數 (在 Visual Basic 中為 <see langword="ByRef" /> 參數) 傳遞時，代表目前的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4082">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4083"><xref:System.Type.MakeByRefType%2A>方法可用來產生`ref`類型 (`ByRef`在 Visual Basic 中) 的參數清單。</span><span class="sxs-lookup"><span data-stu-id="b1857-4083">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="b1857-4084">如果使用的語法的 Microsoft 中繼語言 (MSIL)，目前<xref:System.Type>物件代表<xref:System.Int32>，這個方法會傳回<xref:System.Type>物件，代表`Int32&`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4084">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4085">下列程式碼範例會建立陣列， `ref` (`ByRef`在 Visual Basic 中)，以及指標的類型`Test`類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4085">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-4086">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4086">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-4087">目前的類型為 <see cref="T:System.TypedReference" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4087">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="b1857-4088">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4088">-or-</span>
          </span>
          <span data-ttu-id="b1857-4089">目前的類型為 <see langword="ByRef" /> 類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4089">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="b1857-4090">亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4090">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="b1857-4091">由類型組成的陣列，用來取代目前泛型類型的型別參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4091">An array of types to be substituted for the type parameters of the current generic type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4092">用類型陣列的項目取代目前泛型類型定義的類型參數，並傳回代表所得結果建構類型的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4092">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4093">
            <see cref="T:System.Type" />，表示用 <paramref name="typeArguments" /> 的項目取代目前泛型類型之類型參數所得到的建構類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4093">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4094"><xref:System.Type.MakeGenericType%2A>方法可讓您撰寫程式碼，將特定類型指派給類型參數的泛型類型定義，以便建立<xref:System.Type>物件，代表特定建構的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4094">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="b1857-4095">您可以使用這個<xref:System.Type>物件建立的建構類型的執行階段執行個體。</span><span class="sxs-lookup"><span data-stu-id="b1857-4095">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="b1857-4096">使用類型建構<xref:System.Type.MakeGenericType%2A>可以在開啟，也就是其類型引數部分可以是封入泛型方法或類型的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-4096">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="b1857-4097">發出動態組件時，您可以使用這類開放式建構的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4097">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="b1857-4098">例如，請考慮類別`Base`和`Derived`下列程式碼。</span><span class="sxs-lookup"><span data-stu-id="b1857-4098">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="b1857-4099">若要產生`Derived`在動態組件，就需要建構其基底類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4099">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="b1857-4100">若要這樣做，請呼叫<xref:System.Type.MakeGenericType%2A>方法<xref:System.Type>代表類別物件`Base`，使用泛型型別引數<xref:System.Int32>和型別參數`V`從`Derived`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4100">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="b1857-4101">因為型別和泛型型別參數都表示所<xref:System.Type>物件，包含這兩個陣列可以傳遞至<xref:System.Type.MakeGenericType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-4101">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-4102">建構的類型，例如`Base<int, V>`有用時發出程式碼，但您不能呼叫<xref:System.Type.MakeGenericType%2A>這個類型上的方法，所以不是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-4102">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="b1857-4103">若要建立封閉式的建構的類型可具現化，請先呼叫<xref:System.Type.GetGenericTypeDefinition%2A>方法來取得<xref:System.Type>物件，代表泛型類型定義，然後呼叫<xref:System.Type.MakeGenericType%2A>所需的型別引數。</span><span class="sxs-lookup"><span data-stu-id="b1857-4103">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="b1857-4104"><xref:System.Type>所傳回物件<xref:System.Type.MakeGenericType%2A>相同<xref:System.Type>藉由呼叫取得<xref:System.Object.GetType%2A>建構類型，所產生的方法或<xref:System.Object.GetType%2A>建構建立從相同泛型類型的任何的方法。使用相同的型別引數的型別定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-4104">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b1857-4105">泛型型別的陣列本身並不是泛型型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4105">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="b1857-4106">您不能呼叫<xref:System.Type.MakeGenericType%2A>陣列上輸入，例如`C<T>[]`(`Dim ac() As C(Of T)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-4106">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="b1857-4107">若要建構從封閉泛型類型`C<T>[]`，呼叫<xref:System.Type.GetElementType%2A>可取得泛型類型定義`C<T>`; 呼叫<xref:System.Type.MakeGenericType%2A>泛型類型定義，來建立建構的類型，最後呼叫<xref:System.Type.MakeArrayType%2A>方法要建立陣列類型的建構的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4107">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="b1857-4108">也是如此的指標類型和`ref`類型 (`ByRef`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="b1857-4108">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="b1857-4109">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。</span><span class="sxs-lookup"><span data-stu-id="b1857-4109">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="b1857-4110">巢狀類型</span><span class="sxs-lookup"><span data-stu-id="b1857-4110">Nested Types</span></span>  
 <span data-ttu-id="b1857-4111">如果使用 C#、 c + + 或 Visual Basic 定義泛型類型，其巢狀的類型是所有泛型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4111">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="b1857-4112">即使巢狀型別有沒有自己的型別參數，因為所有的三種語言包含巢狀類型的型別參數清單中封入類型的型別參數，也是如此。</span><span class="sxs-lookup"><span data-stu-id="b1857-4112">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="b1857-4113">請考慮下列類別：</span><span class="sxs-lookup"><span data-stu-id="b1857-4113">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="b1857-4114">巢狀類別的型別參數清單`Inner`有兩個類型參數，`T`和`U`，其中第一個是其封入類別的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-4114">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="b1857-4115">同樣地，巢狀類別的型別參數清單`Innermost1`有三個類型參數， `T`， `U`，和`V`，與`T`和`U`來自其封入類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4115">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="b1857-4116">巢狀的類別`Innermost2`有兩個類型參數，`T`和`U`，這是來自其封入類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4116">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="b1857-4117">如果封入類型的參數清單中有一個以上的型別參數，在順序中的所有型別參數會包含巢狀類型的型別參數清單中。</span><span class="sxs-lookup"><span data-stu-id="b1857-4117">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="b1857-4118">若要建構的泛型型別從巢狀類型的泛型類型定義，請呼叫<xref:System.Type.MakeGenericType%2A>與陣列方法形成串連在型別引數陣列的所有封入類型，最外層的泛型型別，開頭和結束必須有它自己的型別參數之型別本身的巢狀類型引數陣列。</span><span class="sxs-lookup"><span data-stu-id="b1857-4118">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="b1857-4119">若要建立的執行個體`Innermost1`，呼叫<xref:System.Type.MakeGenericType%2A>與陣列，其中包含要指派給 T、 U 和 V 的三種類型的方法。若要建立的執行個體`Innermost2`，呼叫<xref:System.Type.MakeGenericType%2A>方法的陣列，其中包含兩個型別，以指派給 T 和 u。</span><span class="sxs-lookup"><span data-stu-id="b1857-4119">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="b1857-4120">語言傳播以這種方式中封入類型，因此您可以使用以定義巢狀類型的欄位的封入類型的型別參數的型別參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-4120">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="b1857-4121">否則，型別參數不會有巢狀類型的主體內的範圍內。</span><span class="sxs-lookup"><span data-stu-id="b1857-4121">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="b1857-4122">可定義巢狀型別沒有傳播封入類型，透過發出動態組件中的程式碼或使用的型別參數[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-4122">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="b1857-4123">MSIL 組譯工具，請考慮下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="b1857-4123">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="b1857-4124">在此範例中，就不可以定義類型的欄位`T`或`U`類別中`Innermost`，因為這些型別參數不在範圍內。</span><span class="sxs-lookup"><span data-stu-id="b1857-4124">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="b1857-4125">下列的組譯工具程式碼定義的行為會在 c + +、 Visual Basic 和 C# 中定義的巢狀的類別：</span><span class="sxs-lookup"><span data-stu-id="b1857-4125">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="b1857-4126">您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)檢查高階語言中定義的巢狀的類別，並觀察這個命名配置。</span><span class="sxs-lookup"><span data-stu-id="b1857-4126">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4127">下列範例會使用<xref:System.Type.MakeGenericType%2A>方法來建立從泛型類型定義建構的型別<xref:System.Collections.Generic.Dictionary%602>型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4127">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="b1857-4128">建構的類型代表<xref:System.Collections.Generic.Dictionary%602>的`Test`字串索引鍵的物件。</span><span class="sxs-lookup"><span data-stu-id="b1857-4128">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b1857-4129">目前類型不代表泛型型別定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4129">The current type does not represent a generic type definition.</span>
          </span>
          <span data-ttu-id="b1857-4130">亦即，<see cref="P:System.Type.IsGenericTypeDefinition" /> 會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4130">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-4131">
            <paramref name="typeArguments" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4131">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-4132">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4132">-or-</span>
          </span>
          <span data-ttu-id="b1857-4133">
            <paramref name="typeArguments" /> 的任何項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4133">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-4134">
            <paramref name="typeArguments" /> 中的元素個數與目前泛型型別定義中的型別參數個數不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4134">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span>
          </span>
          <span data-ttu-id="b1857-4135">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4135">-or-</span>
          </span>
          <span data-ttu-id="b1857-4136">
            <paramref name="typeArguments" /> 中的所有元素都不符合目前泛型型別對應之型別參數所設定的條件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4136">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span>
          </span>
          <span data-ttu-id="b1857-4137">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4137">-or-</span>
          </span>
          <span data-ttu-id="b1857-4138">
            <paramref name="typeArguments" /> 中包含的項目是指標型別 (<see cref="P:System.Type.IsPointer" /> 傳回 <see langword="true" />)、by-ref 型別 (<see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" />) 或<see cref="T:System.Void" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4138">
              <paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-4139">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4139">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="b1857-4140">衍生類別必須提供實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4140">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4141">傳回 <see cref="T:System.Type" /> 物件，代表指向目前類型的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4141">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4142">
            <see cref="T:System.Type" /> 物件，代表指向目前類型的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4142">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4143"><xref:System.Type.MakePointerType%2A>方法可用來產生參數清單的指標類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4143">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="b1857-4144">如果使用的語法的 Microsoft 中繼語言 (MSIL)，目前<xref:System.Type>物件代表<xref:System.Int32>，這個方法會傳回<xref:System.Type>物件，代表`Int32*`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4144">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4145">下列程式碼範例會建立陣列， `ref` (`ByRef`在 Visual Basic 中)，以及指標的類型`Test`類別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4145">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-4146">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4146">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-4147">目前的類型為 <see cref="T:System.TypedReference" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4147">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="b1857-4148">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4148">-or-</span>
          </span>
          <span data-ttu-id="b1857-4149">目前的類型為 <see langword="ByRef" /> 類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4149">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="b1857-4150">亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4150">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4151">取得一個 <see cref="T:System.Reflection.MemberTypes" /> 值，代表這個成員是類型或巢狀類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4151">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4152">一個 <see cref="T:System.Reflection.MemberTypes" /> 值，代表這個成員是類型或巢狀類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4152">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4153">這個屬性會覆寫<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4153">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1857-4154">因此，當您檢查一組<xref:System.Reflection.MemberInfo>物件 — 例如，將所傳回的陣列<xref:System.Type.GetMembers%2A>—<xref:System.Reflection.MemberInfo.MemberType%2A>屬性會傳回<xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>時指定的成員是巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="b1857-4154">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects—for example, the array returned by <xref:System.Type.GetMembers%2A>—the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="b1857-4155">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-4155">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="b1857-4156">例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4156">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="b1857-4157">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4157">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4158">下列程式碼範例示範`MemberType`欄位當做參數`GetMember`方法：</span><span class="sxs-lookup"><span data-stu-id="b1857-4158">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4159">表示在 <see cref="T:System.Type" /> 資訊中的遺漏值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4159">Represents a missing value in the <see cref="T:System.Type" /> information.</span>
          </span>
          <span data-ttu-id="b1857-4160">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4160">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4161">使用`Missing`欄位以供透過反映來取得參數的預設值的引動過程。</span><span class="sxs-lookup"><span data-stu-id="b1857-4161">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="b1857-4162">如果`Missing`欄位會傳入輸入參數值，而且沒有預設值為該參數，<xref:System.ArgumentException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="b1857-4162">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4163">下列程式碼範例示範使用`Missing`欄位來叫用具有預設引數的方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-4163">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="b1857-4164">此程式碼會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="b1857-4164">This code produces the following output:</span></span>  
  
 <span data-ttu-id="b1857-4165">= 10 b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="b1857-4165">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="b1857-4166">a = 10 b = 1.3 c = 1</span><span class="sxs-lookup"><span data-stu-id="b1857-4166">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="b1857-4167">a = 10 b = 1.2 c = 1</span><span class="sxs-lookup"><span data-stu-id="b1857-4167">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4168">在已定義的目前 <see cref="T:System.Type" /> 中取得模組 (DLL)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4168">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4169">在目前已定義之 <see cref="T:System.Type" /> 中的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4169">The module in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4170">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性會傳回已定義的泛型類型定義所在的模組。</span><span class="sxs-lookup"><span data-stu-id="b1857-4170">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="b1857-4171">例如，如果您建立的執行個體`MyGenericStack<int>`、<xref:System.Type.Module%2A>建構的類型的屬性會傳回模組中`MyGenericStack<T>`定義。</span><span class="sxs-lookup"><span data-stu-id="b1857-4171">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="b1857-4172">同樣地，如果目前<xref:System.Type>代表泛型參數`T`，這個屬性會傳回包含定義的泛型類型的組件`T`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4172">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4173">下列範例示範使用<xref:System.Type.Namespace%2A>和`Module`屬性和<xref:System.Type.ToString%2A>方法<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4173">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4174">取得 <see cref="T:System.Type" /> 的命名空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4174">Gets the namespace of the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4175">
            <see cref="T:System.Type" /> 的命名空間；如果目前執行個體沒有命名空間或代表泛型參數，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4175">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4176">命名空間是邏輯設計階段命名慣例，主要用來定義應用程式中的範圍和組織中類別和其他類型的單一階層式結構。</span><span class="sxs-lookup"><span data-stu-id="b1857-4176">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="b1857-4177">從執行階段的觀點來看，沒有命名空間。</span><span class="sxs-lookup"><span data-stu-id="b1857-4177">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="b1857-4178">如果目前<xref:System.Type>代表建構的泛型類型，這個屬性會傳回包含泛型類型定義的命名空間。</span><span class="sxs-lookup"><span data-stu-id="b1857-4178">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="b1857-4179">同樣地，如果目前<xref:System.Type>代表泛型參數`T`，這個屬性會傳回包含定義的泛型類型定義的命名空間`T`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4179">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="b1857-4180">如果目前<xref:System.Type>物件代表泛型參數，則這個屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4180">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4181">下列範例示範使用`Namespace`和<xref:System.Type.Module%2A>屬性和<xref:System.Type.ToString%2A>方法<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4181">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b1857-4182">要比較的第一個物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4182">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b1857-4183">要比較的第二個物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4183">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4184">表示兩個 <see cref="T:System.Type" /> 物件是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4184">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4185">如果 <see langword="true" /> 等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4185">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b1857-4186">要比較的第一個物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4186">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b1857-4187">要比較的第二個物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4187">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4188">表示兩個 <see cref="T:System.Type" /> 物件是否不相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4188">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4189">如果 <see langword="true" /> 不等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4189">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4190">取得用來取得這個成員的類別物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4190">Gets the class object that was used to obtain this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4191">
            <see langword="Type" /> 物件，用來取得這個 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4191">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4192">如<xref:System.Type>物件，這個屬性的值一律是相同的值<xref:System.Type.DeclaringType%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-4192">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4193">此範例會顯示巢狀類別的反映型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4193">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="b1857-4194">要取得之 <see cref="T:System.Type" /> 的組件限定名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4194">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="throwIfNotFound">
          <span data-ttu-id="b1857-4195">
            <see langword="true" /> 表示找不到類型時擲回 <see cref="T:System.TypeLoadException" />，<see langword="false" /> 表示找不到類型時傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4195">
              <see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span>
          </span>
          <span data-ttu-id="b1857-4196">指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4196">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="b1857-4197">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4197">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="b1857-4198">
            <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4198">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>; <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4199">取得具有指定名稱的 <see cref="T:System.Type" />，指定是否執行區分大小寫的搜尋，以及若找不到該類型時是否擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4199">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span>
          </span>
          <span data-ttu-id="b1857-4200">載入此類型的目的在於反映，而不是執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4200">The type is loaded for reflection only, not for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4201">具有指定名稱的類型 (如有找到)，否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4201">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b1857-4202">如果找不到該類型，<paramref name="throwIfNotFound" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4202">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="b1857-4203">在某些情況下，不論 <paramref name="throwIfNotFound" /> 的值為何，都會擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4203">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span>
          </span>
          <span data-ttu-id="b1857-4204">請參閱＜例外狀況＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4204">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4205">包含類型的組件尚未載入到僅限反映的內容，如果使用<xref:System.Type.ReflectionOnlyGetType%2A>方法是相當於第一個載入的組件反映，使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>方法，並接著藉由呼叫載入型別組件的<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-4205">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b1857-4206">如需組件限定名稱的資訊，請參閱<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-4206">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b1857-4207">如需指定類型名稱的詳細資訊，請參閱<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="b1857-4207">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="b1857-4208">如果已執行載入組件，另一個複本已載入僅限反映的內容。</span><span class="sxs-lookup"><span data-stu-id="b1857-4208">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="b1857-4209">`throwIfNotFound`參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 > 一節中所述。</span><span class="sxs-lookup"><span data-stu-id="b1857-4209">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="b1857-4210">某些例外狀況的值為何`throwIfNotFound`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4210">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="b1857-4211">例如，如果組件無效，<xref:System.BadImageFormatException>就會擲回即使`throwIfNotFound`是`false`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4211">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="b1857-4212">如需使用僅限反映之內容的詳細資訊，請參閱[如何： 載入組件放入 Reflection-Only 內容](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)。</span><span class="sxs-lookup"><span data-stu-id="b1857-4212">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b1857-4213">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4213">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b1857-4214">叫用類別初始設定式並擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4214">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="b1857-4215">
            <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且找不到類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4215">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="b1857-4216">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4216">-or-</span>
          </span>
          <span data-ttu-id="b1857-4217">
            <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4217">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="b1857-4218">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4218">-or-</span>
          </span>
          <span data-ttu-id="b1857-4219">
            <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4219">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b1857-4220">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4220">-or-</span>
          </span>
          <span data-ttu-id="b1857-4221">
            <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4221">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="b1857-4222">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4222">-or-</span>
          </span>
          <span data-ttu-id="b1857-4223">
            <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 物件的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4223">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b1857-4224">
            <paramref name="typeName" /> 不包含組件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4224">
              <paramref name="typeName" /> does not include the assembly name.</span>
          </span>
          <span data-ttu-id="b1857-4225">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4225">-or-</span>
          </span>
          <span data-ttu-id="b1857-4226">
            <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效語法 (例如 "MyType[,\*,]")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4226">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="b1857-4227">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4227">-or-</span>
          </span>
          <span data-ttu-id="b1857-4228">
            <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4228">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="b1857-4229">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4229">-or-</span>
          </span>
          <span data-ttu-id="b1857-4230">
            <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4230">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="b1857-4231">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4231">-or-</span>
          </span>
          <span data-ttu-id="b1857-4232">
            <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4232">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b1857-4233">
            <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4233">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="b1857-4234">找到組件或其相依性的其中一個，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4234">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="b1857-4235">組件或組件的其中一個相依性無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4235">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="b1857-4236">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4236">-or-</span>
          </span>
          <span data-ttu-id="b1857-4237">用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4237">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4238">取得描述目前類型配置的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4238">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4239">取得描述目前類型概略配置特性的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4239">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4240"><xref:System.Runtime.InteropServices.StructLayoutAttribute> 不會傳回<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b1857-4240"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="b1857-4241">相反地，使用這個屬性，讓它。</span><span class="sxs-lookup"><span data-stu-id="b1857-4241">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4242">下列程式碼範例會先定義類別、 結構，以及具有特殊的版面配置屬性 （在類別中，巢狀結構） 的結構。</span><span class="sxs-lookup"><span data-stu-id="b1857-4242">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="b1857-4243">然後此範例使用<xref:System.Type.StructLayoutAttribute%2A>屬性，以取得<xref:System.Runtime.InteropServices.StructLayoutAttribute>每個類型，以及顯示屬性的屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-4243">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-4244">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4244">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="b1857-4245">保留供未來使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4245">Reserved for future use.</span>
          </span>
          <span data-ttu-id="b1857-4246">必須是 IID_NULL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4246">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="b1857-4247">要對應之傳入的名稱陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4247">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="b1857-4248">要對應的名稱計數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4248">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="b1857-4249">用於解譯名稱的地區設定內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4249">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="b1857-4250">呼叫端配置的陣列，用於接收對應於名稱的 ID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4250">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4251">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4251">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4252">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1857-4252">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="b1857-4253">如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="b1857-4253">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="b1857-4254">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4254">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="b1857-4255">要傳回的類型資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4255">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="b1857-4256">類型資訊的地區設定識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4256">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="b1857-4257">所要求類型資訊物件的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4257">A pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4258">擷取物件的類型資訊，可以用來取得介面的類型資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4258">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4259">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1857-4259">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="b1857-4260">如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="b1857-4260">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="b1857-4261">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4261">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="b1857-4262">指向接收物件提供的類型資訊介面數目的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4262">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4263">擷取物件提供的類型資訊介面數目 (0 或 1)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4263">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4264">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1857-4264">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="b1857-4265">如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="b1857-4265">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="b1857-4266">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4266">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="b1857-4267">辨識成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4267">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="b1857-4268">保留供未來使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4268">Reserved for future use.</span>
          </span>
          <span data-ttu-id="b1857-4269">必須是 IID_NULL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4269">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="b1857-4270">地區設定內容，用於解譯引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4270">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="b1857-4271">描述呼叫之內容的旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4271">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="b1857-4272">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4272">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="b1857-4273">指向用於儲存結果之位置的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4273">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="b1857-4274">包含例外狀況資訊的結構指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4274">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="b1857-4275">第一個有錯誤的引數索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4275">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b1857-4276">提供物件所公開的屬性和方法的存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4276">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4277">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1857-4277">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="b1857-4278">如需有關`IDispatch::Invoke`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="b1857-4278">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="b1857-4279">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4279">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4280">傳回表示目前 <see langword="String" /> 的名稱的 <see langword="Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4280">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b1857-4281">表示目前 <see cref="T:System.String" /> 的名稱的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4281">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4282">這個方法會傳回完整的通用語言執行階段命名空間和名稱的所有基本型別。</span><span class="sxs-lookup"><span data-stu-id="b1857-4282">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="b1857-4283">例如，C# 指令`(long)0.Type().ToString()`傳回"System.Int64"，而不是只是 「 Int64"。</span><span class="sxs-lookup"><span data-stu-id="b1857-4283">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="b1857-4284">如果目前<xref:System.Type>代表泛型型別、 類型和其型別引數限定的命名空間和巢狀類型，但不是由組件。</span><span class="sxs-lookup"><span data-stu-id="b1857-4284">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="b1857-4285">如果目前<xref:System.Type>代表型別參數定義中的泛型類型或泛型方法，這個方法會傳回型別參數的非限定的名稱。</span><span class="sxs-lookup"><span data-stu-id="b1857-4285">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4286">下列範例示範使用<xref:System.Type.Namespace%2A>和<xref:System.Type.Module%2A>屬性和`ToString`方法<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="b1857-4286">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="b1857-4287">下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="b1857-4287">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4288">取得目前 <see cref="T:System.Type" /> 的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4288">Gets the handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4289">目前 <see cref="T:System.Type" /> 的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4289">The handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4290">`TypeHandle` 封裝代表類型的內部資料結構的指標。</span><span class="sxs-lookup"><span data-stu-id="b1857-4290">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="b1857-4291">這個控制代碼的處理序存留期間是唯一的。</span><span class="sxs-lookup"><span data-stu-id="b1857-4291">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="b1857-4292">控制代碼無效，只有在當初取得應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="b1857-4292">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b1857-4293">下列範例會傳回對應的型別控制代碼，並控制代碼傳遞至方法，以取得控制代碼的類型，並顯示它。</span><span class="sxs-lookup"><span data-stu-id="b1857-4293">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b1857-4294">.NET Compact Framework 目前不支援這個屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4294">The .NET Compact Framework does not currently support this property.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4295">取得類型的初始設定式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4295">Gets the initializer for the type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4296">物件，包含 <see cref="T:System.Type" /> 的類別建構函式名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4296">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b1857-4297">類別初始設定式也會提供透過<xref:System.Type.FindMembers%2A>方法，或透過多載<xref:System.Type.GetMember%2A>， <xref:System.Type.GetMembers%2A>， <xref:System.Type.GetConstructor%2A>，和<xref:System.Type.GetConstructors%2A>方法會採用<xref:System.Reflection.BindingFlags>做為參數。</span><span class="sxs-lookup"><span data-stu-id="b1857-4297">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="b1857-4298">如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="b1857-4298">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b1857-4299">指示類型，該類型是由表示這個類型的 Common Language Runtime 所提供的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4299">Indicates the type provided by the common language runtime that represents this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b1857-4300">
            <see cref="T:System.Type" /> 的基礎系統類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b1857-4300">The underlying system type for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>