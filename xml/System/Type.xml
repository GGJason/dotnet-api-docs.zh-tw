<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a40925048dd06746d1e1cda2a76aa4ecaae1b916" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731512" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表類型宣告：類別類型、介面類型、陣列類型、值類型、列舉類型、類型參數、泛型類型定義，以及開放式或封閉式的建構泛型類型。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` 是的根<xref:System.Reflection>功能和主要的方式來存取中繼資料。 使用的成員<xref:System.Type>取得型別宣告，成員的類型 （例如建構函式、 方法、 欄位、 屬性和事件的類別） 的相關資訊以及模組和組件部署所在的類別。  
  
 不不使用反映來取得類型及成員的相關資訊，不論其存取層級的程式碼需要任何權限。 不不使用反映來存取公用成員或其存取層級會顯示它們在正常的編譯期間其他成員的程式碼需要任何權限。 不過，為了讓您的程式碼使用反映來存取成員，通常就是無法存取，例如使用私用或內部的方法，或受保護的類型的欄位不會繼承您的類別，您的程式碼必須<xref:System.Security.Permissions.ReflectionPermission>。 請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。  
  
 `Type` 是可讓多個實作的抽象基底類別。 系統一律會提供衍生的類別`RuntimeType`。 在反映中，執行階段的字為開頭的所有類別都建立一次，每個系統和支援的比較作業中的物件。  
  
> [!NOTE]
>  在多執行緒處理的情況下，不需要鎖定<xref:System.Type>物件才能同步處理存取具備`static`資料。 其他程式碼，透過它您有任何控制項，也可能會鎖定您的類別類型。 這可能會導致死結。 相反地，同步處理靜態資料的存取權鎖定私用`static`物件。  
  
> [!NOTE]
>  在衍生的類別可以存取受保護的成員呼叫的程式碼基底類別。 此外，允許存取至呼叫的程式碼組件成員。 規則是，如果您允許存取在早期繫結程式碼，然後您也可以存取晚期繫結程式碼中。  
  
> [!NOTE]
>  擴充其他介面的介面不會繼承擴充介面中定義的方法。  
  
 本節內容：  
  
 [型別物件表示何種類型？](#WhatTypes)   
 [擷取型別物件](#Retrieve)   
 [比較相等的類型物件](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>型別物件表示何種類型？  
 這個類別具備執行緒安全。多個執行緒可以同時讀取此類型的執行個體。 執行個體<xref:System.Type>類別可代表任何下列類型：  
  
-   類別  
  
-   值類型  
  
-   陣列  
  
-   介面  
  
-   列舉  
  
-   委派  
  
-   建構泛型類型和泛型類型定義  
  
-   型別引數與型別參數的建構泛型類型、 泛型類型定義與泛型方法定義  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>擷取型別物件  
 <xref:System.Type>與特定類型相關聯的物件可透過下列方式：  
  
-   執行個體<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法會傳回<xref:System.Type>物件，表示執行個體的類型。 因為所有的 managed 型別衍生自<xref:System.Object>、<xref:System.Object.GetType%2A>可以在任何類型的執行個體上呼叫方法。  
  
     下列範例會呼叫<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法，以判斷物件陣列中每個物件的執行階段類型。  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   靜態<xref:System.Type.GetType%2A?displayProperty=nameWithType>方法會傳回<xref:System.Type>物件，代表指定其完整名稱的類型。  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>， <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType>方法會傳回`Type`表示模組中定義之類型的物件。 第一種方法可以用來取得陣列的<xref:System.Type>類型物件的所有公用和私用模組中定義。 (您可以取得的執行個體`Module`透過<xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>方法，或透過<xref:System.Type.Module%2A?displayProperty=nameWithType>屬性。)  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType>物件包含方法，以擷取中的組件，包含定義的類別數目<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>， <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>。  
  
-   <xref:System.Type.FindInterfaces%2A>方法會傳回已篩選的類型所支援的介面型別清單。  
  
-   <xref:System.Type.GetElementType%2A>方法會傳回`Type`物件，表示項目。  
  
-   <xref:System.Type.GetInterfaces%2A>和<xref:System.Type.GetInterface%2A>方法會傳回<xref:System.Type>代表型別所支援的介面類型的物件。  
  
-   <xref:System.Type.GetTypeArray%2A>方法傳回的陣列<xref:System.Type>代表任意一組物件所指定類型的物件。 物件會指定類型的陣列與<xref:System.Object>。  
  
-   <xref:System.Type.GetTypeFromProgID%2A>和<xref:System.Type.GetTypeFromCLSID%2A>方法可供 COM 互通性。 它們會傳回<xref:System.Type>物件，代表所指定之類型`ProgID`或`CLSID`。  
  
-   <xref:System.Type.GetTypeFromHandle%2A>方法會提供如互通性。 它會傳回`Type`代表類別的控制代碼所指定之類型的物件。  
  
-   C#`typeof`運算子，c + +`typeid`運算子和 Visual Basic`GetType`運算子取得`Type`型別的物件。  
  
-   <xref:System.Type.MakeGenericType%2A>方法會傳回<xref:System.Type>物件代表建構的泛型類型，也就是開放式建構的類型，如果其<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`，並關閉建構類型否則。 只有當它已關閉，可以具現化泛型類型。  
  
-   <xref:System.Type.MakeArrayType%2A>， <xref:System.Type.MakePointerType%2A>，和<xref:System.Type.MakeByRefType%2A>方法會傳回<xref:System.Type>分別表示指定的型別、 指定的型別，以及參考參數的類型的指標陣列的物件 (`ref`在 C# 中， `ByRef`在 Visual Basic 中)。  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>比較相等的類型物件  
 A <xref:System.Type> ，代表類型是唯一的物件，也就是兩個<xref:System.Type>如果且只有它們代表相同的型別物件的參考會參考相同的物件。 這可讓如的比較<xref:System.Type>物件，使用參考相等。 下列範例會比較<xref:System.Type>表示的數字的整數值，以判斷它們是相同類型的物件。  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 下列範例示範少數代表性的功能<xref:System.Type>。 C#`typeof`運算子 (`GetType`在 Visual Basic 中的運算子`typeid`Visual c + + 運算子) 用來取得<xref:System.Type>物件，代表<xref:System.String>。 從這個<xref:System.Type>物件<xref:System.Type.GetMethod%2A>方法用來取得<xref:System.Reflection.MethodInfo>代表<xref:System.String.Substring%2A>可接受的開始位置和長度的多載。  
  
 若要識別多載簽章，程式碼範例會建立暫存陣列，包含兩個<xref:System.Type>物件代表`int`(`Integer`在 Visual Basic 中)。  
  
> [!NOTE]
>  為了更精確，此陣列包含兩個執行個體的參考<xref:System.Type>表示`int`目前的應用程式定義域中。 對於任何類型，沒有只有一個執行個體<xref:System.Type>每個應用程式網域。  
  
 此程式碼範例會使用<xref:System.Reflection.MethodInfo>叫用<xref:System.String.Substring%2A>方法在字串"Hello，World ！"，並顯示結果。  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <block subset="none" type="overrides">
      <para>當您繼承自<see langword="Type" />，您必須覆寫下列成員：  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Type" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會由衍生類別類型物件的建構期間叫用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得宣告此類型的 <see cref="T:System.Reflection.Assembly" />。 若為泛型類型，則取得定義此泛型類型的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <value>
          <see cref="T:System.Reflection.Assembly" /> 執行個體，描述包含目前類型的組件。 若為泛型類型，則此執行個體描述的是含有泛型類型定義的組件，而不是建立與使用特定建構類型的組件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>物件代表建構的泛型型別，這個屬性會傳回包含泛型類型定義的組件。 例如，假設您建立名為 MyGenerics.dll 包含泛型類型定義的組件`MyGenericStack<T>`(`MyGenericStack(Of T)`在 Visual Basic 中`generic<T> ref class MyGenericStack`c + + 中)。 如果您建立的執行個體`MyGenericStack<int>`(`MyGenericStack(Of Integer)`在 Visual Basic 中) 中另一個組件，<xref:System.Type.Assembly%2A>建構類型的屬性會傳回<xref:System.Reflection.Assembly>表示 MyGenerics.dll 物件。  
  
 同樣地，如果目前<xref:System.Type>物件表示未指派的泛型參數`T`，這個屬性會傳回包含定義的泛型類型的組件`T`。  
  
 如果<xref:System.Type.Assembly%2A?displayProperty=nameWithType>屬性並不適用於特定的.NET 實作，例如.NET Core 或通用 Windows 平台，請使用<xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>屬性改為。      
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會顯示與類別相關聯的組件名稱和類型的完整的名稱。  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得類型的組件限定名稱，包含載入 <see cref="T:System.Type" /> 的組件名稱。</summary>
        <value>
          <see cref="T:System.Type" /> 的組件限定名稱，包含載入 <see cref="T:System.Type" /> 的組件名稱，如果目前的執行個體表示泛型類型參數，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型的組件限定名稱是由型別名稱，包括其命名空間，加上逗號，後面接著組件的顯示名稱所組成。 使用取得組件的顯示名稱<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。 請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
 支援通用語言執行平台的所有編譯器都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|逗號 （，）|後面接著組件名稱。|  
|加號 （+）|之前的巢狀的類別。|  
|句號 （.）|代表命名空間識別項。|  
|括號 ([])|類型名稱後面，表示該類型的陣列。<br /><br /> -或-<br /><br /> 對於泛型類型，封入泛型型別引數清單。<br /><br /> -或-<br /><br /> 在型別引數清單中，會封入組件限定的類型。|  
  
 例如，類別的組件限定名稱可能看起來像這樣：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 如果命名空間包含的加號，例如 TopNamespace.Sub+Namespace 則加號 （+） 會加上逸出字元 (\\) 以防止它被解譯為巢狀的分隔符號。 反映會發出這個字串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。  
  
 這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。 若要擷取的型別名稱不含這些尾端字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。  
  
 空格是相關組件名稱以外的所有型別名稱元件中。 在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。  
  
 泛型引數的泛型型別是由組件名稱所限定。 例如，在組件限定類型名稱`MyGenericClass<int>`(`MyGenericClass(Of Integer)`在 Visual Basic 中)，`int`展開到組件限定類型名稱<xref:System.Int32>。  
  
 如果目前<xref:System.Type>物件代表泛型參數，則這個屬性會傳回`null`。  
  
   
  
## Examples  
 下列範例會顯示與類別相關聯的組件名稱和類型的完整的名稱。  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與 <see cref="T:System.Type" /> 關聯的屬性。</summary>
        <value>代表 <see cref="T:System.Reflection.TypeAttributes" /> 屬性集的 <see cref="T:System.Type" /> 物件；若 <see cref="T:System.Type" /> 代表的是泛型類型參數，則這個值就是未指定的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些成員<xref:System.Reflection.TypeAttributes>列舉型別會遮罩，代表一組的值。 每個群組包含一個成員，其基礎值為零。 例如，基礎值的<xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType>中的成員<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>群組為零，因為<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>中的成員<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>群組。 因為這個緣故，您必須使用遮罩之前測試這些值。 這個範例將提供說明。  
  
> [!TIP]
>  大部分用途而言，屬性例如<xref:System.Type.IsClass%2A>，<xref:System.Type.IsAutoLayout%2A>，和<xref:System.Type.IsSpecialName%2A>容易使用以外的類型屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性傳回的泛型類型定義的屬性。 例如，針對傳回的屬性`MyGenericClass<int>`(`MyGenericClass(Of Integer)`在 Visual Basic 中) 的屬性是`MyGenericClass<T>`(`MyGenericClass(Of T)`在 Visual Basic 中)。  
  
 如果目前<xref:System.Type>代表泛型類型參數，也就是如果<xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`—<xref:System.Reflection.TypeAttributes>未指定這個屬性所傳回的值。  
  
   
  
## Examples  
 下列範例用途<xref:System.Type.Attributes%2A>屬性。  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 所直接繼承的類型。</summary>
        <value>目前 <see cref="T:System.Type" /> 直接繼承自的 <see cref="T:System.Type" />，如果目前 <see langword="null" /> 表示 <see langword="Type" /> 類別或介面，則為 <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基底型別是目前的類型直接繼承的類型。 <xref:System.Object> 是唯一的類型，但是沒有基底型別，因此`null`傳回基底型別<xref:System.Object>。  
  
 介面繼承自零或多個基底介面。因此，這個屬性會傳回`null`如果`Type`物件代表的介面。 基底介面可以判斷與<xref:System.Type.GetInterfaces%2A>或<xref:System.Type.FindInterfaces%2A>。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，基底類型會反映的泛型引數。 例如，請考慮下列宣告：  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 建構的類型`C<int>`(`C(Of Integer)`在 Visual Basic 中)，則<xref:System.Type.BaseType%2A>屬性會傳回`B<int>`。  
  
 如果目前<xref:System.Type>表示泛型類型定義的型別參數<xref:System.Type.BaseType%2A>傳回類別條件約束，也就是將型別參數必須繼承的類別。 如果沒有類別條件約束，<xref:System.Type.BaseType%2A>傳回<xref:System.Object?displayProperty=nameWithType>。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Type.BaseType%2A>屬性。  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 下列範例會使用遞迴列出完整的繼承階層架構的組件中找到的每個類別。 此範例會定義名為類別`C`衍生自類別，名為`B`，它會接著，衍生自類別，名為`A`。  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，該值指出目前的 <see cref="T:System.Type" /> 物件是否有尚未被特定類型取代的類型參數。</summary>
        <value>
          如果 <see langword="true" /> 物件本身為泛型類型參數或包含尚未提供特定類型的類型參數則為 <see cref="T:System.Type" />否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立類型的執行個體，必須有任何泛型類型定義 」 或 「 開放式建構的類型中的型別引數型別本身，在任何的封入泛型類型或任何項目中的型別。 另一個說法是，當檢查以遞迴方式，類型必須包含沒有泛型類型參數。  
  
 型別可以很複雜，因為並不容易進行這項判斷。 為了方便起見，並減少錯誤的機會<xref:System.Type.ContainsGenericParameters%2A>屬性提供的標準方式來區別封閉式的建構類型，可以具現化，並開啟建構類型，不能。 如果<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`，無法具現化類型。  
  
 <xref:System.Type.ContainsGenericParameters%2A>以遞迴方式型別參數的屬性搜尋。 例如，它會傳回`true`陣列，其元素是型別`A<T>`(`A(Of T)`在 Visual Basic 中)，即使陣列不是泛型本身。 這和行為的<xref:System.Type.IsGenericType%2A>屬性，它會傳回`false`陣列。  
  
 範例類別和資料表顯示的值的一組<xref:System.Type.ContainsGenericParameters%2A>屬性，請參閱<xref:System.Type.IsGenericType%2A>。  
  
   
  
## Examples  
 下列範例會定義具有兩個型別參數的泛型類別，然後定義 衍生自第一個類別中的第二個泛型類別。 在衍生的類別的基底類別有兩個型別引數： 第一個是<xref:System.Int32>第二個是衍生型別的型別參數。 此範例會顯示這些泛型類別的相關資訊，包括位置回報<xref:System.Type.GenericParameterPosition%2A>屬性。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果目前的 <see cref="T:System.Reflection.MethodBase" /> 表示泛型方法的類型參數，則取得表示宣告方法的 <see cref="T:System.Type" />。</summary>
        <value>如果目前的 <see cref="T:System.Type" /> 表示泛型方法的類型參數，則為表示宣告方法的 <see cref="T:System.Reflection.MethodBase" />否則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 宣告的方法是泛型方法定義。 也就是說，如果<xref:System.Type.DeclaringMethod%2A>不會傳回`null`，然後`DeclaringMethod.IsGenericMethodDefinition`傳回`true`。  
  
 <xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性識別的泛型類型定義或泛型型別參數原本定義所在的泛型方法定義：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件代表泛型方法定義的型別參數。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，然後在<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。  
  
-   取得<xref:System.Type.DeclaringMethod%2A>型別上的屬性其<xref:System.Type.IsGenericParameter%2A>屬性是`false`會擲回<xref:System.InvalidOperationException>。  
  
 <xref:System.Reflection.MethodBase>所傳回<xref:System.Type.DeclaringMethod%2A>屬性<xref:System.Reflection.MethodInfo>在泛型的方法，或<xref:System.Reflection.ConstructorInfo>在一般的建構函式的情況下。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，不支援泛型建構函式。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例會定義具有泛型方法，將型別引數指派給此方法，並產生建構的泛型方法會叫用的類別。 它也會顯示該泛型方法定義的建構的方法的相關資訊。 當顯示的相關資訊的型別參數的泛型方法定義中，在`DisplayGenericMethodInfo`方法，範例程式碼顯示的值<xref:System.Type.DeclaringMethod%2A>方法的泛型型別參數的屬性。  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得宣告目前巢狀類型或泛型型別參數的類型。</summary>
        <value>若目前的類型是巢狀類型，即為表示封入類型的 <see cref="T:System.Type" /> 物件，若目前的類型是泛型類型的類型參數，則為泛型類型定義，而若目前的類型是泛型方法的類型參數，則為宣告泛型方法的類型，若以上皆否，便為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>物件代表泛型類型的型別參數，這個屬性會傳回泛型類型定義。  
  
 如果目前<xref:System.Type>物件代表泛型方法的型別參數，這個屬性會傳回包含泛型方法定義的型別。 如果類型是泛型，則會傳回泛型類型定義。 也就是說，下列程式碼傳回的泛型類型定義<xref:System.Collections.Generic.List%601>泛型類別，其中包含<xref:System.Collections.Generic.List%601.ConvertAll%2A>泛型的方法：  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法定義中<xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性識別泛型型別參數的泛型類型定義或泛型方法定義原本定義：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件代表泛型方法定義的型別參數。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，然後在<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。  
  
-   取得<xref:System.Type.DeclaringType%2A>型別上的屬性其<xref:System.Type.IsGenericParameter%2A>屬性是`false`會擲回<xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 這個範例會顯示在衍生類別中方法的宣告型別。  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得預設繫結器 (Binder) 的參考，它會實作內部規則來選取由 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> 呼叫的適當成員。</summary>
        <value>系統使用的預設繫結器之參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設繫結器提供與 common language runtime 選項適用於所有最特殊的情況。 如果您需要不同於所提供的預設繫結器，如下所示規則定義的繫結器型別衍生自<xref:System.Reflection.Binder>類別，並將該型別使用的執行個體傳遞`binder`參數之一的<xref:System.Type.InvokeMember%2A>多載。  
  
 反映模型一般類型系統的存取範圍的規則。 例如，如果呼叫端在相同的組件，呼叫端不需要特殊權限的內部成員。 否則，呼叫端需要<xref:System.Security.Permissions.ReflectionPermission>。 這是一致的受保護的成員查閱、 private、 等等。  
  
 一般原則是<xref:System.Reflection.Binder.ChangeType%2A>應該執行僅擴展轉換，不會遺失資料。 擴展轉換的範例將轉換為 64 位元帶正負號的整數值的 32 位元帶正負號的整數的值。 這被區分縮小轉換，可能會遺失資料。 縮小轉換的範例 32 位元帶正負號的整數轉換為 64 位元帶正負號的整數。  
  
 下表列出預設的繫結器所支援的轉換。  
  
|來源類型|目標類型|  
|-----------------|-----------------|  
|任何型別|其基底類型。|  
|任何型別|它所實作的介面。|  
|Char|Unt16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double|  
|Byte|Char、 Unt16、 Int16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double|  
|SByte|Int16、Int32、Int64、Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64、Single、Double|  
|Int16|Int32、Int64、Single、Double|  
|UInt32|UInt64、Int64、Single、Double|  
|Int32|Int64、Single、Double|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|Double|  
|非參考|所參考。|  
  
   
  
## Examples  
 下列範例會取得預設繫結器從`DefaultBinder`屬性，並叫用 MyClass 的成員，藉由傳遞`DefaultBinder`當做參數值<xref:System.Type.InvokeMember%2A>。  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>分隔 <see cref="T:System.Type" /> 的命名空間中的名稱。 此欄位為唯讀。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.Type" /> 類型的空陣列。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範`EmptyTypes`欄位使用其中一種`GetConstructor`方法，以取得不採用任何參數的建構函式。  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷目前 <see cref="T:System.Type" /> 的基礎系統類型，是否與指定的 <see cref="T:System.Object" /> 或 <see cref="T:System.Type" /> 的基礎系統類型相同。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">其基礎系統類型將與目前 <see cref="T:System.Type" /> 的基礎系統類型比較的物件。 為使比較成功，<c>o</c> 必須可以轉型或轉換為 <see cref="T:System.Type" /> 型別的物件。</param>
        <summary>判斷目前 <see cref="T:System.Type" /> 物件的基礎系統類型，是否與指定的 <see cref="T:System.Object" /> 的基礎系統類型相同。</summary>
        <returns>
          如果 <paramref name="o" /> 的基礎系統型別與目前 <see cref="T:System.Type" /> 的基礎系統型別相同，則為 <see langword="true" />，否則為 <see langword="false" />。 下列條件成立時，此方法也會傳回 <see langword="false" />：  
  
-   <paramref name="o" /> 為 <see langword="null" />。  
  
-   <paramref name="o" /> 無法轉型或轉換為 <see cref="T:System.Type" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。 它會轉換為`o`物件的型別<xref:System.Type>呼叫<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.Equals%28System.Object%29>比較各種<xref:System.Type>物件執行個體與各種<xref:System.Object>執行個體。  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 特別值得注意的相關範例，是兩件事：  
  
-   比較的<xref:System.Type>物件，表示整數<xref:System.Reflection.TypeInfo>物件，表示整數傳回`true`因為<xref:System.Reflection.TypeInfo>衍生自<xref:System.Type>。  
  
-   比較的<xref:System.Type>物件，代表<xref:System.Collections.Generic.IList%601>物件 （開放式泛型類型） 與`List(Of String)`物件 （封閉式泛型類型） 會傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">其基礎系統類型將與目前 <see cref="T:System.Type" /> 的基礎系統類型比較的物件。</param>
        <summary>判斷目前 <see cref="T:System.Type" /> 的基礎系統類型，是否與指定的 <see cref="T:System.Type" /> 之基礎系統類型相同。</summary>
        <returns>
          如果 <paramref name="o" /> 的基礎系統型別與目前 <see cref="T:System.Type" /> 的基礎系統型別相同，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會使用`Equals`比較兩個類型。  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用在屬性 (Attribute) 上的成員篩選條件。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個欄位會保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。 這個委派所封裝的方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件和第二個是`Object`。 此方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。 `Object`可能任一類別上的欄位的值指派給<xref:System.Reflection.FieldAttributes>， <xref:System.Reflection.MethodAttributes>，或<xref:System.Reflection.MethodImplAttributes>。  
  
 例如，`Object`可以從欄位的值指派給`FieldAttributes`例如 Public。 在此情況下，當`FilterAttribute`叫用委派時，它會傳回`true`所代表的方法時，才`MemberInfo`物件都有公用欄位中的屬性中繼資料。  
  
   
  
## Examples  
 下列範例會取得`FilterAttribute`委派、 將它當做參數傳遞<xref:System.Type.FindMembers%2A>方法，並顯示指定的成員和其屬性。  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用於名稱上的有區分大小寫的成員篩選條件。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個欄位會保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。 這個委派所封裝的方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件和第二個是`Object`。 此方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。 `Object`指派字串值，可能會在結尾包含"*"萬用字元。 只有萬用字元結束字串支援比對。  
  
 例如，`Object`指派的值"位元組 *"。 在此情況下，當`FilterName`叫用委派時，它會傳回`true`所代表的方法時，才`MemberInfo`物件具有開頭為 「 位元組 」 的名稱。  
  
   
  
## Examples  
 下列程式碼範例會取得相關聯的使用者定義的方法`Application`型別。  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用在名稱上的不區分大小寫的成員篩選條件。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個欄位會保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。 這個委派所封裝的方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件和第二個是`Object`。 此方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。 `Object`指派字串值，可能會在結尾包含"*"萬用字元。 只有萬用字元結束字串支援比對。  
  
 例如，`Object`指派的值"位元組 *"。 在此情況下，當`FilterName`叫用委派，它會傳回 true 只所代表的方法如果`MemberInfo`物件具有開頭為 「 位元組 」，忽略大小寫的名稱。  
  
   
  
## Examples  
 下列範例會取得`MemberFilter`委派、 將它當做參數傳遞<xref:System.Type.FindMembers%2A>方法，並顯示方法和屬性的`String`開頭字母"c"，正在略過 大小寫的類別。  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">根據 <c>filterCriteria</c> 比較介面的委派。</param>
        <param name="filterCriteria">判斷在傳回陣列中是否應包含介面的搜尋準則。</param>
        <summary>傳回 <see cref="T:System.Type" /> 物件的陣列，表示由目前 <see cref="T:System.Type" /> 所實作或繼承的介面的篩選清單。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，表示由目前的 <see cref="T:System.Type" /> 所實作或繼承之介面的篩選清單，如果由目前的 <see cref="T:System.Type" /> 所實作或繼承之介面都不符合篩選器，則為 <see cref="T:System.Type" /> 的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫這個方法。  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>和<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>所提供的委派<xref:System.Reflection.Module?displayProperty=nameWithType>類別也可用於，lieu 的<xref:System.Reflection.TypeFilter?displayProperty=nameWithType>委派。  
  
 這個類別所實作之介面的考慮所有在搜尋期間，是否為基底類別或此類別本身所宣告。  
  
 這個方法會搜尋基底類別階層架構中，傳回每一個相符的介面，以及所有比對的每個類別會實作介面的實作 （亦即，會傳回相符的介面的遞移封閉）。 傳回不重複的介面。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法定義中<xref:System.Type.FindInterfaces%2A>搜尋所有介面宣告中的條件約束的型別參數，而且所有介面都繼承與介面宣告在條件約束。 如果目前<xref:System.Type>代表型別引數的泛型型別，<xref:System.Type.FindInterfaces%2A>是否符合條件約束，搜尋所有類型所實作的介面。  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> 可傳回泛型介面，即使在不是泛型類型上。 例如，可能會實作非泛型型別`IEnumerable<int>`(`IEnumerable(Of Integer)`在 Visual Basic 中)。  
  
   
  
## Examples  
 下列範例會尋找指定的介面實作或繼承之指定類型，並接著會顯示介面名稱。  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">靜態初始設定式已叫用並擲回了例外狀況。</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">物件，表示要搜尋的成員類型。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="filter">執行比較的委派，如果目前進行檢查的成員符合 <c>filterCriteria</c>，則傳回 <see langword="true" />；否則傳回 <see langword="false" />。 您可以使用這個類別所提供的 <see langword="FilterAttribute" />、<see langword="FilterName" /> 和 <see langword="FilterNameIgnoreCase" /> 委派。 第一個委派使用 <see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的欄位做為搜尋準則，而其他兩個委派則使用 <see langword="String" /> 物件做為搜尋準則。</param>
        <param name="filterCriteria">判斷在 <see langword="MemberInfo" /> 物件的陣列中是否傳回成員的搜尋準則。  
  
 <see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的欄位可以與這個類別所提供的 <see langword="FilterAttribute" /> 委派結合使用。</param>
        <summary>傳回指定成員類型的 <see cref="T:System.Reflection.MemberInfo" /> 物件的篩選陣列。</summary>
        <returns>指定之成員類型的 <see cref="T:System.Reflection.MemberInfo" /> 物件篩選陣列。  
  
 -或-  
  
 <see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列，如果目前 <see cref="T:System.Type" /> 沒有符合篩選條件的 <paramref name="memberType" /> 類型的成員。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫這個方法。  
  
 成員包括屬性、 方法、 欄位、 事件等等。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Instance`来包含在搜尋中的執行個體成員。  
  
-   指定`BindingFlags.Static`来包含在搜尋中的靜態成員。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 有效值<xref:System.Type.MemberType%2A>中定義<xref:System.Reflection.MemberInfo>。 如果找不到任何這類成員，則會傳回空陣列。  
  
 若要取得使用此方法的類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>表示泛型類型或泛型方法的型別參數<xref:System.Type.FindMembers%2A>處理任何由類別條件約束和介面條件約束的型別參數宣告的成員。  
  
   
  
## Examples  
 下列範例會尋找符合指定的搜尋條件中，在類別中的所有成員，然後顯示 符合的成員。  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得類型的完整名稱 (包括其命名空間，但不包括其組件)。</summary>
        <value>類型的完整名稱 (包括其命名空間，但不包括其組件)；如果目前執行個體代表泛型類型參數、陣列類型、指標類型、根據類型參數的 <see langword="null" /> 類型，或不是泛型類型定義但包含未解析類型參數的泛型類型，則為 <see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，完整的名稱的<xref:System.String>型別是`System.String`。 這和所傳回的組件限定名稱<xref:System.Type.AssemblyQualifiedName%2A>屬性，其中包含的完整名稱加上完整的組件名稱。  
  
 如果目前的型別代表封閉泛型類型，所傳回的字串中的型別引數<xref:System.Type.FullName%2A>屬性會以其完整的組件名稱限定，即使並未被其完整限定的泛型類型本身的字串表示組件名稱。 下列範例說明代表泛型類型定義的類型，另一個則代表封閉泛型類型的 FullName 屬性中的差異。  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 這個屬性會傳回`null`如果：  
  
-   目前<xref:System.Type>物件代表泛型類型的型別參數。  
  
     下列範例會擷取的型別參數<xref:System.Nullable%601>型別，並嘗試顯示其<xref:System.Type.FullName%2A>屬性。  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   目前<xref:System.Type>物件都代表陣列類型、 指標類型或`byref`泛型型別參數為基礎的類型。  
  
     下列範例會定義泛型類型， `Generictype1<T>`，三個方法： `Display(T[])`，傳遞的型別 T; 陣列`HandleT(T)`，T 的物件; 傳遞和`ChangeValue(ref T)`，這傳址方式傳遞 T 物件。 因為 C# 和 Visual Basic 不允許我們定義中的指標為 T`HandleT`方法，我們需要呼叫<xref:System.Type.MakePointerType%2A>方法<xref:System.Type>物件，代表方法的參數類型，若要建立泛型類型的指標。 範例輸出顯示在所有的三種情況下，<xref:System.Type.FullName%2A>屬性是`null`。  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   目前的類型包含有尚未被特定類型取代的泛型類型參數 (也就是<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`)，但類型不是泛型類型定義 (也就是<xref:System.Type.IsGenericTypeDefinition%2A>屬性會傳回 `false`  
  
     在下列範例中，`Derived<T>`繼承自`Base<T>`。 <xref:System.Type.BaseType%2A>屬性會取得<xref:System.Type>物件，代表的基底類型`Derived<T>`，且其<xref:System.Type.FullName%2A>屬性會傳回`null`。  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     若要取得<xref:System.Type.FullName%2A>不`null`，您可以使用<xref:System.Type.GetGenericTypeDefinition%2A>方法來取得泛型類型定義，如範例所示。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會顯示指定之類型的完整名稱。  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得一組 <see cref="T:System.Reflection.GenericParameterAttributes" /> 旗標，敘述目前泛型類型參數的共變數與特殊條件約束。</summary>
        <value>
          <see cref="T:System.Reflection.GenericParameterAttributes" /> 值的位元組合，描述目前泛型類型參數的共變數和特殊條件約束。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的值包含旗標，敘述目前泛型型別參數是否共變數和其他特殊條件約束的旗標。 使用<xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType>值加入選取的共變數旗標，並使用<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType>来選取的條件約束旗標值。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例會定義泛型型別`Test`具有兩個具有不同的條件約束的型別參數。 當程式執行時，條件約束會檢查使用<xref:System.Type.GenericParameterAttributes%2A>屬性和<xref:System.Type.GetGenericParameterConstraints%2A>方法。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前的 <see cref="T:System.Type" /> 物件不是泛型型別參數。 亦即，<see cref="P:System.Type.IsGenericParameter" /> 屬性會傳回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當 <see cref="T:System.Type" /> 物件表示泛型類型或泛型方法的類型參數時，在宣告參數的泛型類型或泛型方法之類型參數清單中，取得類型參數的位置。</summary>
        <value>型別參數在宣告參數的泛型類型或方法之型別參數清單中的位置。 位置編號從 0 開始。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A>屬性會傳回型別參數的位置參數清單的泛型類型定義或泛型方法定義中的型別參數原本定義。 <xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性識別的泛型類型或泛型方法定義：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件代表泛型方法定義的型別參數。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，然後在<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。  
  
 若要提供正確的內容值的<xref:System.Type.GenericParameterPosition%2A>屬性，它會需要識別的泛型型別或型別參數所屬的方法。 例如，請考慮泛型方法的傳回值`GetSomething`下列程式碼：  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 傳回的型別`GetSomething`取決於提供給類別的型別引數`A`和`GetSomething`本身。 您可以取得<xref:System.Reflection.MethodInfo>如`GetSomething`，而且可以從所取得的傳回型別。 當您檢查型別參數的傳回型別，<xref:System.Type.GenericParameterPosition%2A>同時會傳回 0。 位置`V`為 0，因為`V`類別的型別參數清單中的第一個型別參數`A`。 位置`X`為 0，因為`X`是第一個型別參數的型別參數清單中`GetSomething`。  
  
> [!NOTE]
>  呼叫<xref:System.Type.GenericParameterPosition%2A>屬性造成例外狀況，如果目前<xref:System.Type>不代表型別參數。 當您檢查開放式建構類型的類型引數時，使用<xref:System.Type.IsGenericParameter%2A>分辨哪些是型別參數，而這是類型的屬性。 <xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`型別參數; 然後您可以使用<xref:System.Type.GenericParameterPosition%2A>方法來取得它的位置使用<xref:System.Type.DeclaringMethod%2A>和<xref:System.Type.DeclaringType%2A>內容來決定泛型方法或類型定義它的定義.  
  
   
  
## Examples  
 下列範例會定義具有兩個型別參數的泛型類別，並定義衍生自第一個類別中的第二個泛型類別。 在衍生的類別的基底類別有兩個型別引數： 第一個是<xref:System.Int32>，第二個是衍生型別的型別參數。 此範例會顯示這些泛型類別的相關資訊，包括位置回報<xref:System.Type.GenericParameterPosition%2A>屬性。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前類型不代表型別參數。 亦即，<see cref="P:System.Type.IsGenericParameter" /> 會傳回 <see langword="false" />。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此類型之泛型型別引數的陣列。</summary>
        <value>這個類型之泛型型別引數的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性取得只的泛型型別引數;也就是說，已指定目前的型別之泛型型別參數的型別。 如果目前的類型是泛型類型定義，這個屬性會傳回空陣列。  
  
> [!NOTE]
>  如果另一個泛型類型或泛型方法中使用泛型型別，則其泛型型別引數的某些可能封入方法或類型的泛型型別參數。  
  
 若要取得代表泛型類型定義的類型的泛型型別參數，請使用<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>屬性。 若要取得<xref:System.Reflection.TypeInfo>物件目前<xref:System.Type>物件，請使用<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>擴充方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得陣列中的維度數目。</summary>
        <returns>包含目前類型中之維度數目的整數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示在陣列中的維度數目。  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個方法的功能不受基底類別的支援，因此必須改為在衍生類別中實作。</exception>
        <exception cref="T:System.ArgumentException">目前的類型不是陣列。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.Attributes" /> 屬性並取得位元遮罩，指示與 <see cref="T:System.Type" /> 關聯的屬性。</summary>
        <returns>
          <see cref="T:System.Reflection.TypeAttributes" /> 物件，代表 <see cref="T:System.Type" /> 的屬性集。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的特定建構函式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">由 <see cref="T:System.Type" /> 物件組成的陣列，表示所要建構函式參數的數目、順序和類型。  
  
 -或-  
  
 由 <see cref="T:System.Type" /> 物件組成的空陣列，用來取得不需任何參數的建構函式。 這種供陣列是由 <see langword="static" /> 欄位 <see cref="F:System.Type.EmptyTypes" /> 提供的。</param>
        <summary>搜尋其參數符合在指定陣列中的類型的公用執行個體建構函式。</summary>
        <returns>物件，表示其參數符合參數類型陣列中之類型的公用執行個體建構函式 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載尋找公用執行個體建構函式，無法用來取得類別初始設定式 (.cctor)。 若要取得的類別初始設定式，使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果要求的建構函式為非公用，則這個方法會傳回`null`。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數取代型別參數。 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回`null`。  
  
   
  
## Examples  
 下列範例會取得的型別`MyClass`，取得<xref:System.Reflection.ConstructorInfo>物件，並會顯示建構函式簽章。  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。  
  
 -或-  
  
 用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。  
  
 -或-  
  
 <see cref="F:System.Type.EmptyTypes" />。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，代表在參數類型陣列中與對應項目關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束 (Constraint) 搜尋其參數符合指定的引數類型和修飾詞 (Modifier) 的建構函式。</summary>
        <returns>
          <see cref="T:System.Reflection.ConstructorInfo" /> 物件，代表符合指定之需求的建構函式 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`陣列，就可以選取相符項目。 如果`binder`無法選取相符項目，然後`null`傳回。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的建構函式：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數取代型別參數。 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回`null`。  
  
   
  
## Examples  
 下列程式會取得的型別`MyClass1`類別，取得<xref:System.Reflection.ConstructorInfo>物件符合指定的繫結旗標，並顯示建構函式的簽章。  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。  
  
 -或-  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="callConvention">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及清除堆疊。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。  
  
 -或-  
  
 用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束和指定的呼叫慣例，搜尋其參數符合指定的引數類型和修飾詞的建構函式。</summary>
        <returns>物件，代表符合指定之需求的建構函式 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`陣列，就可以選取相符項目。 如果`binder`無法選取相符項目，然後`null`傳回。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的建構函式：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用此方法的類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數取代型別參數。 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回`null`。  
  
   
  
## Examples  
 下列範例會取得的型別`MyClass1`，取得<xref:System.Reflection.ConstructorInfo>物件符合指定的繫結旗標，並會顯示建構函式簽章。  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。  
  
 -或-  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="callConvention">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及清除堆疊。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。  
  
 -或-  
  
 用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束和指定的呼叫慣例，搜尋其參數符合指定的引數類型和修飾詞的建構函式。</summary>
        <returns>
          <see cref="T:System.Reflection.ConstructorInfo" /> 物件，代表符合指定之需求的建構函式 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`陣列，就可以選取相符項目。 如果`binder`無法選取相符項目，然後`null`傳回。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的建構函式：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 這個方法會實作 <xref:System.Type.GetConstructor%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。  
  
 -或-  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <exception cref="T:System.NotSupportedException">目前的型別是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的建構函式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回所有定義給目前 <see cref="T:System.Type" /> 的公用建構函式。</summary>
        <returns>由 <see cref="T:System.Reflection.ConstructorInfo" /> 物件組成的陣列，表示定義給目前 <see cref="T:System.Type" /> 的所有公用執行個體建構函式，但不含類型初始設定式 (靜態建構函式)。 如果目前的 <see cref="T:System.Type" /> 沒有定義任何公用執行個體建構函式，或目前的 <see cref="T:System.Type" /> 表示泛型類型或泛型方法定義中的類型參數，則會傳回 <see cref="T:System.Reflection.ConstructorInfo" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>方法不會建構函式傳回以特定順序，例如，按宣告順序。 您的程式碼不得相依於建構函式會傳回的順序，因為順序不同。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 這個方法多載呼叫<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>方法多載，與<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>在 Visual Basic 中)。 將不會發現類別初始設定式 (.cctor)。 類別初始設定式，請使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數所取代的型別參數的物件。 比方說，如果類別`C<T>`的建構函式`C(T t1)`(`Sub New(ByVal t1 As T)`在 Visual Basic 中)，則呼叫<xref:System.Type.GetConstructors%2A>上`C<int>`傳回<xref:System.Reflection.ConstructorInfo>表示`C(int t1)`C# 中 (`Sub New(ByVal t1 As Integer)`在 Visual Basic 中)。  
  
 如果目前<xref:System.Type>表示泛型型別參數時，<xref:System.Type.GetConstructors%2A>方法會傳回空陣列。  
  
   
  
## Examples  
 此範例中顯示的輸出<xref:System.Type.GetConstructors%2A>從類別具有兩個執行個體建構函式和一個靜態建構函式多載。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 這個程式碼的輸出為：  
  
 2  
  
 False  
  
 False  
  
 因為<xref:System.Type.GetConstructors>多載只會使用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>和<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，靜態建構函式都不會計算由`for`運算式，也不會評估`IsStatic`。  
  
 靜態建構函式，請使用<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>多載，並傳遞組合 (邏輯`OR`) 的<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，如下列程式碼範例所示：  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 現在的輸出為：  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的 <see cref="T:System.Type" />，搜尋定義給目前 <see langword="BindingFlags" /> 的建構函式。</summary>
        <returns>
          <see cref="T:System.Reflection.ConstructorInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有建構函式，包括類型初始設定式 (如果已定義)。 如果目前的 <see cref="T:System.Reflection.ConstructorInfo" /> 沒有定義建構函式，或所定義的建構函式都不符合繫結條件約束，或目前的 <see cref="T:System.Type" /> 表示泛型類型或泛型方法定義中的類型參數，則傳回 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>方法不會建構函式傳回以特定順序，例如，按宣告順序。 您的程式碼不得相依於建構函式會傳回的順序，因為順序不同。  
  
 `bindingAttr` 可以用於指定是否要傳回只有公用建構函式或公用和非公用建構函式。  
  
 如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`陣列，就可以選取相符項目。 如果`binder`無法選取相符項目，然後`null`傳回。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的建構函式：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。 不會傳回基底類別建構函式。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有適當的型別引數所取代的型別參數的物件。 比方說，如果類別`C<T>`的建構函式`C(T t1)`(`Sub New(ByVal t1 As T)`在 Visual Basic 中)，則呼叫<xref:System.Type.GetConstructors%2A>上`C<int>`傳回<xref:System.Reflection.ConstructorInfo>表示`C(int t1)`C# 中 (`Sub New(ByVal t1 As Integer)`在 Visual Basic 中)。  
  
 如果目前<xref:System.Type>表示泛型型別參數時，<xref:System.Type.GetConstructors%2A>方法會傳回空陣列。  
  
   
  
## Examples  
 此範例中顯示的輸出<xref:System.Type.GetConstructors>從類別具有兩個執行個體建構函式和一個靜態建構函式多載。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 這個程式碼的輸出為：  
  
 2  
  
 False  
  
 False  
  
 因為<xref:System.Type.GetConstructors%2A>多載只會使用<xref:System.Reflection.BindingFlags.Public>和<xref:System.Reflection.BindingFlags.Instance>，靜態建構函式都不會計算由`for`運算式，也不會評估`IsStatic`。  
  
 靜態建構函式，請使用<xref:System.Type.GetConstructors%2A>多載，並將它傳遞的組合 (邏輯 OR) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，如下列程式碼範例所示：  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 現在的輸出為：  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>搜尋定義給目前 <see cref="T:System.Type" /> 的成員，而它的 <see cref="T:System.Reflection.DefaultMemberAttribute" /> 已設定。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有預設成員。  
  
 -或-  
  
 <see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有預設成員)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 在衍生類別可以覆寫這個方法。  
  
 成員包括屬性、 方法、 欄位、 事件等等。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數所取代的型別參數的物件。 比方說，如果類別`C<T>`屬性`P`傳回`T`，則呼叫<xref:System.Type.GetDefaultMembers%2A>上`C<int>`傳回`int P`C# 中 (`Property P As Integer`在 Visual Basic 中)。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。  
  
   
  
## Examples  
 下列範例會取得的預設成員資訊`MyClass`並顯示預設成員。  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，傳回由目前陣列、指標或參考類型所包含或參考物件的 <see cref="T:System.Type" />。</summary>
        <returns>目前的陣列、指標或參考類型所內含或參考之物件的 <see cref="T:System.Type" />，如果目前的 <see langword="null" /> 不是陣列或指標、未以傳址方式傳遞，或表示泛型類型或泛型類型或泛型方法定義中之類型參數，則為 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回`null`如<xref:System.Array>類別。  
  
   
  
## Examples  
 下列範例示範如何使用`GetElementType`方法。  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要擷取其名稱的值。</param>
        <summary>針對目前的列舉類型，傳回具有指定值之常數的名稱。</summary>
        <returns>具有指定值之目前列舉類型的成員名稱，如果找不到這類常數，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。  
  
 -或-  
  
 <paramref name="value" /> 不是目前的型別，也沒有與目前型別相同的基礎型別。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前列舉類型之成員的名稱。</summary>
        <returns>包含列舉之成員名稱的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回值陣列的項目依列舉常數的二進位值 （也就是不帶正負號值） 排序。 如果陣列包含具有相同值的列舉的常數，其對應名稱的順序會是 unspecified。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前列舉類型的基礎類型。</summary>
        <returns>目前列舉的基礎類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，在 C# 和 Visual Basic 中列舉的基礎類型是<xref:System.Int32>。 您可以指定其他整數類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。  
  
 -或-  
  
 列舉類型無效，因為它包含一個以上的執行個體欄位。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前列舉類型中常數的值陣列。</summary>
        <returns>包含值的陣列。 陣列的項目依列舉常數的二進位值 (也就是不帶正負號值) 排序。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的特定事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，其中包含由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件名稱。</param>
        <summary>傳回代表指定公用事件的 <see cref="T:System.Reflection.EventInfo" /> 物件。</summary>
        <returns>如果找到，則表示由目前 <see cref="T:System.Type" /> 所宣告或繼承之指定公用事件的物件；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。 否則事件會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體的事件。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.EventInfo>物件，並取得指定之事件按鈕類別事件。  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含目前 <see cref="T:System.Type" /> 所宣告或繼承之事件的名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，傳回表示指定事件的 <see cref="T:System.Reflection.EventInfo" /> 物件。</summary>
        <returns>如果找到，則表示由目前 <see cref="T:System.Type" /> 所宣告或繼承之指定事件的物件；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的事件：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用事件。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用事件 （也就是私用、 內部和受保護的事件）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的事件<xref:System.Type>，不只是繼承的事件。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。 否則事件會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>方法來搜尋的公用或非公用事件名為 「 按一下 」 不是型別`static`(`Shared`在 Visual Basic 中)。  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的所有公用事件。</summary>
        <returns>
          <see cref="T:System.Reflection.EventInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所宣告或繼承的所有公用事件。  
  
 -或-  
  
 <see cref="T:System.Reflection.EventInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有公用事件)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。 否則事件會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 <xref:System.Type.GetEvents%2A>方法沒有傳回事件以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於事件會傳回的順序，因為順序不同。  
  
 在衍生類別可以覆寫這個方法。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。  
  
   
  
## Examples  
 下列範例會取得陣列的<xref:System.Reflection.EventInfo>物件資訊，請取得的所有事件`Button`類別，並顯示事件名稱。 若要編譯 Visual Basic 範例，請使用下列命令列：  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件。</summary>
        <returns>
          <see cref="T:System.Reflection.EventInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所宣告或繼承之符合指定繫結條件約束的所有事件。  
  
 -或-  
  
 如果目前 <see cref="T:System.Reflection.EventInfo" /> 沒有事件，或沒有事件符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A>方法沒有傳回事件以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於事件會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的事件：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用事件。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用事件 （也就是私用、 內部和受保護的事件）。 只保護，而且在基底類別上的內部事件都會傳回到;不會傳回基底類別上的私用事件。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的事件<xref:System.Type>，不只是繼承的事件。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。 否則事件會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。  
  
   
  
## Examples  
 下列範例會取得陣列的<xref:System.Reflection.EventInfo>符合指定的繫結旗標的物件取得的所有事件`Button`類別，並顯示事件名稱。 若要編譯 Visual Basic 範例，請使用下列命令列：  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的特定欄位。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的資料欄位的名稱。</param>
        <summary>搜尋具有指定名稱的公用欄位。</summary>
        <returns>物件，代表具有指定之名稱的公用欄位 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體欄位。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的欄位。  
  
   
  
## Examples  
 下列範例會取得`Type`物件指定的類別，取得<xref:System.Reflection.FieldInfo>物件的欄位，並顯示欄位的值。  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">此 <see cref="T:System.Type" /> 物件為尚未呼叫 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 方法的 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的資料欄位的名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>使用指定的繫結條件約束搜尋指定的欄位。</summary>
        <returns>代表符合指定之需求欄位的物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的欄位：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`要在搜尋中包含公用欄位。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用欄位 （也就是私用、 內部和受保護欄位）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋僅將宣告上的欄位<xref:System.Type>，不只是繼承的欄位。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的欄位。  
  
   
  
## Examples  
 下列範例會取得`Type`物件指定的類別，取得<xref:System.Reflection.FieldInfo>符合指定的繫結旗標，並顯示欄位的值之欄位的物件。  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的欄位。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Type" /> 的所有公用欄位。</summary>
        <returns>
          <see cref="T:System.Reflection.FieldInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義的所有公用欄位。  
  
 -或-  
  
 <see cref="T:System.Reflection.FieldInfo" /> 類型的空陣列 (如果沒有為目前 <see cref="T:System.Type" /> 定義公用欄位)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於欄位會傳回的順序，因為順序不同。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的公用欄位。  
  
   
  
## Examples  
 下列範例會示範搭配`GetFields()`方法。  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的欄位。</summary>
        <returns>
          <see cref="T:System.Reflection.FieldInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有欄位。  
  
 -或-  
  
 如果沒有任何欄位定義給目前 <see cref="T:System.Reflection.FieldInfo" /> 的欄位，或沒有已定義的欄位符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於欄位會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的欄位：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`要在搜尋中包含公用欄位。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用欄位 （也就是私用、 內部和受保護欄位）。 只保護，而且會傳回基底類別上的內部欄位。不會傳回基底類別上的私用欄位。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋僅將宣告上的欄位<xref:System.Type>，不只是繼承的欄位。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的公用欄位。  
  
   
  
## Examples  
 下列範例會示範搭配`GetFields(BindingFlags)`方法。  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Type" /> 物件的陣列，代表封閉泛型類型的類型引數，或泛型類型定義的類型參數。</summary>
        <returns>由 <see cref="T:System.Type" /> 物件組成的陣列，代表泛型類型的類型引數。 如果目前的類型不是泛型類型，則傳回空的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列項目會以其出現在泛型類型的型別引數清單中的順序傳回。  
  
-   如果目前的類型是封閉式的建構的類型 (也就是<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`false`)，所傳回的陣列<xref:System.Type.GetGenericArguments%2A>方法包含已指派給泛型類型定義的泛型類型參數的型別.  
  
-   如果目前的類型是泛型類型定義，陣列會包含型別參數。  
  
-   如果目前的類型是開放式建構的類型 (也就是<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`) 中的特定型別不已指派給所有型別參數與封入泛型類型或方法的型別參數，此陣列包含型別與型別參數。 使用<xref:System.Type.IsGenericParameter%2A>屬性來區分它們。 如需示範此案例中，請參閱的程式碼範例<xref:System.Type.ContainsGenericParameters%2A>屬性。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Type.GetGenericArguments%2A>方法來顯示型別引數的建構類型和其泛型型別定義的型別參數。  
  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Type.IsGenericTypeDefinition%2A>屬性。 請參閱範例輸出的較大範例。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回由 <see cref="T:System.Type" /> 物件組成的陣列，這些物件代表對目前泛型類型參數所設下的條件約束。</summary>
        <returns>由 <see cref="T:System.Type" /> 物件組成的陣列，這些物件代表對目前泛型類型參數所設下的條件約束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個泛型型別參數的條件約束會表示為<xref:System.Type>物件。 使用<xref:System.Type.IsClass%2A>屬性來判斷條件約束是否是基底類別條件約束; 如果屬性傳回`false`，條件約束是介面條件約束。 如果類型參數沒有類別條件約束和介面條件約束，則會傳回空陣列。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例會定義泛型型別`Test`具有兩個具有不同的條件約束的型別參數。 當程式執行時，條件約束會檢查使用<xref:System.Type.GenericParameterAttributes%2A>屬性和<xref:System.Type.GetGenericParameterConstraints%2A>方法。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前的 <see cref="T:System.Type" /> 物件不是泛型型別參數。 亦即，<see cref="P:System.Type.IsGenericParameter" /> 屬性會傳回 <see langword="false" />。</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回代表泛型類型定義的 <see cref="T:System.Type" /> 物件，利用此泛型類型定義就可以建構出目前的泛型類型。</summary>
        <returns>代表泛型類型的 <see cref="T:System.Type" /> 物件，利用此泛型類型就可以建構出目前的類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型類型定義是用於建構其他類型的範本。 例如，從泛型類型定義`G<T>`（以表示 C# 語法。`G(Of T)`在 Visual Basic 或`generic <typename T> ref class G`c + + 中) 您可以建構並具現化類型`G<int>`(`G(Of Integer)`在 Visual Basic 中)。 指定<xref:System.Type>物件，代表這個建構的型別，<xref:System.Type.GetGenericTypeDefinition%2A>方法傳回的泛型類型定義。  
  
 如果兩個建構的類型建立從相同泛型類型定義，使用相同的型別引數，<xref:System.Type.GetGenericTypeDefinition%2A>方法會傳回相同<xref:System.Type>這兩種類型的物件。  
  
 如果您呼叫<xref:System.Type.GetGenericTypeDefinition%2A>方法<xref:System.Type>表示物件已是泛型類型定義，它會傳回目前<xref:System.Type>。  
  
> [!IMPORTANT]
>  泛型類型的陣列不是泛型本身。 C# 程式碼`A<int>[] v;`或 Visual Basic 程式碼`Dim v() As A(Of Integer)`，變數的型別`v`不是泛型。 使用<xref:System.Type.IsGenericType%2A>決定類型是否為泛型，然後再呼叫<xref:System.Type.GetGenericTypeDefinition%2A>。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例會建構類型的執行個體建立使用一般的執行個體建立，並接著會使用<xref:System.Type.GetType%2A>和<xref:System.Type.GetGenericTypeDefinition%2A>方法來擷取建構的類型和泛型類型定義。 這個範例會使用泛型<xref:System.Collections.Generic.Dictionary%602>類型; 建構的類型代表<xref:System.Collections.Generic.Dictionary%602>的`Test`字串索引鍵的物件。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前的類型不是泛型類型。  亦即，<see cref="P:System.Type.IsGenericType" /> 會傳回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個執行個體的雜湊碼。</summary>
        <returns>這個執行個體的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例顯示的雜湊碼`System.Windows.Forms.Button`類別。  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得由目前 <see cref="T:System.Type" /> 所實作或繼承的特定介面。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的介面名稱。 若為泛型介面，則為 mangled 名稱。</param>
        <summary>搜尋具有指定名稱的介面。</summary>
        <returns>物件，代表具有指定之名稱的介面是由目前 <see cref="T:System.Type" /> 所實作或繼承的 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。  
  
> [!NOTE]
>  若為泛型介面，`name`參數則為 mangled 的名稱，結尾抑音符號 (\`) 及型別參數數目。 這是為泛型介面定義與建構的泛型介面，則為 true。 例如，若要尋找`IExample<T>`(`IExample(Of T)`在 Visual Basic 中) 或`IExample<string>`(`IExample(Of String)`在 Visual Basic 中)，搜尋``"IExample`1"``。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Type.GetInterface%28System.String%29>方法來搜尋<xref:System.Collections.Hashtable>類別<xref:System.Runtime.Serialization.IDeserializationCallback>介面，並列出介面的方法。  
  
 程式碼範例也示範<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法多載而<xref:System.Type.GetInterfaceMap%2A>方法。  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">目前的 <see cref="T:System.Type" /> 代表的型別有實作出相同的泛型介面，但型別引數不同。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的介面名稱。 若為泛型介面，則為 mangled 名稱。</param>
        <param name="ignoreCase">
          <see langword="true" />，便會忽略 <c>name</c> 中指定簡單介面名稱之該部分的大小寫 (指定命名空間的部分必須使用正確的大小寫)。  
  
 -或-  
  
 <see langword="false" /> 表示對 <c>name</c> 的所有部分執行區分大小寫的搜尋。</param>
        <summary>在衍生類別中覆寫時，指定是否針對介面名稱以不區分大小寫的方式來搜尋指定的介面。</summary>
        <returns>物件，代表具有指定之名稱的介面是由目前 <see cref="T:System.Type" /> 所實作或繼承的 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase`參數只適用於簡單介面名稱，不到命名空間。 部分`name`指定命名空間必須包含正確的大小寫，或將找不到介面。 例如，字串"System.icomparable"尋找<xref:System.IComparable>介面，但字串"system.icomparable"並不會。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。  
  
> [!NOTE]
>  若為泛型介面，`name`參數則為 mangled 的名稱，結尾抑音符號 (\`) 及型別參數數目。 這是為泛型介面定義與建構的泛型介面，則為 true。 例如，若要尋找`IExample<T>`(`IExample(Of T)`在 Visual Basic 中) 或`IExample<string>`(`IExample(Of String)`在 Visual Basic 中)，搜尋`"IExample`1"'。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法來執行不區分大小寫的搜尋<xref:System.Collections.Hashtable>類別<xref:System.Collections.IEnumerable>介面。  
  
 程式碼範例也示範<xref:System.Type.GetInterface%28System.String%29>方法多載而<xref:System.Type.GetInterfaceMap%2A>方法。  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">目前的 <see cref="T:System.Type" /> 代表的型別有實作出相同的泛型介面，但型別引數不同。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">要擷取對應的介面類型。</param>
        <summary>傳回指定介面類型的介面對應。</summary>
        <returns>物件，表示 <paramref name="interfaceType" /> 的介面對應。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 介面對應會表示如何在介面對應到實際的成員上實作該介面的類別。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，類型的項目中的適當的型別引數會取代參數<xref:System.Reflection.InterfaceMapping>這個方法所傳回。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Type.GetInterfaceMap%2A>方法，以判斷如何<xref:System.IFormatProvider>介面對應至<xref:System.Globalization.CultureInfo>方法，以及如何<xref:System.IAppDomainSetup>介面對應至<xref:System.AppDomainSetup>屬性。 請注意，因為<xref:System.IAppDomainSetup>介面會定義一組屬性，傳回<xref:System.Reflection.InterfaceMapping>物件包含個別<xref:System.Reflection.MethodInfo>屬性的 get 和 set 存取子的物件。  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> 不是否由目前的類型所實作。  
  
 -或-  
  
 <paramref name="interfaceType" /> 參數不會參考介面。  
  
 -或-  
  
 <paramref name="interfaceType" /> 是泛型介面，而且目前的型別是陣列型別。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">目前的 <see cref="T:System.Type" /> 表示泛型型別參數，也就是說，<see cref="P:System.Type.IsGenericParameter" /> 為 <see langword="true" />。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，取得由目前 <see cref="T:System.Type" /> 所實作或繼承的所有介面。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所實作或繼承的所有介面。  
  
 -或-  
  
 <see cref="T:System.Type" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 未實作或繼承介面)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A>方法不會傳回介面特定的順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於介面會傳回的順序，因為順序不同。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。  
  
   
  
## Examples  
 下列範例會取得指定之類別的型別，並顯示型別所實作或繼承的所有介面。 若要編譯 Visual Basic 範例，請使用下列編譯器命令：  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">靜態初始設定式已叫用並擲回了例外狀況。</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的指定成員。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用成員名稱。</param>
        <summary>搜尋具有指定名稱的公用成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體成員。  
  
 成員包括屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 這個方法多載不會尋找類別初始設定式 (.cctor)。 類別初始設定式，請使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  為泛型方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例顯示的所有成員`String`以字母 c 開頭的類別  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的成員名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，表示傳回空陣列。</param>
        <summary>使用指定的繫結條件約束搜尋指定的成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫這個方法。  
  
 成員包括屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定".cctor" `name`，和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中) 的`bindingAttr`。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  為泛型方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例顯示的所有公用靜態成員`myString`以字母 c 開頭的類別  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的成員名稱。</param>
        <param name="type">要搜尋的值。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，表示傳回空陣列。</param>
        <summary>使用指定的繫結條件約束，搜尋指定成員類型的指定成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成員包括屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定".cctor" `name`，<xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType>如`type`，和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>中Visual Basic) 的`bindingAttr`。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  為泛型方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例顯示的所有方法`myString`以字母 c 開頭的類別  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">衍生類別必須提供實作。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的成員 (屬性、方法、欄位、事件等等)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Type" /> 的所有公用成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有公用成員。  
  
 -或-  
  
 <see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有公用成員)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成員包括屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMembers%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 這個方法多載呼叫<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法多載，與<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>在 Visual Basic 中)。 將不會發現類別初始設定式 (.cctor)。 類別初始設定式，請使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Type.GetMembers>方法多載來收集指定之類別的所有公用成員的相關資訊。  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零 (<see cref="F:System.Reflection.BindingFlags.Default" />)，表示傳回空陣列。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有成員。  
  
 -或-  
  
 如果沒有任何成員定義給目前的 <see cref="T:System.Reflection.MemberInfo" />，或沒有已定義的成員符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成員包括屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMembers%2A>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。 只保護，而且會傳回基底類別上的內部成員。不會傳回基底類別上的私用成員。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。  
  
 呼叫這個方法只使用`Public`旗標] 或 [僅`NonPublic`旗標將會傳回指定的成員，而且不需要任何其他旗標。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得使用的類別初始設定式<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MemberInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<xref:System.Object>如果沒有類別條件約束。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法多載來收集指定之類別的所有公用執行個體成員的相關資訊。  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的特定方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用方法名稱。</param>
        <summary>搜尋具有指定名稱的公用方法。</summary>
        <returns>物件，代表具有指定之名稱的公用方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體方法。  
  
 如果方法多載，而且有一個以上的公用方法，<xref:System.Type.GetMethod%28System.String%29>方法會擲回<xref:System.Reflection.AmbiguousMatchException>例外狀況。 在下列範例中，例外狀況會擲回的多個公用的多載，因為<xref:System.Int32.ToString%2A?displayProperty=nameWithType>方法。  相反地，因為`Person.ToString`方法覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>，因此未超載，<xref:System.Type.GetMethod%28System.String%29>方法是能夠擷取<xref:System.Reflection.MethodInfo>物件。  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 您可以執行下列命令來擷取特定方法的其中一個動作：  
  
-   呼叫<xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29>方法並指定`bindingAttr`唯一識別該方法的引數。 例如，如果擲回例外狀況，因為類型都有靜態和執行個體的多載，您可以指定`bindingAttr`引數的<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>。  
  
-   呼叫的多載<xref:System.Type.GetMethod%2A>方法包含`types`定義方法的參數型別參數。  
  
-   呼叫<xref:System.Type.GetMethods>方法來擷取包含所有屬於類型的公用方法的陣列。 您可以再逐一查看以識別重複的方法，名為`name`。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  為泛型方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例會取得名為的方法`MethodA`。  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的方法名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>使用指定的繫結條件約束搜尋指定的方法。</summary>
        <returns>物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：  
  
-   您必須指定<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>以取得傳回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用方法。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。  
  
-   指定<xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType>包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 若要忽略大小寫的`name`。  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果多載的方法和一個以上多載符合所指定的條件約束`bindingAttr`引數，方法會擲回<xref:System.Reflection.AmbiguousMatchException>例外狀況。 在下列範例中，因為，會擲回例外狀況：  
  
-   `TestClass`類型有兩個公用執行個體多載`DisplayValue`方法，`DisplayValue(String)`和`DisplayValue(String, Object[])`。  
  
-   `TestClass`類型有兩個公用執行個體多載`Equals`方法，其中繼承自<xref:System.Object>:`Equals(TestClass)`和`Equals(Object)`。  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 您可以執行下列命令來擷取特定方法的其中一個動作：  
  
-   變更繫結條件約束。 在上述範例中，嘗試擷取公用執行個體`Equals`類型所宣告，且不會成功繼承方法擷取`Equals(TestClass)`。  
  
-   呼叫的多載<xref:System.Type.GetMethod%2A>方法包含`types`定義方法的參數型別參數。  
  
-   呼叫<xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>方法來擷取包含所有具有指定的繫結屬性的方法屬於類型的陣列。 您可以再逐一查看以識別重複的方法，名為`name`。 這種方法如下所示的上一個範例處理常式<xref:System.Reflection.AmbiguousMatchException>例外狀況。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  為泛型方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例會取得符合指定的繫結旗標的方法。  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用方法名稱。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
 -或-  
  
 <see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</param>
        <summary>搜尋指定的公用方法，其參數符合指定的引數類型。</summary>
        <returns>代表其參數符合指定之引數類型的公用方法物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體方法。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  `name`參數不能包含型別引數。 例如，C# 程式碼`GetMethod("MyGenericMethod<int>")`搜尋文字名稱的方法"`MyGenericMethod<int>`"，而不會針對名為的方法`MyGenericMethod`具有一個泛型類型引數`int`。 請改用`GetMethod("MyGenericMethod")`中適當的參數`types`陣列。  
  
   
  
## Examples  
 下列範例會尋找特定的多載`MethodA`，指定各種不同的引數型別。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 下列範例會擷取<xref:System.Reflection.MethodInfo>物件來代表`Add`非泛型型別的方法 (<xref:System.Collections.ArrayList>類別)，開放式泛型類型 (<xref:System.Collections.Generic.List%601>類別)，和已關閉的泛型型別 (`List(Of String)`型別。  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 此範例會定義`GetAddMethod`方法，可擷取適當<xref:System.Reflection.MethodInfo>物件。 若要提供`types`開放式的泛型型別引數，呼叫<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>方法。 若要提供`types`封閉泛型類型引數，它會擷取的值<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱及指定參數的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用方法名稱。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
 -或-  
  
 <see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。 預設的繫結器不會處理這個參數。</param>
        <summary>搜尋指定的公用方法，其參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的公用方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體方法。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  為泛型方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMethod("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。 請改用`GetMethod("MyMethod")`中適當的參數`types`陣列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱及指定參數的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的方法名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
 -或-  
  
 <see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用方法。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  為泛型方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例會尋找特定的多載`MethodA`，指定繫結條件約束和各種不同的引數型別。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的方法名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="callConvention">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及如何清除堆疊。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
 -或-  
  
 <see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束和指定的呼叫慣例，來搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 下表顯示基底類別成員會傳回由`GetXXX`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用方法。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。  
  
> [!NOTE]
>  為泛型方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋的文字名稱的成員 」`MyMethod<int>`"，而不會針對名為的方法`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例會尋找特定的多載`MethodA`、 指定繫結條件約束、 呼叫慣例和引數類型的不同。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的方法名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="callConvention">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及哪一個處理程序清除堆疊。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
 -或-  
  
 用以取得沒有參數的方法之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。  
  
 -或-  
  
 <see langword="null" />。 如果 <c>types</c> 為 <see langword="null" />，則引數不相符。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束和指定的呼叫慣例搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 如果 `types` 為 `null`，則引數不相符。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用方法。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。  
  
 -或-  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <exception cref="T:System.NotSupportedException">目前的型別是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Type" /> 的所有公用方法。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義的所有公用方法。  
  
 -或-  
  
 <see cref="T:System.Reflection.MethodInfo" /> 類型的空陣列 (如果沒有為目前 <see cref="T:System.Type" /> 定義公用方法)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>方法不會傳回方法特定的順序，例如依字母順序排列或按宣告順序。 您的程式碼必須依賴方法會傳回的順序，因為順序不同。  
  
 建構函式不包含陣列中的這個呼叫所傳回的方法。 若要個別呼叫`GetConstructors()`以取得建構函式方法。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的方法。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有方法。  
  
 -或-  
  
 如果沒有任何方法定義給目前的 <see cref="T:System.Reflection.MethodInfo" />，或沒有已定義的方法符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>方法不會傳回方法特定的順序，例如依字母順序排列或按宣告順序。 您的程式碼必須依賴方法會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含哪些方法：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用方法。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。 只保護，而且會傳回基底類別上的內部方法。不會傳回基底類別上的私用方法。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋的方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查閱建構函式和方法時，無法省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>如果沒有類別條件約束。  
  
   
  
## Examples  
 下列範例會建立具有兩個公用方法和一個受保護的方法的類別，然後建立`Type`物件對應至`MyTypeClass`、 取得所有的公用和非公用方法，並顯示其名稱。  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讓特定類型在目前的 <see cref="T:System.Type" /> 內變成巢狀。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含要取得之巢狀類型名稱的字串。</param>
        <summary>搜尋具有指定名稱的公用巢狀類型。</summary>
        <returns>物件，代表具有指定名稱的巢狀類型 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。  
  
 使用巢狀類別的簡單名稱`name`。 切勿在外部類別的名稱。 一般巢狀類別中，使用為 mangled 的名稱 — 也就是附加抑音符號以及泛型引數數目。 例如，使用字串"內部\`1"以取得泛型巢狀類別`Inner<T>`(`Inner(Of T)`在 Visual Basic 中)。 不包含型別參數的特定語言的語法。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。  
  
 如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。 即使封入泛型型別是封閉式的建構的類型，也是如此。  
  
> [!NOTE]
>  如果目前<xref:System.Type>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。 這不一定在動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">包含要取得之巢狀類型名稱的字串。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束搜尋指定的巢狀類型。</summary>
        <returns>物件，代表符合指定之需求的巢狀類型 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用巢狀類別的簡單名稱`name`。 切勿在外部類別的名稱。 一般巢狀類別中，使用為 mangled 的名稱 — 也就是附加抑音符號以及泛型參數的數目。 例如，使用字串"內部\`1"以取得泛型巢狀類別`Inner<T>`(`Inner(Of T)`在 Visual Basic 中)。 不包含型別參數的特定語言的語法。  
  
 下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：  
  
-   您必須指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>取得傳回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用巢狀型別。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要在搜尋中包含非公用巢狀的類型 （也就是私用、 內部和受保護巢狀型別）。  
  
 這個方法會傳回目前類型之巢狀的類型。 它不會搜尋目前類型的基底類別。 若要尋找的巢狀類型，基底類別中，您必須逐步繼承階層中，呼叫<xref:System.Type.GetNestedType%2A>每個層級。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>都會被忽略。  
  
 呼叫這個方法只使用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>旗標] 或 [僅<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>旗標將會傳回指定的巢狀類型，並不需要任何其他旗標。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。  
  
 如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。 即使封入泛型型別是封閉式的建構的類型，也是如此。  
  
> [!NOTE]
>  如果目前<xref:System.Type>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。 這不一定在動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讓其在目前的 <see cref="T:System.Type" /> 內變成巢狀之類型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回在目前 <see cref="T:System.Type" /> 內形成巢狀的公用類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中的巢狀公用類型 (搜尋不是遞迴的)；如果目前 <see cref="T:System.Type" /> 中沒有巢狀公用類型，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A>方法沒有傳回型別特定的順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於型別會傳回的順序，因為順序不同。  
  
 只有在目前的類型中巢狀的公用型別會傳回。搜尋不是遞迴的。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。  
  
 如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。 即使封入泛型型別是封閉式的建構的類型，也是如此。  
  
> [!NOTE]
>  如果目前<xref:System.Type>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。 這不一定在動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。  
  
   
  
## Examples  
 下列範例會定義巢狀的類別和`struct`中`MyClass`，然後取得使用的型別之巢狀類型的物件和`MyClass`。  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋在目前 <see cref="T:System.Type" /> 內形成巢狀的類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中符合指定繫結條件約束的所有巢狀類型 (搜尋不是遞迴的)；如果找不到符合繫結條件約束的巢狀類型，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋巢狀類型不是遞迴的。  
  
 <xref:System.Type.GetNestedTypes%2A>方法沒有傳回型別特定的順序，例如依字母順序排列或按宣告順序。 您的程式碼不得相依於型別會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：  
  
-   您必須指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>取得傳回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用巢狀型別。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要在搜尋中包含非公用巢狀的類型 （也就是私用、 內部和受保護巢狀型別）。  
  
 這個方法會傳回目前類型之巢狀的類型。 它不會搜尋目前類型的基底類別。 若要尋找的巢狀類型，基底類別中，您必須逐步繼承階層中，呼叫<xref:System.Type.GetNestedTypes%2A>每個層級。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>都會被忽略。  
  
 呼叫這個方法只使用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>旗標] 或 [僅<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>旗標將會傳回指定的巢狀類型，並不需要任何其他旗標。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。  
  
 如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。 即使封入泛型型別是封閉式的建構的類型，也是如此。  
  
> [!NOTE]
>  如果目前<xref:System.Type>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。 這不一定在動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。  
  
   
  
## Examples  
 下列範例會建立兩個巢狀公用類別和兩個巢狀的受保護的類別，並會顯示符合指定的繫結條件約束的類別資訊。  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Type" /> 的所有公用屬性。</summary>
        <returns>
          <see cref="T:System.Reflection.PropertyInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有公用屬性。  
  
 -或-  
  
 類型 <see cref="T:System.Reflection.PropertyInfo" /> 的空陣列，如果目前 <see cref="T:System.Type" /> 並沒有公用屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個多載就相當於呼叫<xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29>多載`bindingAttr`引數等於`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`在 C# 和`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`在 Visual Basic 中。 它會傳回所有公用執行個體和靜態屬性，表示由目前類型所定義兩個那些<xref:System.Type>物件以及繼承自一個基底類型。  
  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 <xref:System.Type.GetProperties%2A>方法不會傳回屬性以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼必須依賴屬性會傳回的順序，因為順序不同。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
   
  
## Examples  
 下列範例示範 `GetProperties` 方法的用法。  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋目前 <see cref="T:System.Type" /> 的屬性。</summary>
        <returns>
          <see cref="T:System.Reflection.PropertyInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中符合指定繫結條件約束的所有屬性。  
  
 -或-  
  
 如果目前 <see cref="T:System.Reflection.PropertyInfo" /> 沒有屬性，或沒有屬性符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 <xref:System.Type.GetProperties%2A>方法不會傳回屬性以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼必須依賴屬性會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用屬性。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。 只保護，而且會傳回基底類別上的內部屬性。不會傳回基底類別上的私用屬性。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的屬性<xref:System.Type>，不只是繼承的屬性。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數所取代的型別參數的物件。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
   
  
## Examples  
 下列範例會定義名為類別`PropertyClass`包含六個屬性： 兩個都是公用，一個是私用、 保護的其中一個，為內部 (`Friend`在 Visual Basic 中)，且其中一個受保護內部 (`Protected Friend`在 Visual Basic 中)。 接著會顯示一些基本的屬性資訊 (屬性名稱和型別，是否是讀取/寫入，以及是否可看到其`get`和`set`存取子) 符合指定的繫結條件約束的屬性。  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的特定屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <summary>搜尋具有指定名稱的公用屬性。</summary>
        <returns>物件，代表具有指定之名稱的公用屬性 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
 情況<xref:System.Reflection.AmbiguousMatchException>發生如下：  
  
-   類型包含兩個索引的屬性具有相同名稱但不同數量的參數。 若要解決模稜兩可，使用的多載<xref:System.Type.GetProperty%2A>方法所指定的參數類型。  
  
-   衍生的型別宣告會隱藏繼承的屬性具有相同的名稱，使用屬性`new`修飾詞 (`Shadows`在 Visual Basic 中)。 若要解決模稜兩可，請使用<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>方法多載，並新增<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>旗標將搜尋限制不會繼承的成員。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。 例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為索引子，且不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會擷取`Type`物件的使用者定義的類別，擷取該類別的屬性，並顯示屬性名稱。  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 就內部而言，這個屬性是中繼資料中所參考的名稱 「 項目。 」 嘗試取得`PropertyInfo`使用反映必須指定此內部名稱才能正確地傳回`PropertyInfo`屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的屬性名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <summary>使用指定的繫結條件約束搜尋指定的屬性。</summary>
        <returns>代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含的屬性：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用屬性。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的屬性<xref:System.Type>，不只是繼承的屬性。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
 情況<xref:System.Reflection.AmbiguousMatchException>發生如下：  
  
-   類型包含兩個索引的屬性具有相同名稱但不同數量的參數。 若要解決模稜兩可，使用的多載<xref:System.Type.GetProperty%2A>方法所指定的參數類型。  
  
-   衍生的型別宣告會隱藏繼承的屬性具有相同名稱的屬性使用`new`修飾詞 (`Shadows`在 Visual Basic 中)。 若要解決模稜兩可，包括<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>將搜尋限制不會繼承的成員。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。 例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為索引子，且不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例擷取的使用者定義的類別類型、 擷取該類別的屬性，並顯示根據指定的繫結條件約束的屬性名稱。  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <summary>搜尋具有指定名稱和傳回型別的公用屬性。</summary>
        <returns>物件，代表具有指定之名稱的公用屬性 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。 例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為索引子，且不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會定義具有一個屬性的類別，並擷取名稱和屬性的型別。  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" /> 或 <paramref name="returnType" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
 -或-  
  
 用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <summary>搜尋指定的公用屬性，其參數符合指定的引數類型。</summary>
        <returns>代表其參數符合指定之引數類型的公用屬性物件 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。 例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為索引子，且不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會擷取`Type`物件的使用者定義的類別，擷取該類別的屬性，並顯示屬性名稱和屬性的型別所傳遞的引數指定`GetProperty`。  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱，且符合指定引數類型的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的項目是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
 -或-  
  
 用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <summary>搜尋指定的公用屬性，其參數符合指定的引數類型。</summary>
        <returns>代表其參數符合指定之引數類型的公用屬性物件 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。 例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為索引子，且不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱，且符合指定引數類型的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的項目是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
 -或-  
  
 用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>搜尋指定的公用屬性，其參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的公用屬性 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。 例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為索引子，且不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會取得`Type`物件對應至`MyPropertyClass`，並使用引數傳遞給擷取之索引的屬性，這個類別的`GetProperty`方法。  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱，且符合指定引數類型和修飾詞的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。  
  
 -或-  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的項目是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的屬性名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
 -或-  
  
 用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束搜尋指定的屬性，而該屬性的參數符合指定的引數類型和修飾詞。</summary>
        <returns>代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用，以反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中結合使用值`Or`) 以取得它。  
  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含的屬性：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用屬性。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的屬性<xref:System.Type>，不只是繼承的屬性。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。 例如，如果變數`myList`指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)`在 Visual Basic 中) 擷取具有索引 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為索引子，且不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別程式庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性變更的中繼資料中索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。  
  
 -或-  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的項目是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的屬性名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
 -或-  
  
 零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載成員的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
 -或-  
  
 用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束搜尋指定的屬性，而該屬性的參數符合指定的引數類型和修飾詞的建構函式。</summary>
        <returns>代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要在搜尋中包含的屬性：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用屬性。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 上的靜態成員`private`繼承的類別中的靜態成員不會包含。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的屬性<xref:System.Type>，不只是繼承的屬性。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
 -或-  
  
 <paramref name="modifiers" /> 是多維的。  
  
 -或-  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <exception cref="T:System.NotSupportedException">目前的型別是 <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得代表指定類型的 <see cref="T:System.Type" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前的 <see cref="T:System.Type" />。</summary>
        <returns>目前的 <see cref="T:System.Type" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的組件限定名稱。 請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</param>
        <summary>取得具有指定名稱的 <see cref="T:System.Type" />，執行區分大小寫的搜尋。</summary>
        <returns>具有指定名稱的類型 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。 <xref:System.Type.GetType%2A> 引起指定的組件載入`typeName`。 您也可以載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法，這個方法，然後使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>方法來取得<xref:System.Type>物件。 如果類型是在編譯時期已知程式組件中，它是在 C# 中，使用更有效率<xref:System.Type.GetType%2A>在 Visual Basic 或 c + + 中。  
  
> [!NOTE]
>  如果`typeName`找不到，呼叫<xref:System.Type.GetType%28System.String%29>方法會傳回`null`。 它不會擲回例外狀況。 若要控制是否擲回例外狀況，請呼叫的多載<xref:System.Type.GetType%2A>方法`throwOnError`參數。  
  
 <xref:System.Type.GetType%2A> 只適用於從磁碟載入的組件。 如果您呼叫<xref:System.Type.GetType%2A>查閱來定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會發生不一致的行為。 行為取決於動態組件是持續性，也就是，建立使用`RunAndSave`或`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。 如果在動態組件會持續，並寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。 如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。 `GetType` 不了解暫時性動態組件。因此，呼叫`GetType`擷取型別中的暫時性動態組件傳回`null`。  
  
 若要使用`GetType`上動態模組中，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件和呼叫`GetType`之後再儲存。 否則，您會得到兩個組件的複本在記憶體中。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。  
  
 `typeName` 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。 請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。 如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。 如果組件具有強式名稱，是完整組件名稱是必要。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱和泛型型別引數。 支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。 您也可以藉由建立載入型別<xref:System.Reflection.AssemblyName>物件並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。 然後您可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。 請參閱<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|倒單引號 （'）|前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。|  
|括號 ([])|將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。|  
|逗號 （，）|後面接著組件名稱。|  
|句號 （.）|代表命名空間識別項。|  
|加號 （+）|之前的巢狀的類別。|  
  
 例如，類別的完整限定的名稱可能看起來像這樣：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (\\) 以防止它被解譯為巢狀的分隔符號。 反映會發出這個字串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。  
  
 這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。 若要擷取的型別名稱不含這些尾端字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。  
  
 空格是相關組件名稱以外的所有型別名稱元件中。 在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。  
  
 泛型類型的名稱結尾是反單引號 (\`) 後面接著數字，代表泛型型別引數數目。 此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。 比方說，反映傳回 mangled 的名稱`Tuple`1` and `Tuple`2`泛型的方法從`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。  
  
 為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能會表示如下：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。 否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`fromMyAssembly.dll，類型的索引鍵聯<xref:System.String>，可能會以下面方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  組件限定型別可以括在方括號，它必須出現在型別參數清單中。 在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。  
  
 可為 null 的類型是泛型類型的特殊案例。 例如，可為 null<xref:System.Int32>由 「 System.Nullable'1[System.Int32]"的字串。  
  
> [!NOTE]
>  您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。 例如，可為 null<xref:System.Boolean>類型由`typeof(Nullable<bool>)`在 C# 中，由`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。  
  
 下表顯示您使用的語法`GetType`各種類型。  
  
|若要取得|使用|  
|------------|---------|  
|可為 null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|若要將 unmanaged 的指標 `MyType`|`Type.GetType("MyType*")`|  
|將 unmanaged 的指標的指標 `MyType`|`Type.GetType("MyType**")`|  
|Managed 的指標或參考 `MyType`|`Type.GetType("MyType&")`。 請注意，參考與指標不同，僅限一個層級。|  
|父類別和巢狀的類別|`Type.GetType("MyParentClass+MyNestedClass")`|  
|一維陣列，其下限為 0|`Type.GetType("MyType[]")`|  
|一維陣列，未知的下限|`Type.GetType("MyType[*]")`|  
|N 維陣列|逗號 （，） 的 n-1 次數總計的括號內。 例如，`System.Object[,,]`代表三維`Object`陣列。|  
|陣列的一維陣列|`Type.GetType("MyType[][]")`|  
|矩形的二維陣列下限未知|`Type.GetType("MyType[,]")`|  
|具有一個型別引數的泛型型別|`Type.GetType("MyGenericType`1[MyType]")`|  
|具有兩個型別引數的泛型型別|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|具有兩個組件限定型別引數的泛型型別|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|組件限定泛型型別與組件限定型別引數|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|泛型型別，其型別引數是兩個型別引數的泛型型別|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 下列範例會擷取的型別`System.Int32`並使用該類型的物件顯示<xref:System.Type.FullName%2A>屬性`System.Int32`。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
 -或-  
  
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在[適用於 Windows 市集應用程式的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或是[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
 -或-  
  
 目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的組件限定名稱。 請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。 指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。 請參閱＜例外狀況＞一節。</param>
        <summary>取得具有指定名稱的 <see cref="T:System.Type" />，執行區分大小寫的搜尋，並設定找不到該類型時，是否應擲回例外狀況。</summary>
        <returns>具有指定名稱的類型。 如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。 <xref:System.Type.GetType%2A> 引起指定的組件載入`typeName`。 您也可以載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法，這個方法，然後使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>方法來取得<xref:System.Type>物件。 如果類型是在編譯時期已知程式組件中，會更有效率使用`typeof`在 C# 中，<xref:System.Type.GetType%2A>在 Visual Basic 中，或`typeid`c + + 中。  
  
 `GetType` 只適用於從磁碟載入的組件。 如果您呼叫`GetType`查閱來定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會發生不一致的行為。 行為取決於動態組件是持續性，也就是，建立使用`RunAndSave`或`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。 如果在動態組件會持續，並寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。 如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。 `GetType` 不了解暫時性動態組件。因此，呼叫`GetType`擷取型別中的暫時性動態組件傳回`null`。  
  
 若要使用`GetType`上動態模組中，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件和呼叫`GetType`之後再儲存。 否則，您會得到兩個組件的複本在記憶體中。  
  
 `throwOnError`參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 > 一節中所述。 某些例外狀況的值為何`throwOnError`。 例如，如果找到的類型，但無法載入，<xref:System.TypeLoadException>就會擲回即使`throwOnError`是`false`。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。  
  
 `typeName` 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。 請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。 如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。 如果組件具有強式名稱，是完整組件名稱是必要。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱，以及泛型引數。 支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。 您也可以藉由建立載入型別<xref:System.Reflection.AssemblyName>物件並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。 然後您可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。 請參閱<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|倒單引號 （'）|前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。|  
|括號 ([])|將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。|  
|逗號 （，）|後面接著組件名稱。|  
|句號 （.）|代表命名空間識別項。|  
|加號 （+）|之前的巢狀的類別。|  
  
 例如，類別的完整限定的名稱可能看起來像這樣：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (\\) 以防止它被解譯為巢狀的分隔符號。 反映會發出這個字串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。  
  
 這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。 若要擷取的型別名稱不含這些尾端字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。  
  
 空格是相關組件名稱以外的所有型別名稱元件中。 在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。  
  
 泛型類型的名稱結尾是反單引號 (\`) 後面接著數字，代表泛型型別引數數目。 此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。 比方說，反映傳回 mangled 的名稱`Tuple`1` and `Tuple`2`泛型的方法從`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。  
  
 為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能會表示如下：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。 否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`MyAssembly.dll，具有索引鍵的類型從<xref:System.String>，可能會以下面方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  組件限定型別可以括在方括號，它必須出現在型別參數清單中。 在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。  
  
 可為 null 的類型是泛型類型的特殊案例。 例如，可為 null<xref:System.Int32>由 「 System.Nullable'1[System.Int32]"的字串。  
  
> [!NOTE]
>  您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。 例如，可為 null<xref:System.Boolean>類型由`typeof(Nullable<bool>)`在 C# 中，由`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。  
  
 下表顯示您使用的語法`GetType`各種類型。  
  
|若要取得|使用|  
|------------|---------|  
|可為 null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|若要將 unmanaged 的指標 `MyType`|`Type.GetType("MyType*")`|  
|將 unmanaged 的指標的指標 `MyType`|`Type.GetType("MyType**")`|  
|Managed 的指標或參考 `MyType`|`Type.GetType("MyType&")`。 請注意，參考與指標不同，僅限一個層級。|  
|父類別和巢狀的類別|`Type.GetType("MyParentClass+MyNestedClass")`|  
|一維陣列，其下限為 0|`Type.GetType("MyArray[]")`|  
|一維陣列，未知的下限|`Type.GetType("MyArray[*]")`|  
|N 維陣列|逗號 （，） 的 n-1 次數總計的括號內。 例如，`System.Object[,,]`代表三維`Object`陣列。|  
|二維陣列的陣列|`Type.GetType("MyArray[][]")`|  
|矩形的二維陣列下限未知|`Type.GetType("MyArray[,]")`|  
|具有一個型別引數的泛型型別|`Type.GetType("MyGenericType`1[MyType]")`|  
|具有兩個型別引數的泛型型別|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|具有兩個組件限定型別引數的泛型型別|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|組件限定泛型型別與組件限定型別引數|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|泛型型別，其型別引數是兩個型別引數的泛型型別|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 下列範例會擷取的型別`System.Int32`並使用該類型的物件顯示<xref:System.Type.FullName%2A>屬性`System.Int32`。 如果型別物件參考不存在的組件，這個範例會擲回例外狀況。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
 -或-  
  
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效的語法。 例如，"MyType[,*,]"。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
 -或-  
  
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在[適用於 Windows 市集應用程式的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或是[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
 -或-  
  
 目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的組件限定名稱。 請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該型別時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。指定 <see langword="false" /> 還會隱藏一些其他例外情況，但不是全部。 請參閱＜例外狀況＞一節。</param>
        <param name="ignoreCase">
          <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</param>
        <summary>取得具有指定名稱的 <see cref="T:System.Type" />，指定找不到類型時是否要擲回例外狀況，以及是否要執行區分大小寫的搜尋。</summary>
        <returns>具有指定名稱的類型。 如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。 <xref:System.Type.GetType%2A> 引起指定的組件載入`typeName`。 您也可以載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法，這個方法，然後使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>方法來取得<xref:System.Type>物件。 如果類型是在編譯時期已知程式組件中，會更有效率使用`typeof`在 C# 中，<xref:System.Type.GetType%2A>在 Visual Basic 中，或`typeid`c + + 中。  
  
 `GetType` 只適用於從磁碟載入的組件。 如果您呼叫`GetType`查閱來定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會發生不一致的行為。 行為取決於動態組件是持續性，也就是，建立使用`RunAndSave`或`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。 如果在動態組件會持續，並寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。 如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。 `GetType` 不了解暫時性動態組件。因此，呼叫`GetType`擷取型別中的暫時性動態組件傳回`null`。  
  
 若要使用`GetType`上動態模組中，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件和呼叫`GetType`之後再儲存。 否則，您會得到兩個組件的複本在記憶體中。  
  
 `throwOnError`參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 > 一節中所述。 某些例外狀況的值為何`throwOnError`。 例如，如果找到的類型，但無法載入，<xref:System.TypeLoadException>就會擲回即使`throwOnError`是`false`。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位一律是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則會是繼承實作屬性的方法相同。 反映會將屬性視為依名稱和簽章隱藏。 請參閱附註 2 下方。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  進行反映，屬性和事件是依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。  
  
3.  自訂屬性不是一般類型系統的一部分。  
  
 陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。  
  
 `typeName` 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。 請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。 如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。 如果組件具有強式名稱，是完整組件名稱是必要。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱和型別引數。 支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。 您也可以藉由建立載入型別<xref:System.Reflection.AssemblyName>物件並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。 然後您可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。 請參閱<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|倒單引號 （'）|前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。|  
|括號 ([])|將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。|  
|逗號 （，）|後面接著組件名稱。|  
|句號 （.）|代表命名空間識別項。|  
|加號 （+）|之前的巢狀的類別。|  
  
 例如，類別的完整限定的名稱可能看起來像這樣：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (\\) 以防止它被解譯為巢狀的分隔符號。 反映會發出這個字串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。  
  
 這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。 若要擷取的型別名稱不含這些尾端字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。  
  
 空格是相關組件名稱以外的所有型別名稱元件中。 在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。  
  
 泛型類型的名稱結尾是反單引號 (\`) 後面接著數字，代表泛型型別引數數目。 此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。 比方說，反映傳回 mangled 的名稱`Tuple`1` and `Tuple`2`泛型的方法從`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。  
  
 為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能會表示如下：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。 否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`MyAssembly.dll，具有索引鍵的類型從<xref:System.String>，可能會以下面方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  組件限定型別可以括在方括號，它必須出現在型別參數清單中。 在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。  
  
 可為 null 的類型是泛型類型的特殊案例。 例如，可為 null<xref:System.Int32>由 「 System.Nullable'1[System.Int32]"的字串。  
  
> [!NOTE]
>  您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。 例如，可為 null<xref:System.Boolean>類型由`typeof(Nullable<bool>)`在 C# 中，由`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。  
  
 下表顯示您使用的語法`GetType`各種類型。  
  
|若要取得|使用|  
|------------|---------|  
|可為 null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|若要將 unmanaged 的指標 `MyType`|`Type.GetType("MyType*")`|  
|將 unmanaged 的指標的指標 `MyType`|`Type.GetType("MyType**")`|  
|Managed 的指標或參考 `MyType`|`Type.GetType("MyType&")`。 請注意，參考與指標不同，僅限一個層級。|  
|父類別和巢狀的類別|`Type.GetType("MyParentClass+MyNestedClass")`|  
|一維陣列，其下限為 0|`Type.GetType("MyArray[]")`|  
|一維陣列，未知的下限|`Type.GetType("MyArray[*]")`|  
|N 維陣列|逗號 （，） 的 n-1 次數總計的括號內。 例如，`System.Object[,,]`代表三維`Object`陣列。|  
|二維陣列的陣列|`Type.GetType("MyArray[][]")`|  
|矩形的二維陣列下限未知|`Type.GetType("MyArray[,]")`|  
|具有一個型別引數的泛型型別|`Type.GetType("MyGenericType`1[MyType]")`|  
|具有兩個型別引數的泛型型別|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|具有兩個組件限定型別引數的泛型型別|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|組件限定泛型型別與組件限定型別引數|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|泛型型別，其型別引數是兩個型別引數的泛型型別|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
 -或-  
  
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效的語法。 例如，"MyType[,*,]"。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
 -或-  
  
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
 -或-  
  
 目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的名稱。 如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。 如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</param>
        <param name="assemblyResolver">方法，會找出並傳回 <c>typeName</c> 中指定的組件。 組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。 如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。  
  
 注意：不要從未知或未受信任的呼叫端傳遞方法。 這樣做可能會提高惡意程式碼的權限。 只使用您所提供或熟悉的方法。</param>
        <param name="typeResolver">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。 如果未提供任何組件，<c>typeResolver</c> 方法會提供一個組件。 這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <see langword="false" /> 至該參數。  
  
 注意：不要從未知或未受信任的呼叫端傳遞方法。</param>
        <summary>取得具有指定名稱的類型，並選擇性提供自訂方法來解析組件和類型。</summary>
        <returns>具有指定名稱的類型；如果找不到類型，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法，以及詳細資料的使用方式案例`assemblyResolver`和`typeResolver`參數位於<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。  
  
> [!NOTE]
>  如果`typeName`找不到，呼叫<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>方法會傳回`null`。 它不會擲回例外狀況。 若要控制是否擲回例外狀況，請呼叫的多載<xref:System.Type.GetType%2A>方法`throwOnError`參數。  
  
 呼叫這個方法多載會呼叫相同<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，並指定`false`如`throwOnError`和`ignoreCase`參數。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentException">將 <paramref name="typeName" /> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
 -或-  
  
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或組件的其中一個相依性，但無法加以載入。  
  
 -或-  
  
 <paramref name="typeName" /> 包含無效的組件名稱。  
  
 -或-  
  
 <paramref name="typeName" /> 是有效的組件名稱，沒有型別名稱。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
 -或-  
  
 用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的名稱。 如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。 如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</param>
        <param name="assemblyResolver">方法，會找出並傳回 <c>typeName</c> 中指定的組件。 組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。 如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。  
  
 注意：不要從未知或未受信任的呼叫端傳遞方法。 這樣做可能會提高惡意程式碼的權限。 只使用您所提供或熟悉的方法。</param>
        <param name="typeResolver">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。 如果未提供任何組件，方法會提供一個組件。 這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <see langword="false" /> 至該參數。  
  
 注意：不要從未知或未受信任的呼叫端傳遞方法。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。 指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。 請參閱＜例外狀況＞一節。</param>
        <summary>取得具有指定名稱的類型，指定找不到類型時是否擲回例外狀況，同時選擇性提供自訂方法來解析組件和類型。</summary>
        <returns>具有指定名稱的類型。 如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法，以及詳細資料的使用方式案例`assemblyResolver`和`typeResolver`參數位於<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。  
  
 呼叫這個方法多載會呼叫相同<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，並指定`false`如`ignoreCase`參數。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
 -或-  
  
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.ArgumentException">將 <paramref name="typeName" /> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，且 <paramref name="typeName" /> 包含無效的語法 (例如 "MyType[,*,]")。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
 -或-  
  
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。  
  
 -或-  
  
 <paramref name="typeName" /> 包含無效的組件名稱。  
  
 -或-  
  
 <paramref name="typeName" /> 是有效的組件名稱，沒有型別名稱。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
 -或-  
  
 用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的名稱。 如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。 如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</param>
        <param name="assemblyResolver">方法，會找出並傳回 <c>typeName</c> 中指定的組件。 組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。 如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。  
  
 注意：不要從未知或未受信任的呼叫端傳遞方法。 這樣做可能會提高惡意程式碼的權限。 只使用您所提供或熟悉的方法。</param>
        <param name="typeResolver">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。 如果未提供任何組件，方法會提供一個組件。 這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <c>ignoreCase</c> 的值至該參數。  
  
 注意：不要從未知或未受信任的呼叫端傳遞方法。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。 指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。 請參閱＜例外狀況＞一節。</param>
        <param name="ignoreCase">
          <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</param>
        <summary>取得具有指定名稱的類型，指定是否執行區分大小寫的搜尋以及找不到類型時是否擲回例外狀況，同時選擇性提供自訂方法來解析組件和類型。</summary>
        <returns>具有指定名稱的類型。 如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法多載，以及其相關聯的多載 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>和<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) 來取代的預設實作<xref:System.Type.GetType%2A>與更有彈性的實作方法。 您可以藉由提供您自己解析型別名稱和包含它們的組件名稱的方法，執行下列作業：  
  
-   控制項類型從載入的組件的版本。  
  
-   提供查閱不包含組件名稱的型別名稱的另一個位置。  
  
-   載入組件使用部分的組件名稱。  
  
-   傳回的子類別<xref:System.Type?displayProperty=nameWithType>，不由 common language runtime (CLR) 建立。  
  
 比方說，在版本相容序列化這個方法可讓您使用的部分名稱來搜尋"best fit"的組件。 其他多載<xref:System.Type.GetType%2A>方法需要組件限定類型名稱，其中包含的版本號碼。  
  
 型別系統的替代實作可能要傳回的子類別<xref:System.Type?displayProperty=nameWithType>，不會建立由 CLR; 所有類型的其他多載會傳回<xref:System.Type.GetType%2A>方法屬於執行階段類型。  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>使用注意事項  
 這個方法多載，以及其相關聯的多載剖析`typeName`成的型別和組件名稱的名稱，再解析名稱。 組件名稱的解析就會發生型別名稱，解析之前，因為型別名稱必須解析組件的內容中。  
  
> [!NOTE]
>  如果您不熟悉的組件限定類型名稱的概念，請參閱<xref:System.Type.AssemblyQualifiedName%2A>屬性。  
  
 如果`typeName`不是組件限定名稱，則會略過組件解析。 可以 Mscorlib.dll 或目前正在執行的組件的內容中解析不合格的型別名稱，或您可以選擇性地提供中的組件`typeResolver`參數。 要包含或省略不同種類的名稱解析會顯示為資料表中的組件名稱的效果[混合的名稱解析](#mixed_name_resolution)> 一節。  
  
 一般使用方式附註：  
  
-   不要傳遞至方法`assemblyResolver`或`typeResolver`他們是來自未知或不受信任的呼叫端。 只使用您所提供或熟悉的方法。  
  
    > [!CAUTION]
    >  使用來自未知或未受信任的呼叫者方法可能會導致提高權限的惡意程式碼。  
  
-   如果您省略`assemblyResolver`及/或`typeResolver`參數、 值`throwOnError`參數傳遞至此執行預設解析的方法。  
  
-   如果`throwOnError`是`true`，這個方法會擲回<xref:System.TypeLoadException>時`typeResolver`傳回`null`，和<xref:System.IO.FileNotFoundException>時`assemblyResolver`傳回`null`。  
  
-   這個方法不會攔截擲回例外狀況`assemblyResolver`和`typeResolver`。 您必須負責解析程式方法所擲回任何例外狀況。  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>解析組件  
 `assemblyResolver`方法會接收<xref:System.Reflection.AssemblyName>物件，它會藉由剖析字串組件名稱包含在產生`typeName`。 如果`typeName`不包含組件名稱，`assemblyResolver`則不會呼叫和`null`傳遞至`typeResolver`。  
  
 如果`assemblyResolver`不提供標準的組件探查用來找出組件。 如果`assemblyResolver`提供，則<xref:System.Type.GetType%2A>方法不會進行一般探查; 在此情況下您必須確定您`assemblyResolver`可以處理傳遞給它的所有組件。  
  
 `assemblyResolver`方法應傳回`null`如果無法解析的組件。 如果`assemblyResolver`傳回`null`，`typeResolver`則不會呼叫並不進行任何處理就會發生; 此外，如果`throwOnError`是`true`、<xref:System.IO.FileNotFoundException>就會擲回。  
  
 如果<xref:System.Reflection.AssemblyName>傳遞至`assemblyResolver`是部分名稱、 一或多個其各部分的`null`。 例如，如果不有任何版本，<xref:System.Reflection.AssemblyName.Version%2A>屬性是`null`。 如果<xref:System.Reflection.AssemblyName.Version%2A>屬性，<xref:System.Reflection.AssemblyName.CultureInfo%2A>屬性，而<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>方法都會傳回`null`，然後提供組件的簡單名稱。 `assemblyResolver`方法可以使用或忽略所有組件的組件名稱。  
  
 不同的組件解析選項的效果會顯示為資料表中[混合的名稱解析](#mixed_name_resolution)區段中的，簡單且組件限定類型名稱。  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>解析型別  
 如果`typeName`未指定組件名稱，`typeResolver`一律會呼叫。 如果`typeName`指定組件名稱，`typeResolver`只有順利解析組件名稱時，才會呼叫。 如果`assemblyResolver`或標準的組件探查傳回`null`，`typeResolver`則不會呼叫。  
  
 `typeResolver`方法會接收三個引數：  
  
-   要搜尋的組件或`null`如果`typeName`不包含組件名稱。  
  
-   簡單類型的名稱。 當巢狀型別，這是最外層包含型別。 當泛型型別，這是泛型類型的簡單名稱。  
  
-   布林值，是`true`如果型別名稱的情況下會被忽略。  
  
 實作可決定使用這些引數的方式。 `typeResolver`方法應傳回`null`若無法解析型別。 如果`typeResolver`傳回`null`和`throwOnError`是`true`的這個多載<xref:System.Type.GetType%2A>會擲回<xref:System.TypeLoadException>。  
  
 不同的型別解析選項的效果會顯示為資料表中[混合的名稱解析](#mixed_name_resolution)區段中的，簡單且組件限定類型名稱。  
  
#### <a name="resolving-nested-types"></a>解析巢狀的類型  
 如果`typeName`是巢狀型別名稱的最外層包含型別傳遞至`typeResolver`。 當`typeResolver`傳回此型別，<xref:System.Type.GetNestedType%2A>之前已解決的最內層的巢狀的類型，方法稱為遞迴運作。  
  
#### <a name="resolving-generic-types"></a>正在解析的泛型型別  
 <xref:System.Type.GetType%2A>稱為遞迴解析泛型型別： 首先要解決泛型類型本身，然後解決它的型別引數。 如果型別引數是泛型，<xref:System.Type.GetType%2A>稱為遞迴解析其型別引數，等等。  
  
 組合`assemblyResolver`和`typeResolver`您提供必須能夠解決這類遞迴的所有層級。 例如，假設您提供`assemblyResolver`所控制的載入`MyAssembly`。 假設您想要解決的泛型型別`Dictionary<string, MyType>`(`Dictionary(Of String, MyType)`在 Visual Basic 中)。 您可能會傳遞下列泛型類型名稱：  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 請注意，`MyType`是只有組件限定型別引數。 名稱<xref:System.Collections.Generic.Dictionary%602>和<xref:System.String>類別不是組件限定。 您`typeResolver`必須能夠處理其中任一組件或`null`，因為它會接收`null`如<xref:System.Collections.Generic.Dictionary%602>和<xref:System.String>。 它可以處理此情況下所呼叫的多載<xref:System.Type.GetType%2A>取用一個字串，因為這兩個不合格的類型名稱都 Mscorlib.dll 中的方法：  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver`不會呼叫方法的字典類型和字串類型，因為這些型別名稱不是組件限定。  
  
 現在假設，而不是`System.String`，第一個泛型引數類型是`YourType`，從`YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 這個組件是目前執行的組件都 Mscorlib.dll，因為無法解析`YourType`沒有組件限定名稱。 因為您`assemblyResolve`會遞迴呼叫，它必須能夠處理這種情況。 而不是傳回`null`以外的組件`MyAssembly`，它現在會執行使用提供的組件載入<xref:System.Reflection.AssemblyName>物件。  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 回到[使用注意事項](#usage_notes)。  
  
#### <a name="resolving-type-names-with-special-characters"></a>正在解析的型別名稱，含有特殊字元  
 某些字元有特殊意義，在組件限定名稱。 如果是簡單類型名稱包含這些字元，字元的簡單名稱是組件限定名稱的一部分時，就會造成剖析錯誤。 若要避免剖析錯誤，您必須逸出特殊字元以反斜線之前您可以將傳遞的組件限定名稱<xref:System.Type.GetType%2A>方法。 例如，如果型別為`Strange]Type`，逸出字元必須加入晚於方括號，如下所示： `Strange\]Type`。  
  
> [!NOTE]
>  無法在 Visual Basic 或 C# 中，建立具有這類特殊字元的名稱，但可由使用 Microsoft intermediate language (MSIL)，或發出動態組件。  
  
 下表顯示類型名稱的特殊字元。  
  
|字元|意義|  
|---------------|-------------|  
|`,` （逗號）|分隔符號組件限定名稱。|  
|`[]` （方括號）|做成對的後置詞，指出陣列型別。分隔符號組中，為封入泛型引數清單和組件限定名稱。|  
|`&` （連字號）|做為尾碼，表示型別是參考型別。|  
|`*` （星號）|做為尾碼，表示型別是指標類型。|  
|`+` （加號）|巢狀類型的分隔符號。|  
|`\` （反斜線）|逸出字元。|  
  
 屬性，例如<xref:System.Type.AssemblyQualifiedName%2A>傳回正確逸出字串。 您必須傳遞正確逸出的字串<xref:System.Type.GetType%2A>方法。 接著，<xref:System.Type.GetType%2A>方法會傳遞至的正確逸出的名稱`typeResolver`以及預設的型別解析方法。 如果您要比較的名稱中的未逸出名稱`typeResolver`，您必須移除逸出字元。  
  
 回到[使用注意事項](#usage_notes)。  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>混合的名稱解析  
 下表摘要說明之間的互動`assemblyResolver`， `typeResolver`，和型別名稱和組件名稱中的所有組合的預設名稱解析`typeName`:  
  
|型別名稱的內容|組件解析程式方法|型別解析程式方法|結果|  
|---------------------------|------------------------------|--------------------------|------------|  
|型別，組件|null|null|相當於呼叫<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載。|  
|型別，組件|提供|null|`assemblyResolver` 傳回的組件，或傳回`null`若無法解析組件。 如果組件解析，<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載用來從組件載入的型別; 否則就不會嘗試解析類型。|  
|型別，組件|null|提供|相當於組件名稱，以轉換<xref:System.Reflection.AssemblyName>物件並呼叫<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>方法多載，以取得組件。 如果組件已解決，將它傳遞至`typeResolver`，否則`typeResolver`則不會呼叫，而且沒有任何進一步嘗試解析類型。|  
|型別，組件|提供|提供|`assemblyResolver` 傳回的組件，或傳回`null`若無法解析組件。 如果組件已解決，將它傳遞至`typeResolver`，否則`typeResolver`則不會呼叫，而且沒有任何進一步嘗試解析類型。|  
|類型|提供 null|null|相當於呼叫<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載。 因為未提供組件名稱，會搜尋才 Mscorlib.dll 和目前執行的組件。 如果`assemblyResolver`提供，則會忽略它。|  
|類型|提供 null|提供|`typeResolver` 呼叫時，和`null`傳遞的組件。 `typeResolver` 可以從任何組件，包括它的目的會自動載入的組件提供的類型。 如果`assemblyResolver`提供，則會忽略它。|  
|組件|提供 null|提供 null|A<xref:System.IO.FileLoadException>擲回，因為組件名稱會剖析如同一般組件限定類型名稱。 這會導致無效的組件名稱。|  
  
 回到：[使用注意事項](#usage_notes)，[解析組件](#resolving_assemblies)，[解析型別的](#resolving_types)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
 -或-  
  
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.ArgumentException">將 <paramref name="typeName" /> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。  
  
 -或-  
  
 <paramref name="throwOnError" /> 為 <see langword="true" />，且 <paramref name="typeName" /> 包含無效的語法 (例如 "MyType[,*,]")。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
 -或-  
  
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或其相依性的其中之一，但無法載入。  
  
 -或-  
  
 <paramref name="typeName" /> 包含無效的組件名稱。  
  
 -或-  
  
 <paramref name="typeName" /> 是有效的組件名稱，沒有型別名稱。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
 -或-  
  
 用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">要決定類型之物件的陣列。</param>
        <summary>取得指定陣列中物件的類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，代表 <paramref name="args" /> 中對應項目的類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Type.GetTypeArray%2A>列出陣列的項目類型的方法。  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="args" /> 的其中一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用了類別初始設定式，並至少有一個會擲回例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要取得其基礎類型程式碼的類型。</param>
        <summary>取得指定的 <see cref="T:System.Type" /> 的基礎類型程式碼。</summary>
        <returns>基礎類型程式碼，如果 <see cref="F:System.TypeCode.Empty" /> 是 <paramref name="type" /> 則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您繼承自<xref:System.Type>，您可以藉由覆寫來變更此方法的行為<xref:System.Type.GetTypeCodeImpl%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.TypeCode>可以用於列舉型別。 在決策區塊`WriteObjectInfo`方法，<xref:System.TypeCode>的<xref:System.Object>參數會檢查，並有適當錯誤訊息寫入至主控台。  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回此 <see cref="T:System.Type" /> 執行個體的基礎型別碼。</summary>
        <returns>基礎類型的型別碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法提供實作`static`（C# 中） 或`Shared`（在 Visual Basic)<xref:System.Type.GetTypeCode%28System.Type%29>方法。 當您繼承自<xref:System.Type>，您可以覆寫這個方法以提供您自己實作<xref:System.Type.GetTypeCode%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得與指定的類別識別項 (CLSID) 關聯的類型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">要取得之類型的 CLSID。</param>
        <summary>取得與指定的類別識別項 (CLSID) 關聯的類型。</summary>
        <returns>
          <see langword="System.__ComObject" />，不論 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。  COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。 您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。  
  
> [!TIP]
>  您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。  
  
 具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：  
  
1.  取得<xref:System.Type>物件，代表`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法來具現化 COM 物件。  
  
 如需範例，請參閱。  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29>多載會忽略任何會具現化時，可能會發生例外狀況<xref:System.Type>物件根據`clsid`引數。 請注意，如果將會擲回任何例外狀況`clsid`登錄中找不到。  
  
   
  
## Examples  
 下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](http://msdn.microsoft.com/library/office/ff838565.aspx)擷取代表 Microsoft Word 應用程式的 COM 類型。 它接著會執行個體化類型呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。 所有受管理的物件，包括為 COM 可見的 (也就是其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。 雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件以建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">要取得之類型的 CLSID。</param>
        <param name="throwOnError">
          <see langword="true" />，擲回任何會發生的例外狀況。  
  
 -或-  
  
 <see langword="false" /> 則忽略任何會發生的例外狀況。</param>
        <summary>取得與指定的類別識別項 (CLSID) 關聯的類型，並指定如果載入類型時發生錯誤是否擲回例外狀況。</summary>
        <returns>
          <see langword="System.__ComObject" />，不論 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。  COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。 您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。  
  
> [!TIP]
>  您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。  
  
 具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：  
  
1.  取得<xref:System.Type>物件，代表`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法來具現化 COM 物件。  
  
 如需範例，請參閱。  
  
 例外狀況，例如<xref:System.OutOfMemoryException>指定時就會擲回`true`如`throwOnError`，但不是將取消登錄 Clsid 的失敗。  
  
   
  
## Examples  
 下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](http://msdn.microsoft.com/library/office/ff838565.aspx)擷取代表 Microsoft Word 應用程式的 COM 類型。 它接著會執行個體化類型呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。 如果在載入類型時發生錯誤，則會擲回例外狀況。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。 所有受管理的物件，包括為 COM 可見的 (也就是其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。 雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件以建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">要取得之類型的 CLSID。</param>
        <param name="server">要載入類型的伺服器。 如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</param>
        <summary>從指定的伺服器中，取得與指定的類別識別項 (CLSID) 相關聯的類型。</summary>
        <returns>
          <see langword="System.__ComObject" />，不論 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。  COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。 您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。  
  
> [!TIP]
>  您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。  
  
 具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：  
  
1.  取得<xref:System.Type>物件，代表`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法來具現化 COM 物件。  
  
   
  
## Examples  
 下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](http://msdn.microsoft.com/library/office/ff838565.aspx)擷取代表從名為 computer17.central.contoso.com 伺服器的 Microsoft Word 應用程式的 COM 類型。它接著會執行個體化類型呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。 所有受管理的物件，包括為 COM 可見的 (也就是其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。 雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件以建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">要取得之類型的 CLSID。</param>
        <param name="server">要載入類型的伺服器。 如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</param>
        <param name="throwOnError">
          <see langword="true" />，擲回任何會發生的例外狀況。  
  
 -或-  
  
 <see langword="false" /> 則忽略任何會發生的例外狀況。</param>
        <summary>從指定的伺服器中，取得與指定的類別識別項 (CLSID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</summary>
        <returns>
          <see langword="System.__ComObject" />，不論 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。  COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。 您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。  
  
> [!TIP]
>  您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。  
  
 具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：  
  
1.  取得<xref:System.Type>物件，代表`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法來具現化 COM 物件。  
  
 例外狀況，例如<xref:System.OutOfMemoryException>指定時就會擲回`true`如`throwOnError`，但不是將取消登錄 Clsid 的失敗。  
  
   
  
## Examples  
 下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](http://msdn.microsoft.com/library/office/ff838565.aspx)擷取代表從名為 computer17.central.contoso.com 伺服器的 Microsoft Word 應用程式的 COM 類型。它接著會執行個體化類型呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。 如果在載入類型時發生錯誤，則會擲回例外狀況。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。 所有受管理的物件，包括為 COM 可見的 (也就是其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。 雖然<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />方法會傳回<see cref="T:System.Type" />對應於特定的受管理物件 GUID 的物件不能使用該<see cref="T:System.Type" />物件以建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例顯示。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">參考類型的物件。</param>
        <summary>取得指定的類型控制代碼所參考的類型。</summary>
        <returns>由指定 <see cref="T:System.RuntimeTypeHandle" /> 參考的類型，如果 <see langword="null" /> 的 <see cref="P:System.RuntimeTypeHandle.Value" /> 屬性為 <paramref name="handle" /> 則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制代碼是有效的只有在所取得的應用程式定義域。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.GetTypeFromHandle%2A>方法來取得<xref:System.Type>物件從<xref:System.RuntimeTypeHandle>提供<xref:System.Type.GetTypeHandle%2A>方法。  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得與指定的程式識別項 (ProgID) 相關聯的類型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要取得之類型的 ProgID。</param>
        <summary>取得與指定的程式識別項 (ProgID) 相關聯的類型；如果在載入 <see cref="T:System.Type" /> 時發生錯誤，則傳回 null。</summary>
        <returns>如果 <paramref name="progID" /> 在登錄中是有效項目，而且有類型與它相關聯，則為與指定的 ProgID 相關聯的類型，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供用於 COM 支援。 因為已取代的命名空間概念 Progid 不會使用 Microsoft.NET Framework 中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">要取得之類型的 ProgID。</param>
        <param name="throwOnError">
          <see langword="true" />，擲回任何會發生的例外狀況。  
  
 -或-  
  
 <see langword="false" /> 則忽略任何會發生的例外狀況。</param>
        <summary>取得與指定的程式識別項 (ProgID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</summary>
        <returns>如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供用於 COM 支援。 因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。  
  
   
  
## Examples  
 下列範例會擷取藉由傳遞 ProgID，指定是否要擲回例外狀況，如果是無效的 ProgID 的類型。 此範例接著會顯示相關的 ProgID，以及任何適用的例外狀況的訊息，ClassID。  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定的 ProgID 未註冊。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要取得之類型的 progID。</param>
        <param name="server">要載入類型的伺服器。 如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</param>
        <summary>從指定的伺服器中，取得與指定的程式識別項 (progID) 相關聯的類型；如果在載入類型時發生錯誤，則傳回 null。</summary>
        <returns>如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供用於 COM 支援。 因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。  
  
   
  
## Examples  
 下列範例會擷取藉由傳遞的 ProgID 和伺服器名稱的型別。 然後範例會顯示 ProgID 與 ClassID，或如果的 ProgID 或伺服器名稱無效，會擲回例外狀況。  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">要取得之 <see cref="T:System.Type" /> 的 progID。</param>
        <param name="server">要載入類型的伺服器。 如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</param>
        <param name="throwOnError">
          <see langword="true" />，擲回任何會發生的例外狀況。  
  
 -或-  
  
 <see langword="false" /> 則忽略任何會發生的例外狀況。</param>
        <summary>從指定的伺服器中，取得與指定的程式識別項 (progID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</summary>
        <returns>如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供用於 COM 支援。 因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。  
  
   
  
## Examples  
 下列範例會擷取藉由傳遞的 ProgID 和伺服器名稱的型別。 此範例接著會顯示相關的 ProgID，指定是否要擲回例外狀況的 ProgID 或伺服器名稱不正確的 ClassID。  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">未註冊指定的 progID。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">要取得其類型控制代碼的物件。</param>
        <summary>取得指定物件的 <see cref="T:System.Type" /> 的控制代碼。</summary>
        <returns>指定 <see cref="T:System.Type" /> 之 <see cref="T:System.Object" /> 的控制代碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制代碼是有效的只有在所取得的應用程式定義域。  
  
   
  
## Examples  
 下列範例會定義類別`MyClass1`、 取得其執行個體，和擷取之物件的執行階段控制代碼。  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與 <see cref="T:System.Type" /> 相關聯的 GUID。</summary>
        <value>與 <see cref="T:System.Type" /> 相關聯的 GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID 是與使用類型相關聯<xref:System.Runtime.InteropServices.GuidAttribute>屬性。  
  
   
  
## Examples  
 下列範例會建立類別`MyClass1`的公用方法，建立`Type`物件對應至`MyClass1`，並取得<xref:System.Guid>結構使用`GUID`屬性`Type`類別。  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前 <see cref="T:System.Type" /> 是否內含或參考其他類型；也就是說，目前 <see cref="T:System.Type" /> 是否為陣列、指標或以傳址方式傳遞。</summary>
        <value>
          如果 <see langword="true" /> 是陣列、指標或以傳址方式傳遞，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，Type.GetType("Int32[]")。傳回 HasElementType `true`，但 Type.GetType("Int32")。傳回 HasElementType `false`。 HasElementType 也會傳回`true`如"Int32 *"和"Int32 （& s) 」。  
  
 如果目前<xref:System.Type>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回`false`。  
  
   
  
## Examples  
 下列範例會傳回`true`或`false`根據物件是否為陣列、 參考類型或指標。  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.HasElementType" /> 屬性並判斷目前 <see cref="T:System.Type" /> 是否內含或參考其他類型；也就是說，目前 <see cref="T:System.Type" /> 是否為陣列、指標或以傳址方式傳遞。</summary>
        <returns>
          如果 <see langword="true" /> 是陣列、指標或以傳址方式傳遞，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，Type.GetType("Int32[]")。傳回 HasElementTypeImpl `true`，但 Type.GetType("Int32")。傳回 HasElementTypeImpl `false`。 HasElementTypeImpl 也會傳回`true`如"Int32 *"和"Int32 （& s) 」。  
  
   
  
## Examples  
 下列範例會定義類別`MyTypeDelegator`，它會覆寫`HasElementTypeImpl`方法。 主要的類別會檢查`HasElementType`屬性，並顯示型別。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>叫用目前 <see cref="T:System.Type" /> 的特定成員。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。  
  
 -或-  
  
 空字串 ("")，要叫用預設成員。  
  
 -或-  
  
 對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</param>
        <param name="invokeAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。 該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。 不需要指定查閱的類型。 如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。 請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</param>
        <param name="target">要在其上叫用指定成員的物件。</param>
        <param name="args">包含引數的陣列，這些引數會傳遞給要叫用的成員。</param>
        <summary>使用指定的繫結條件約束並符合指定的引數清單，來叫用指定的成員。</summary>
        <returns>表示叫用的成員之傳回值的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是 private 和 protected 成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。  
  
 下列<xref:System.Reflection.BindingFlags>引動過程旗標可以用來代表要與成員採取什麼動作：  
  
-   `CreateInstance` 叫用建構函式。 `name` 已忽略。 與其他引動過程旗標無效。  
  
-   `InvokeMethod` 叫用方法，但不是建構函式或類型初始設定式。 不適用於`SetField`或`SetProperty`。 如果`InvokeMethod`單獨使用時，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動加入。  
  
-   `GetField` 若要取得欄位的值。 不適用於`SetField`。  
  
-   `SetField` 若要設定欄位的值。 不適用於`GetField`。  
  
-   `GetProperty` 若要取得的屬性。 不適用於`SetProperty`。  
  
-   `SetProperty` 若要設定屬性。 不適用於`GetProperty`。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果兩個下列條件成立，就會叫用方法：  
  
-   方法宣告中的參數數目等於引數在數目`args`陣列 (除非在成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每個引數的類型可以轉換型別參數的繫結器。  
  
 繫結器將會尋找所有相符的方法。 這些方法找到要求的繫結的類型為基礎 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。 方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。  
  
 選取方法之後，它會叫用。 協助工具會在該點檢查。 搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>類別會負責選取方法被叫用。 預設繫結器選取最適合的相符項目。  
  
 完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和叫用透過<xref:System.Reflection>每當程式碼受到完全信任。  
  
 您可以使用`Type.InvokeMember`將欄位設定為特定值，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是`String`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 如果 F `String[]`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 這將會初始化欄位 F 此新陣列。 您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 這會變更陣列 F 保留字串"b"中的字串"z"。  
  
 當您叫用`IDispatch`成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。 例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。 叫用成員的 DispID 的速度比依名稱查閱的成員。 在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會使用`InvokeMember`存取類型的成員。  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。  
  
 -或-  
  
 已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
 -或-  
  
 其中一個具名參數陣列包含的字串是 <see langword="null" />。</exception>
        <exception cref="T:System.MethodAccessException">指定的成員是類別初始設定式。</exception>
        <exception cref="T:System.MissingFieldException">找不到欄位或屬性。</exception>
        <exception cref="T:System.MissingMethodException">找不到符合 <paramref name="args" /> 中之引數的方法。  
  
 -或-  
  
 目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">無法在 <paramref name="target" /> 上叫用指定的成員。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">有一個以上的方法符合繫結準則。</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 目前不支援這個方法。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 所表示的方法有一或多個未指定的泛型類型參數。 亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用於存取非公用成員，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。  
  
 -或-  
  
 空字串 ("")，要叫用預設成員。  
  
 -或-  
  
 對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</param>
        <param name="invokeAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。 該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。 不需要指定查閱的類型。 如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。 請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</param>
        <param name="target">要在其上叫用指定成員的物件。</param>
        <param name="args">包含引數的陣列，這些引數會傳遞給要叫用的成員。</param>
        <param name="culture">表示要使用之全球化地區設定的物件，它可能是地區設定特性轉換所需要的，例如將數值 <see cref="T:System.String" /> 轉換成 <see cref="T:System.Double" />。  
  
 -或-  
  
 Null 參考 (Visual Basic 中的 <see langword="Nothing" />)，可使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <summary>使用指定的繫結條件約束並符合指定的引數清單和文化特性 (Culture) 來叫用指定的成員。</summary>
        <returns>表示叫用的成員之傳回值的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Globalization.CultureInfo>(`culture`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`culture`。  
  
> [!NOTE]
>  您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。  
  
 下列<xref:System.Reflection.BindingFlags>引動過程旗標可以用來代表要與成員採取什麼動作：  
  
-   `CreateInstance` 叫用建構函式。 `name` 已忽略。 與其他引動過程旗標無效。  
  
-   `InvokeMethod` 叫用方法，但不是建構函式或類型初始設定式。 不適用於`SetField`或`SetProperty`。 如果`InvokeMethod`單獨使用時，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動加入。  
  
-   `GetField` 若要取得欄位的值。 不適用於`SetField`。  
  
-   `SetField` 若要設定欄位的值。 不適用於`GetField`。  
  
-   `GetProperty` 若要取得的屬性。 不適用於`SetProperty`。  
  
-   `SetProperty` 若要設定屬性。 不適用於`GetProperty`。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果兩個下列條件成立，就會叫用方法：  
  
-   方法宣告中的參數數目等於引數在數目`args`陣列 (除非在成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每個引數的類型可以轉換型別參數的繫結器。  
  
 繫結器將會尋找所有相符的方法。 這些方法找到要求的繫結的類型為基礎 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。 方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。  
  
 選取方法之後，它會叫用。 協助工具會在該點檢查。 搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>類別會負責選取方法被叫用。 預設繫結器選取最適合的相符項目。  
  
 完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和每當程式碼受到完全信任時，透過反映來叫用。  
  
 您可以使用`Type.InvokeMember`將欄位設定為特定值，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是`String`您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 如果 F `String[]`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 這將會初始化欄位 F 此新陣列。 您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 這會變更陣列 F 保留字串"b"中的字串"z"。  
  
 當您叫用`IDispatch`成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。 例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。 叫用成員的 DispID 的速度比依名稱查閱的成員。 在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。  
  
 -或-  
  
 已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
 -或-  
  
 其中一個具名參數陣列包含的字串是 <see langword="null" />。</exception>
        <exception cref="T:System.MethodAccessException">指定的成員是類別初始設定式。</exception>
        <exception cref="T:System.MissingFieldException">找不到欄位或屬性。</exception>
        <exception cref="T:System.MissingMethodException">找不到符合 <paramref name="args" /> 中之引數的方法。  
  
 -或-  
  
 目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">無法在 <paramref name="target" /> 上叫用指定的成員。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">有一個以上符合繫結準則的方法。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 所表示的方法有一或多個未指定的泛型類型參數。 亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用於存取非公用成員，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。  
  
 -或-  
  
 空字串 ("")，要叫用預設成員。  
  
 -或-  
  
 對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</param>
        <param name="invokeAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。 該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。 不需要指定查閱的類型。 如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
 -或-  
  
 Null 參考 (在 Visual Basic 中為 Nothing)，可使用 <see cref="P:System.Type.DefaultBinder" />。 請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</param>
        <param name="target">要在其上叫用指定成員的物件。</param>
        <param name="args">包含引數的陣列，這些引數會傳遞給要叫用的成員。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>args</c> 陣列中與對應元素產生關聯的屬性。 參數的關聯屬性儲存在成員的簽章中。  
  
 預設繫結器只會在呼叫 COM 元件時處理這個參數。</param>
        <param name="culture">
          <see cref="T:System.Globalization.CultureInfo" /> 物件，代表要使用的全球化地區設定，進行特定地區設定轉換時可能需要這個物件，例如將數值的 String 轉換成 Double。  
  
 -或-  
  
 Null 參考 (Visual Basic 中的 <see langword="Nothing" />)，可使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="namedParameters">陣列，包含 <c>args</c> 陣列中的值所要傳遞之目標參數的名稱。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束並符合指定的引數清單、修飾詞和文化特性，來叫用指定的成員。</summary>
        <returns>表示叫用的成員之傳回值的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` 呼叫建構函式或方法成員、 取得或設定之屬性成員，取得或設定資料欄位成員，或取得或設定陣列成員的項目。  
  
> [!NOTE]
>  您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。  
  
 當您叫用`IDispatch`成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。 例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。 叫用成員的 DispID 的速度比依名稱查閱的成員。 在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。  
  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>或<xref:System.Globalization.CultureInfo>(`modifiers`和`culture`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別來撰寫並處理的自訂繫結器`modifiers`和`culture`. `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 每個 `namedParameters` 中的參數都取得 `args` 陣列中對應元素的值。 如果 `args` 的長度大於 `namedParameters` 的長度，剩餘的引數值會依順序傳遞。  
  
 `namedParameters`陣列可以用來變更輸入陣列中的引數的順序。 例如，給定方法`M(string a, int b)`(`M(ByVal a As String, ByVal b As Integer)`在 Visual Basic 中) 並輸入的陣列`{ 42, "x" }`，輸入的陣列可以傳遞至不變`args`如果陣列`{ "b", "a" }`提供給`namedParameters`。  
  
 下列<xref:System.Reflection.BindingFlags>篩選旗標可以用來定義要包含在搜尋中的成員：  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。  
  
 下列<xref:System.Reflection.BindingFlags>修飾詞旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 若要忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋才上宣告的成員<xref:System.Type>，不只是繼承的成員。  
  
 下列<xref:System.Reflection.BindingFlags>引動過程旗標可以用來代表要與成員採取什麼動作：  
  
-   `CreateInstance` 叫用建構函式。 `name` 已忽略。 與其他引動過程旗標無效。  
  
-   `InvokeMethod` 叫用方法，但不是建構函式或類型初始設定式。 不適用於`SetField`或`SetProperty`。 如果`InvokeMethod`單獨使用時，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動加入。  
  
-   `GetField` 若要取得欄位的值。 不適用於`SetField`。  
  
-   `SetField` 若要設定欄位的值。 不適用於`GetField`。  
  
-   `GetProperty` 若要取得的屬性。 不適用於`SetProperty`。  
  
-   `SetProperty` 若要設定屬性。 不適用於`GetProperty`。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果兩個下列條件成立，就會叫用方法：  
  
-   方法宣告中的參數數目等於引數在數目`args`陣列 (除非在成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每個引數的類型可以轉換型別參數的繫結器。  
  
 繫結器將會尋找所有相符的方法。 這些方法找到要求的繫結的類型為基礎 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。 方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。  
  
 選取方法之後，它會叫用。 協助工具會在該點檢查。 搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>類別會負責選取方法被叫用。 預設繫結器選取最適合的相符項目。  
  
 `InvokeMember` 可用來叫用其參數具有預設值的方法。 若要繫結至這些方法，需要反映<xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>指定。 預設值是參數，您可以提供不同的值，或提供<xref:System.Reflection.Missing.Value?displayProperty=nameWithType>使用預設值。  
  
 例如，請考慮方法，例如 MyMethod (x，float y int = 2.0)。 要叫用這個方法，只有第一個引數為 MyMethod(4)，需傳遞其中一個以上的繫結旗標，並將兩個引數，也就是 4 的第一個引數傳遞和`Missing.Value`第二個引數。 除非您使用`Missing.Value`，您不可以省略選擇性參數與`Invoke`方法。 如果您必須這麼做，使用`InvokeMember`改為。  
  
 完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和叫用透過<xref:System.Reflection>每當程式碼受到完全信任。  
  
 您可以使用`Type.InvokeMember`將欄位設定為特定值，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是`String`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 如果 F `String[]`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 這將會初始化欄位 F 此新陣列。 您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 這會變更陣列 F 保留字串"b"中的字串"z"。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> 和 <paramref name="modifiers" /> 的長度不同。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。  
  
 -或-  
  
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。  
  
 -或-  
  
 具名參數陣列大於引數陣列。  
  
 -或-  
  
 已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
 -或-  
  
 其中一個具名參數陣列包含的字串是 <see langword="null" />。</exception>
        <exception cref="T:System.MethodAccessException">指定的成員是類別初始設定式。</exception>
        <exception cref="T:System.MissingFieldException">找不到欄位或屬性。</exception>
        <exception cref="T:System.MissingMethodException">找不到符合 <paramref name="args" /> 中之引數的方法。  
  
 -或-  
  
 找不到具有 <paramref name="namedParameters" /> 中所提供引數名稱的成員。  
  
 -或-  
  
 目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">無法在 <paramref name="target" /> 上叫用指定的成員。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">有一個以上符合繫結準則的方法。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 所表示的方法有一或多個未指定的泛型類型參數。 亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用於存取非公用成員，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為抽象並且必須被覆寫。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是抽象，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A>屬性會傳回`true`在下列情況：  
  
-   目前的類型是抽象的。也就是說，它無法具現化，但只可做為衍生類別的基底類別。 在 C# 中，抽象類別會以標記[抽象](~/docs/csharp/language-reference/keywords/abstract.md)關鍵字; 在 Visual Basic 中，它們會標示[MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)關鍵字。  
  
-   目前的類型是介面。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
   
  
## Examples  
 下列範例會建立的陣列<xref:System.Type>代表下列類型的物件： 包含類型傳回`true`的指定的物件是否`abstract`; 否則它會傳回`false`。  
  
-   `AbstractClass`抽象類別 (類別標示為`abstract`在 C# 和`MustInherit`在 Visual Basic 中)。  
  
-   `DerivedClass`繼承自一個類別`AbstractClass`。  
  
-   `SingleClass`不可繼承的類別。 它定義為`sealed`在 C# 和`NotInheritable`在 Visual Basic 中。  
  
-   `ITypeInfo`介面。  
  
-   `ImplementingClass`實作的類別`ITypeInfo`介面。  
  
 方法會傳回`true`僅適用於`AbstractClass`，抽象類別，和`ITypeInfo`，介面。  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否為 <see langword="AnsiClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</summary>
        <value>
          如果為 <see langword="true" /> 選取字串格式屬性 <see langword="AnsiClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>選取字串格式屬性。 字串格式屬性定義如何解譯字串增強互通性。  
  
 如果目前<xref:System.Type>代表泛型型別，這個屬性與從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。  
  
   
  
## Examples  
 下列範例會取得欄位資訊，並檢查`AnsiClass`屬性。  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，以表示類型是否為陣列。</summary>
        <value>
          如果目前的類型是陣列則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A>屬性會傳回`false`如<xref:System.Array>類別。 它也會傳回`false`如果目前的執行個體<xref:System.Type>物件，表示集合型別或設計來搭配集合，例如介面<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>。  
  
 若要檢查的陣列，使用程式碼如下所示：  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 如果目前的型別代表泛型類型或類型參數的泛型類型或泛型方法定義中，這個屬性永遠傳回`false`。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Type.IsArray%2A>屬性。  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsArray" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為陣列。</summary>
        <returns>
          如果 <see langword="true" /> 是陣列，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行個體<xref:System.Array>類別必須傳回`false`因為它是一個物件，而非陣列。  
  
   
  
## Examples  
 下列範例會覆寫`IsArrayImpl`方法中的`MyTypeDelegator`類別，如果變數是陣列，並顯示結果的檢查。  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">要與目前的類型比較的類型。</param>
        <summary>判斷指定類型的執行個體是否可以指派給目前類型的執行個體。</summary>
        <returns>
          <see langword="true" /> (下列任何條件成立時)：  
  
-   <paramref name="c" /> 和目前執行個體代表相同類型。  
  
-   <paramref name="c" /> 直接或間接衍生自目前執行個體。 <paramref name="c" /> 會直接衍生自目前的執行個體 (如果它繼承自目前的執行個體)，<paramref name="c" /> 會間接衍生自目前的執行個體 (如果它繼承自目前的執行個體所繼承的一或多個一連串類別)。  
  
-   目前執行個體是 <paramref name="c" /> 實作的介面。  
  
-   <paramref name="c" /> 是泛型類型參數，而且目前執行個體代表 <paramref name="c" /> 的其中一個條件約束。  
  
     在下列範例中，目前的執行個體是 <see cref="T:System.Type" /> 物件，代表 <see cref="T:System.IO.Stream" /> 類別。 <c>GenericWithConstraint</c> 泛型型別，其泛型型別參數必須是型別 <see cref="T:System.IO.Stream" />。 傳遞其泛型型別參數至 <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> 表示泛型型別參數的執行個體可以指派給 <see cref="T:System.IO.Stream" /> 物件。  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" /> 代表實值類型，而且目前執行個體代表 <c>Nullable&lt;c&gt;</c> (在 Visual Basic 中為 <c>Nullable(Of c)</c>)。  
  
 如果以上條件都不成立，或者 <paramref name="c" /> 為 <see langword="false" />，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A>方法可以用來判斷執行個體是否`c`可以指派至目前型別的執行個體，方法當處理的物件在設計階段未知的型別便最有用並允許條件式指派，如下列範例會顯示。  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 這個方法因此可確保一行程式碼，如下列會在執行階段執行而不擲回<xref:System.InvalidCastException>或類似的例外狀況的例外狀況：  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 在衍生類別可以覆寫這個方法。  
  
> [!NOTE]
>  無法從封閉式的建構類型可指派的泛型類型定義。 也就是說，您無法將指派封閉式的建構的類型`MyGenericList<int>`(`MyGenericList(Of Integer)`在 Visual Basic 中) 類型的變數至`MyGenericList<T>`。  
  
 如果`c`參數的類型是<xref:System.Reflection.Emit.TypeBuilder>，結果根據用來建立的類型。 下列程式碼範例示範此使用名為內建型別`B`。  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 下列範例會示範`IsAssignableFrom`類別、 整數陣列，與泛型方法使用定義。  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否為 <see langword="AutoClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</summary>
        <value>
          如果為 <see langword="true" /> 選取字串格式屬性 <see langword="AutoClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>選取字串格式屬性。 字串格式屬性定義如何解譯字串增強互通性。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前類型的欄位是否已由 Common Language Runtime 自動配置版面的值。</summary>
        <value>
          如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了方便起見，已提供這個屬性。 或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取型別配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>設定。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>，<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值會指出類型的欄位配置記憶體中的方式。  
  
 動態類型，您可以指定<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>當您建立的類型。 在程式碼，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性附帶<xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType>列舉值的型別，可讓執行階段判斷適當的方式來配置的類別。  
  
> [!NOTE]
>  您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至類型。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由 `MyGenericType<T>.`  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
   
  
## Examples  
 下列範例會建立類型的執行個體，並顯示<xref:System.Type.IsAutoLayout%2A>屬性。  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否以傳址方式傳遞。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是以傳址方式傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得實際的型別，由參考所傳遞的型別取值 （dereference），然後呼叫<xref:System.Type.GetElementType%2A>該型別上。  
  
   
  
## Examples  
 下列範例會示範使用`IsByRef`屬性檢查指定的型別傳址方式傳遞。 此範例會定義類別`MyTypeDelegator`，它會覆寫`HasElementTypeImpl`方法。 主要的類別會檢查`HasElementType`屬性，並顯示型別。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsByRef" /> 屬性並判斷 <see cref="T:System.Type" /> 是否以傳址方式傳遞。</summary>
        <returns>
          如果 <see cref="T:System.Type" /> 是以傳址方式傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示 <see cref="T:System.Type" /> 是類別或委派，也就是非實值類型或介面。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是類別，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`true`類別，以及委派。 它會傳回`false`實值型別 （適用於結構和列舉型別） 即使 boxing 處理。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`true`。如果目前<xref:System.Type>代表建構的泛型型別，這個屬性會傳回`true`如果泛型類型定義為類別定義; 也就是說，它不會定義介面或實值類型。  
  
> [!NOTE]
>  這個屬性會傳回`true`如`Type`執行個體表示<xref:System.Enum>和<xref:System.ValueType>類別。 這兩個類別列舉的基底類型和實值類型，分別是，但不是列舉型別或值型別本身。 如需詳細資訊，請參閱<xref:System.Type.IsValueType%2A>和<xref:System.Type.IsEnum%2A>屬性。  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>列舉值區分型別宣告為類別或介面。不過，類別和實值類型會標示<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>屬性。 如果您在擷取值的型別屬性屬性然後使用<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>值，以判斷是否為類別，而不是實值類型的類型，您也必須呼叫<xref:System.Type.IsValueType%2A>屬性。 如範例<xref:System.Reflection.TypeAttributes>列舉包含的其他資訊，以及 anexample。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會建立類型的執行個體，並指出類型是否為類別。  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為 COM 物件。</summary>
        <value>
          如果 <see langword="true" /> 是 COM 物件，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回`false`的 COM 介面，因為它們不是物件。 可以由 Microsoft.NET Framework 物件實作 COM 介面。  
  
 您也可以載入 COM 類別，並取得`Type`使用該 COM 類別的物件[Tlbimp.exe （類型程式庫匯入工具）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int`> (`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsCOMObject" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為 COM 物件。</summary>
        <returns>
          如果 <see langword="true" /> 是 COM 物件，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回`false`的 COM 介面，因為它們不是物件。 可以由 Microsoft.NET Framework 物件實作 COM 介面。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個物件是否表示建構的泛型類型。 您可以建立已建構之泛型類型的執行個體。</summary>
        <value>
          如果這個物件代表建構的泛型類型，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建構的泛型類型已明確提供給所有泛型型別參數的類型。 它也稱為封閉泛型類型。  
  
 當這個屬性是`true`，您可以建立執行個體目前的類型; 當它是`false`，您不能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出在內容中是否可以裝載 <see cref="T:System.Type" />。</summary>
        <value>
          如果在內容中可以裝載 <see cref="T:System.Type" />，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 內容會攔截呼叫類別的成員，並強制執行原則會套用至類別，例如同步處理。 如需詳細遠端內容的詳細資訊，請參閱<xref:System.Runtime.Remoting.Contexts.Context>。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
   
  
## Examples  
 下列範例會示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>屬性<xref:System.Type>類別。 它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>實作 <see cref="P:System.Type.IsContextful" /> 屬性並判斷在內容中是否可以裝載 <see cref="T:System.Type" />。</summary>
        <returns>
          如果在內容中可以裝載 <see cref="T:System.Type" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫這個方法。  
  
 內容會攔截呼叫類別的成員，並強制執行原則會套用至類別，例如同步處理。  
  
   
  
## Examples  
 下列範例會示範使用`IsContextfulImpl`方法。  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前的 <see cref="T:System.Type" /> 是否表示列舉類型。</summary>
        <value>
          如果目前 <see langword="true" /> 代表列舉，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`true`列舉型別，但不是適合用於<xref:System.Enum>型別本身。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例示範如何使用`IsEnum`屬性。  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要測試的值。</param>
        <summary>傳回值，這個值表示指定的值是否存在於目前的列舉類型中。</summary>
        <returns>
          如果指定的值是目前列舉型別的成員，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 屬於的型別不得為列舉的基礎型別。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">進行測試以確定是否和目前類型等價的 COM 類型。</param>
        <summary>判斷兩個 COM 類型是否具有相同的識別以及是否適合類型等價。</summary>
        <returns>
          如果 COM 類型相等，則為 <see langword="true" />，否則為 <see langword="false" />。 如果一個類型位於已載入來執行的組件中，而另一個類型位於已載入至純反映性的內容的組件中，這個方法也會傳回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，通用語言執行平台支援的 managed 組件，而不需要 managed 組件，以取得 interop 從 COM 類型的型別資訊直接將 COM 類型的類型資訊內嵌組件。 因為內嵌類型資訊僅包含 Managed 組件實際所使用的類型和成員，所以兩個 Managed 組件可能對於相同的 COM 類型會有非常不同的檢視。 每個 Managed 組件有不同的 <xref:System.Type> 物件以代表其 COM 類型檢視。 通用語言執行平台支援介面、結構、列舉和委派等這些不同檢視之間的類型等價。  
  
 類型等價表示從一個 Managed 組件傳到另一個的 COM 物件，可以在接收的組件中轉換成適當的 Managed 類型。 <xref:System.Type.IsEquivalentTo%2A>方法可讓以判斷 COM 物件取得另一個組件具有相同的 COM 識別做為第一個組件的自己內嵌 interop 類型，其中的組件，因此可以轉換成該類型。  
  
 如需詳細資訊，請參閱[類型等價和內嵌 Interop 類型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前類型的欄位是否已在明確指定之位移配置版面的值。</summary>
        <value>
          如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了方便起見，已提供這個屬性。 或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取型別配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>設定。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>， <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值會指出類型的欄位配置記憶體中的方式。  
  
 動態類型，您可以指定<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>當您建立的類型。 在程式碼，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性附帶<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>的型別，來指定欄位開始的位移會明確指定的列舉值。  
  
> [!NOTE]
>  您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至類型。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
   
  
## Examples  
 下列範例會建立類型的執行個體，並顯示的值及其<xref:System.Type.IsExplicitLayout%2A>屬性。 它會使用`MySystemTime`類別，這也是在程式碼範例中為<xref:System.Runtime.InteropServices.StructLayoutAttribute>。  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前的 <see cref="T:System.Type" /> 是否表示泛型類型或泛型方法定義中的類型參數。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 物件表示泛型型別或泛型方法定義中的型別參數，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> 您可以取得物件，代表泛型型別參數呼叫<xref:System.Type.GetGenericArguments%2A>方法<xref:System.Type>物件，代表泛型類型定義，或<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>方法<xref:System.Reflection.MethodInfo>物件，代表泛型方法定義。  
  
-   泛型類型或方法定義<xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`結果陣列的每一個元素。  
  
-   封閉式建構的類型或方法，如<xref:System.Type.IsGenericParameter%2A>屬性會傳回`false`所傳回之陣列的每個項目的<xref:System.Type.GetGenericArguments%2A>方法。  
  
-   對於開放式建構的類型或方法，陣列的某些項目可能是特定類型，而且其他人可能型別參數。 <xref:System.Type.IsGenericParameter%2A> 傳回`false`類型和`true`的型別參數。 程式碼範例<xref:System.Type.ContainsGenericParameters%2A>屬性示範具有混合型別與型別參數的泛型類別。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.IsGenericParameter%2A>以測試是否為泛型類型的泛型型別參數的屬性。  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前類型是否為泛型類型。</summary>
        <value>
          <see langword="true" /> 如果目前的類型是泛型型別。否則， <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.IsGenericType%2A>屬性來判斷是否<xref:System.Type>物件代表泛型類型。 使用<xref:System.Type.ContainsGenericParameters%2A>屬性來判斷是否<xref:System.Type>物件都代表開放式建構的類型或封閉式的建構的類型。  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A>屬性會傳回`false`如果立即的型別不是泛型。 例如，其項目屬於型別陣列`A<int>`(`A(Of Integer)`在 Visual Basic 中) 是本身不是泛型類型。  
  
 下表摘要說明在反映中泛型使用的通用詞彙的非變異條件。  
  
|詞彙|非變異值|  
|----------|---------------|  
|Generic Type Definition - 泛型類型定義|<xref:System.Type.IsGenericTypeDefinition%2A> 屬性為 `true`。<br /><br /> 定義泛型類型。 建構的類型由呼叫<xref:System.Type.MakeGenericType%2A>方法<xref:System.Type>物件，代表泛型類型定義，並指定型別引數的陣列。<br /><br /> <xref:System.Type.MakeGenericType%2A> 只有在泛型類型定義上，可以被呼叫。<br /><br /> 任何泛型類型定義為泛型類型 (<xref:System.Type.IsGenericType%2A>屬性是`true`)，但反之不然，則為 true。|  
|Generic Type - 泛型類型|<xref:System.Type.IsGenericType%2A> 屬性為 `true`。<br /><br /> 可以是泛型類型定義、 開放式建構的類型或封閉式的建構的類型。<br /><br /> 請注意，陣列類型的項目型別為泛型本身並不是泛型型別。 也是如此的<xref:System.Type>物件，代表泛型類型的指標。|  
|開放式建構的類型|<xref:System.Type.ContainsGenericParameters%2A> 屬性為 `true`。<br /><br /> 範例包括有未指派的型別參數的泛型型別、 開放式建構類型，或泛型類型定義中巢狀類型或泛型類型具有其型別引數<xref:System.Type.ContainsGenericParameters%2A>屬性是`true`。<br /><br /> 您不可能建立開放式建構類型的執行個體。<br /><br /> 請注意，並非所有開放式建構的類型的泛型。 例如，其項目類型是泛型類型定義陣列不是泛型，而開放式建構類型的指標不是泛型。|  
|封閉式建構的類型|<xref:System.Type.ContainsGenericParameters%2A> 屬性為 `false`。<br /><br /> 當遞迴檢查，型別沒有任何未指派的泛型參數。|  
|Generic Type Parameter - 泛型型別參數|<xref:System.Type.IsGenericParameter%2A> 屬性為 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 屬性為 `true`。<br /><br /> 在泛型類型定義中，將於之後指定類型的預留位置。|  
|Generic Type Argument - 泛型類型引數|可以是任何類型，包括泛型類型參數。<br /><br /> 型別引數所指定的陣列為<xref:System.Type>物件傳遞至<xref:System.Type.MakeGenericType%2A>方法建立已建構的泛型型別時。 如果執行個體的產生的型別建立，<xref:System.Type.ContainsGenericParameters%2A>屬性必須是`false`所有型別引數。|  
  
 下列程式碼範例及下表說明部分這些條款及非變異值。 `Derived`類別是特別感興趣的因為其基底類型是具有型別和型別參數的混合，其型別引數清單中的建構的類型。  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 下表顯示範例會使用的類別上建立`Base`， `Derived`，和`G`。 當 c + + 和 C# 程式碼都相同時，則會顯示只有一個項目。  
  
|範例|非變異值|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|此型別：<br /><br /> <xref:System.Type.IsGenericType%2A> 為 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 為 `true`。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|此型別：<br /><br /> <xref:System.Type.IsGenericType%2A> 為 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 為 `true`。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|類型的變數`d`:<br /><br /> <xref:System.Type.IsGenericType%2A> 是`false`因為`d`是陣列。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 為 `false`。|  
|`T``U`，和`V`（everywhere 它們會顯示）|<xref:System.Type.IsGenericParameter%2A> 為 `true`。<br /><br /> <xref:System.Type.IsGenericType%2A> 是`false`因為沒有任何方法來限制泛型類型的型別參數。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是`true`因為`T`， `U`，和`V`本身也是泛型型別參數。 這不表示任何關於稍後指派給它們的型別引數。|  
|欄位的類型 `F`|<xref:System.Type.IsGenericType%2A> 為 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 是`false`因為型別已被指派至類型參數的`G`。 請注意，這相當於呼叫<xref:System.Type.MakeGenericType%2A>方法。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是`true`因為欄位的型別`F`已是開放式建構的類型的型別引數。 建構的類型為開放式因為其型別引數 (也就是`Base`) 是泛型類型定義。 下列說明處理遞迴性質<xref:System.Type.IsGenericType%2A>屬性。|  
|巢狀的類別 `Nested`|<xref:System.Type.IsGenericType%2A> 是`true`，即使`Nested`類別具有自己的任何泛型類型參數，因為它巢狀在泛型型別。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `true`。 也就是說，您可以呼叫<xref:System.Type.MakeGenericType%2A>方法並提供封入類型的型別參數`Derived`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是`true`封入類型，因為`Derived`，泛型類型參數。 下列說明處理遞迴性質<xref:System.Type.ContainsGenericParameters%2A>屬性。|  
  
   
  
## Examples  
 下列程式碼範例顯示的值<xref:System.Type.IsGenericType%2A>， <xref:System.Type.IsGenericTypeDefinition%2A>， <xref:System.Type.IsGenericParameter%2A>，和<xref:System.Type.ContainsGenericParameters%2A>< 備註 > 一節所述之類型的屬性。 屬性值的說明，請參閱 < 備註 > 中的表格。  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前的 <see cref="T:System.Type" /> 是否表示可用於建構其他泛型類型的泛型類型定義。</summary>
        <value>
          如果 <see langword="true" /> 物件表示泛型類型定義，則為 <see cref="T:System.Type" />否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型類型定義是用於建構其他類型的範本。 例如，從泛型類型定義`G<T>`（以表示 C# 語法。`G(Of T)`在 Visual Basic 或`generic <typename T> ref class G`c + + 中) 您可以建構並具現化類型`G<int>`(`G(Of Integer)`在 Visual Basic 中)，藉由呼叫<xref:System.Type.MakeGenericType%2A>與包含泛型引數清單的方法<xref:System.Int32>型別。 指定<xref:System.Type>物件，代表這個建構的型別，<xref:System.Type.GetGenericTypeDefinition%2A>方法會取得泛型類型定義傳回一次。  
  
 使用<xref:System.Type.IsGenericTypeDefinition%2A>屬性來判斷您是否可以從目前的型別來建立新的類型。 如果<xref:System.Type.IsGenericTypeDefinition%2A>屬性會傳回`true`，您可以呼叫<xref:System.Type.MakeGenericType%2A>方法來建立新的泛型型別。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列範例會顯示類型，包括這是泛型類型定義的相關資訊。 建構的類型、 其泛型型別定義，以及一般型別，會顯示資訊。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否套用了 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 屬性 (Attribute)，亦即其是否從 COM 類型程式庫匯入。</summary>
        <value>
          如果 <see langword="true" /> 具有 <see cref="T:System.Type" />，則為 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由 `MyGenericType<T>.`  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">要與目前的類型比較的物件。</param>
        <summary>判斷指定的物件是否為目前 <see cref="T:System.Type" /> 的執行個體。</summary>
        <returns>
          如果在目前 <see langword="Type" /> 位於 <paramref name="o" /> 所代表之物件的階層架構中，或者目前 <see langword="Type" /> 位於 <paramref name="o" /> 支援的介面中，則為 <see langword="true" />。 如果都不是這些情況，或者如果 <paramref name="o" /> 為 <see langword="null" />，又或者如果目前 <see langword="Type" /> 為開放式泛型類型 (亦即 <see cref="P:System.Type.ContainsGenericParameters" /> 會傳回 <see langword="true" />)，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫這個方法。  
  
> [!NOTE]
>  建構的類型不是其泛型型別定義的執行個體。 也就是說， `MyGenericList<int>` (`MyGenericList(Of Integer)`在 Visual Basic 中) 不是執行個體的`MyGenericList<T>`(`MyGenericList(Of T)`在 Visual Basic 中)。  
  
   
  
## Examples  
 下列範例示範 `IsInstanceOfType` 方法的用法。  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為介面；也就是說，不是類別或實值類型。</summary>
        <value>
          如果 <see langword="true" /> 是介面，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask>區分型別宣告為類別、 介面或實值類型。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會建立一個介面、 檢查介面類型，並指出類別是否具有`IsInterface`屬性集。  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前類型的欄位是否已依為其定義或發出至中繼資料之順序，循序配置版面的值。</summary>
        <value>
          如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了方便起見，已提供這個屬性。 或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取型別配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>設定。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>， <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值會指出類型的欄位配置記憶體中的方式。  
  
 動態類型，您可以指定<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>當您建立的類型。 在程式碼，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性附帶<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>的型別，以指定該版面配置是循序的列舉值。  
  
> [!NOTE]
>  您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至類型。  
  
 如需詳細資訊，請參閱章節 9.1.2 通用語言基礎結構 (CLI) 文件 < 磁碟分割第二部分： 中繼資料定義和語意 > 規格。 您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
   
  
## Examples  
 下列範例會建立類別的執行個體的<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>中的列舉值<xref:System.Runtime.InteropServices.StructLayoutAttribute>類別已設定，會檢查是否有<xref:System.Type.IsLayoutSequential%2A>屬性，並顯示結果。  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否以傳址方式封送處理。</summary>
        <value>
          如果 <see langword="true" /> 是以傳址方式進行封送處理，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>屬性<xref:System.Type>類別。 它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>實作 <see cref="P:System.Type.IsMarshalByRef" /> 屬性，判斷 <see cref="T:System.Type" /> 是否以傳址方式封送處理。</summary>
        <returns>
          如果 <see langword="true" /> 是以傳址方式進行封送處理，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫這個方法。  
  
   
  
## Examples  
 下列範例會判斷是否會依參考封送處理指定的型別，並顯示結果。  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前的 <see cref="T:System.Type" /> 物件代表的類型之定義是否位於另一個類型的定義內部。</summary>
        <value>
          如果 <see langword="true" /> 巢狀於另一個類型中，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A>屬性會傳回`true`所有巢狀類型，不論可見性。 若要同時測試巢狀結構和可見性，使用 相關的屬性<xref:System.Type.IsNestedAssembly%2A>， <xref:System.Type.IsNestedFamily%2A>， <xref:System.Type.IsNestedFamANDAssem%2A>， <xref:System.Type.IsNestedFamORAssem%2A>， <xref:System.Type.IsNestedPrivate%2A>，或<xref:System.Type.IsNestedPublic%2A>。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask>列舉成員選取類型的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。 然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只在它自己的組件內為可見。</summary>
        <value>
          如果 <see langword="true" /> 是巢狀並只在它自己的組件內為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。 然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只對同時屬於它自己家族和它自己組件的類別為可見。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是巢狀並只對同時屬於它自己家族和它自己組件的類別為可見，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
> [!NOTE]
>  C# 和 Visual Basic 語言不包含可讓您定義的巢狀的類型，是只在它自己組件中受保護的類型為可見的語意。 `protected internal` 在 C# 中的可見性和`Protected Friend`可見性，在 Visual Basic 中的定義的巢狀的類型，會顯示受保護的類型和相同的組件中的型別。  
  
 A<xref:System.Type>物件的系列會定義為相同的所有物件<xref:System.Type>和及其子型別。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。 然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只在它自己的系列內為可見。</summary>
        <value>
          如果 <see langword="true" /> 是巢狀並只在它自己的家族內為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
 A<xref:System.Type>物件的系列定義為所有物件的完全相同<xref:System.Type>和及其子型別。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。 然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀並只對屬於它自己家族或它自己組件的類別為可見。</summary>
        <value>
          如果 <see langword="true" /> 是巢狀並只對屬於它自己家族或它自己組件的類別為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類型的可見性會`protected internal`在 C# 或`Protected Friend`在 Visual Basic 中<xref:System.Type.IsNestedFamORAssem%2A>屬性會傳回`true`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
 A<xref:System.Type>物件的系列定義為所有物件的完全相同<xref:System.Type>和及其子型別。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。 然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀並且宣告為私用。</summary>
        <value>
          如果 <see langword="true" /> 是巢狀並且宣告為私用，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。 然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出類別是否為巢狀 (Nest) 並且宣告為公用 (Public)。</summary>
        <value>
          如果類別是巢狀並且宣告為公用，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。 然後它會擷取的可見性相關的數字的值<xref:System.Type>父類型和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否未宣告為公用。</summary>
        <value>
          如果 <see langword="true" /> 尚未宣告為公用而且不是巢狀類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿使用這個屬性與巢狀類型;使用<xref:System.Type.IsNestedPublic%2A>屬性改為。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性會傳回`false`。  
  
   
  
## Examples  
 此範例用途`IsNotPublic`来取得之類型的可見性屬性。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 下列程式碼範例示範為何無法使用`IsPublic`和`IsNotPublic`巢狀類別。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 巢狀類別，略過的結果`IsPublic`和`IsNotPublic`和結果的注意`IsNestedPublic`和`IsNestedPrivate`。 此程式碼片段的反映輸出應如下所示：  
  
|類別|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為指標。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是指標，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回`false`。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會示範搭配`IsPointer`屬性。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsPointer" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為指標。</summary>
        <returns>
          如果 <see cref="T:System.Type" /> 是指標，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為其中一個基本類型 (Primitive Type)。</summary>
        <value>
          如果 <see langword="true" /> 是其中一個基本類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本類型為<xref:System.Boolean>， <xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.IntPtr>， <xref:System.UIntPtr>， <xref:System.Char>，<xref:System.Double>，和<xref:System.Single>。  
  
 如果目前<xref:System.Type>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回`false`。  
  
   
  
## Examples  
 下列範例會示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>屬性<xref:System.Type>類別。 它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsPrimitive" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為其中一個基本類型。</summary>
        <returns>
          如果 <see langword="true" /> 是其中一個基本類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本類型為<xref:System.Boolean>， <xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.Char>， <xref:System.Double>，和<xref:System.Single>。  
  
   
  
## Examples  
 下列範例會判斷指定的型別是否為基本類型，並顯示結果。  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否宣告為公用。</summary>
        <value>
          如果 <see langword="true" /> 已宣告為公用而且不是巢狀類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿使用巢狀型別。使用<xref:System.Type.IsNestedPublic%2A>改為。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性會傳回`true`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立的執行個體`MyTestClass`，檢查是否有`IsPublic`屬性，並顯示結果。  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 巢狀類別，略過的結果`IsPublic`和`IsNotPublic`和結果的注意<xref:System.Type.IsNestedPublic%2A>和<xref:System.Type.IsNestedPrivate%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否宣告為密封。</summary>
        <value>
          如果 <see langword="true" /> 宣告為密封，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性永遠傳回`true`。  
  
   
  
## Examples  
 下列範例會建立的執行個體`sealed`類別，檢查有無`IsSealed`屬性，並顯示結果。  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前類型在目前信任層級上是否為安全性關鍵或安全性安全關鍵，因而可以執行重要的作業。</summary>
        <value>
          如果目前類型在目前信任層級上為安全性關鍵或安全性安全關鍵，則為 <see langword="true" />，如果是安全性透明，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。 這些屬性的組合是下表所示：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
> [!IMPORTANT]
>  對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。 如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。 組件和其所有類型都視為透明的。 執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。 相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。 您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。  
  
 如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前類型在目前信任層級上是否為安全性安全關鍵，也就是說，它是否能執行重要作業並由安全性透明的程式碼存取。</summary>
        <value>
          如果目前類型在目前信任層級上為安全性安全關鍵，則為 <see langword="true" />；如果為安全性關鍵或安全性透明，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。 這些屬性的組合是下表所示：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
> [!IMPORTANT]
>  對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。 如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。 組件和其所有類型都視為透明的。 執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。 相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。 您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。  
  
 如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前類型在目前信任層級上是否為透明，因此無法執行重要作業。</summary>
        <value>
          如果型別在目前信任層級上為安全性透明，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性會傳回`true`、<xref:System.Type.IsSecurityCritical%2A>和<xref:System.Type.IsSecuritySafeCritical%2A>屬性傳回`false`。  
  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
> [!IMPORTANT]
>  對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。 如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。 組件和其所有類型都視為透明的。 執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。 相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。 您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。  
  
 如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否可序列化。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 可序列化，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
在.NET 標準所定義的類型未標示有<xref:System.SerializableAttribute>。 相反地，每個.NET 實作可決定是否可序列化類型。 在執行階段，您可以使用<xref:System.Type.IsSerializable%2A>屬性來決定是否該實作會支援序列化之型別的執行個體。 如需詳細資訊和範例，請參閱[如何判斷是否可序列化的.NET 標準物件](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)。
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
   
  
## Examples  
 下列範例會建立的執行個體`MyTestClass`類別，設定 [Serializable] 屬性，並檢查`IsSerializable`屬性`true`或`false`。  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示類型是否具有需要特殊處理的名稱。</summary>
        <value>
          如果類型具有需要特殊處理的名稱，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭或包含底線字元 (_)、 屬性存取子和運算子多載方法的名稱是由某些編譯器需要特殊處理的類型的範例。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">要與目前的類型比較的類型。</param>
        <summary>判斷目前 <see cref="T:System.Type" /> 是否衍生自指定的 <see cref="T:System.Type" />。</summary>
        <returns>
          如果目前 <see langword="true" /> 衍生自 <see langword="Type" />，則為 <paramref name="c" />，否則為 <see langword="false" />。 如果 <see langword="false" /> 和目前 <paramref name="c" /> 相等，這個方法也會傳回 <see langword="Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以呼叫<xref:System.Type.IsSubclassOf%2A>方法，以判斷下列任一項：  
  
-   是否從另一個衍生一個類別。  
  
-   型別是否衍生自<xref:System.ValueType>。 不過，<xref:System.Type.IsValueType%2A>是更有效率的方式來決定類型是否為實值類型。  
  
-   型別是否衍生自<xref:System.Enum>。 不過，<xref:System.Type.IsEnum%2A>方法是更有效率的方式來決定類型是否為列舉型別。  
  
-   是否為型別是一種委派，也就是是否從它衍生<xref:System.Delegate>或<xref:System.MulticastDelegate>。  
  
 <xref:System.Type.IsSubclassOf%2A>方法無法用來判斷是否介面衍生自另一個介面，或者類別是否實作介面。 使用<xref:System.Type.IsAssignableFrom%2A>基於這個目的，如下列範例所示的方法。  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 如果目前<xref:System.Type>表示型別參數中的泛型類型或泛型方法定義，其衍生自其類別條件約束，或從<xref:System.Object?displayProperty=nameWithType>如果它沒有類別條件約束。  
  
> [!NOTE]
>  介面，搭配使用時，除非<xref:System.Type.IsSubclassOf%2A>是反向<xref:System.Type.IsAssignableFrom%2A>。 也就是說，如果`t1.IsSubclassOf(t2)`是`true`，然後`t2.IsAssignableFrom(t1)`也`true`。  
  
 在衍生類別可以覆寫這個方法。  
  
   
  
## Examples  
 下列範例會建立名為類別`Class1`和衍生的類別，名為`DerivedC1`。 它會呼叫<xref:System.Type.IsSubclassOf%2A>方法，以顯示，`DerivedC1`是子類別的`Class1`。  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否為 <see langword="UnicodeClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</summary>
        <value>
          如果為 <see langword="true" /> 選取字串格式屬性 <see langword="UnicodeClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>用來選取字串格式屬性。 字串格式屬性定義如何解譯字串增強互通性。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為實值類型。</summary>
        <value>
          如果 <see langword="true" /> 是實值類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實值型別會表示為位元; 順序的型別實值類型不是類別或介面。 實值型別稱為 「 結構 」 中的某些程式設計語言。 列舉是特殊案例的實值類型。  
  
 這個屬性會傳回`false`如<xref:System.ValueType>類別，因為<xref:System.ValueType>不是實值型別本身。 它是所有的實值類型的基底類別，因此任何實值類型，可以指派給它。 這並不是可能如果<xref:System.ValueType>本身是實值類型。 會在指派給欄位的類型時，會進行 boxed 處理實值類型<xref:System.ValueType>。  
  
 這個屬性會傳回`true`列舉型別，但不是適合用於<xref:System.Enum>型別本身。 如需示範此行為的範例，請參閱<xref:System.Type.IsEnum%2A>。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會建立類型的變數`MyEnum`，檢查是否有`IsValueType`屬性，並顯示結果。  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>實作 <see cref="P:System.Type.IsValueType" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為實值類型；也就是說，不是類別或介面。</summary>
        <returns>
          如果 <see langword="true" /> 是實值類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供來啟用其他的型別系統的實作。 它是不通常用於應用程式程式碼。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得一個值，表示位於組件之外的程式碼是否能存取 <see cref="T:System.Type" />。</summary>
        <value>
          如果目前 <see langword="true" /> 是公用類型或公用巢狀類型 (所有封入類型均為公用)，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性來決定類型是否為公用介面的元件組件的一部分。  
  
   
  
## Examples  
 下列程式碼範例會測試兩個類別，其中只有一個外部是可見的組件。  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回代表目前類型之陣列的 <see cref="T:System.Type" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Type" /> 物件，代表由目前類型組成的一維陣列，其下限為零。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，代表由目前類型組成的一維陣列，其下限為零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>方法可用來產生執行階段計算其項目類型的陣列型別。  
  
 **請注意**common language runtime 會區別向量 （也就是一維陣列，都以零為起始） 和多維度陣列。 Vector 中，永遠只有一個維度，其不是剛好只有一個維度的多維陣列相同。 這個方法多載只可用來建立的向量類型，這是唯一的方式建立的向量類型。 使用<xref:System.Type.MakeArrayType%28System.Int32%29>方法多載來建立多維陣列型別。  
  
   
  
## Examples  
 下列程式碼範例會建立陣列， `ref` (`ByRef`在 Visual Basic 中)，以及指標的類型`Test`類別。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <exception cref="T:System.TypeLoadException">目前的類型為 <see cref="T:System.TypedReference" />。  
  
 -或-  
  
 目前的類型為 <see langword="ByRef" /> 類型。 亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">陣列的維度數目。 這個數字必須小於或等於 32。</param>
        <summary>傳回 <see cref="T:System.Type" /> 物件，代表由目前類型組成且為指定維度個數的陣列。</summary>
        <returns>物件，代表由目前類型組成且為指定維度個數的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>方法可用來產生執行階段計算其項目類型的陣列型別。  
  
> [!NOTE]
>  Common language runtime 會區別向量 （也就是一維陣列，都以零為起始） 和多維度陣列。 Vector 中，永遠只有一個維度，其不是剛好只有一個維度的多維陣列相同。 您無法使用這個方法多載來建立的向量類型。如果`rank`為 1，這個方法多載會傳回剛好有一個維度的多維陣列類型。 使用<xref:System.Type.MakeArrayType>方法多載來建立的向量類型。  
  
   
  
## Examples  
 下列程式碼範例會建立陣列， `ref` (`ByRef`在 Visual Basic 中)，以及指標的類型`Test`類別。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> 無效。 例如，0 或負數。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <exception cref="T:System.TypeLoadException">目前的類型為 <see cref="T:System.TypedReference" />。  
  
 -或-  
  
 目前的類型為 <see langword="ByRef" /> 類型。 亦即，<see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" />。  
  
 -或-  
  
 <paramref name="rank" /> 大於 32。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Type" /> 物件，當做 <see langword="ref" /> (Visual Basic 中的 <see langword="ByRef" />) 參數傳遞時，代表目前的類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，當做 <see langword="ref" /> 參數 (在 Visual Basic 中為 <see langword="ByRef" /> 參數) 傳遞時，代表目前的類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A>方法可用來產生`ref`類型 (`ByRef`在 Visual Basic 中) 的參數清單。  
  
 如果使用的語法的 Microsoft 中繼語言 (MSIL)，目前<xref:System.Type>物件代表<xref:System.Int32>，這個方法會傳回<xref:System.Type>物件，代表`Int32&`。  
  
   
  
## Examples  
 下列程式碼範例會建立陣列， `ref` (`ByRef`在 Visual Basic 中)，以及指標的類型`Test`類別。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <exception cref="T:System.TypeLoadException">目前的類型為 <see cref="T:System.TypedReference" />。  
  
 -或-  
  
 目前的類型為 <see langword="ByRef" /> 類型。 亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">由類型組成的陣列，用來取代目前泛型類型的型別參數。</param>
        <summary>用類型陣列的項目取代目前泛型類型定義的類型參數，並傳回代表所得結果建構類型的 <see cref="T:System.Type" /> 物件。</summary>
        <returns>
          <see cref="T:System.Type" />，表示用 <paramref name="typeArguments" /> 的項目取代目前泛型類型之類型參數所得到的建構類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A>方法可讓您撰寫程式碼，將特定類型指派給類型參數的泛型類型定義，以便建立<xref:System.Type>物件，代表特定建構的類型。 您可以使用這個<xref:System.Type>物件建立的建構類型的執行階段執行個體。  
  
 使用類型建構<xref:System.Type.MakeGenericType%2A>可以在開啟，也就是其類型引數部分可以是封入泛型方法或類型的型別參數。 發出動態組件時，您可以使用這類開放式建構的類型。 例如，請考慮類別`Base`和`Derived`下列程式碼。  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 若要產生`Derived`在動態組件，就需要建構其基底類型。 若要這樣做，請呼叫<xref:System.Type.MakeGenericType%2A>方法<xref:System.Type>代表類別物件`Base`，使用泛型型別引數<xref:System.Int32>和型別參數`V`從`Derived`。 因為型別和泛型型別參數都表示所<xref:System.Type>物件，包含這兩個陣列可以傳遞至<xref:System.Type.MakeGenericType%2A>方法。  
  
> [!NOTE]
>  建構的類型，例如`Base<int, V>`有用時發出程式碼，但您不能呼叫<xref:System.Type.MakeGenericType%2A>這個類型上的方法，所以不是泛型類型定義。 若要建立封閉式的建構的類型可具現化，請先呼叫<xref:System.Type.GetGenericTypeDefinition%2A>方法來取得<xref:System.Type>物件，代表泛型類型定義，然後呼叫<xref:System.Type.MakeGenericType%2A>所需的型別引數。  
  
 <xref:System.Type>所傳回物件<xref:System.Type.MakeGenericType%2A>相同<xref:System.Type>藉由呼叫取得<xref:System.Object.GetType%2A>建構類型，所產生的方法或<xref:System.Object.GetType%2A>建構建立從相同泛型類型的任何的方法。使用相同的型別引數的型別定義。  
  
> [!NOTE]
>  泛型型別的陣列本身並不是泛型型別。 您不能呼叫<xref:System.Type.MakeGenericType%2A>陣列上輸入，例如`C<T>[]`(`Dim ac() As C(Of T)`在 Visual Basic 中)。 若要建構從封閉泛型類型`C<T>[]`，呼叫<xref:System.Type.GetElementType%2A>可取得泛型類型定義`C<T>`; 呼叫<xref:System.Type.MakeGenericType%2A>泛型類型定義，來建立建構的類型，最後呼叫<xref:System.Type.MakeArrayType%2A>方法要建立陣列類型的建構的類型。 也是如此的指標類型和`ref`類型 (`ByRef`在 Visual Basic 中)。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
## <a name="nested-types"></a>巢狀類型  
 如果使用 C#、 c + + 或 Visual Basic 定義泛型類型，其巢狀的類型是所有泛型。 即使巢狀型別有沒有自己的型別參數，因為所有的三種語言包含巢狀類型的型別參數清單中封入類型的型別參數，也是如此。 請考慮下列類別：  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 巢狀類別的型別參數清單`Inner`有兩個類型參數，`T`和`U`，其中第一個是其封入類別的型別參數。 同樣地，巢狀類別的型別參數清單`Innermost1`有三個類型參數， `T`， `U`，和`V`，與`T`和`U`來自其封入類別。 巢狀的類別`Innermost2`有兩個類型參數，`T`和`U`，這是來自其封入類別。  
  
 如果封入類型的參數清單中有一個以上的型別參數，在順序中的所有型別參數會包含巢狀類型的型別參數清單中。  
  
 若要建構的泛型型別從巢狀類型的泛型類型定義，請呼叫<xref:System.Type.MakeGenericType%2A>與陣列方法形成串連在型別引數陣列的所有封入類型，最外層的泛型型別，開頭和結束必須有它自己的型別參數之型別本身的巢狀類型引數陣列。 若要建立的執行個體`Innermost1`，呼叫<xref:System.Type.MakeGenericType%2A>與陣列，其中包含要指派給 T、 U 和 V 的三種類型的方法。若要建立的執行個體`Innermost2`，呼叫<xref:System.Type.MakeGenericType%2A>方法的陣列，其中包含兩個型別，以指派給 T 和 u。  
  
 語言傳播以這種方式中封入類型，因此您可以使用以定義巢狀類型的欄位的封入類型的型別參數的型別參數。 否則，型別參數不會有巢狀類型的主體內的範圍內。 可定義巢狀型別沒有傳播封入類型，透過發出動態組件中的程式碼或使用的型別參數[Ilasm.exe （IL 組譯工具）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。 MSIL 組譯工具，請考慮下列程式碼：  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 在此範例中，就不可以定義類型的欄位`T`或`U`類別中`Innermost`，因為這些型別參數不在範圍內。 下列的組譯工具程式碼定義的行為會在 c + +、 Visual Basic 和 C# 中定義的巢狀的類別：  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)檢查高階語言中定義的巢狀的類別，並觀察這個命名配置。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.MakeGenericType%2A>方法來建立從泛型類型定義建構的型別<xref:System.Collections.Generic.Dictionary%602>型別。 建構的類型代表<xref:System.Collections.Generic.Dictionary%602>的`Test`字串索引鍵的物件。  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前類型不代表泛型型別定義。 亦即，<see cref="P:System.Type.IsGenericTypeDefinition" /> 會傳回 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="typeArguments" /> 的任何項目是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArguments" /> 中的元素個數與目前泛型型別定義中的型別參數個數不同。  
  
 -或-  
  
 <paramref name="typeArguments" /> 中的所有元素都不符合目前泛型型別對應之型別參數所設定的條件。  
  
 -或-  
  
 <paramref name="typeArguments" /> 中包含的項目是指標型別 (<see cref="P:System.Type.IsPointer" /> 傳回 <see langword="true" />)、by-ref 型別 (<see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" />) 或<see cref="T:System.Void" />。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Type" /> 物件，代表指向目前類型的指標。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，代表指向目前類型的指標。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A>方法可用來產生參數清單的指標類型。  
  
 如果使用的語法的 Microsoft 中繼語言 (MSIL)，目前<xref:System.Type>物件代表<xref:System.Int32>，這個方法會傳回<xref:System.Type>物件，代表`Int32*`。  
  
   
  
## Examples  
 下列程式碼範例會建立陣列， `ref` (`ByRef`在 Visual Basic 中)，以及指標的類型`Test`類別。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <exception cref="T:System.TypeLoadException">目前的類型為 <see cref="T:System.TypedReference" />。  
  
 -或-  
  
 目前的類型為 <see langword="ByRef" /> 類型。 亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得一個 <see cref="T:System.Reflection.MemberTypes" /> 值，代表這個成員是類型或巢狀類型。</summary>
        <value>一個 <see cref="T:System.Reflection.MemberTypes" /> 值，代表這個成員是類型或巢狀類型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會覆寫<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>。 因此，當您檢查一組<xref:System.Reflection.MemberInfo>物件 — 例如，將所傳回的陣列<xref:System.Type.GetMembers%2A>—<xref:System.Reflection.MemberInfo.MemberType%2A>屬性會傳回<xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>時指定的成員是巢狀的類型。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值由`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例示範`MemberType`欄位當做參數`GetMember`方法：  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示在 <see cref="T:System.Type" /> 資訊中的遺漏值。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Missing`欄位以供透過反映來取得參數的預設值的引動過程。 如果`Missing`欄位會傳入輸入參數值，而且沒有預設值為該參數，<xref:System.ArgumentException>就會擲回。  
  
   
  
## Examples  
 下列程式碼範例示範使用`Missing`欄位來叫用具有預設引數的方法。  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 此程式碼會產生下列輸出：  
  
 = 10 b = 55.3 c = 12  
  
 a = 10 b = 1.3 c = 1  
  
 a = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在已定義的目前 <see cref="T:System.Type" /> 中取得模組 (DLL)。</summary>
        <value>在目前已定義之 <see cref="T:System.Type" /> 中的模組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性會傳回已定義的泛型類型定義所在的模組。 例如，如果您建立的執行個體`MyGenericStack<int>`、<xref:System.Type.Module%2A>建構的類型的屬性會傳回模組中`MyGenericStack<T>`定義。  
  
 同樣地，如果目前<xref:System.Type>代表泛型參數`T`，這個屬性會傳回包含定義的泛型類型的組件`T`。  
  
   
  
## Examples  
 下列範例示範使用<xref:System.Type.Namespace%2A>和`Module`屬性和<xref:System.Type.ToString%2A>方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Type" /> 的命名空間。</summary>
        <value>
          <see cref="T:System.Type" /> 的命名空間；如果目前執行個體沒有命名空間或代表泛型參數，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 命名空間是邏輯設計階段命名慣例，主要用來定義應用程式中的範圍和組織中類別和其他類型的單一階層式結構。 從執行階段的觀點來看，沒有命名空間。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性會傳回包含泛型類型定義的命名空間。 同樣地，如果目前<xref:System.Type>代表泛型參數`T`，這個屬性會傳回包含定義的泛型類型定義的命名空間`T`。  
  
 如果目前<xref:System.Type>物件代表泛型參數，則這個屬性會傳回`null`。  
  
   
  
## Examples  
 下列範例示範使用`Namespace`和<xref:System.Type.Module%2A>屬性和<xref:System.Type.ToString%2A>方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個物件。</param>
        <param name="right">要比較的第二個物件。</param>
        <summary>表示兩個 <see cref="T:System.Type" /> 物件是否相等。</summary>
        <returns>
          如果 <see langword="true" /> 等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個物件。</param>
        <param name="right">要比較的第二個物件。</param>
        <summary>表示兩個 <see cref="T:System.Type" /> 物件是否不相等。</summary>
        <returns>
          如果 <see langword="true" /> 不等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來取得這個成員的類別物件。</summary>
        <value>
          <see langword="Type" /> 物件，用來取得這個 <see cref="T:System.Type" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如<xref:System.Type>物件，這個屬性的值一律是相同的值<xref:System.Type.DeclaringType%2A>屬性。  
  
   
  
## Examples  
 此範例會顯示巢狀類別的反映型別。  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之 <see cref="T:System.Type" /> 的組件限定名稱。</param>
        <param name="throwIfNotFound">
          <see langword="true" /> 表示找不到類型時擲回 <see cref="T:System.TypeLoadException" />，<see langword="false" /> 表示找不到類型時傳回 <see langword="null" />。 指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。 請參閱＜例外狀況＞一節。</param>
        <param name="ignoreCase">
          <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</param>
        <summary>取得具有指定名稱的 <see cref="T:System.Type" />，指定是否執行區分大小寫的搜尋，以及若找不到該類型時是否擲回例外狀況。 載入此類型的目的在於反映，而不是執行。</summary>
        <returns>具有指定名稱的類型 (如有找到)，否則為 <see langword="null" />。 如果找不到該類型，<paramref name="throwIfNotFound" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwIfNotFound" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含類型的組件尚未載入到僅限反映的內容，如果使用<xref:System.Type.ReflectionOnlyGetType%2A>方法是相當於第一個載入的組件反映，使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>方法，並接著藉由呼叫載入型別組件的<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法。 如需組件限定名稱的資訊，請參閱<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>屬性。 如需指定類型名稱的詳細資訊，請參閱<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。  
  
 如果已執行載入組件，另一個複本已載入僅限反映的內容。  
  
 `throwIfNotFound`參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 > 一節中所述。 某些例外狀況的值為何`throwIfNotFound`。 例如，如果組件無效，<xref:System.BadImageFormatException>就會擲回即使`throwIfNotFound`是`false`。  
  
 如需使用僅限反映之內容的詳細資訊，請參閱[如何： 載入組件放入 Reflection-Only 內容](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且找不到類型。  
  
 -或-  
  
 <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。  
  
 -或-  
  
 <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
 -或-  
  
 <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
 -或-  
  
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 物件的陣列。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 不包含組件名稱。  
  
 -或-  
  
 <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效語法 (例如 "MyType[,*,]")。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
 -或-  
  
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
 -或-  
  
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
 -或-  
  
 用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得描述目前類型配置的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</summary>
        <value>取得描述目前類型概略配置特性的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 不會傳回<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法。 相反地，使用這個屬性，讓它。  
  
   
  
## Examples  
 下列程式碼範例會先定義類別、 結構，以及具有特殊的版面配置屬性 （在類別中，巢狀結構） 的結構。 然後此範例使用<xref:System.Type.StructLayoutAttribute%2A>屬性，以取得<xref:System.Runtime.InteropServices.StructLayoutAttribute>每個類型，以及顯示屬性的屬性。  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應之傳入的名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，用於接收對應於名稱的 ID。</param>
        <summary>將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的類型資訊。</param>
        <param name="lcid">類型資訊的地區設定識別項。</param>
        <param name="ppTInfo">所要求類型資訊物件的指標。</param>
        <summary>擷取物件的類型資訊，可以用來取得介面的類型資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向接收物件提供的類型資訊介面數目的位置。</param>
        <summary>擷取物件提供的類型資訊介面數目 (0 或 1)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">辨識成員。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</param>
        <param name="pVarResult">指向用於儲存結果之位置的指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊的結構指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>提供物件所公開的屬性和方法的存取權。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回表示目前 <see langword="String" /> 的名稱的 <see langword="Type" />。</summary>
        <returns>表示目前 <see cref="T:System.String" /> 的名稱的 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回完整的通用語言執行階段命名空間和名稱的所有基本型別。 例如，C# 指令`(long)0.Type().ToString()`傳回"System.Int64"，而不是只是 「 Int64"。  
  
 如果目前<xref:System.Type>代表泛型型別、 類型和其型別引數限定的命名空間和巢狀類型，但不是由組件。 如果目前<xref:System.Type>代表型別參數定義中的泛型類型或泛型方法，這個方法會傳回型別參數的非限定的名稱。  
  
   
  
## Examples  
 下列範例示範使用<xref:System.Type.Namespace%2A>和<xref:System.Type.Module%2A>屬性和`ToString`方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的控制代碼。</summary>
        <value>目前 <see cref="T:System.Type" /> 的控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` 封裝代表類型的內部資料結構的指標。 這個控制代碼的處理序存留期間是唯一的。 控制代碼無效，只有在當初取得應用程式定義域。  
  
   
  
## Examples  
 下列範例會傳回對應的型別控制代碼，並控制代碼傳遞至方法，以取得控制代碼的類型，並顯示它。  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 目前不支援這個屬性。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得類型的初始設定式。</summary>
        <value>物件，包含 <see cref="T:System.Type" /> 的類別建構函式名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別初始設定式也會提供透過<xref:System.Type.FindMembers%2A>方法，或透過多載<xref:System.Type.GetMember%2A>， <xref:System.Type.GetMembers%2A>， <xref:System.Type.GetConstructor%2A>，和<xref:System.Type.GetConstructors%2A>方法會採用<xref:System.Reflection.BindingFlags>做為參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性會傳回`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示類型，該類型是由表示這個類型的 Common Language Runtime 所提供的。</summary>
        <value>
          <see cref="T:System.Type" /> 的基礎系統類型。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>