<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Type.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a40925048dd06746d1e1cda2a76aa4ecaae1b916.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a40925048dd06746d1e1cda2a76aa4ecaae1b916</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</source>
          <target state="translated">代表類型宣告：類別類型、介面類型、陣列類型、值類型、列舉類型、類型參數、泛型類型定義，以及開放式或封閉式的建構泛型類型。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is the root of the <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> functionality and is the primary way to access metadata.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> 是的根<ph id="ph2">&lt;xref:System.Reflection&gt;</ph>功能和主要的方式來存取中繼資料。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Use the members of <ph id="ph1">&lt;xref:System.Type&gt;</ph> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</source>
          <target state="translated">使用的成員<ph id="ph1">&lt;xref:System.Type&gt;</ph>取得型別宣告，成員的類型 （例如建構函式、 方法、 欄位、 屬性和事件的類別） 的相關資訊以及模組和組件部署所在的類別。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</source>
          <target state="translated">不不使用反映來取得類型及成員的相關資訊，不論其存取層級的程式碼需要任何權限。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</source>
          <target state="translated">不不使用反映來存取公用成員或其存取層級會顯示它們在正常的編譯期間其他成員的程式碼需要任何權限。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">不過，為了讓您的程式碼使用反映來存取成員，通常就是無法存取，例如使用私用或內部的方法，或受保護的類型的欄位不會繼承您的類別，您的程式碼必須<ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is an abstract base class that allows multiple implementations.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> 是可讓多個實作的抽象基底類別。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The system will always provide the derived class <ph id="ph1">`RuntimeType`</ph>.</source>
          <target state="translated">系統一律會提供衍生的類別<ph id="ph1">`RuntimeType`</ph>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</source>
          <target state="translated">在反映中，執行階段的字為開頭的所有類別都建立一次，每個系統和支援的比較作業中的物件。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In multithreading scenarios, do not lock <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects in order to synchronize access to <ph id="ph2">`static`</ph> data.</source>
          <target state="translated">在多執行緒處理的情況下，不需要鎖定<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件才能同步處理存取具備<ph id="ph2">`static`</ph>資料。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Other code, over which you have no control, might also lock your class type.</source>
          <target state="translated">其他程式碼，透過它您有任何控制項，也可能會鎖定您的類別類型。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This might result in a deadlock.</source>
          <target state="translated">這可能會導致死結。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Instead, synchronize access to static data by locking a private <ph id="ph1">`static`</ph> object.</source>
          <target state="translated">相反地，同步處理靜態資料的存取權鎖定私用<ph id="ph1">`static`</ph>物件。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A derived class can access protected members of the calling code's base classes.</source>
          <target state="translated">在衍生的類別可以存取受保護的成員呼叫的程式碼基底類別。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Also, access is allowed to assembly members of the calling code's assembly.</source>
          <target state="translated">此外，允許存取至呼叫的程式碼組件成員。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</source>
          <target state="translated">規則是，如果您允許存取在早期繫結程式碼，然後您也可以存取晚期繫結程式碼中。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</source>
          <target state="translated">擴充其他介面的介面不會繼承擴充介面中定義的方法。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In this section:</source>
          <target state="translated">本節內容：</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>What types does a Type object represent?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>型別物件表示何種類型？<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Retrieving a Type object<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>擷取型別物件<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Comparing type objects for equality<ept id="p1">](#Equality)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>比較相等的類型物件<ept id="p1">](#Equality)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>What types does a Type object represent?</source>
          <target state="translated">型別物件表示何種類型？</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This class is thread safe; multiple threads can concurrently read from an instance of this type.</source>
          <target state="translated">這個類別具備執行緒安全。多個執行緒可以同時讀取此類型的執行個體。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Type&gt;</ph> class can represent any of the following types:</source>
          <target state="translated">執行個體<ph id="ph1">&lt;xref:System.Type&gt;</ph>類別可代表任何下列類型：</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Classes</source>
          <target state="translated">類別</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Value types</source>
          <target state="translated">值類型</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Arrays</source>
          <target state="translated">陣列</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces</source>
          <target state="translated">介面</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Enumerations</source>
          <target state="translated">列舉</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Delegates</source>
          <target state="translated">委派</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Constructed generic types and generic type definitions</source>
          <target state="translated">建構泛型類型和泛型類型定義</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</source>
          <target state="translated">型別引數與型別參數的建構泛型類型、 泛型類型定義與泛型方法定義</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Retrieving a Type object</source>
          <target state="translated">擷取型別物件</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object associated with a particular type can be obtained in the following ways:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph>與特定類型相關聯的物件可透過下列方式：</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The instance <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the type of an instance.</source>
          <target state="translated">執行個體<ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>方法會傳回<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，表示執行個體的類型。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Because all managed types derive from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be called on an instance of any type.</source>
          <target state="translated">因為所有的 managed 型別衍生自<ph id="ph1">&lt;xref:System.Object&gt;</ph>、<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>可以在任何類型的執行個體上呼叫方法。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method to determine the runtime type of each object in an object array.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>方法，以判斷物件陣列中每個物件的執行階段類型。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The static <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> methods return a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a type specified by its fully qualified name.</source>
          <target state="translated">靜態<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>方法會傳回<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，代表指定其完整名稱的類型。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph> methods return <ph id="ph4">`Type`</ph> objects that represent the types defined in a module.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph>方法會傳回<ph id="ph4">`Type`</ph>表示模組中定義之類型的物件。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The first method can be used to obtain an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects for all the public and private types defined in a module.</source>
          <target state="translated">第一種方法可以用來取得陣列的<ph id="ph1">&lt;xref:System.Type&gt;</ph>類型物件的所有公用和私用模組中定義。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>(You can obtain an instance of <ph id="ph1">`Module`</ph> through the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph> method, or through the <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph> property.)</source>
          <target state="translated">(您可以取得的執行個體<ph id="ph1">`Module`</ph>透過<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph>方法，或透過<ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph>屬性。)</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph> object contains a number of methods to retrieve the classes defined in an assembly, including <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph>物件包含方法，以擷取中的組件，包含定義的類別數目<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> method returns a filtered list of interface types supported by a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>方法會傳回已篩選的類型所支援的介面型別清單。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> method returns a <ph id="ph2">`Type`</ph> object that represents the element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph>方法會傳回<ph id="ph2">`Type`</ph>物件，表示項目。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> methods return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects representing the interface types supported by a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph>方法會傳回<ph id="ph3">&lt;xref:System.Type&gt;</ph>代表型別所支援的介面類型的物件。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method returns an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects representing the types specified by an arbitrary set of objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph>方法傳回的陣列<ph id="ph2">&lt;xref:System.Type&gt;</ph>代表任意一組物件所指定類型的物件。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The objects are specified with an array of type <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">物件會指定類型的陣列與<ph id="ph1">&lt;xref:System.Object&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> methods are provided for COM interoperability.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法可供 COM 互通性。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>They return a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type specified by a <ph id="ph2">`ProgID`</ph> or <ph id="ph3">`CLSID`</ph>.</source>
          <target state="translated">它們會傳回<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表所指定之類型<ph id="ph2">`ProgID`</ph>或<ph id="ph3">`CLSID`</ph>。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method is provided for interoperability.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph>方法會提供如互通性。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>It returns a <ph id="ph1">`Type`</ph> object that represents the type specified by a class handle.</source>
          <target state="translated">它會傳回<ph id="ph1">`Type`</ph>代表類別的控制代碼所指定之類型的物件。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator, the C++ <ph id="ph2">`typeid`</ph> operator, and the Visual Basic <ph id="ph3">`GetType`</ph> operator obtain the <ph id="ph4">`Type`</ph> object for a type.</source>
          <target state="translated">C#<ph id="ph1">`typeof`</ph>運算子，c + +<ph id="ph2">`typeid`</ph>運算子和 Visual Basic<ph id="ph3">`GetType`</ph>運算子取得<ph id="ph4">`Type`</ph>型別的物件。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing a constructed generic type, which is an open constructed type if its <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, and a closed constructed type otherwise.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法會傳回<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件代表建構的泛型類型，也就是開放式建構的類型，如果其<ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性會傳回<ph id="ph4">`true`</ph>，並關閉建構類型否則。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A generic type can be instantiated only if it is closed.</source>
          <target state="translated">只有當它已關閉，可以具現化泛型類型。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> methods return <ph id="ph4">&lt;xref:System.Type&gt;</ph> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<ph id="ph5">`ref`</ph> in C#, <ph id="ph6">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>方法會傳回<ph id="ph4">&lt;xref:System.Type&gt;</ph>分別表示指定的型別、 指定的型別，以及參考參數的類型的指標陣列的物件 (<ph id="ph5">`ref`</ph>在 C# 中， <ph id="ph6">`ByRef`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Comparing type objects for equality</source>
          <target state="translated">比較相等的類型物件</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a type is unique; that is, two <ph id="ph2">&lt;xref:System.Type&gt;</ph> object references refer to the same object if and only if they represent the same type.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Type&gt;</ph> ，代表類型是唯一的物件，也就是兩個<ph id="ph2">&lt;xref:System.Type&gt;</ph>如果且只有它們代表相同的型別物件的參考會參考相同的物件。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This allows for comparison of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects using reference equality.</source>
          <target state="translated">這可讓如的比較<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，使用參考相等。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example compares the <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent a number of integer values to determine whether they are of the same type.</source>
          <target state="translated">下列範例會比較<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的數字的整數值，以判斷它們是相同類型的物件。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following  example shows a few representative features of <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">下列範例示範少數代表性的功能<ph id="ph1">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator (<ph id="ph2">`GetType`</ph> operator in Visual Basic, <ph id="ph3">`typeid`</ph> operator in Visual C++) is used to get a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">C#<ph id="ph1">`typeof`</ph>運算子 (<ph id="ph2">`GetType`</ph>在 Visual Basic 中的運算子<ph id="ph3">`typeid`</ph>Visual c + + 運算子) 用來取得<ph id="ph4">&lt;xref:System.Type&gt;</ph>物件，代表<ph id="ph5">&lt;xref:System.String&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>From this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object, the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method is used to get a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing the <ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph> overload that takes a starting location and a length.</source>
          <target state="translated">從這個<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件<ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph>方法用來取得<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>代表<ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph>可接受的開始位置和長度的多載。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To identify the overload signature, the code example creates a temporary array containing two <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing <ph id="ph2">`int`</ph> (<ph id="ph3">`Integer`</ph> in Visual Basic).</source>
          <target state="translated">若要識別多載簽章，程式碼範例會建立暫存陣列，包含兩個<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表<ph id="ph2">`int`</ph>(<ph id="ph3">`Integer`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To be precise, the array contains two references to the instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> that represents <ph id="ph2">`int`</ph> in the current application domain.</source>
          <target state="translated">為了更精確，此陣列包含兩個執行個體的參考<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示<ph id="ph2">`int`</ph>目前的應用程式定義域中。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>For any type, there is only one instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> per application domain.</source>
          <target state="translated">對於任何類型，沒有只有一個執行個體<ph id="ph1">&lt;xref:System.Type&gt;</ph>每個應用程式網域。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The code example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> to invoke the <ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph> method on the string "Hello, World!", and displays the result.</source>
          <target state="translated">此程式碼範例會使用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>叫用<ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph>方法在字串"Hello，World ！"，並顯示結果。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This type is thread safe.</source>
          <target state="translated">此型別具備執行緒安全。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>When you inherit from <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, you must override the following members:</source>
          <target state="translated">當您繼承自<ph id="ph1">&lt;see langword="Type" /&gt;</ph>，您必須覆寫下列成員：</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Type.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.#ctor">
          <source>This constructor is invoked by derived classes during the construction of type objects.</source>
          <target state="translated">這個建構函式會由衍生類別類型物件的建構期間叫用。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the type is declared.</source>
          <target state="translated">取得宣告此類型的 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>For generic types, gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the generic type is defined.</source>
          <target state="translated">若為泛型類型，則取得定義此泛型類型的 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> instance that describes the assembly containing the current type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 執行個體，描述包含目前類型的組件。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</source>
          <target state="translated">若為泛型類型，則此執行個體描述的是含有泛型類型定義的組件，而不是建立與使用特定建構類型的組件。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表建構的泛型型別，這個屬性會傳回包含泛型類型定義的組件。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> in C++).</source>
          <target state="translated">例如，假設您建立名為 MyGenerics.dll 包含泛型類型定義的組件<ph id="ph1">`MyGenericStack&lt;T&gt;`</ph>(<ph id="ph2">`MyGenericStack(Of T)`</ph>在 Visual Basic 中<ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph>c + + 中)。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> in Visual Basic) in another assembly, the <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> property for the constructed type returns an <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents MyGenerics.dll.</source>
          <target state="translated">如果您建立的執行個體<ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>(<ph id="ph2">`MyGenericStack(Of Integer)`</ph>在 Visual Basic 中) 中另一個組件，<ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph>建構類型的屬性會傳回<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>表示 MyGenerics.dll 物件。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an unassigned generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">同樣地，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件表示未指派的泛型參數<ph id="ph2">`T`</ph>，這個屬性會傳回包含定義的泛型類型的組件<ph id="ph3">`T`</ph>。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph>屬性並不適用於特定的.NET 實作，例如.NET Core 或通用 Windows 平台，請使用<ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph>屬性改為。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">下列範例會顯示與類別相關聯的組件名稱和類型的完整的名稱。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="P:System.Type.AssemblyQualifiedName">
          <source>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object was loaded.</source>
          <target state="translated">取得類型的組件限定名稱，包含載入 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的組件名稱。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, which includes the name of the assembly from which the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> was loaded, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的組件限定名稱，包含載入 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 的組件名稱，如果目前的執行個體表示泛型類型參數，則為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</source>
          <target state="translated">類型的組件限定名稱是由型別名稱，包括其命名空間，加上逗號，後面接著組件的顯示名稱所組成。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The display name of an assembly is obtained using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">使用取得組件的顯示名稱<ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">例如，"ProcessorArchitecture = msil"。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">不過，它不包含在所傳回的字串<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性，因為相容性。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">請參閱 <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">支援通用語言執行平台的所有編譯器都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Delimiter</source>
          <target state="translated">分隔符號</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Meaning</source>
          <target state="translated">意義</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">反斜線 (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Escape character.</source>
          <target state="translated">逸出字元。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Comma (,)</source>
          <target state="translated">逗號 （，）</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes the Assembly name.</source>
          <target state="translated">後面接著組件名稱。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Plus sign (+)</source>
          <target state="translated">加號 （+）</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes a nested class.</source>
          <target state="translated">之前的巢狀的類別。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Period (.)</source>
          <target state="translated">句號 （.）</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">代表命名空間識別項。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Brackets ([])</source>
          <target state="translated">括號 ([])</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>After a type name, denotes an array of that type.</source>
          <target state="translated">類型名稱後面，表示該類型的陣列。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For a generic type, encloses the generic type argument list.</source>
          <target state="translated">對於泛型類型，封入泛型型別引數清單。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Within a type argument list, encloses an assembly-qualified type.</source>
          <target state="translated">在型別引數清單中，會封入組件限定的類型。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, the assembly-qualified name for a class might look like this:</source>
          <target state="translated">例如，類別的組件限定名稱可能看起來像這樣：</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">如果命名空間包含的加號，例如 TopNamespace.Sub+Namespace 則加號 （+） 會加上逸出字元 (<ph id="ph1">\\</ph>) 以防止它被解譯為巢狀的分隔符號。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Reflection would emit this string as follows:</source>
          <target state="translated">反映會發出這個字串，如下所示：</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A"+ +"會變成"<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+ 」，和 「<ph id="ph4">\\</ph>能夠又 「 變"<ph id="ph5">\\</ph><ph id="ph6">\\</ph>"。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">這個限定的名稱可以保存下來，並稍後用來載入<ph id="ph1">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">搜尋並載入<ph id="ph1">&lt;xref:System.Type&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>與型別名稱只有或組件限定的類型名稱。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 與類型名稱只會尋找<ph id="ph2">&lt;xref:System.Type&gt;</ph>在呼叫者的組件，然後系統組件。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 與組件限定的類型名稱會尋找<ph id="ph2">&lt;xref:System.Type&gt;</ph>任何組件中。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">若要擷取的型別名稱不含這些尾端字元，請使用<ph id="ph1">`t.GetElementType().ToString()`</ph>，其中<ph id="ph2">`t`</ph>是型別。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">空格是相關組件名稱以外的所有型別名稱元件中。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Generic arguments of generic types are themselves qualified by assembly name.</source>
          <target state="translated">泛型引數的泛型型別是由組件名稱所限定。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, in the assembly-qualified type name for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic), <ph id="ph3">`int`</ph> is expanded to the assembly-qualified type name for <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">例如，在組件限定類型名稱<ph id="ph1">`MyGenericClass&lt;int&gt;`</ph>(<ph id="ph2">`MyGenericClass(Of Integer)`</ph>在 Visual Basic 中)，<ph id="ph3">`int`</ph>展開到組件限定類型名稱<ph id="ph4">&lt;xref:System.Int32&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表泛型參數，則這個屬性會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">下列範例會顯示與類別相關聯的組件名稱和類型的完整的名稱。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">下列範例會比較所傳回的字串<ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph>方法和<ph id="ph2">`Name`</ph>， <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="P:System.Type.Attributes">
          <source>Gets the attributes associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得與 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 關聯的屬性。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, unless the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter, in which case the value is unspecified.</source>
          <target state="translated">代表 <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> 屬性集的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 物件；若 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 代表的是泛型類型參數，則這個值就是未指定的。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Some members of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration are masks that represent a group of values.</source>
          <target state="translated">某些成員<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph>列舉型別會遮罩，代表一組的值。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Each group includes one member whose underlying value is zero.</source>
          <target state="translated">每個群組包含一個成員，其基礎值為零。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the underlying value of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> group is zero, as is the <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> group.</source>
          <target state="translated">例如，基礎值的<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph>中的成員<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph>群組為零，因為<ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>中的成員<ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>群組。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Because of this, you must use the mask before testing for those values.</source>
          <target state="translated">因為這個緣故，您必須使用遮罩之前測試這些值。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The example provides an illustration.</source>
          <target state="translated">這個範例將提供說明。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For most purposes, properties like <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> are easier to use than type attributes.</source>
          <target state="translated">大部分用途而言，屬性例如<ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>，<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph>容易使用以外的類型屬性。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the attributes of the generic type definition.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性傳回的泛型類型定義的屬性。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the attributes returned for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic) are the attributes of <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">例如，針對傳回的屬性<ph id="ph1">`MyGenericClass&lt;int&gt;`</ph>(<ph id="ph2">`MyGenericClass(Of Integer)`</ph>在 Visual Basic 中) 的屬性是<ph id="ph3">`MyGenericClass&lt;T&gt;`</ph>(<ph id="ph4">`MyGenericClass(Of T)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter — that is, if the <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph3">`true`</ph> — the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> value returned by this property is unspecified.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型類型參數，也就是如果<ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>屬性會傳回<ph id="ph3">`true`</ph>—<ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph>未指定這個屬性所傳回的值。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The following example usesthe <ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph> property.</source>
          <target state="translated">下列範例用途<ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Type.BaseType">
          <source>Gets the type from which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所直接繼承的類型。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> from which the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> represents the <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph> class or an interface.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 直接繼承自的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，如果目前 <ph id="ph3">&lt;see langword="null" /&gt;</ph> 表示 <ph id="ph4">&lt;see langword="Type" /&gt;</ph> 類別或介面，則為 <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base type is the type from which the current type directly inherits.</source>
          <target state="translated">基底型別是目前的類型直接繼承的類型。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source><ph id="ph1">&lt;xref:System.Object&gt;</ph> is the only type that does not have a base type, therefore <ph id="ph2">`null`</ph> is returned as the base type of <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph> 是唯一的類型，但是沒有基底型別，因此<ph id="ph2">`null`</ph>傳回基底型別<ph id="ph3">&lt;xref:System.Object&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>Interfaces inherit from zero or more base interfaces; therefore, this property returns <ph id="ph1">`null`</ph> if the <ph id="ph2">`Type`</ph> object represents an interface.</source>
          <target state="translated">介面繼承自零或多個基底介面。因此，這個屬性會傳回<ph id="ph1">`null`</ph>如果<ph id="ph2">`Type`</ph>物件代表的介面。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base interfaces can be determined with <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</source>
          <target state="translated">基底介面可以判斷與<ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, the base type reflects the generic arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，基底類型會反映的泛型引數。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For example, consider the following declarations:</source>
          <target state="translated">例如，請考慮下列宣告：</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> property returns <ph id="ph4">`B&lt;int&gt;`</ph>.</source>
          <target state="translated">建構的類型<ph id="ph1">`C&lt;int&gt;`</ph>(<ph id="ph2">`C(Of Integer)`</ph>在 Visual Basic 中)，則<ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph>屬性會傳回<ph id="ph4">`B&lt;int&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type definition, <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns the class constraint, that is, the class the type parameter must inherit.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示泛型類型定義的型別參數<ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph>傳回類別條件約束，也就是將型別參數必須繼承的類別。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If there is no class constraint, <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果沒有類別條件約束，<ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph>傳回<ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property.</source>
          <target state="translated">下列範例示範如何使用<ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</source>
          <target state="translated">下列範例會使用遞迴列出完整的繼承階層架構的組件中找到的每個類別。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The example defines a class named <ph id="ph1">`C`</ph> that derives from a class named <ph id="ph2">`B`</ph>, which, in turn, derives from a class named <ph id="ph3">`A`</ph>.</source>
          <target state="translated">此範例會定義名為類別<ph id="ph1">`C`</ph>衍生自類別，名為<ph id="ph2">`B`</ph>，它會接著，衍生自類別，名為<ph id="ph3">`A`</ph>。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Type.ContainsGenericParameters">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object has type parameters that have not been replaced by specific types.</source>
          <target state="translated">取得值，該值指出目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件是否有尚未被特定類型取代的類型參數。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 物件本身為泛型類型參數或包含尚未提供特定類型的類型參數則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</source>
          <target state="translated">若要建立類型的執行個體，必須有任何泛型類型定義 」 或 「 開放式建構的類型中的型別引數型別本身，在任何的封入泛型類型或任何項目中的型別。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</source>
          <target state="translated">另一個說法是，當檢查以遞迴方式，類型必須包含沒有泛型類型參數。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Since types can be arbitrarily complex, making this determination is difficult.</source>
          <target state="translated">型別可以很複雜，因為並不容易進行這項判斷。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For convenience and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</source>
          <target state="translated">為了方便起見，並減少錯誤的機會<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性提供的標準方式來區別封閉式的建構類型，可以具現化，並開啟建構類型，不能。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the type cannot be instantiated.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>，無法具現化類型。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>以遞迴方式型別參數的屬性搜尋。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for an array whose elements are type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the array is not itself generic.</source>
          <target state="translated">例如，它會傳回<ph id="ph1">`true`</ph>陣列，其元素是型別<ph id="ph2">`A&lt;T&gt;`</ph>(<ph id="ph3">`A(Of T)`</ph>在 Visual Basic 中)，即使陣列不是泛型本身。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for arrays.</source>
          <target state="translated">這和行為的<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>屬性，它會傳回<ph id="ph2">`false`</ph>陣列。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For a set of example classes and a table showing the values of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property, see <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</source>
          <target state="translated">範例類別和資料表顯示的值的一組<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性，請參閱<ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</source>
          <target state="translated">下列範例會定義具有兩個型別參數的泛型類別，然後定義 衍生自第一個類別中的第二個泛型類別。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph> and the second is a type parameter of the derived type.</source>
          <target state="translated">在衍生的類別的基底類別有兩個型別引數： 第一個是<ph id="ph1">&lt;xref:System.Int32&gt;</ph>第二個是衍生型別的型別參數。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">此範例會顯示這些泛型類別的相關資訊，包括位置回報<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringMethod">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the declaring method, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method.</source>
          <target state="translated">如果目前的 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 表示泛型方法的類型參數，則取得表示宣告方法的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method, a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents declaring method; otherwise, <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 表示泛型方法的類型參數，則為表示宣告方法的 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>否則為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The declaring method is a generic method definition.</source>
          <target state="translated">宣告的方法是泛型方法定義。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>That is, if <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> does not return <ph id="ph2">`null`</ph>, then <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">也就是說，如果<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>不會傳回<ph id="ph2">`null`</ph>，然後<ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph>傳回<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性識別的泛型類型定義或泛型型別參數原本定義所在的泛型方法定義：</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性會傳回<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>、 該<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>代表泛型方法定義，以及目前<ph id="ph4">&lt;xref:System.Type&gt;</ph>物件代表泛型方法定義的型別參數。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性會傳回<ph id="ph2">`null`</ph>，然後在<ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>屬性一律會傳回<ph id="ph4">&lt;xref:System.Type&gt;</ph>物件，代表泛型類型定義和目前<ph id="ph5">&lt;xref:System.Type&gt;</ph>物件都代表該泛型類型的型別參數定義。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">取得<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>型別上的屬性其<ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>屬性是<ph id="ph3">`false`</ph>會擲回<ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> that is returned by the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property is either a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the case of a generic method, or a <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> in the case of a generic constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>所傳回<ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>在泛型的方法，或<ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>在一般的建構函式的情況下。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>In the .NET Framework version 2.0, generic constructors are not supported.</source>
          <target state="translated">在.NET Framework 2.0 版中，不支援泛型建構函式。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性備註。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</source>
          <target state="translated">下列程式碼範例會定義具有泛型方法，將型別引數指派給此方法，並產生建構的泛型方法會叫用的類別。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>It also displays information about the generic method definition and the constructed method.</source>
          <target state="translated">它也會顯示該泛型方法定義的建構的方法的相關資訊。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>When displaying information about the type parameters of the generic method definition, in the <ph id="ph1">`DisplayGenericMethodInfo`</ph> method, the example code shows the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property for the method's generic type parameter.</source>
          <target state="translated">當顯示的相關資訊的型別參數的泛型方法定義中，在<ph id="ph1">`DisplayGenericMethodInfo`</ph>方法，範例程式碼顯示的值<ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>方法的泛型型別參數的屬性。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringType">
          <source>Gets the type that declares the current nested type or generic type parameter.</source>
          <target state="translated">取得宣告目前巢狀類型或泛型型別參數的類型。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">若目前的類型是巢狀類型，即為表示封入類型的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，若目前的類型是泛型類型的類型參數，則為泛型類型定義，而若目前的類型是泛型方法的類型參數，則為宣告泛型方法的類型，若以上皆否，便為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type, this property returns the generic type definition.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表泛型類型的型別參數，這個屬性會傳回泛型類型定義。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表泛型方法的型別參數，這個屬性會傳回包含泛型方法定義的型別。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the type is generic, the generic type definition is returned.</source>
          <target state="translated">如果類型是泛型，則會傳回泛型類型定義。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>That is, the following code returns the generic type definition of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class, which contains the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> generic method:</source>
          <target state="translated">也就是說，下列程式碼傳回的泛型類型定義<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>泛型類別，其中包含<ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph>泛型的方法：</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法定義中<ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性識別泛型型別參數的泛型類型定義或泛型方法定義原本定義：</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性會傳回<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>、 該<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>代表泛型方法定義，以及目前<ph id="ph4">&lt;xref:System.Type&gt;</ph>物件代表泛型方法定義的型別參數。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性會傳回<ph id="ph2">`null`</ph>，然後在<ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>屬性一律會傳回<ph id="ph4">&lt;xref:System.Type&gt;</ph>物件，代表泛型類型定義和目前<ph id="ph5">&lt;xref:System.Type&gt;</ph>物件都代表該泛型類型的型別參數定義。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">取得<ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>型別上的屬性其<ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>屬性是<ph id="ph3">`false`</ph>會擲回<ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>This example displays the declaring type of a method in a derived class.</source>
          <target state="translated">這個範例會顯示在衍生類別中方法的宣告型別。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Type.DefaultBinder">
          <source>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">取得預設繫結器 (Binder) 的參考，它會實作內部規則來選取由 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> 呼叫的適當成員。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>A reference to the default binder used by the system.</source>
          <target state="translated">系統使用的預設繫結器之參考。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</source>
          <target state="translated">預設繫結器提供與 common language runtime 選項適用於所有最特殊的情況。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> class and pass an instance of that type using the <ph id="ph2">`binder`</ph> parameter of one of the <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> overloads.</source>
          <target state="translated">如果您需要不同於所提供的預設繫結器，如下所示規則定義的繫結器型別衍生自<ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph>類別，並將該型別使用的執行個體傳遞<ph id="ph2">`binder`</ph>參數之一的<ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>多載。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Reflection models the accessibility rules of the common type system.</source>
          <target state="translated">反映模型一般類型系統的存取範圍的規則。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</source>
          <target state="translated">例如，如果呼叫端在相同的組件，呼叫端不需要特殊權限的內部成員。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Otherwise, the caller needs <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">否則，呼叫端需要<ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is consistent with lookup of members that are protected, private, and so on.</source>
          <target state="translated">這是一致的受保護的成員查閱、 private、 等等。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The general principle is that <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> should perform only widening conversions, which never lose data.</source>
          <target state="translated">一般原則是<ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph>應該執行僅擴展轉換，不會遺失資料。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</source>
          <target state="translated">擴展轉換的範例將轉換為 64 位元帶正負號的整數值的 32 位元帶正負號的整數的值。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is distinguished from a narrowing conversion, which may lose data.</source>
          <target state="translated">這被區分縮小轉換，可能會遺失資料。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</source>
          <target state="translated">縮小轉換的範例 32 位元帶正負號的整數轉換為 64 位元帶正負號的整數。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following table lists the conversions supported by the default binder.</source>
          <target state="translated">下表列出預設的繫結器所支援的轉換。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Source Type</source>
          <target state="translated">來源類型</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Target Type</source>
          <target state="translated">目標類型</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">任何型別</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Its base type.</source>
          <target state="translated">其基底類型。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">任何型別</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The interface it implements.</source>
          <target state="translated">它所實作的介面。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char</source>
          <target state="translated">Char</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Unt16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Byte</source>
          <target state="translated">Byte</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Char、 Unt16、 Int16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>SByte</source>
          <target state="translated">SByte</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16, Int32, Int64, Single, Double</source>
          <target state="translated">Int16、Int32、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt16</source>
          <target state="translated">UInt16</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">UInt32、Int32、UInt64、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16</source>
          <target state="translated">Int16</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32, Int64, Single, Double</source>
          <target state="translated">Int32、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32</source>
          <target state="translated">UInt32</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64, Int64, Single, Double</source>
          <target state="translated">UInt64、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32</source>
          <target state="translated">Int32</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64, Single, Double</source>
          <target state="translated">Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64</source>
          <target state="translated">UInt64</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single、Double</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64</source>
          <target state="translated">Int64</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single、Double</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single</source>
          <target state="translated">Single</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Double</source>
          <target state="translated">Double</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Non-reference</source>
          <target state="translated">非參考</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>By-reference.</source>
          <target state="translated">所參考。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following example gets the default binder from the <ph id="ph1">`DefaultBinder`</ph> property, and invokes a member of MyClass by passing the <ph id="ph2">`DefaultBinder`</ph> value as a parameter to <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>.</source>
          <target state="translated">下列範例會取得預設繫結器從<ph id="ph1">`DefaultBinder`</ph>屬性，並叫用 MyClass 的成員，藉由傳遞<ph id="ph2">`DefaultBinder`</ph>當做參數值<ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>Separates names in the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">分隔 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的命名空間中的名稱。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>This field is read-only.</source>
          <target state="translated">此欄位為唯讀。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>Represents an empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">表示 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>This field is read-only.</source>
          <target state="translated">此欄位為唯讀。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.EmptyTypes">
          <source>The following code example shows the <ph id="ph1">`EmptyTypes`</ph> field used in one of the <ph id="ph2">`GetConstructor`</ph> methods to get a constructor that takes no parameters.</source>
          <target state="translated">下列程式碼範例示範<ph id="ph1">`EmptyTypes`</ph>欄位使用其中一種<ph id="ph2">`GetConstructor`</ph>方法，以取得不採用任何參數的建構函式。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">判斷目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎系統類型，是否與指定的 <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎系統類型相同。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">其基礎系統類型將與目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎系統類型比較的物件。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>For the comparison to succeed, <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> must be able to be cast or converted to an object of type   <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">為使比較成功，<bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> 必須可以轉型或轉換為 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型別的物件。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">判斷目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的基礎系統類型，是否與指定的 <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> 的基礎系統類型相同。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="o" /&gt;</ph> 的基礎系統型別與目前 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎系統型別相同，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if: .</source>
          <target state="translated">下列條件成立時，此方法也會傳回 <ph id="ph1">&lt;see langword="false" /&gt;</ph>：</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be cast or converted to a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 無法轉型或轉換為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">這個方法覆寫 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>It casts <ph id="ph1">`o`</ph> to an object of type <ph id="ph2">&lt;xref:System.Type&gt;</ph> and calls the <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">它會轉換為<ph id="ph1">`o`</ph>物件的型別<ph id="ph2">&lt;xref:System.Type&gt;</ph>呼叫<ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph> to compare various <ph id="ph2">&lt;xref:System.Type&gt;</ph> object instances with various <ph id="ph3">&lt;xref:System.Object&gt;</ph> instances.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph>比較各種<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件執行個體與各種<ph id="ph3">&lt;xref:System.Object&gt;</ph>執行個體。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>Two things are particularly worth noting about the example:</source>
          <target state="translated">特別值得注意的相關範例，是兩件事：</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents an integer with a <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object that represents an integer return <ph id="ph3">`true`</ph> because <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> is derived from <ph id="ph5">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">比較的<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，表示整數<ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph>物件，表示整數傳回<ph id="ph3">`true`</ph>因為<ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph>衍生自<ph id="ph5">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a  <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> object (an open generic type) with a <ph id="ph3">`List(Of String)`</ph> object (a closed generic type) returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">比較的<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表<ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph>物件 （開放式泛型類型） 與<ph id="ph3">`List(Of String)`</ph>物件 （封閉式泛型類型） 會傳回<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">其基礎系統類型將與目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎系統類型比較的物件。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">判斷目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎系統類型，是否與指定的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 之基礎系統類型相同。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="o" /&gt;</ph> 的基礎系統型別與目前 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎系統型別相同，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Type)">
          <source>The following example uses <ph id="ph1">`Equals`</ph> to compare two types.</source>
          <target state="translated">下列範例會使用<ph id="ph1">`Equals`</ph>比較兩個類型。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>Represents the member filter used on attributes.</source>
          <target state="translated">表示用在屬性 (Attribute) 上的成員篩選條件。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>This field is read-only.</source>
          <target state="translated">此欄位為唯讀。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">這個欄位會保留所使用的委派的參考<ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">這個委派所封裝的方法會採用兩個參數： 第一個是<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>物件和第二個是<ph id="ph2">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">此方法會判斷是否<ph id="ph1">`MemberInfo`</ph>物件名稱符合所指定的準則<ph id="ph2">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The <ph id="ph1">`Object`</ph> may be assigned the value of any one of the fields on the classes <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Object`</ph>可能任一類別上的欄位的值指派給<ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>，或<ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>For example, the <ph id="ph1">`Object`</ph> can be assigned the value of a field from <ph id="ph2">`FieldAttributes`</ph> such as Public.</source>
          <target state="translated">例如，<ph id="ph1">`Object`</ph>可以從欄位的值指派給<ph id="ph2">`FieldAttributes`</ph>例如 Public。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>In that case, when the <ph id="ph1">`FilterAttribute`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object is decorated with the public field attribute in metadata.</source>
          <target state="translated">在此情況下，當<ph id="ph1">`FilterAttribute`</ph>叫用委派時，它會傳回<ph id="ph2">`true`</ph>所代表的方法時，才<ph id="ph3">`MemberInfo`</ph>物件都有公用欄位中的屬性中繼資料。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The following example gets the <ph id="ph1">`FilterAttribute`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the specified members and their attributes.</source>
          <target state="translated">下列範例會取得<ph id="ph1">`FilterAttribute`</ph>委派、 將它當做參數傳遞<ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph>方法，並顯示指定的成員和其屬性。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>Represents the case-sensitive member filter used on names.</source>
          <target state="translated">表示用於名稱上的有區分大小寫的成員篩選條件。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>This field is read-only.</source>
          <target state="translated">此欄位為唯讀。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">這個欄位會保留所使用的委派的參考<ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">這個委派所封裝的方法會採用兩個參數： 第一個是<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>物件和第二個是<ph id="ph2">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">此方法會判斷是否<ph id="ph1">`MemberInfo`</ph>物件名稱符合所指定的準則<ph id="ph2">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated"><ph id="ph1">`Object`</ph>指派字串值，可能會在結尾包含"*"萬用字元。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">只有萬用字元結束字串支援比對。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "Byte*".</source>
          <target state="translated">例如，<ph id="ph1">`Object`</ph>指派的值"位元組 *"。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object has a name that begins with "Byte".</source>
          <target state="translated">在此情況下，當<ph id="ph1">`FilterName`</ph>叫用委派時，它會傳回<ph id="ph2">`true`</ph>所代表的方法時，才<ph id="ph3">`MemberInfo`</ph>物件具有開頭為 「 位元組 」 的名稱。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The following code example gets the methods associated with the user-defined <ph id="ph1">`Application`</ph> type.</source>
          <target state="translated">下列程式碼範例會取得相關聯的使用者定義的方法<ph id="ph1">`Application`</ph>型別。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Represents the case-insensitive member filter used on names.</source>
          <target state="translated">表示用在名稱上的不區分大小寫的成員篩選條件。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field is read-only.</source>
          <target state="translated">此欄位為唯讀。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">這個欄位會保留所使用的委派的參考<ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">這個委派所封裝的方法會採用兩個參數： 第一個是<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>物件和第二個是<ph id="ph2">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">此方法會判斷是否<ph id="ph1">`MemberInfo`</ph>物件名稱符合所指定的準則<ph id="ph2">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated"><ph id="ph1">`Object`</ph>指派字串值，可能會在結尾包含"*"萬用字元。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">只有萬用字元結束字串支援比對。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "ByTe*".</source>
          <target state="translated">例如，<ph id="ph1">`Object`</ph>指派的值"位元組 *"。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return true only if the method represented by the <ph id="ph2">`MemberInfo`</ph> object has a name that begins with "byte", ignoring case.</source>
          <target state="translated">在此情況下，當<ph id="ph1">`FilterName`</ph>叫用委派，它會傳回 true 只所代表的方法如果<ph id="ph2">`MemberInfo`</ph>物件具有開頭為 「 位元組 」，忽略大小寫的名稱。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The following example gets the <ph id="ph1">`MemberFilter`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the methods and their attributes of the <ph id="ph3">`String`</ph> class that begin with the letter "c", disregarding the case.</source>
          <target state="translated">下列範例會取得<ph id="ph1">`MemberFilter`</ph>委派、 將它當做參數傳遞<ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph>方法，並顯示方法和屬性的<ph id="ph3">`String`</ph>開頭字母"c"，正在略過 大小寫的類別。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate that compares the interfaces against <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">根據 <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> 比較介面的委派。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The search criteria that determines whether an interface should be included in the returned array.</source>
          <target state="translated">判斷在傳回陣列中是否應包含介面的搜尋準則。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">傳回 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，表示由目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 所實作或繼承的介面的篩選清單。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no interfaces matching the filter are implemented or inherited by the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，表示由目前的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 所實作或繼承之介面的篩選清單，如果由目前的 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 所實作或繼承之介面都不符合篩選器，則為 <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> 的空陣列。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph> delegates supplied by the <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph> class may also be used, in lieu of the <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph>所提供的委派<ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph>類別也可用於，lieu 的<ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph>委派。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</source>
          <target state="translated">這個類別所實作之介面的考慮所有在搜尋期間，是否為基底類別或此類別本身所宣告。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</source>
          <target state="translated">這個方法會搜尋基底類別階層架構中，傳回每一個相符的介面，以及所有比對的每個類別會實作介面的實作 （亦即，會傳回相符的介面的遞移封閉）。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>No duplicate interfaces are returned.</source>
          <target state="translated">傳回不重複的介面。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法定義中<ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>搜尋所有介面宣告中的條件約束的型別參數，而且所有介面都繼承與介面宣告在條件約束。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type argument of a generic type, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces implemented by the type, whether or not they match constraints.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別引數的泛型型別，<ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>是否符合條件約束，搜尋所有類型所實作的介面。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> can return generic interfaces, even on types that are not generic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> 可傳回泛型介面，即使在不是泛型類型上。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>For example, a nongeneric type might implement <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">例如，可能會實作非泛型型別<ph id="ph1">`IEnumerable&lt;int&gt;`</ph>(<ph id="ph2">`IEnumerable(Of Integer)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</source>
          <target state="translated">下列範例會尋找指定的介面實作或繼承之指定類型，並接著會顯示介面名稱。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">靜態初始設定式已叫用並擲回了例外狀況。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An object that indicates the type of member to search for.</source>
          <target state="translated">物件，表示要搜尋的成員類型。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The delegate that does the comparisons, returning <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member currently being inspected matches the <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> and <ph id="ph2">&lt;see langword="false" /&gt;</ph> otherwise.</source>
          <target state="translated">執行比較的委派，如果目前進行檢查的成員符合 <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>，則傳回 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否則傳回 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can use the <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>, <ph id="ph2">&lt;see langword="FilterName" /&gt;</ph>, and <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> delegates supplied by this class.</source>
          <target state="translated">您可以使用這個類別所提供的 <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>、<ph id="ph2">&lt;see langword="FilterName" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> 委派。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The first uses the fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> as search criteria, and the other two delegates use <ph id="ph4">&lt;see langword="String" /&gt;</ph> objects as the search criteria.</source>
          <target state="translated">第一個委派使用 <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>、<ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> 的欄位做為搜尋準則，而其他兩個委派則使用 <ph id="ph4">&lt;see langword="String" /&gt;</ph> 物件做為搜尋準則。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The search criteria that determines whether a member is returned in the array of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects.</source>
          <target state="translated">判斷在 <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 物件的陣列中是否傳回成員的搜尋準則。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> can be used in conjunction with the <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph> delegate supplied by this class.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>、<ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> 的欄位可以與這個類別所提供的 <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph> 委派結合使用。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Returns a filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">傳回指定成員類型的 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 物件的篩選陣列。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">指定之成員類型的 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 物件篩選陣列。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have members of type <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph> that match the filter criteria.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 類型的空陣列，如果目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 沒有符合篩選條件的 <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph> 類型的成員。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">成員包括屬性、 方法、 欄位、 事件等等。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的成員：</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Instance`</ph> to include instance members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Instance`</ph>来包含在搜尋中的執行個體成員。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Static`</ph> to include static members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Static`</ph>来包含在搜尋中的靜態成員。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用成員。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的成員<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的成員。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Valid values for <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> are defined in <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</source>
          <target state="translated">有效值<ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph>中定義<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If no such members are found, an empty array is returned.</source>
          <target state="translated">如果找不到任何這類成員，則會傳回空陣列。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">若要取得使用此方法的類別初始設定式 (.cctor)，您必須指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> processes any members declared by the class constraint and the interface constraints of the type parameter.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示泛型類型或泛型方法的型別參數<ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph>處理任何由類別條件約束和介面條件約束的型別參數宣告的成員。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</source>
          <target state="translated">下列範例會尋找符合指定的搜尋條件中，在類別中的所有成員，然後顯示 符合的成員。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="P:System.Type.FullName">
          <source>Gets the fully qualified name of the type, including its namespace but not its assembly.</source>
          <target state="translated">取得類型的完整名稱 (包括其命名空間，但不包括其組件)。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The fully qualified name of the type, including its namespace but not its assembly; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter, an array type, pointer type, or <ph id="ph2">&lt;see langword="byref" /&gt;</ph> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</source>
          <target state="translated">類型的完整名稱 (包括其命名空間，但不包括其組件)；如果目前執行個體代表泛型類型參數、陣列類型、指標類型、根據類型參數的 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 類型，或不是泛型類型定義但包含未解析類型參數的泛型類型，則為 <ph id="ph2">&lt;see langword="byref" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>For example, the fully qualified name of the <ph id="ph1">&lt;xref:System.String&gt;</ph> type is <ph id="ph2">`System.String`</ph>.</source>
          <target state="translated">例如，完整的名稱的<ph id="ph1">&lt;xref:System.String&gt;</ph>型別是<ph id="ph2">`System.String`</ph>。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Contrast this with the assembly-qualified name returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, which consists of the full name plus the full assembly name.</source>
          <target state="translated">這和所傳回的組件限定名稱<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性，其中包含的完整名稱加上完整的組件名稱。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>If the current type represents a closed generic type, the type arguments in the string returned by the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</source>
          <target state="translated">如果目前的型別代表封閉泛型類型，所傳回的字串中的型別引數<ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph>屬性會以其完整的組件名稱限定，即使並未被其完整限定的泛型類型本身的字串表示組件名稱。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</source>
          <target state="translated">下列範例說明代表泛型類型定義的類型，另一個則代表封閉泛型類型的 FullName 屬性中的差異。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property returns <ph id="ph1">`null`</ph> if:</source>
          <target state="translated">這個屬性會傳回<ph id="ph1">`null`</ph>如果：</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type.</source>
          <target state="translated">目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表泛型類型的型別參數。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example retrieves the type parameter of the <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type and attempts to display its <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property.</source>
          <target state="translated">下列範例會擷取的型別參數<ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph>型別，並嘗試顯示其<ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an array type, a pointer  type, or a <ph id="ph2">`byref`</ph> type that is based on a generic type parameter.</source>
          <target state="translated">目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件都代表陣列類型、 指標類型或<ph id="ph2">`byref`</ph>泛型型別參數為基礎的類型。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example defines a generic type, <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, with three methods: <ph id="ph2">`Display(T[])`</ph>, which is passed an array of type T; <ph id="ph3">`HandleT(T)`</ph>, which is passed a T object; and <ph id="ph4">`ChangeValue(ref T)`</ph>, which is passed a T object by reference.</source>
          <target state="translated">下列範例會定義泛型類型， <ph id="ph1">`Generictype1&lt;T&gt;`</ph>，三個方法： <ph id="ph2">`Display(T[])`</ph>，傳遞的型別 T; 陣列<ph id="ph3">`HandleT(T)`</ph>，T 的物件; 傳遞和<ph id="ph4">`ChangeValue(ref T)`</ph>，這傳址方式傳遞 T 物件。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Because C# and Visual Basic do not allow us to define T as a pointer in the <ph id="ph1">`HandleT`</ph> method, we have to call the <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents the method's parameter type to create a pointer to a generic type.</source>
          <target state="translated">因為 C# 和 Visual Basic 不允許我們定義中的指標為 T<ph id="ph1">`HandleT`</ph>方法，我們需要呼叫<ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>方法<ph id="ph3">&lt;xref:System.Type&gt;</ph>物件，代表方法的參數類型，若要建立泛型類型的指標。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The output from the example shows that in all three cases, the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">範例輸出顯示在所有的三種情況下，<ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph>屬性是<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current type contains generic type parameters that have not been replaced by specific types (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>), but the type is not a generic type definition (that is, the <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph4">`false`</ph></source>
          <target state="translated">目前的類型包含有尚未被特定類型取代的泛型類型參數 (也就是<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>)，但類型不是泛型類型定義 (也就是<ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>屬性會傳回 <ph id="ph4">`false`</ph></target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>In the following example, <ph id="ph1">`Derived&lt;T&gt;`</ph> inherits from <ph id="ph2">`Base&lt;T&gt;`</ph>.</source>
          <target state="translated">在下列範例中，<ph id="ph1">`Derived&lt;T&gt;`</ph>繼承自<ph id="ph2">`Base&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property obtains the  <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the base type of <ph id="ph3">`Derived&lt;T&gt;`</ph>, and its <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> property returns <ph id="ph5">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph>屬性會取得<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，代表的基底類型<ph id="ph3">`Derived&lt;T&gt;`</ph>，且其<ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph>屬性會傳回<ph id="ph5">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>To get a <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> that is not <ph id="ph2">`null`</ph>, you can use the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get the generic type definition, as the example illustrates.</source>
          <target state="translated">若要取得<ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph>不<ph id="ph2">`null`</ph>，您可以使用<ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>方法來取得泛型類型定義，如範例所示。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example displays the full name of the specified type.</source>
          <target state="translated">下列範例會顯示指定之類型的完整名稱。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">下列範例會比較所傳回的字串<ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph>方法和<ph id="ph2">`Name`</ph>， <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>Gets a combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> flags that describe the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">取得一組 <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> 旗標，敘述目前泛型類型參數的共變數與特殊條件約束。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> 值的位元組合，描述目前泛型類型參數的共變數和特殊條件約束。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</source>
          <target state="translated">這個屬性的值包含旗標，敘述目前泛型型別參數是否共變數和其他特殊條件約束的旗標。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph> value to select the covariance flags, and use the <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph> value to select the constraint flags.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph>值加入選取的共變數旗標，並使用<ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph>来選取的條件約束旗標值。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性備註。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">下列程式碼範例會定義泛型型別<ph id="ph1">`Test`</ph>具有兩個具有不同的條件約束的型別參數。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">當程式執行時，條件約束會檢查使用<ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>屬性和<ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件不是泛型型別參數。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> 屬性會傳回 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type or a generic method.</source>
          <target state="translated">當 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件表示泛型類型或泛型方法的類型參數時，在宣告參數的泛型類型或泛型方法之類型參數清單中，取得類型參數的位置。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</source>
          <target state="translated">型別參數在宣告參數的泛型類型或方法之型別參數清單中的位置。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Position numbers begin at 0.</source>
          <target state="translated">位置編號從 0 開始。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>屬性會傳回型別參數的位置參數清單的泛型類型定義或泛型方法定義中的型別參數原本定義。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type or method definition:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性識別的泛型類型或泛型方法定義：</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性會傳回<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>、 該<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>代表泛型方法定義，以及目前<ph id="ph4">&lt;xref:System.Type&gt;</ph>物件代表泛型方法定義的型別參數。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>屬性會傳回<ph id="ph2">`null`</ph>，然後在<ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>屬性一律會傳回<ph id="ph4">&lt;xref:System.Type&gt;</ph>物件，代表泛型類型定義和目前<ph id="ph5">&lt;xref:System.Type&gt;</ph>物件都代表該泛型類型的型別參數定義。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>To provide the correct context for the value of the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property, it is necessary to identify the generic type or method a type parameter belongs to.</source>
          <target state="translated">若要提供正確的內容值的<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>屬性，它會需要識別的泛型型別或型別參數所屬的方法。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>For example, consider the return value of the generic method <ph id="ph1">`GetSomething`</ph> in the following code:</source>
          <target state="translated">例如，請考慮泛型方法的傳回值<ph id="ph1">`GetSomething`</ph>下列程式碼：</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The type returned by <ph id="ph1">`GetSomething`</ph> depends on the type arguments supplied to class <ph id="ph2">`A`</ph> and to <ph id="ph3">`GetSomething`</ph> itself.</source>
          <target state="translated">傳回的型別<ph id="ph1">`GetSomething`</ph>取決於提供給類別的型別引數<ph id="ph2">`A`</ph>和<ph id="ph3">`GetSomething`</ph>本身。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>You can obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for <ph id="ph2">`GetSomething`</ph>, and from that you can obtain the return type.</source>
          <target state="translated">您可以取得<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>如<ph id="ph2">`GetSomething`</ph>，而且可以從所取得的傳回型別。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type parameters of the return type, <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> returns 0 for both.</source>
          <target state="translated">當您檢查型別參數的傳回型別，<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>同時會傳回 0。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`V`</ph> is 0 because <ph id="ph2">`V`</ph> is the first type parameter in the type parameter list for class <ph id="ph3">`A`</ph>.</source>
          <target state="translated">位置<ph id="ph1">`V`</ph>為 0，因為<ph id="ph2">`V`</ph>類別的型別參數清單中的第一個型別參數<ph id="ph3">`A`</ph>。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`X`</ph> is 0 because <ph id="ph2">`X`</ph> is the first type parameter in the type parameter list for <ph id="ph3">`GetSomething`</ph>.</source>
          <target state="translated">位置<ph id="ph1">`X`</ph>為 0，因為<ph id="ph2">`X`</ph>是第一個型別參數的型別參數清單中<ph id="ph3">`GetSomething`</ph>。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Calling the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property causes an exception if the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> does not represent a type parameter.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>屬性造成例外狀況，如果目前<ph id="ph2">&lt;xref:System.Type&gt;</ph>不代表型別參數。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type arguments of an open constructed type, use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell which are type parameters and which are types.</source>
          <target state="translated">當您檢查開放式建構類型的類型引數時，使用<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>分辨哪些是型別參數，而這是類型的屬性。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for a type parameter; you can then use the <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> method to obtain its position and use the <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> properties to determine the generic method or type definition that defines it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>型別參數; 然後您可以使用<ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>方法來取得它的位置使用<ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>和<ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>內容來決定泛型方法或類型定義它的定義.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</source>
          <target state="translated">下列範例會定義具有兩個型別參數的泛型類別，並定義衍生自第一個類別中的第二個泛型類別。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and the second is a type parameter of the derived type.</source>
          <target state="translated">在衍生的類別的基底類別有兩個型別引數： 第一個是<ph id="ph1">&lt;xref:System.Int32&gt;</ph>，第二個是衍生型別的型別參數。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">此範例會顯示這些泛型類別的相關資訊，包括位置回報<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>The current type does not represent a type parameter.</source>
          <target state="translated">目前類型不代表型別參數。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> 會傳回 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Type.GenericTypeArguments">
          <source>Gets an array of the generic type arguments for this type.</source>
          <target state="translated">取得此類型之泛型型別引數的陣列。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>An array of the generic type arguments for this type.</source>
          <target state="translated">這個類型之泛型型別引數的陣列。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</source>
          <target state="translated">這個屬性取得只的泛型型別引數;也就是說，已指定目前的型別之泛型型別參數的型別。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If the current type is a generic type definition, this property returns an empty array.</source>
          <target state="translated">如果目前的類型是泛型類型定義，這個屬性會傳回空陣列。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</source>
          <target state="translated">如果另一個泛型類型或泛型方法中使用泛型型別，則其泛型型別引數的某些可能封入方法或類型的泛型型別參數。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get the generic type parameters of a type that represents a generic type definition, use the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">若要取得代表泛型類型定義的類型的泛型型別參數，請使用<ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get a <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object for the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, use the <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph> extension method.</source>
          <target state="translated">若要取得<ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph>物件目前<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，請使用<ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph>擴充方法。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>Gets the number of dimensions in an array.</source>
          <target state="translated">取得陣列中的維度數目。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>An integer that contains the number of dimensions in the current type.</source>
          <target state="translated">包含目前類型中之維度數目的整數。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetArrayRank">
          <source>The following example displays the number of dimensions in an array.</source>
          <target state="translated">下列範例會顯示在陣列中的維度數目。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</source>
          <target state="translated">這個方法的功能不受基底類別的支援，因此必須改為在衍生類別中實作。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The current type is not an array.</source>
          <target state="translated">目前的類型不是陣列。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property and gets a bitmask indicating the attributes associated with the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">在衍生類別中覆寫時，實作 <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> 屬性並取得位元遮罩，指示與 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 關聯的屬性。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> 物件，代表 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 的屬性集。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific constructor of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的特定建構函式。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the desired constructor.</source>
          <target state="translated">由 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件組成的陣列，表示所要建構函式參數的數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects, to get a constructor that takes no parameters.</source>
          <target state="translated">由 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件組成的空陣列，用來取得不需任何參數的建構函式。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Such an empty array is provided by the <ph id="ph1">&lt;see langword="static" /&gt;</ph> field <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated">這種供陣列是由 <ph id="ph1">&lt;see langword="static" /&gt;</ph> 欄位 <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> 提供的。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Searches for a public instance constructor whose parameters match the types in the specified array.</source>
          <target state="translated">搜尋其參數符合在指定陣列中的類型的公用執行個體建構函式。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，表示其參數符合參數類型陣列中之類型的公用執行個體建構函式 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</source>
          <target state="translated">這個方法多載尋找公用執行個體建構函式，無法用來取得類別初始設定式 (.cctor)。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>To get a class initializer, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">若要取得的類別初始設定式，使用多載採用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>，並指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the requested constructor is non-public, this method returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">如果要求的建構函式為非公用，則這個方法會傳回<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object, and displays the constructor signature.</source>
          <target state="translated">下列範例會取得的型別<ph id="ph1">`MyClass`</ph>，取得<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>物件，並會顯示建構函式簽章。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">用以取得沒有參數的建構函式之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the parameter type array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，代表在參數類型陣列中與對應項目關聯的屬性。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">使用指定的繫結條件約束 (Constraint) 搜尋其參數符合指定的引數類型和修飾詞 (Modifier) 的建構函式。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> 物件，代表符合指定之需求的建構函式 (如有找到)，否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">如果沒有完全相符，<ph id="ph1">`binder`</ph>會嘗試強制轉型中指定的參數類型<ph id="ph2">`types`</ph>陣列，就可以選取相符項目。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">如果<ph id="ph1">`binder`</ph>無法選取相符項目，然後<ph id="ph2">`null`</ph>傳回。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的建構函式：</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用建構函式。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following program obtains the type of <ph id="ph1">`MyClass1`</ph> class, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object matching the specified binding flags, and displays the signature of the constructor.</source>
          <target state="translated">下列程式會取得的型別<ph id="ph1">`MyClass1`</ph>類別，取得<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>物件符合指定的繫結旗標，並顯示建構函式的簽章。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> 的長度不同。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及清除堆疊。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">用以取得沒有參數的建構函式之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">使用指定的繫結條件約束和指定的呼叫慣例，搜尋其參數符合指定的引數類型和修飾詞的建構函式。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表符合指定之需求的建構函式 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">如果沒有完全相符，<ph id="ph1">`binder`</ph>會嘗試強制轉型中指定的參數類型<ph id="ph2">`types`</ph>陣列，就可以選取相符項目。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">如果<ph id="ph1">`binder`</ph>無法選取相符項目，然後<ph id="ph2">`null`</ph>傳回。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的建構函式：</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用建構函式。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">若要取得使用此方法的類別初始設定式 (.cctor)，您必須指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個方法一律會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass1`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that matches the specified binding flags, and displays the constructor signature.</source>
          <target state="translated">下列範例會取得的型別<ph id="ph1">`MyClass1`</ph>，取得<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>物件符合指定的繫結旗標，並會顯示建構函式簽章。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> 的長度不同。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及清除堆疊。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">用以取得沒有參數的建構函式之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束和指定的呼叫慣例，搜尋其參數符合指定的引數類型和修飾詞的建構函式。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> 物件，代表符合指定之需求的建構函式 (如有找到)，否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">如果沒有完全相符，<ph id="ph1">`binder`</ph>會嘗試強制轉型中指定的參數類型<ph id="ph2">`types`</ph>陣列，就可以選取相符項目。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">如果<ph id="ph1">`binder`</ph>無法選取相符項目，然後<ph id="ph2">`null`</ph>傳回。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的建構函式：</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用建構函式。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This method implements <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</source>
          <target state="translated">這個方法會實作 <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> 的長度不同。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">目前的型別是 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the constructors of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的建構函式。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>Returns all the public constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">傳回所有定義給目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的公用建構函式。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all the public instance constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, but not including the type initializer (static constructor).</source>
          <target state="translated">由 <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> 物件組成的陣列，表示定義給目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 的所有公用執行個體建構函式，但不含類型初始設定式 (靜態建構函式)。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>If no public instance constructors are defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, or if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method, an empty array of type <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> is returned.</source>
          <target state="translated">如果目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 沒有定義任何公用執行個體建構函式，或目前的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 表示泛型類型或泛型方法定義中的類型參數，則會傳回 <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>方法不會建構函式傳回以特定順序，例如，按宣告順序。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於建構函式會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">這個方法多載呼叫<ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph>方法多載，與<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">將不會發現類別初始設定式 (.cctor)。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">類別初始設定式，請使用多載採用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>，並指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">比方說，如果類別<ph id="ph1">`C&lt;T&gt;`</ph>的建構函式<ph id="ph2">`C(T t1)`</ph>(<ph id="ph3">`Sub New(ByVal t1 As T)`</ph>在 Visual Basic 中)，則呼叫<ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>上<ph id="ph5">`C&lt;int&gt;`</ph>傳回<ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>表示<ph id="ph7">`C(int t1)`</ph>C# 中 (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示泛型型別參數時，<ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>方法會傳回空陣列。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">此範例中顯示的輸出<ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>從類別具有兩個執行個體建構函式和一個靜態建構函式多載。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The output of this code is:</source>
          <target state="translated">這個程式碼的輸出為：</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph>多載只會使用<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>，靜態建構函式都不會計算由<ph id="ph4">`for`</ph>運算式，也不會評估<ph id="ph5">`IsStatic`</ph>。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> overload, and pass the combination (logical <ph id="ph2">`OR`</ph>) of <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">靜態建構函式，請使用<ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph>多載，並傳遞組合 (邏輯<ph id="ph2">`OR`</ph>) 的<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>， <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>， <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>， <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>，如下列程式碼範例所示：</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Now the output is:</source>
          <target state="translated">現在的輸出為：</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>True</source>
          <target state="translated">True</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，搜尋定義給目前 <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph> 的建構函式。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints, including the type initializer if it is defined.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> 物件的陣列，代表為目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 定義之符合指定繫結條件約束的所有建構函式，包括類型初始設定式 (如果已定義)。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> if no constructors are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, if none of the defined constructors match the binding constraints, or if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">如果目前的 <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> 沒有定義建構函式，或所定義的建構函式都不符合繫結條件約束，或目前的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 表示泛型類型或泛型方法定義中的類型參數，則傳回 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>方法不會建構函式傳回以特定順序，例如，按宣告順序。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於建構函式會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`bindingAttr`</ph> can be used to specify whether to return only public constructors or both public and non-public constructors.</source>
          <target state="translated"><ph id="ph1">`bindingAttr`</ph> 可以用於指定是否要傳回只有公用建構函式或公用和非公用建構函式。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">如果沒有完全相符，<ph id="ph1">`binder`</ph>會嘗試強制轉型中指定的參數類型<ph id="ph2">`types`</ph>陣列，就可以選取相符項目。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">如果<ph id="ph1">`binder`</ph>無法選取相符項目，然後<ph id="ph2">`null`</ph>傳回。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的建構函式：</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用建構函式。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Constructors of base classes are not returned.</source>
          <target state="translated">不會傳回基底類別建構函式。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">比方說，如果類別<ph id="ph1">`C&lt;T&gt;`</ph>的建構函式<ph id="ph2">`C(T t1)`</ph>(<ph id="ph3">`Sub New(ByVal t1 As T)`</ph>在 Visual Basic 中)，則呼叫<ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>上<ph id="ph5">`C&lt;int&gt;`</ph>傳回<ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>表示<ph id="ph7">`C(int t1)`</ph>C# 中 (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示泛型型別參數時，<ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>方法會傳回空陣列。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">此範例中顯示的輸出<ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph>從類別具有兩個執行個體建構函式和一個靜態建構函式多載。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The output of this code is:</source>
          <target state="translated">這個程式碼的輸出為：</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>多載只會使用<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph>和<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>，靜態建構函式都不會計算由<ph id="ph4">`for`</ph>運算式，也不會評估<ph id="ph5">`IsStatic`</ph>。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload, and pass it the combination (logical OR) of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">靜態建構函式，請使用<ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>多載，並將它傳遞的組合 (邏輯 OR) <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>， <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>， <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>，如下列程式碼範例所示：</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Now the output is:</source>
          <target state="translated">現在的輸出為：</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>True</source>
          <target state="translated">True</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>Searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> whose <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> is set.</source>
          <target state="translated">搜尋定義給目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的成員，而它的 <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> 已設定。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all default members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 的所有預設成員。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have default members.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 類型的空陣列 (如果目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 沒有預設成員)。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">成員包括屬性、 方法、 欄位、 事件等等。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a property <ph id="ph2">`P`</ph> that returns <ph id="ph3">`T`</ph>, calling <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns <ph id="ph6">`int P`</ph> in C# (<ph id="ph7">`Property P As Integer`</ph> in Visual Basic).</source>
          <target state="translated">比方說，如果類別<ph id="ph1">`C&lt;T&gt;`</ph>屬性<ph id="ph2">`P`</ph>傳回<ph id="ph3">`T`</ph>，則呼叫<ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph>上<ph id="ph5">`C&lt;int&gt;`</ph>傳回<ph id="ph6">`int P`</ph>C# 中 (<ph id="ph7">`Property P As Integer`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following example obtains the default member information of <ph id="ph1">`MyClass`</ph> and displays the default members.</source>
          <target state="translated">下列範例會取得的預設成員資訊<ph id="ph1">`MyClass`</ph>並顯示預設成員。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or reference type.</source>
          <target state="translated">在衍生類別中覆寫時，傳回由目前陣列、指標或參考類型所包含或參考物件的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer, or reference type, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">目前的陣列、指標或參考類型所內含或參考之物件的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，如果目前的 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 不是陣列或指標、未以傳址方式傳遞，或表示泛型類型或泛型類型或泛型方法定義中之類型參數，則為 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>This method returns <ph id="ph1">`null`</ph> for the <ph id="ph2">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">這個方法會傳回<ph id="ph1">`null`</ph>如<ph id="ph2">&lt;xref:System.Array&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>The following example demonstrates using the <ph id="ph1">`GetElementType`</ph> method.</source>
          <target state="translated">下列範例示範如何使用<ph id="ph1">`GetElementType`</ph>方法。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The value whose name is to be retrieved.</source>
          <target state="translated">要擷取其名稱的值。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>Returns the name of the constant that has the specified value, for the current enumeration type.</source>
          <target state="translated">針對目前的列舉類型，傳回具有指定值之常數的名稱。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The name of the member of the current enumeration type that has the specified value, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such constant is found.</source>
          <target state="translated">具有指定值之目前列舉類型的成員名稱，如果找不到這類常數，則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">目前的類型不是列舉。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is neither of the current type nor does it have the same underlying type as the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 不是目前的型別，也沒有與目前型別相同的基礎型別。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>Returns the names of the members of the current enumeration type.</source>
          <target state="translated">傳回目前列舉類型之成員的名稱。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>An array that contains the names of the members of the enumeration.</source>
          <target state="translated">包含列舉之成員名稱的陣列。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</source>
          <target state="translated">傳回值陣列的項目依列舉常數的二進位值 （也就是不帶正負號值） 排序。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</source>
          <target state="translated">如果陣列包含具有相同值的列舉的常數，其對應名稱的順序會是 unspecified。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>The current type is not an enumeration.</source>
          <target state="translated">目前的類型不是列舉。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Returns the underlying type of the current enumeration type.</source>
          <target state="translated">傳回目前列舉類型的基礎類型。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The underlying type of the current enumeration.</source>
          <target state="translated">目前列舉的基礎類型。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>By default, the underlying type of an enumeration in C# and Visual Basic is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">根據預設，在 C# 和 Visual Basic 中列舉的基礎類型是<ph id="ph1">&lt;xref:System.Int32&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Other integer types can be specified.</source>
          <target state="translated">您可以指定其他整數類型。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The current type is not an enumeration.</source>
          <target state="translated">目前的類型不是列舉。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The enumeration type is not valid, because it contains more than one instance field.</source>
          <target state="translated">列舉類型無效，因為它包含一個以上的執行個體欄位。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>Returns an array of the values of the constants in the current enumeration type.</source>
          <target state="translated">傳回目前列舉類型中常數的值陣列。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>An array that contains the values.</source>
          <target state="translated">包含值的陣列。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</source>
          <target state="translated">陣列的項目依列舉常數的二進位值 (也就是不帶正負號值) 排序。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The current type is not an enumeration.</source>
          <target state="translated">目前的類型不是列舉。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific event declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承的特定事件。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The string containing the name of an event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">字串，其中包含由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承的事件名稱。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified public event.</source>
          <target state="translated">傳回代表指定公用事件的 <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The object representing the specified public event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果找到，則表示由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承之指定公用事件的物件；否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則事件會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search includes public static and public instance events.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體的事件。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> object and gets the event for a button class for the specified event.</source>
          <target state="translated">下列範例會建立<ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph>物件，並取得指定之事件按鈕類別事件。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of an event which is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">字串，包含目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承之事件的名稱。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified event, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束，傳回表示指定事件的 <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The object representing the specified event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果找到，則表示由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承之指定事件的物件；否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的事件：</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用事件。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用事件 （也就是私用、 內部和受保護的事件）。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的事件<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的事件。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則事件會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method to search a type for a public or non-public event named "Click" that is not <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">下列程式碼範例使用<ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph>方法來搜尋的公用或非公用事件名為 「 按一下 」 不是型別<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承的事件。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>Returns all the public events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承的所有公用事件。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events which are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承的所有公用事件。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public events.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 類型的空陣列 (如果目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 沒有公用事件)。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則事件會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph>方法沒有傳回事件以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於事件會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">下列範例會取得陣列的<ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph>物件資訊，請取得的所有事件<ph id="ph2">`Button`</ph>類別，並顯示事件名稱。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">若要編譯 Visual Basic 範例，請使用下列命令列：</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承的事件。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all events that are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 所宣告或繼承之符合指定繫結條件約束的所有事件。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have events, or if none of the events match the binding constraints.</source>
          <target state="translated">如果目前 <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 沒有事件，或沒有事件符合繫結條件約束，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph>方法沒有傳回事件以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於事件會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的事件：</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用事件。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用事件 （也就是私用、 內部和受保護的事件）。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Only protected and internal events on base classes are returned; private events on base classes are not returned.</source>
          <target state="translated">只保護，而且在基底類別上的內部事件都會傳回到;不會傳回基底類別上的私用事件。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的事件<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的事件。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">事件會被視為公用，以反映，如果有至少一個的方法或公用存取子。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則事件會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋的事件類別條件約束。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects that match the specified binding flags, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">下列範例會取得陣列的<ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph>符合指定的繫結旗標的物件取得的所有事件<ph id="ph2">`Button`</ph>類別，並顯示事件名稱。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">若要編譯 Visual Basic 範例，請使用下列命令列：</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific field of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的特定欄位。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">字串，包含要取得的資料欄位的名稱。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>Searches for the public field with the specified name.</source>
          <target state="translated">搜尋具有指定名稱的公用欄位。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>An object representing the public field with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表具有指定之名稱的公用欄位 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search includes public static and public instance fields.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體欄位。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的欄位。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field, and displays the value of the field.</source>
          <target state="translated">下列範例會取得<ph id="ph1">`Type`</ph>物件指定的類別，取得<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>物件的欄位，並顯示欄位的值。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>This <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> whose <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has not yet been called.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件為尚未呼叫 <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> 方法的 <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">字串，包含要取得的資料欄位的名稱。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified field, using the specified binding constraints.</source>
          <target state="translated">使用指定的繫結條件約束搜尋指定的欄位。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the field that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">代表符合指定之需求欄位的物件 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的欄位：</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>要在搜尋中包含公用欄位。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用欄位 （也就是私用、 內部和受保護欄位）。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋僅將宣告上的欄位<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的欄位。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的欄位。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field that matches the specified binding flags, and displays the value of the field.</source>
          <target state="translated">下列範例會取得<ph id="ph1">`Type`</ph>物件指定的類別，取得<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>符合指定的繫結旗標，並顯示欄位的值之欄位的物件。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的欄位。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>Returns all the public fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">傳回目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的所有公用欄位。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all the public fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 物件的陣列，代表為目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 定義的所有公用欄位。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no public fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 類型的空陣列 (如果沒有為目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 定義公用欄位)。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph>方法不會傳回欄位以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於欄位會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的公用欄位。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following example shows a use of the <ph id="ph1">`GetFields()`</ph> method.</source>
          <target state="translated">下列範例會示範搭配<ph id="ph1">`GetFields()`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the fields defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的欄位。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 物件的陣列，代表為目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 定義之符合指定繫結條件約束的所有欄位。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined fields match the binding constraints.</source>
          <target state="translated">如果沒有任何欄位定義給目前 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 的欄位，或沒有已定義的欄位符合繫結條件約束，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph>方法不會傳回欄位以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於欄位會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的欄位：</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>要在搜尋中包含公用欄位。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用欄位 （也就是私用、 內部和受保護欄位）。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</source>
          <target state="translated">只保護，而且會傳回基底類別上的內部欄位。不會傳回基底類別上的私用欄位。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋僅將宣告上的欄位<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的欄位。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的公用欄位。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following example shows a use of the <ph id="ph1">`GetFields(BindingFlags)`</ph> method.</source>
          <target state="translated">下列範例會示範搭配<ph id="ph1">`GetFields(BindingFlags)`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</source>
          <target state="translated">傳回 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表封閉泛型類型的類型引數，或泛型類型定義的類型參數。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic type.</source>
          <target state="translated">由 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件組成的陣列，代表泛型類型的類型引數。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an empty array if the current type is not a generic type.</source>
          <target state="translated">如果目前的類型不是泛型類型，則傳回空的陣列。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</source>
          <target state="translated">陣列項目會以其出現在泛型類型的型別引數清單中的順序傳回。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a closed constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic type definition.</source>
          <target state="translated">如果目前的類型是封閉式的建構的類型 (也就是<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性會傳回<ph id="ph2">`false`</ph>)，所傳回的陣列<ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>方法包含已指派給泛型類型定義的泛型類型參數的型別.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a generic type definition, the array contains the type parameters.</source>
          <target state="translated">如果目前的類型是泛型類型定義，陣列會包含型別參數。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is an open constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</source>
          <target state="translated">如果目前的類型是開放式建構的類型 (也就是<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>) 中的特定型別不已指派給所有型別參數與封入泛型類型或方法的型別參數，此陣列包含型別與型別參數。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>屬性來區分它們。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">如需示範此案例中，請參閱的程式碼範例<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性備註。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</source>
          <target state="translated">下列程式碼範例使用<ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>方法來顯示型別引數的建構類型和其泛型型別定義的型別參數。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property.</source>
          <target state="translated">這個程式碼範例是針對所提供之較大範例的一部分<ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>See the larger example for sample output.</source>
          <target state="translated">請參閱範例輸出的較大範例。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">衍生類別必須提供實作。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">傳回由 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件組成的陣列，這些物件代表對目前泛型類型參數所設下的條件約束。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">由 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件組成的陣列，這些物件代表對目前泛型類型參數所設下的條件約束。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Each constraint on a generic type parameter is expressed as a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">每個泛型型別參數的條件約束會表示為<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> property to determine whether a constraint is the base class constraint; if the property returns <ph id="ph2">`false`</ph>, the constraint is an interface constraint.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>屬性來判斷條件約束是否是基底類別條件約束; 如果屬性傳回<ph id="ph2">`false`</ph>，條件約束是介面條件約束。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>If a type parameter has no class constraint and no interface constraints, an empty array is returned.</source>
          <target state="translated">如果類型參數沒有類別條件約束和介面條件約束，則會傳回空陣列。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性備註。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">下列程式碼範例會定義泛型型別<ph id="ph1">`Test`</ph>具有兩個具有不同的條件約束的型別參數。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">當程式執行時，條件約束會檢查使用<ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>屬性和<ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件不是泛型型別參數。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> 屬性會傳回 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current generic type can be constructed.</source>
          <target state="translated">傳回代表泛型類型定義的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，利用此泛型類型定義就可以建構出目前的泛型類型。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type from which the current type can be constructed.</source>
          <target state="translated">代表泛型類型的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，利用此泛型類型就可以建構出目前的類型。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">泛型類型定義是用於建構其他類型的範本。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">例如，從泛型類型定義<ph id="ph1">`G&lt;T&gt;`</ph>（以表示 C# 語法。<ph id="ph2">`G(Of T)`</ph>在 Visual Basic 或<ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph>c + + 中) 您可以建構並具現化類型<ph id="ph4">`G&lt;int&gt;`</ph>(<ph id="ph5">`G(Of Integer)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the generic type definition.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表這個建構的型別，<ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>方法傳回的泛型類型定義。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If two constructed types are created from the same generic type definition, using the same type arguments, the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for both types.</source>
          <target state="translated">如果兩個建構的類型建立從相同泛型類型定義，使用相同的型別引數，<ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>方法會傳回相同<ph id="ph2">&lt;xref:System.Type&gt;</ph>這兩種類型的物件。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that already represents a generic type definition, it returns the current <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">如果您呼叫<ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.Type&gt;</ph>表示物件已是泛型類型定義，它會傳回目前<ph id="ph3">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>An array of generic types is not itself generic.</source>
          <target state="translated">泛型類型的陣列不是泛型本身。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>In the C# code <ph id="ph1">`A&lt;int&gt;[] v;`</ph> or the Visual Basic code <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, the type of variable <ph id="ph3">`v`</ph> is not generic.</source>
          <target state="translated">C# 程式碼<ph id="ph1">`A&lt;int&gt;[] v;`</ph>或 Visual Basic 程式碼<ph id="ph2">`Dim v() As A(Of Integer)`</ph>，變數的型別<ph id="ph3">`v`</ph>不是泛型。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Use <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> to determine whether a type is generic before calling <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>決定類型是否為泛型，然後再呼叫<ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性備註。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> methods to retrieve the constructed type and the generic type definition.</source>
          <target state="translated">下列程式碼範例會建構類型的執行個體建立使用一般的執行個體建立，並接著會使用<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>方法來擷取建構的類型和泛型類型定義。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>This example uses the generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type; the constructed type represents a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph3">`Test`</ph> objects with string keys.</source>
          <target state="translated">這個範例會使用泛型<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>類型; 建構的類型代表<ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>的<ph id="ph3">`Test`</ph>字串索引鍵的物件。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The current type is not a generic type.</source>
          <target state="translated">目前的類型不是泛型類型。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> 會傳回 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">衍生類別必須提供實作。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">傳回這個執行個體的雜湊碼。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>The hash code for this instance.</source>
          <target state="translated">這個執行個體的雜湊碼。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">這個方法覆寫 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>The following example displays the hash code of the <ph id="ph1">`System.Windows.Forms.Button`</ph> class.</source>
          <target state="translated">下列範例顯示的雜湊碼<ph id="ph1">`System.Windows.Forms.Button`</ph>類別。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific interface implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所實作或繼承的特定介面。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">字串，包含要取得的介面名稱。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">若為泛型介面，則為 mangled 名稱。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>Searches for the interface with the specified name.</source>
          <target state="translated">搜尋具有指定名稱的介面。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表具有指定之名稱的介面是由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所實作或繼承的 (如有找到)；否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Type&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">若為泛型介面，<ph id="ph1">`name`</ph>參數則為 mangled 的名稱，結尾抑音符號 (<ph id="ph2">\`</ph>) 及型別參數數目。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">這是為泛型介面定義與建構的泛型介面，則為 true。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">``"IExample`1"``</ph>.</source>
          <target state="translated">例如，若要尋找<ph id="ph1">`IExample&lt;T&gt;`</ph>(<ph id="ph2">`IExample(Of T)`</ph>在 Visual Basic 中) 或<ph id="ph3">`IExample&lt;string&gt;`</ph>(<ph id="ph4">`IExample(Of String)`</ph>在 Visual Basic 中)，搜尋<ph id="ph5">``"IExample`1"``</ph>。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method to search the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph> interface, and lists the methods of the interface.</source>
          <target state="translated">下列程式碼範例使用<ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph>方法來搜尋<ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>類別<ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph>介面，並列出介面的方法。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">程式碼範例也示範<ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph>方法多載而<ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 代表的型別有實作出相同的泛型介面，但型別引數不同。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">字串，包含要取得的介面名稱。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">若為泛型介面，則為 mangled 名稱。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of that part of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>，便會忽略 <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> 中指定簡單介面名稱之該部分的大小寫 (指定命名空間的部分必須使用正確的大小寫)。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for all parts of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> 表示對 <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> 的所有部分執行區分大小寫的搜尋。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</source>
          <target state="translated">在衍生類別中覆寫時，指定是否針對介面名稱以不區分大小寫的方式來搜尋指定的介面。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表具有指定之名稱的介面是由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所實作或繼承的 (如有找到)；否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The <ph id="ph1">`ignoreCase`</ph> parameter applies only to the simple interface name, not to the namespace.</source>
          <target state="translated"><ph id="ph1">`ignoreCase`</ph>參數只適用於簡單介面名稱，不到命名空間。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The portion of <ph id="ph1">`name`</ph> that specifies the namespace must have the correct case, or the interface will not be found.</source>
          <target state="translated">部分<ph id="ph1">`name`</ph>指定命名空間必須包含正確的大小寫，或將找不到介面。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, the string "System.icomparable" finds the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface, but the string "system.icomparable" does not.</source>
          <target state="translated">例如，字串"System.icomparable"尋找<ph id="ph1">&lt;xref:System.IComparable&gt;</ph>介面，但字串"system.icomparable"並不會。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Type&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">若為泛型介面，<ph id="ph1">`name`</ph>參數則為 mangled 的名稱，結尾抑音符號 (<ph id="ph2">\`</ph>) 及型別參數數目。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">這是為泛型介面定義與建構的泛型介面，則為 true。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">`"IExample`</ph>1"`.</source>
          <target state="translated">例如，若要尋找<ph id="ph1">`IExample&lt;T&gt;`</ph>(<ph id="ph2">`IExample(Of T)`</ph>在 Visual Basic 中) 或<ph id="ph3">`IExample&lt;string&gt;`</ph>(<ph id="ph4">`IExample(Of String)`</ph>在 Visual Basic 中)，搜尋<ph id="ph5">`"IExample`</ph>1"'。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method to perform a case-insensitive search of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">下列程式碼範例使用<ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph>方法來執行不區分大小寫的搜尋<ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>類別<ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph>介面。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">程式碼範例也示範<ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph>方法多載而<ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 代表的型別有實作出相同的泛型介面，但型別引數不同。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface type to retrieve a mapping for.</source>
          <target state="translated">要擷取對應的介面類型。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the specified interface type.</source>
          <target state="translated">傳回指定介面類型的介面對應。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>An object that represents the interface mapping for <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph>.</source>
          <target state="translated">物件，表示 <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> 的介面對應。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</source>
          <target state="translated">介面對應會表示如何在介面對應到實際的成員上實作該介面的類別。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> returned by this method.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，類型的項目中的適當的型別引數會取代參數<ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph>這個方法所傳回。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method to determine how the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interface maps to <ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph> methods, and how the <ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph> interface maps to <ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph> properties.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph>方法，以判斷如何<ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>介面對應至<ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph>方法，以及如何<ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph>介面對應至<ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Note that, because the <ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph> interface defines a set of properties, the returned <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> object includes separate <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects for a property's get and set accessors.</source>
          <target state="translated">請注意，因為<ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph>介面會定義一組屬性，傳回<ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph>物件包含個別<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>屬性的 get 和 set 存取子的物件。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is not implemented by the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> 不是否由目前的類型所實作。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> parameter does not refer to an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> 參數不會參考介面。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is a generic interface, and the current type is an array type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> 是泛型介面，而且目前的型別是陣列型別。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter; that is, <ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 表示泛型型別參數，也就是說，<ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">衍生類別必須提供實作。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">在衍生類別中覆寫時，取得由目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 所實作或繼承的所有介面。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 所實作或繼承的所有介面。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no interfaces are implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (如果目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 未實作或繼承介面)。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> method does not return interfaces in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph>方法不會傳回介面特定的順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>Your code must not depend on the order in which interfaces are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於介面會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Type&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋的介面條件約束和繼承自類別或介面條件約束的介面。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</source>
          <target state="translated">下列範例會取得指定之類別的型別，並顯示型別所實作或繼承的所有介面。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>To compile the Visual Basic example, use the following compiler commands:</source>
          <target state="translated">若要編譯 Visual Basic 範例，請使用下列編譯器命令：</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">靜態初始設定式已叫用並擲回了例外狀況。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the specified members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的指定成員。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>The string containing the name of the public members to get.</source>
          <target state="translated">字串，包含要取得的公用成員名稱。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>Searches for the public members with the specified name.</source>
          <target state="translated">搜尋具有指定名稱的公用成員。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search includes public static and public instance members.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體成員。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">成員包括屬性、 方法、 欄位、 事件等等。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This method overload will not find class initializers (.cctor).</source>
          <target state="translated">這個方法多載不會尋找類別初始設定式 (.cctor)。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">類別初始設定式，請使用多載採用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>，並指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">為泛型方法，不包括中的型別引數<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>搜尋的文字名稱的成員 」<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following example displays all the members of the <ph id="ph1">`String`</ph> class that start with the letter C.</source>
          <target state="translated">下列範例顯示的所有成員<ph id="ph1">`String`</ph>以字母 c 開頭的類別</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">字串，包含要取得的成員名稱。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">零，表示傳回空陣列。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified members, using the specified binding constraints.</source>
          <target state="translated">使用指定的繫結條件約束搜尋指定的成員。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">成員包括屬性、 方法、 欄位、 事件等等。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的成員：</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用成員。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的成員<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的成員。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph7">`bindingAttr`</ph>.</source>
          <target state="translated">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定".cctor" <ph id="ph1">`name`</ph>，和<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中) 的<ph id="ph7">`bindingAttr`</ph>。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">為泛型方法，不包括中的型別引數<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>搜尋的文字名稱的成員 」<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following example displays all the public static members of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">下列範例顯示的所有公用靜態成員<ph id="ph1">`myString`</ph>以字母 c 開頭的類別</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">字串，包含要取得的成員名稱。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The value to search for.</source>
          <target state="translated">要搜尋的值。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">零，表示傳回空陣列。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Searches for the specified members of the specified member type, using the specified binding constraints.</source>
          <target state="translated">使用指定的繫結條件約束，搜尋指定成員類型的指定成員。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">成員包括屬性、 方法、 欄位、 事件等等。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的成員：</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用成員。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的成員<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的成員。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`type`</ph>, and  <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph7">`Or`</ph><ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph9">`bindingAttr`</ph>.</source>
          <target state="translated">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定".cctor" <ph id="ph1">`name`</ph>，<ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph>如<ph id="ph3">`type`</ph>，和<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph7">`Or`</ph> <ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>中Visual Basic) 的<ph id="ph9">`bindingAttr`</ph>。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">為泛型方法，不包括中的型別引數<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>搜尋的文字名稱的成員 」<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following example displays all the methods of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">下列範例顯示的所有方法<ph id="ph1">`myString`</ph>以字母 c 開頭的類別</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A derived class must provide an implementation.</source>
          <target state="translated">衍生類別必須提供實作。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the members (properties, methods, fields, events, and so on) of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的成員 (屬性、方法、欄位、事件等等)。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>Returns all the public members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">傳回目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的所有公用成員。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all the public members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 的所有公用成員。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public members.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 類型的空陣列 (如果目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 沒有公用成員)。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">成員包括屬性、 方法、 欄位、 事件等等。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph6">`Or`</ph><ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph8">`Or`</ph><ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">這個方法多載呼叫<ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph>方法多載，與<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph6">`Or`</ph> <ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph8">`Or`</ph> <ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">將不會發現類別初始設定式 (.cctor)。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">類別初始設定式，請使用多載採用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>，並指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph> method overload to collect information about all public members of a specified class.</source>
          <target state="translated">下列程式碼範例示範如何使用<ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph>方法多載來收集指定之類別的所有公用成員的相關資訊。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Zero (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>), to return an empty array.</source>
          <target state="translated">零 (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>)，表示傳回空陣列。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的成員。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all members defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 物件的陣列，代表為目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 定義之符合指定繫結條件約束的所有成員。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if no members are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined members match the binding constraints.</source>
          <target state="translated">如果沒有任何成員定義給目前的 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>，或沒有已定義的成員符合繫結條件約束，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">成員包括屬性、 方法、 欄位、 事件等等。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>方法不會傳回成員以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於成員會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的成員：</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用成員。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Only protected and internal members on base classes are returned; private members on base classes are not returned.</source>
          <target state="translated">只保護，而且會傳回基底類別上的內部成員。不會傳回基底類別上的私用成員。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的成員<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的成員。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">`Public`</ph> flag or only the <ph id="ph2">`NonPublic`</ph> flag will return the specified members and does not require any other flags.</source>
          <target state="translated">呼叫這個方法只使用<ph id="ph1">`Public`</ph>旗標] 或 [僅<ph id="ph2">`NonPublic`</ph>旗標將會傳回指定的成員，而且不需要任何其他旗標。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">您也可以取得使用的類別初始設定式<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中的成員類別條件約束或搜尋的成員<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload to collect information about all public instance members of a specified class.</source>
          <target state="translated">下列程式碼範例示範如何使用<ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph>方法多載來收集指定之類別的所有公用執行個體成員的相關資訊。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific method of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的特定方法。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">字串，包含要取得的公用方法名稱。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>Searches for the public method with the specified name.</source>
          <target state="translated">搜尋具有指定名稱的公用方法。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>An object that represents the public method with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表具有指定之名稱的公用方法 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體方法。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If a method is overloaded and has more than one public method, the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">如果方法多載，而且有一個以上的公用方法，<ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph>方法會擲回<ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>In the following example, an exception is thrown because there is more than one public overload of the <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">在下列範例中，例外狀況會擲回的多個公用的多載，因為<ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>On the other hand, because the <ph id="ph1">`Person.ToString`</ph> method overrides  <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> and therefore is not overloaded, the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method is able to retrieve the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">相反地，因為<ph id="ph1">`Person.ToString`</ph>方法覆寫<ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>，因此未超載，<ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph>方法是能夠擷取<ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">您可以執行下列命令來擷取特定方法的其中一個動作：</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method and specify a <ph id="ph2">`bindingAttr`</ph> argument that uniquely identifies the method.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph>方法並指定<ph id="ph2">`bindingAttr`</ph>唯一識別該方法的引數。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  <ph id="ph1">`bindingAttr`</ph> argument  of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph3">`Or`</ph><ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">例如，如果擲回例外狀況，因為類型都有靜態和執行個體的多載，您可以指定<ph id="ph1">`bindingAttr`</ph>引數的<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph3">`Or`</ph> <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">呼叫的多載<ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph>方法包含<ph id="ph2">`types`</ph>定義方法的參數型別參數。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> method to retrieve an array containing all of the public methods belonging to a type.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph>方法來擷取包含所有屬於類型的公用方法的陣列。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">您可以再逐一查看以識別重複的方法，名為<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">為泛型方法，不包括中的型別引數<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>搜尋的文字名稱的成員 」<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The following example gets a method named <ph id="ph1">`MethodA`</ph>.</source>
          <target state="translated">下列範例會取得名為的方法<ph id="ph1">`MethodA`</ph>。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>More than one method is found with the specified name.</source>
          <target state="translated">找到一個以上具有指定名稱的方法。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">字串，包含要取得的方法名稱。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified method, using the specified binding constraints.</source>
          <target state="translated">使用指定的繫結條件約束搜尋指定的方法。</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表符合指定之需求的方法 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要在搜尋中包含哪些方法：</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>或<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>来包含在搜尋中的公用方法。</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> 若要搜尋的方法上宣告<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的方法。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If a method is overloaded and more than one overload meets the constraints specified by the <ph id="ph1">`bindingAttr`</ph> argument, the method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">如果多載的方法和一個以上多載符合所指定的條件約束<ph id="ph1">`bindingAttr`</ph>引數，方法會擲回<ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the following example, an exception is thrown because:</source>
          <target state="translated">在下列範例中，因為，會擲回例外狀況：</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`DisplayValue`</ph> method, <ph id="ph3">`DisplayValue(String)`</ph> and <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestClass`</ph>類型有兩個公用執行個體多載<ph id="ph2">`DisplayValue`</ph>方法，<ph id="ph3">`DisplayValue(String)`</ph>和<ph id="ph4">`DisplayValue(String, Object[])`</ph>。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`Equals`</ph> method,  one of which is inherited from <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> and <ph id="ph5">`Equals(Object)`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestClass`</ph>類型有兩個公用執行個體多載<ph id="ph2">`Equals`</ph>方法，其中繼承自<ph id="ph3">&lt;xref:System.Object&gt;</ph>:<ph id="ph4">`Equals(TestClass)`</ph>和<ph id="ph5">`Equals(Object)`</ph>。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">您可以執行下列命令來擷取特定方法的其中一個動作：</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Change the binding constraints.</source>
          <target state="translated">變更繫結條件約束。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the previous example, attempting to retrieve a public instance <ph id="ph1">`Equals`</ph> method that is declared by the type and not inherited successfully retrieves <ph id="ph2">`Equals(TestClass)`</ph>.</source>
          <target state="translated">在上述範例中，嘗試擷取公用執行個體<ph id="ph1">`Equals`</ph>類型所宣告，且不會成功繼承方法擷取<ph id="ph2">`Equals(TestClass)`</ph>。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">呼叫的多載<ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph>方法包含<ph id="ph2">`types`</ph>定義方法的參數型別參數。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph>方法來擷取包含所有具有指定的繫結屬性的方法屬於類型的陣列。</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">您可以再逐一查看以識別重複的方法，名為<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>This approach is illustrated in the previous example's handler for the <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">這種方法如下所示的上一個範例處理常式<ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">為泛型方法，不包括中的型別引數<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>搜尋的文字名稱的成員 」<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the method that matches the specified binding flags.</source>
          <target state="translated">下列範例會取得符合指定的繫結旗標的方法。</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">字串，包含要取得的公用方法名稱。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的空陣列 (由 <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> 欄位提供)，可取得不採用參數的方法。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Searches for the specified public method whose parameters match the specified argument types.</source>
          <target state="translated">搜尋指定的公用方法，其參數符合指定的引數類型。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An object representing the public method whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">代表其參數符合指定之引數類型的公用方法物件 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體方法。</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">`name`</ph> parameter cannot include type arguments.</source>
          <target state="translated"><ph id="ph1">`name`</ph>參數不能包含型別引數。</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> searches for a method with the text name "<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyGenericMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph>搜尋文字名稱的方法"<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyGenericMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">請改用<ph id="ph1">`GetMethod("MyGenericMethod")`</ph>中適當的參數<ph id="ph2">`types`</ph>陣列。</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying a variety of argument types.</source>
          <target state="translated">下列範例會尋找特定的多載<ph id="ph1">`MethodA`</ph>，指定各種不同的引數型別。</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>範例需要<ph id="ph2">`/unsafe`</ph>編譯器選項。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example retrieves <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects that represent the <ph id="ph2">`Add`</ph> methods  of a non-generic type (the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> class), an open generic type (the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class), and a closed generic type (the <ph id="ph5">`List(Of String)`</ph> type.</source>
          <target state="translated">下列範例會擷取<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>物件來代表<ph id="ph2">`Add`</ph>非泛型型別的方法 (<ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>類別)，開放式泛型類型 (<ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>類別)，和已關閉的泛型型別 (<ph id="ph5">`List(Of String)`</ph>型別。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The example defines a <ph id="ph1">`GetAddMethod`</ph> method that retrieves the appropriate <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">此範例會定義<ph id="ph1">`GetAddMethod`</ph>方法，可擷取適當<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for an open generic type, it calls the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">若要提供<ph id="ph1">`types`</ph>開放式的泛型型別引數，呼叫<ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for a closed generic type, it retrieves the value of the <ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">若要提供<ph id="ph1">`types`</ph>封閉泛型類型引數，它會擷取的值<ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">找到一個以上具有指定名稱及指定參數的方法。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">字串，包含要取得的公用方法名稱。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的空陣列 (由 <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> 欄位提供)，可取得不採用參數的方法。</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public method whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">搜尋指定的公用方法，其參數符合指定的引數類型和修飾詞。</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表符合指定之需求的公用方法 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體方法。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">為泛型方法，不包括中的型別引數<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph>搜尋的文字名稱的成員 」<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">請改用<ph id="ph1">`GetMethod("MyMethod")`</ph>中適當的參數<ph id="ph2">`types`</ph>陣列。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">找到一個以上具有指定名稱及指定參數的方法。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">字串，包含要取得的方法名稱。</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的空陣列 (由 <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> 欄位提供)，可取得不採用參數的方法。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">使用指定的繫結條件約束搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表符合指定之需求的方法 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要在搜尋中包含哪些方法：</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用方法。</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋的方法上宣告<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的方法。</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">為泛型方法，不包括中的型別引數<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>搜尋的文字名稱的成員 」<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints and a variety of argument types.</source>
          <target state="translated">下列範例會尋找特定的多載<ph id="ph1">`MethodA`</ph>，指定繫結條件約束和各種不同的引數型別。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>範例需要<ph id="ph2">`/unsafe`</ph>編譯器選項。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">字串，包含要取得的方法名稱。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</source>
          <target state="translated">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及如何清除堆疊。</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的空陣列 (由 <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> 欄位提供)，可取得不採用參數的方法。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">使用指定的繫結條件約束和指定的呼叫慣例，來搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表符合指定之需求的方法 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`GetXXX`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`GetXXX`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要在搜尋中包含哪些方法：</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用方法。</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋的方法上宣告<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的方法。</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">為泛型方法，不包括中的型別引數<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">例如，C# 程式碼<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>搜尋的文字名稱的成員 」<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"，而不會針對名為的方法<ph id="ph3">`MyMethod`</ph>具有一個泛型類型引數<ph id="ph4">`int`</ph>。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints, calling conventions, and a variety of argument types.</source>
          <target state="translated">下列範例會尋找特定的多載<ph id="ph1">`MethodA`</ph>、 指定繫結條件約束、 呼叫慣例和引數類型的不同。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>範例需要<ph id="ph2">`/unsafe`</ph>編譯器選項。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">字串，包含要取得的方法名稱。</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</source>
          <target state="translated">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及哪一個處理程序清除堆疊。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</source>
          <target state="translated">用以取得沒有參數的方法之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, arguments are not matched.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，則引數不相符。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束和指定的呼叫慣例搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表符合指定之需求的方法 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <ph id="ph1">`types`</ph> is <ph id="ph2">`null`</ph>, arguments are not matched.</source>
          <target state="translated">如果 <ph id="ph1">`types`</ph> 為 <ph id="ph2">`null`</ph>，則引數不相符。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要在搜尋中包含哪些方法：</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用方法。</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋的方法上宣告<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的方法。</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> 的長度不同。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">目前的型別是 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的方法。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>Returns all the public methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">傳回目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的所有公用方法。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the public methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 物件的陣列，代表為目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 定義的所有公用方法。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no public methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 類型的空陣列 (如果沒有為目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 定義公用方法)。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph>方法不會傳回方法特定的順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">您的程式碼必須依賴方法會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructors are not included in the array of methods returned by this call.</source>
          <target state="translated">建構函式不包含陣列中的這個呼叫所傳回的方法。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Make a separate call to <ph id="ph1">`GetConstructors()`</ph> to get the constructor methods.</source>
          <target state="translated">若要個別呼叫<ph id="ph1">`GetConstructors()`</ph>以取得建構函式方法。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the methods defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的方法。</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 物件的陣列，代表為目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 定義之符合指定繫結條件約束的所有方法。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined methods match the binding constraints.</source>
          <target state="translated">如果沒有任何方法定義給目前的 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>，或沒有已定義的方法符合繫結條件約束，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph>方法不會傳回方法特定的順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">您的程式碼必須依賴方法會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要在搜尋中包含哪些方法：</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用方法。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用方法 （也就是私用、 內部和受保護的方法）。</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</source>
          <target state="translated">只保護，而且會傳回基底類別上的內部方法。不會傳回基底類別上的私用方法。</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋的方法上宣告<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的方法。</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">查閱建構函式和方法時，無法省略參數。</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">叫用時，您只可以省略參數。</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<ph id="ph2">&lt;xref:System.Object&gt;</ph>如果沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following example creates a class with two public methods and one protected method, creates a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyTypeClass`</ph>, gets all public and non-public methods, and displays their names.</source>
          <target state="translated">下列範例會建立具有兩個公用方法和一個受保護的方法的類別，然後建立<ph id="ph1">`Type`</ph>物件對應至<ph id="ph2">`MyTypeClass`</ph>、 取得所有的公用和非公用方法，並顯示其名稱。</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific type nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">讓特定類型在目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 內變成巢狀。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">包含要取得之巢狀類型名稱的字串。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>Searches for the public nested type with the specified name.</source>
          <target state="translated">搜尋具有指定名稱的公用巢狀類型。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>An object representing the public nested type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表具有指定名稱的巢狀類型 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">使用巢狀類別的簡單名稱<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">切勿在外部類別的名稱。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</source>
          <target state="translated">一般巢狀類別中，使用為 mangled 的名稱 — 也就是附加抑音符號以及泛型引數數目。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">例如，使用字串"內部<ph id="ph1">\`</ph>1"以取得泛型巢狀類別<ph id="ph2">`Inner&lt;T&gt;`</ph>(<ph id="ph3">`Inner(Of T)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">不包含型別參數的特定語言的語法。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">即使封入泛型型別是封閉式的建構的類型，也是如此。</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">這不一定在動態組件中定義，或使用編譯的巢狀型別的<bpt id="p1">[</bpt>Ilasm.exe （IL 組譯工具）<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">包含要取得之巢狀類型名稱的字串。</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束搜尋指定的巢狀類型。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表符合指定之需求的巢狀類型 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">使用巢狀類別的簡單名稱<ph id="ph1">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">切勿在外部類別的名稱。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</source>
          <target state="translated">一般巢狀類別中，使用為 mangled 的名稱 — 也就是附加抑音符號以及泛型參數的數目。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">例如，使用字串"內部<ph id="ph1">\`</ph>1"以取得泛型巢狀類別<ph id="ph2">`Inner&lt;T&gt;`</ph>(<ph id="ph3">`Inner(Of T)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">不包含型別參數的特定語言的語法。</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>或<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>取得傳回。</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>来包含在搜尋中的公用巢狀型別。</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>要在搜尋中包含非公用巢狀的類型 （也就是私用、 內部和受保護巢狀型別）。</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">這個方法會傳回目前類型之巢狀的類型。</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">它不會搜尋目前類型的基底類別。</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> at each level.</source>
          <target state="translated">若要尋找的巢狀類型，基底類別中，您必須逐步繼承階層中，呼叫<ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>每個層級。</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> 和<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>都會被忽略。</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">呼叫這個方法只使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>旗標] 或 [僅<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>旗標將會傳回指定的巢狀類型，並不需要任何其他旗標。</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">即使封入泛型型別是封閉式的建構的類型，也是如此。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">這不一定在動態組件中定義，或使用編譯的巢狀型別的<bpt id="p1">[</bpt>Ilasm.exe （IL 組譯工具）<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the types nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">讓其在目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 內變成巢狀之類型。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>Returns the public types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">傳回在目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 內形成巢狀的公用類型。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the public types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no public types are nested in the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 中的巢狀公用類型 (搜尋不是遞迴的)；如果目前 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 中沒有巢狀公用類型，則為 <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>方法沒有傳回型別特定的順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於型別會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Only the public types immediately nested in the current type are returned; the search is not recursive.</source>
          <target state="translated">只有在目前的類型中巢狀的公用型別會傳回。搜尋不是遞迴的。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">即使封入泛型型別是封閉式的建構的類型，也是如此。</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">這不一定在動態組件中定義，或使用編譯的巢狀型別的<bpt id="p1">[</bpt>Ilasm.exe （IL 組譯工具）<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following example defines a nested class and a <ph id="ph1">`struct`</ph> in <ph id="ph2">`MyClass`</ph>, and then obtains objects of the nested types using the type of <ph id="ph3">`MyClass`</ph>.</source>
          <target state="translated">下列範例會定義巢狀的類別和<ph id="ph1">`struct`</ph>中<ph id="ph2">`MyClass`</ph>，然後取得使用的型別之巢狀類型的物件和<ph id="ph3">`MyClass`</ph>。</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋在目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 內形成巢狀的類型。</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, if no nested types are found that match the binding constraints.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 中符合指定繫結條件約束的所有巢狀類型 (搜尋不是遞迴的)；如果找不到符合繫結條件約束的巢狀類型，則為 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The search for nested types is not recursive.</source>
          <target state="translated">搜尋巢狀類型不是遞迴的。</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>方法沒有傳回型別特定的順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">您的程式碼不得相依於型別會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>或<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>取得傳回。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>来包含在搜尋中的公用巢狀型別。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>要在搜尋中包含非公用巢狀的類型 （也就是私用、 內部和受保護巢狀型別）。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">這個方法會傳回目前類型之巢狀的類型。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">它不會搜尋目前類型的基底類別。</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> at each level.</source>
          <target state="translated">若要尋找的巢狀類型，基底類別中，您必須逐步繼承階層中，呼叫<ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>每個層級。</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> 和<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>都會被忽略。</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">呼叫這個方法只使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>旗標] 或 [僅<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>旗標將會傳回指定的巢狀類型，並不需要任何其他旗標。</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">如果巢狀型別為泛型，則這個方法會傳回其泛型型別定義。</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">即使封入泛型型別是封閉式的建構的類型，也是如此。</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型類型定義以 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">這不一定在動態組件中定義，或使用編譯的巢狀型別的<bpt id="p1">[</bpt>Ilasm.exe （IL 組譯工具）<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">巢狀泛型類型，以及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</source>
          <target state="translated">下列範例會建立兩個巢狀公用類別和兩個巢狀的受保護的類別，並會顯示符合指定的繫結條件約束的類別資訊。</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的屬性。</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>Returns all the public properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">傳回目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的所有公用屬性。</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all public properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 的所有公用屬性。</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public properties.</source>
          <target state="translated">類型 <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> 的空陣列，如果目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 並沒有公用屬性。</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Calling this overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> overload with a <ph id="ph2">`bindingAttr`</ph> argument equal to <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> in C# and  <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> in Visual Basic.</source>
          <target state="translated">呼叫這個多載就相當於呼叫<ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph>多載<ph id="ph2">`bindingAttr`</ph>引數等於<ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph>在 C# 和<ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph>在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>It returns all public instance and static properties, both those defined by the type represented by the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as well as those inherited from its base types.</source>
          <target state="translated">它會傳回所有公用執行個體和靜態屬性，表示由目前類型所定義兩個那些<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件以及繼承自一個基底類型。</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph>方法不會傳回屬性以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">您的程式碼必須依賴屬性會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following example demonstrates the use of the <ph id="ph1">`GetProperties`</ph> method.</source>
          <target state="translated">下列範例示範 <ph id="ph1">`GetProperties`</ph> 方法的用法。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的屬性。</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> 物件的陣列，代表目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 中符合指定繫結條件約束的所有屬性。</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have properties, or if none of the properties match the binding constraints.</source>
          <target state="translated">如果目前 <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> 沒有屬性，或沒有屬性符合繫結條件約束，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列。</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph>方法不會傳回屬性以特定順序，例如依字母順序排列或按宣告順序。</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">您的程式碼必須依賴屬性會傳回的順序，因為順序不同。</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>来包含在搜尋中的篩選旗標可以用來定義的巢狀類型：</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用屬性。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</source>
          <target state="translated">只保護，而且會傳回基底類別上的內部屬性。不會傳回基底類別上的私用屬性。</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的屬性<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的屬性。</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前的 T:System.Type 代表建構的泛型類型，則這個方法會傳回<ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數所取代的型別參數的物件。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following example defines a class named <ph id="ph1">`PropertyClass`</ph> that includes six properties: two are public, one is private, one is protected, one is internal (<ph id="ph2">`Friend`</ph> in Visual Basic), and one is protected internal (<ph id="ph3">`Protected Friend`</ph> in Visual Basic).</source>
          <target state="translated">下列範例會定義名為類別<ph id="ph1">`PropertyClass`</ph>包含六個屬性： 兩個都是公用，一個是私用、 保護的其中一個，為內部 (<ph id="ph2">`Friend`</ph>在 Visual Basic 中)，且其中一個受保護內部 (<ph id="ph3">`Protected Friend`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors) for the properties that match the specified binding constraints.</source>
          <target state="translated">接著會顯示一些基本的屬性資訊 (屬性名稱和型別，是否是讀取/寫入，以及是否可看到其<ph id="ph1">`get`</ph>和<ph id="ph2">`set`</ph>存取子) 符合指定的繫結條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific property of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的特定屬性。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">字串，包含要取得的公用屬性名稱。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>Searches for the public property with the specified name.</source>
          <target state="translated">搜尋具有指定名稱的公用屬性。</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表具有指定之名稱的公用屬性 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體屬性。</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">情況<ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>發生如下：</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">類型包含兩個索引的屬性具有相同名稱但不同數量的參數。</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">若要解決模稜兩可，使用的多載<ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph>方法所指定的參數類型。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A derived type declares a property that hides an inherited property with the same name, by using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">衍生的型別宣告會隱藏繼承的屬性具有相同的名稱，使用屬性<ph id="ph1">`new`</ph>修飾詞 (<ph id="ph2">`Shadows`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use the <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method overload and add the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> flag to restrict the search to members that are not inherited.</source>
          <target state="translated">若要解決模稜兩可，請使用<ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph>方法多載，並新增<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph>旗標將搜尋限制不會繼承的成員。</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexers and Default Properties</source>
          <target state="translated">索引子和預設屬性</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph><ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>，和<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">例如，如果變數<ph id="ph1">`myList`</ph>指<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>，語法<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph>在 Visual Basic 中) 擷取具有索引 3 的項目。</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>You can overload the property.</source>
          <target state="translated">您可以多載的屬性。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">不過，類別程式庫開發人員可以使用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>屬性變更的中繼資料中索引子名稱。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String&gt;</ph>類別具有名為索引子<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">若要判斷型別是否具有預設屬性，請使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>方法來測試<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">如果類型具有<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>屬性會傳回預設屬性的名稱。</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves a property of that class, and displays the property name.</source>
          <target state="translated">下列範例會擷取<ph id="ph1">`Type`</ph>物件的使用者定義的類別，擷取該類別的屬性，並顯示屬性名稱。</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Internally, this property is referred to in the metadata by the name "Item."</source>
          <target state="translated">就內部而言，這個屬性是中繼資料中所參考的名稱 「 項目。 」</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Any attempt to get <ph id="ph1">`PropertyInfo`</ph> using reflection must specify this internal name in order to correctly return the <ph id="ph2">`PropertyInfo`</ph> property.</source>
          <target state="translated">嘗試取得<ph id="ph1">`PropertyInfo`</ph>使用反映必須指定此內部名稱才能正確地傳回<ph id="ph2">`PropertyInfo`</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">找到一個以上具有指定名稱的屬性。</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">字串，包含要取得的屬性名稱。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified property, using the specified binding constraints.</source>
          <target state="translated">使用指定的繫結條件約束搜尋指定的屬性。</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">代表符合指定之需求屬性的物件 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要在搜尋中包含的屬性：</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用屬性。</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的屬性<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的屬性。</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">情況<ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>發生如下：</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">類型包含兩個索引的屬性具有相同名稱但不同數量的參數。</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">若要解決模稜兩可，使用的多載<ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph>方法所指定的參數類型。</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A derived type declares a property that hides an inherited property with the same name, using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">衍生的型別宣告會隱藏繼承的屬性具有相同名稱的屬性使用<ph id="ph1">`new`</ph>修飾詞 (<ph id="ph2">`Shadows`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, include <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to restrict the search to members that are not inherited.</source>
          <target state="translated">若要解決模稜兩可，包括<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph>將搜尋限制不會繼承的成員。</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexers and Default Properties</source>
          <target state="translated">索引子和預設屬性</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph><ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>，和<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">例如，如果變數<ph id="ph1">`myList`</ph>指<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>，語法<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph>在 Visual Basic 中) 擷取具有索引 3 的項目。</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You can overload the property.</source>
          <target state="translated">您可以多載的屬性。</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">不過，類別程式庫開發人員可以使用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>屬性變更的中繼資料中索引子名稱。</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String&gt;</ph>類別具有名為索引子<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">若要判斷型別是否具有預設屬性，請使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>方法來測試<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">如果類型具有<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>屬性會傳回預設屬性的名稱。</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</source>
          <target state="translated">下列範例擷取的使用者定義的類別類型、 擷取該類別的屬性，並顯示根據指定的繫結條件約束的屬性名稱。</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">字串，包含要取得的公用屬性名稱。</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The return type of the property.</source>
          <target state="translated">屬性的傳回型別。</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Searches for the public property with the specified name and return type.</source>
          <target state="translated">搜尋具有指定名稱和傳回型別的公用屬性。</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表具有指定之名稱的公用屬性 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體屬性。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexers and Default Properties</source>
          <target state="translated">索引子和預設屬性</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph><ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>，和<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">例如，如果變數<ph id="ph1">`myList`</ph>指<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>，語法<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph>在 Visual Basic 中) 擷取具有索引 3 的項目。</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>You can overload the property.</source>
          <target state="translated">您可以多載的屬性。</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">不過，類別程式庫開發人員可以使用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>屬性變更的中繼資料中索引子名稱。</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String&gt;</ph>類別具有名為索引子<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">若要判斷型別是否具有預設屬性，請使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>方法來測試<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">如果類型具有<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>屬性會傳回預設屬性的名稱。</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The following example defines a class with one property and retrieves the name and type of the property.</source>
          <target state="translated">下列範例會定義具有一個屬性的類別，並擷取名稱和屬性的型別。</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">找到一個以上具有指定名稱的屬性。</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> 為 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">字串，包含要取得的公用屬性名稱。</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">用以取得未編製索引的屬性之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">搜尋指定的公用屬性，其參數符合指定的引數類型。</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">代表其參數符合指定之引數類型的公用屬性物件 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體屬性。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">索引子和預設屬性</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph><ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>，和<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">例如，如果變數<ph id="ph1">`myList`</ph>指<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>，語法<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph>在 Visual Basic 中) 擷取具有索引 3 的項目。</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">您可以多載的屬性。</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">不過，類別程式庫開發人員可以使用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>屬性變更的中繼資料中索引子名稱。</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String&gt;</ph>類別具有名為索引子<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">若要判斷型別是否具有預設屬性，請使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>方法來測試<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">如果類型具有<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>屬性會傳回預設屬性的名稱。</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to <ph id="ph2">`GetProperty`</ph>.</source>
          <target state="translated">下列範例會擷取<ph id="ph1">`Type`</ph>物件的使用者定義的類別，擷取該類別的屬性，並顯示屬性名稱和屬性的型別所傳遞的引數指定<ph id="ph2">`GetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">找到一個以上具有指定名稱，且符合指定引數類型的屬性。</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的項目是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">字串，包含要取得的公用屬性名稱。</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">屬性的傳回型別。</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">用以取得未編製索引的屬性之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">搜尋指定的公用屬性，其參數符合指定的引數類型。</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">代表其參數符合指定之引數類型的公用屬性物件 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體屬性。</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">索引子和預設屬性</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph><ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>，和<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">例如，如果變數<ph id="ph1">`myList`</ph>指<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>，語法<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph>在 Visual Basic 中) 擷取具有索引 3 的項目。</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">您可以多載的屬性。</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">不過，類別程式庫開發人員可以使用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>屬性變更的中繼資料中索引子名稱。</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String&gt;</ph>類別具有名為索引子<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">若要判斷型別是否具有預設屬性，請使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>方法來測試<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">如果類型具有<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>屬性會傳回預設屬性的名稱。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">找到一個以上具有指定名稱，且符合指定引數類型的屬性。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的項目是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">字串，包含要取得的公用屬性名稱。</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">屬性的傳回型別。</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">用以取得未編製索引的屬性之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public property whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">搜尋指定的公用屬性，其參數符合指定的引數類型和修飾詞。</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">物件，代表符合指定之需求的公用屬性 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`name`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">搜尋包含 public static 和 public 的執行個體屬性。</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">索引子和預設屬性</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph><ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>，和<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">例如，如果變數<ph id="ph1">`myList`</ph>指<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>，語法<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph>在 Visual Basic 中) 擷取具有索引 3 的項目。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">您可以多載的屬性。</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">不過，類別程式庫開發人員可以使用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>屬性變更的中繼資料中索引子名稱。</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String&gt;</ph>類別具有名為索引子<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">若要判斷型別是否具有預設屬性，請使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>方法來測試<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">如果類型具有<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>屬性會傳回預設屬性的名稱。</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyPropertyClass`</ph>, and the indexed property of this class is retrieved using the arguments passed to the <ph id="ph3">`GetProperty`</ph> method.</source>
          <target state="translated">下列範例會取得<ph id="ph1">`Type`</ph>物件對應至<ph id="ph2">`MyPropertyClass`</ph>，並使用引數傳遞給擷取之索引的屬性，這個類別的<ph id="ph3">`GetProperty`</ph>方法。</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified argument types and modifiers.</source>
          <target state="translated">找到一個以上具有指定名稱，且符合指定引數類型和修飾詞的屬性。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> 的長度不同。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的項目是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">字串，包含要取得的屬性名稱。</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">屬性的傳回型別。</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">用以取得未編製索引的屬性之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">使用指定的繫結條件約束搜尋指定的屬性，而該屬性的參數符合指定的引數類型和修飾詞。</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">代表符合指定之需求屬性的物件 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">屬性會被視為公用，以反映，如果有至少一個存取子是公用。</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">否則屬性會被視為私用，而且您必須使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (在 Visual Basic 中結合使用值<ph id="ph4">`Or`</ph>) 以取得它。</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要在搜尋中包含的屬性：</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用屬性。</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的屬性<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的屬性。</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個方法會傳回<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>具有適當的型別引數取代型別參數。</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">索引子和預設屬性</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph><ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>，和<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>已簡化存取索引的屬性的語法，並允許一個索引的屬性是其類型的預設值。</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">例如，如果變數<ph id="ph1">`myList`</ph>指<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>，語法<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph>在 Visual Basic 中) 擷取具有索引 3 的項目。</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">您可以多載的屬性。</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">在 C# 中，這項功能稱為索引子，且不能以名稱來參考。</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">不過，類別程式庫開發人員可以使用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>屬性變更的中繼資料中索引子名稱。</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String&gt;</ph>類別具有名為索引子<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">若要判斷型別是否具有預設屬性，請使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>方法來測試<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">如果類型具有<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>屬性會傳回預設屬性的名稱。</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> 的長度不同。</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的項目是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">字串，包含要取得的屬性名稱。</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">零，傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載成員的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">屬性的傳回型別。</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">用以取得未編製索引的屬性之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 類型的空陣列 (也就是，Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">預設的繫結器不會處理這個參數。</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束搜尋指定的屬性，而該屬性的參數符合指定的引數類型和修飾詞的建構函式。</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">代表符合指定之需求屬性的物件 (如有找到)；否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(<ph id="ph2">`modifiers`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`modifiers`</ph>。</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要在搜尋中包含的屬性：</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">您必須指定<ph id="ph1">`BindingFlags.Instance`</ph>或<ph id="ph2">`BindingFlags.Static`</ph>以取得傳回。</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用屬性。</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>包含<ph id="ph2">`public`</ph>和<ph id="ph3">`protected`</ph>階層; 上的靜態成員<ph id="ph4">`private`</ph>繼承的類別中的靜態成員不會包含。</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的屬性<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的屬性。</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 的其中一個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> 是多維的。</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> 的長度不同。</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph>, or <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">目前的型別是 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>、<ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the specified type.</source>
          <target state="translated">取得代表指定類型的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>Gets the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">要取得之類型的組件限定名稱。</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">請參閱 <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search.</source>
          <target state="translated">取得具有指定名稱的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，執行區分大小寫的搜尋。</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">具有指定名稱的類型 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if you know its namespace-qualified name.</source>
          <target state="translated">您可以使用<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法，以取得<ph id="ph2">&lt;xref:System.Type&gt;</ph>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 引起指定的組件載入<ph id="ph2">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">您也可以載入組件使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法，這個方法，然後使用<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>方法<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>方法來取得<ph id="ph5">&lt;xref:System.Type&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or  in C++.</source>
          <target state="translated">如果類型是在編譯時期已知程式組件中，它是在 C# 中，使用更有效率<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>在 Visual Basic 或 c + + 中。</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>找不到，呼叫<ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph>方法會傳回<ph id="ph3">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>It does not throw an exception.</source>
          <target state="translated">它不會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">若要控制是否擲回例外狀況，請呼叫的多載<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法<ph id="ph2">`throwOnError`</ph>參數。</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 只適用於從磁碟載入的組件。</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you call <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">如果您呼叫<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>查閱來定義動態組件中定義的型別<ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph>服務，您可能會發生不一致的行為。</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">行為取決於動態組件是持續性，也就是，建立使用<ph id="ph1">`RunAndSave`</ph>或<ph id="ph2">`Save`</ph>存取模式的<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">如果在動態組件會持續，並寫入磁碟之前<ph id="ph1">`GetType`</ph>是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果組件尚未儲存至磁碟<ph id="ph1">`GetType`</ph>呼叫時，此方法會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> 不了解暫時性動態組件。因此，呼叫<ph id="ph2">`GetType`</ph>擷取型別中的暫時性動態組件傳回<ph id="ph3">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">若要使用<ph id="ph1">`GetType`</ph>上動態模組中，訂閱<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph>事件和呼叫<ph id="ph3">`GetType`</ph>之後再儲存。</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">否則，您會得到兩個組件的複本在記憶體中。</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">請參閱 <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">如果組件具有強式名稱，是完整組件名稱是必要。</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱和泛型型別引數。</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">例如，"ProcessorArchitecture = msil"。</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">不過，它不包含在所傳回的字串<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性，因為相容性。</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">您也可以藉由建立載入型別<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>物件並將其傳遞至適當的多載<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">然後您可以使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>方法來載入組件類型。</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">請參閱<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Delimiter</source>
          <target state="translated">分隔符號</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Meaning</source>
          <target state="translated">意義</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">反斜線 (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Escape character.</source>
          <target state="translated">逸出字元。</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backtick (`)</source>
          <target state="translated">倒單引號 （'）</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Brackets ([])</source>
          <target state="translated">括號 ([])</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Comma (,)</source>
          <target state="translated">逗號 （，）</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">後面接著組件名稱。</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Period (.)</source>
          <target state="translated">句號 （.）</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">代表命名空間識別項。</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Plus sign (+)</source>
          <target state="translated">加號 （+）</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes a nested class.</source>
          <target state="translated">之前的巢狀的類別。</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">例如，類別的完整限定的名稱可能看起來像這樣：</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (<ph id="ph1">\\</ph>) 以防止它被解譯為巢狀的分隔符號。</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">反映會發出這個字串，如下所示：</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A"+ +"會變成"<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+ 」，和 「<ph id="ph4">\\</ph>能夠又 「 變"<ph id="ph5">\\</ph><ph id="ph6">\\</ph>"。</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">這個限定的名稱可以保存下來，並稍後用來載入<ph id="ph1">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">搜尋並載入<ph id="ph1">&lt;xref:System.Type&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>與型別名稱只有或組件限定的類型名稱。</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 與類型名稱只會尋找<ph id="ph2">&lt;xref:System.Type&gt;</ph>在呼叫者的組件，然後系統組件。</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 與組件限定的類型名稱會尋找<ph id="ph2">&lt;xref:System.Type&gt;</ph>任何組件中。</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">若要擷取的型別名稱不含這些尾端字元，請使用<ph id="ph1">`t.GetElementType().ToString()`</ph>，其中<ph id="ph2">`t`</ph>是型別。</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">空格是相關組件名稱以外的所有型別名稱元件中。</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">泛型類型的名稱結尾是反單引號 (<ph id="ph1">\`</ph>) 後面接著數字，代表泛型型別引數數目。</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">比方說，反映傳回 mangled 的名稱<ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph>泛型的方法從<ph id="ph4">`Tuple(Of T)`</ph>和<ph id="ph5">`Tuple(Of T0, T1)`</ph>在 Visual Basic 中，或<ph id="ph6">`Tuple&lt;T&gt;`</ph>和 Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> Visual C# 中。</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">例如，泛型<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>有兩個類型參數。</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>的<ph id="ph2">`MyType`</ph>類型的索引鍵聯<ph id="ph3">&lt;xref:System.String&gt;</ph>可能會表示如下：</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> fromMyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>的<ph id="ph2">`MyType`</ph>fromMyAssembly.dll，類型的索引鍵聯<ph id="ph3">&lt;xref:System.String&gt;</ph>，可能會以下面方式指定：</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">組件限定型別可以括在方括號，它必須出現在型別參數清單中。</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">可為 null 的類型是泛型類型的特殊案例。</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">例如，可為 null<ph id="ph1">&lt;xref:System.Int32&gt;</ph>由 「 System.Nullable'1[System.Int32]"的字串。</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">例如，可為 null<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>類型由<ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph>在 C# 中，由<ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph>c + + 和<ph id="ph4">`GetType(Nullable(Of Boolean))`</ph>在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">下表顯示您使用的語法<ph id="ph1">`GetType`</ph>各種類型。</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To Get</source>
          <target state="translated">若要取得</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Use</source>
          <target state="translated">使用</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">可為 null <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">若要將 unmanaged 的指標 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">將 unmanaged 的指標的指標 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Managed 的指標或參考 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>。</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">請注意，參考與指標不同，僅限一個層級。</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A parent class and a nested class</source>
          <target state="translated">父類別和巢狀的類別</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">一維陣列，其下限為 0</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">一維陣列，未知的下限</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An n-dimensional array</source>
          <target state="translated">N 維陣列</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">逗號 （，） 的 n-1 次數總計的括號內。</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">例如，<ph id="ph1">`System.Object[,,]`</ph>代表三維<ph id="ph2">`Object`</ph>陣列。</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An array of one-dimensional arrays</source>
          <target state="translated">陣列的一維陣列</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">矩形的二維陣列下限未知</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with one type argument</source>
          <target state="translated">具有一個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two type arguments</source>
          <target state="translated">具有兩個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">具有兩個組件限定型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">組件限定泛型型別與組件限定型別引數</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">泛型型別，其型別引數是兩個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">下列範例會擷取的型別<ph id="ph1">`System.Int32`</ph>並使用該類型的物件顯示<ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph>屬性<ph id="ph3">`System.Int32`</ph>。</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型以指標類型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> 類型或 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> 做為其中一個類型引數。</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型具有不正確的類型引數數目。</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表 <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> 的陣列。</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>適用於 Windows 市集應用程式的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或是<bpt id="p2">[</bpt>可攜式類別庫<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改為攔截基底類別例外狀況 <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">找到組件或其相依性的其中一個，但無法載入。</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">組件或組件的其中一個相依性無效。</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">要取得之類型的組件限定名稱。</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">請參閱 <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示找不到該類型時擲回例外狀況，而 <ph id="ph2">&lt;see langword="false" /&gt;</ph> 則表示傳回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">指定 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 也會隱藏其他某些例外狀況條件，但並不是全部。</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</source>
          <target state="translated">取得具有指定名稱的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，執行區分大小寫的搜尋，並設定找不到該類型時，是否應擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">具有指定名稱的類型。</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">如果找不到該類型，<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 參數會指定是要傳回 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或是擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">在某些情況下，不論 <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 的值為何，都會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">您可以使用<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法，以取得<ph id="ph2">&lt;xref:System.Type&gt;</ph>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 引起指定的組件載入<ph id="ph2">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">您也可以載入組件使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法，這個方法，然後使用<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>方法<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>方法來取得<ph id="ph5">&lt;xref:System.Type&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">如果類型是在編譯時期已知程式組件中，會更有效率使用<ph id="ph1">`typeof`</ph>在 C# 中，<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>在 Visual Basic 中，或<ph id="ph3">`typeid`</ph>c + + 中。</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> 只適用於從磁碟載入的組件。</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">如果您呼叫<ph id="ph1">`GetType`</ph>查閱來定義動態組件中定義的型別<ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph>服務，您可能會發生不一致的行為。</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">行為取決於動態組件是持續性，也就是，建立使用<ph id="ph1">`RunAndSave`</ph>或<ph id="ph2">`Save`</ph>存取模式的<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">如果在動態組件會持續，並寫入磁碟之前<ph id="ph1">`GetType`</ph>是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果組件尚未儲存至磁碟<ph id="ph1">`GetType`</ph>呼叫時，此方法會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> 不了解暫時性動態組件。因此，呼叫<ph id="ph2">`GetType`</ph>擷取型別中的暫時性動態組件傳回<ph id="ph3">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">若要使用<ph id="ph1">`GetType`</ph>上動態模組中，訂閱<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph>事件和呼叫<ph id="ph3">`GetType`</ph>之後再儲存。</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">否則，您會得到兩個組件的複本在記憶體中。</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph>參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 &gt; 一節中所述。</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">某些例外狀況的值為何<ph id="ph1">`throwOnError`</ph>。</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">例如，如果找到的類型，但無法載入，<ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph>就會擲回即使<ph id="ph2">`throwOnError`</ph>是<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">請參閱 <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">如果組件具有強式名稱，是完整組件名稱是必要。</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱，以及泛型引數。</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">例如，"ProcessorArchitecture = msil"。</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">不過，它不包含在所傳回的字串<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性，因為相容性。</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">您也可以藉由建立載入型別<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>物件並將其傳遞至適當的多載<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">然後您可以使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>方法來載入組件類型。</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">請參閱<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">分隔符號</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">意義</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">反斜線 (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">逸出字元。</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">倒單引號 （'）</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">括號 ([])</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">逗號 （，）</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">後面接著組件名稱。</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">句號 （.）</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">代表命名空間識別項。</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">加號 （+）</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">之前的巢狀的類別。</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">例如，類別的完整限定的名稱可能看起來像這樣：</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (<ph id="ph1">\\</ph>) 以防止它被解譯為巢狀的分隔符號。</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">反映會發出這個字串，如下所示：</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A"+ +"會變成"<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+ 」，和 「<ph id="ph4">\\</ph>能夠又 「 變"<ph id="ph5">\\</ph><ph id="ph6">\\</ph>"。</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">這個限定的名稱可以保存下來，並稍後用來載入<ph id="ph1">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">搜尋並載入<ph id="ph1">&lt;xref:System.Type&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>與型別名稱只有或組件限定的類型名稱。</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 與類型名稱只會尋找<ph id="ph2">&lt;xref:System.Type&gt;</ph>在呼叫者的組件，然後系統組件。</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 與組件限定的類型名稱會尋找<ph id="ph2">&lt;xref:System.Type&gt;</ph>任何組件中。</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">若要擷取的型別名稱不含這些尾端字元，請使用<ph id="ph1">`t.GetElementType().ToString()`</ph>，其中<ph id="ph2">`t`</ph>是型別。</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">空格是相關組件名稱以外的所有型別名稱元件中。</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">泛型類型的名稱結尾是反單引號 (<ph id="ph1">\`</ph>) 後面接著數字，代表泛型型別引數數目。</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">比方說，反映傳回 mangled 的名稱<ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph>泛型的方法從<ph id="ph4">`Tuple(Of T)`</ph>和<ph id="ph5">`Tuple(Of T0, T1)`</ph>在 Visual Basic 中，或<ph id="ph6">`Tuple&lt;T&gt;`</ph>和 Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> Visual C# 中。</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">例如，泛型<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>有兩個類型參數。</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>的<ph id="ph2">`MyType`</ph>類型的索引鍵聯<ph id="ph3">&lt;xref:System.String&gt;</ph>可能會表示如下：</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>的<ph id="ph2">`MyType`</ph>MyAssembly.dll，具有索引鍵的類型從<ph id="ph3">&lt;xref:System.String&gt;</ph>，可能會以下面方式指定：</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">組件限定型別可以括在方括號，它必須出現在型別參數清單中。</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">可為 null 的類型是泛型類型的特殊案例。</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">例如，可為 null<ph id="ph1">&lt;xref:System.Int32&gt;</ph>由 「 System.Nullable'1[System.Int32]"的字串。</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">例如，可為 null<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>類型由<ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph>在 C# 中，由<ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph>c + + 和<ph id="ph4">`GetType(Nullable(Of Boolean))`</ph>在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">下表顯示您使用的語法<ph id="ph1">`GetType`</ph>各種類型。</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To Get</source>
          <target state="translated">若要取得</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Use</source>
          <target state="translated">使用</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">可為 null <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">若要將 unmanaged 的指標 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">將 unmanaged 的指標的指標 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Managed 的指標或參考 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>。</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">請注意，參考與指標不同，僅限一個層級。</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">父類別和巢狀的類別</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">一維陣列，其下限為 0</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">一維陣列，未知的下限</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">N 維陣列</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">逗號 （，） 的 n-1 次數總計的括號內。</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">例如，<ph id="ph1">`System.Object[,,]`</ph>代表三維<ph id="ph2">`Object`</ph>陣列。</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">二維陣列的陣列</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">矩形的二維陣列下限未知</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">具有一個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">具有兩個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">具有兩個組件限定型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">組件限定泛型型別與組件限定型別引數</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">泛型型別，其型別引數是兩個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">下列範例會擷取的型別<ph id="ph1">`System.Int32`</ph>並使用該類型的物件顯示<ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph>屬性<ph id="ph3">`System.Int32`</ph>。</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type object refers to an assembly that does not exist, this example throws an exception.</source>
          <target state="translated">如果型別物件參考不存在的組件，這個範例會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到類型。</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效字元，例如內嵌的定位字元。</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 是空字串。</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 代表大小無效的陣列類型。</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表 <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> 的陣列。</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效的語法。</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">例如，"MyType[,*,]"。</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型以指標類型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> 類型或 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> 做為其中一個類型引數。</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型具有不正確的類型引數數目。</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到組件或組件的其中一個相依性。</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>適用於 Windows 市集應用程式的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或是<bpt id="p2">[</bpt>可攜式類別庫<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改為攔截基底類別例外狀況 <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">找到組件或其相依性的其中一個，但無法載入。</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">組件或組件的其中一個相依性無效。</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">要取得之類型的組件限定名稱。</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">請參閱 <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.Specifying <ph id="ph4">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示找不到該型別時擲回例外狀況，而 <ph id="ph2">&lt;see langword="false" /&gt;</ph> 則表示傳回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。指定 <ph id="ph4">&lt;see langword="false" /&gt;</ph> 還會隱藏一些其他例外情況，但不是全部。</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示對 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 執行不區分大小寫的搜尋，<ph id="ph2">&lt;see langword="false" /&gt;</ph> 表示對 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 執行區分大小寫的搜尋。</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</source>
          <target state="translated">取得具有指定名稱的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，指定找不到類型時是否要擲回例外狀況，以及是否要執行區分大小寫的搜尋。</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">具有指定名稱的類型。</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">如果找不到該類型，<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 參數會指定是要傳回 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或是擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">在某些情況下，不論 <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 的值為何，都會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">您可以使用<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法，以取得<ph id="ph2">&lt;xref:System.Type&gt;</ph>中另一個組件，類型的物件，如果您知道其命名空間限定名稱。</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 引起指定的組件載入<ph id="ph2">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">您也可以載入組件使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法，這個方法，然後使用<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>方法<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>方法來取得<ph id="ph5">&lt;xref:System.Type&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">如果類型是在編譯時期已知程式組件中，會更有效率使用<ph id="ph1">`typeof`</ph>在 C# 中，<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>在 Visual Basic 中，或<ph id="ph3">`typeid`</ph>c + + 中。</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> 只適用於從磁碟載入的組件。</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">如果您呼叫<ph id="ph1">`GetType`</ph>查閱來定義動態組件中定義的型別<ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph>服務，您可能會發生不一致的行為。</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">行為取決於動態組件是持續性，也就是，建立使用<ph id="ph1">`RunAndSave`</ph>或<ph id="ph2">`Save`</ph>存取模式的<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">如果在動態組件會持續，並寫入磁碟之前<ph id="ph1">`GetType`</ph>是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件，而該組件中擷取的型別。</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果組件尚未儲存至磁碟<ph id="ph1">`GetType`</ph>呼叫時，此方法會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> 不了解暫時性動態組件。因此，呼叫<ph id="ph2">`GetType`</ph>擷取型別中的暫時性動態組件傳回<ph id="ph3">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">若要使用<ph id="ph1">`GetType`</ph>上動態模組中，訂閱<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph>事件和呼叫<ph id="ph3">`GetType`</ph>之後再儲存。</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">否則，您會得到兩個組件的複本在記憶體中。</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph>參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 &gt; 一節中所述。</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">某些例外狀況的值為何<ph id="ph1">`throwOnError`</ph>。</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">例如，如果找到的類型，但無法載入，<ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph>就會擲回即使<ph id="ph2">`throwOnError`</ph>是<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">下表顯示基底類別成員會傳回由<ph id="ph1">`Get`</ph>反映型別上的方法。</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">成員類型</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">非靜態</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">建構函式</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Field</source>
          <target state="translated">欄位</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">欄位一律是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Event</source>
          <target state="translated">Event - 事件</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Method</source>
          <target state="translated">方法</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">可以。</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">（虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">巢狀的類型</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Property</source>
          <target state="translated">屬性</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">不適用</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">一般類型系統規則會是繼承實作屬性的方法相同。</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">反映會將屬性視為依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">請參閱附註 2 下方。</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回型別、 參數類型、 個 sentinel 和 unmanaged 呼叫慣例。</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">這是二進位比較。</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">進行反映，屬性和事件是依名稱和簽章隱藏。</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">如果您同時有 get 和 set 存取子的屬性在基底類別，但在衍生的類別只有 get 存取子，衍生的類別屬性隱藏基底類別屬性中，並不能存取基底類別上的 setter。</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">自訂屬性不是一般類型系統的一部分。</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">陣列或 COM 類型不會搜尋除非它們已經被載入至可用的類別目錄。</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> 可以是類型名稱限定它的命名空間或組件限定名稱，其中包含組件名稱規格。</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">請參閱 <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>包含命名空間，但不是組件名稱，這個方法會搜尋才呼叫物件的組件和 Mscorlib.dll 中，依此順序。</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">如果部分或完整的組件名稱的完整類型名稱，這個方法會搜尋指定的組件中。</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">如果組件具有強式名稱，是完整組件名稱是必要。</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性會傳回完整的型別名稱，包括巢狀的類型、 組件名稱和型別引數。</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">在.NET Framework 2.0 版中，處理器架構加入至組件識別，而且可以指定為組件名稱字串的一部分。</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">例如，"ProcessorArchitecture = msil"。</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">不過，它不包含在所傳回的字串<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性，因為相容性。</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">您也可以藉由建立載入型別<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>物件並將其傳遞至適當的多載<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">然後您可以使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>方法來載入組件類型。</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">請參閱<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">分隔符號</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">意義</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">反斜線 (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">逸出字元。</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">倒單引號 （'）</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">前面有一個或多個代表型別參數，在泛型類型名稱的結尾，位於數目的數字。</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">括號 ([])</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">將建構的泛型類型; 泛型型別引數清單在型別引數清單中，括住的組件限定的類型。</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">逗號 （，）</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">後面接著組件名稱。</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">句號 （.）</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">代表命名空間識別項。</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">加號 （+）</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">之前的巢狀的類別。</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">例如，類別的完整限定的名稱可能看起來像這樣：</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">如果命名空間已 TopNamespace.Sub+Namespace，則必須在字串前面加號 （+） 以逸出字元 (<ph id="ph1">\\</ph>) 以防止它被解譯為巢狀的分隔符號。</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">反映會發出這個字串，如下所示：</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A"+ +"會變成"<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+ 」，和 「<ph id="ph4">\\</ph>能夠又 「 變"<ph id="ph5">\\</ph><ph id="ph6">\\</ph>"。</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">這個限定的名稱可以保存下來，並稍後用來載入<ph id="ph1">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">搜尋並載入<ph id="ph1">&lt;xref:System.Type&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>與型別名稱只有或組件限定的類型名稱。</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 與類型名稱只會尋找<ph id="ph2">&lt;xref:System.Type&gt;</ph>在呼叫者的組件，然後系統組件。</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 與組件限定的類型名稱會尋找<ph id="ph2">&lt;xref:System.Type&gt;</ph>任何組件中。</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">型別名稱可能包含代表的類型，例如型別是否為參考類型、 指標類型或陣列類型的其他資訊的尾端字元。</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">若要擷取的型別名稱不含這些尾端字元，請使用<ph id="ph1">`t.GetElementType().ToString()`</ph>，其中<ph id="ph2">`t`</ph>是型別。</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">空格是相關組件名稱以外的所有型別名稱元件中。</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">在 組件名稱 '，' 分隔符號之前的空格有意義，但是 '，' 分隔符號之後的空格會被忽略。</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">泛型類型的名稱結尾是反單引號 (<ph id="ph1">\`</ph>) 後面接著數字，代表泛型型別引數數目。</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">此名稱修飾 （name-mangling） 的目的是要讓編譯器支援的泛型類型具有相同名稱但不同數目的型別參數，在相同範圍內發生。</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">比方說，反映傳回 mangled 的名稱<ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph>泛型的方法從<ph id="ph4">`Tuple(Of T)`</ph>和<ph id="ph5">`Tuple(Of T0, T1)`</ph>在 Visual Basic 中，或<ph id="ph6">`Tuple&lt;T&gt;`</ph>和 Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> Visual C# 中。</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">為泛型類型，類型引數清單括在括號，並以逗號分隔的型別引數。</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">例如，泛型<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>有兩個類型參數。</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>的<ph id="ph2">`MyType`</ph>類型的索引鍵聯<ph id="ph3">&lt;xref:System.String&gt;</ph>可能會表示如下：</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">若要指定組件限定類型的型別引數清單中，請將方括號內的組件限定類型。</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">否則，逗號分隔的組件限定名稱的組件會被視為分隔其他型別引數。</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>的<ph id="ph2">`MyType`</ph>MyAssembly.dll，具有索引鍵的類型從<ph id="ph3">&lt;xref:System.String&gt;</ph>，可能會以下面方式指定：</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">組件限定型別可以括在方括號，它必須出現在型別參數清單中。</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">在型別參數清單中搜尋組件的完整與不完整類型的規則不完整與不完整的非泛型類型的規則相同。</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">可為 null 的類型是泛型類型的特殊案例。</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">例如，可為 null<ph id="ph1">&lt;xref:System.Int32&gt;</ph>由 「 System.Nullable'1[System.Int32]"的字串。</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">您也可以在 C#、 c + + 和 Visual Basic 中取得使用運算子型別可為 null 的類型。</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">例如，可為 null<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>類型由<ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph>在 C# 中，由<ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph>c + + 和<ph id="ph4">`GetType(Nullable(Of Boolean))`</ph>在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">下表顯示您使用的語法<ph id="ph1">`GetType`</ph>各種類型。</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To Get</source>
          <target state="translated">若要取得</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Use</source>
          <target state="translated">使用</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">可為 null <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">若要將 unmanaged 的指標 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">將 unmanaged 的指標的指標 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Managed 的指標或參考 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>。</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">請注意，參考與指標不同，僅限一個層級。</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">父類別和巢狀的類別</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">一維陣列，其下限為 0</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">一維陣列，未知的下限</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">N 維陣列</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">逗號 （，） 的 n-1 次數總計的括號內。</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">例如，<ph id="ph1">`System.Object[,,]`</ph>代表三維<ph id="ph2">`Object`</ph>陣列。</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">二維陣列的陣列</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">矩形的二維陣列下限未知</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">具有一個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">具有兩個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">具有兩個組件限定型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">組件限定泛型型別與組件限定型別引數</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">泛型型別，其型別引數是兩個型別引數的泛型型別</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到類型。</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效字元，例如內嵌的定位字元。</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 是空字串。</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 代表大小無效的陣列類型。</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表 <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> 的陣列。</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效的語法。</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">例如，"MyType[,*,]"。</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型以指標類型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> 類型或 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> 做為其中一個類型引數。</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型具有不正確的類型引數數目。</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到組件或組件的其中一個相依性。</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">找到組件或其相依性的其中一個，但無法載入。</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">組件或組件的其中一個相依性無效。</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The name of the type to get.</source>
          <target state="translated">要取得之類型的名稱。</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">如果已提供 <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> 參數，則類型名稱可為 <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> 能解析的任何字串。</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">如果已提供 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> 參數或已使用標準類型解析，<bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 就必須是組件限定名稱 (請參閱 <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">方法，會找出並傳回 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 中指定的組件。</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">組件名稱做為 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 物件傳遞至 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 不包含組件名稱，則不會呼叫 <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">如果未提供 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>，則會執行標準組件解析。</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意：不要從未知或未受信任的呼叫端傳遞方法。</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">這樣做可能會提高惡意程式碼的權限。</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">只使用您所提供或熟悉的方法。</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">從 <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> 或標準組件解析傳回的組件，找出並傳回由 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 指定之類型的方法。</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If no assembly is provided, the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> method can provide one.</source>
          <target state="translated">如果未提供任何組件，<bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> 方法會提供一個組件。</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 至該參數。</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意：不要從未知或未受信任的呼叫端傳遞方法。</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">取得具有指定名稱的類型，並選擇性提供自訂方法來解析組件和類型。</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The type with the specified name, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the type is not found.</source>
          <target state="translated">具有指定名稱的類型；如果找不到類型，則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">這個方法，以及詳細資料的使用方式案例<ph id="ph1">`assemblyResolver`</ph>和<ph id="ph2">`typeResolver`</ph>參數位於<ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>找不到，呼叫<ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph>方法會傳回<ph id="ph3">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>It does not throw an exception.</source>
          <target state="translated">它不會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">若要控制是否擲回例外狀況，請呼叫的多載<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法<ph id="ph2">`throwOnError`</ph>參數。</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`throwOnError`</ph> and <ph id="ph4">`ignoreCase`</ph> parameters.</source>
          <target state="translated">呼叫這個方法多載會呼叫相同<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載，並指定<ph id="ph2">`false`</ph>如<ph id="ph3">`throwOnError`</ph>和<ph id="ph4">`ignoreCase`</ph>參數。</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">將 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型以指標類型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> 類型或 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> 做為其中一個類型引數。</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型具有不正確的類型引數數目。</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表 <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> 的陣列。</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">找到組件或組件的其中一個相依性，但無法加以載入。</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 包含無效的組件名稱。</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 是有效的組件名稱，沒有型別名稱。</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">組件或組件的其中一個相依性無效。</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">要取得之類型的名稱。</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">如果已提供 <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> 參數，則類型名稱可為 <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> 能解析的任何字串。</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">如果已提供 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> 參數或已使用標準類型解析，<bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 就必須是組件限定名稱 (請參閱 <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">方法，會找出並傳回 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 中指定的組件。</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">組件名稱做為 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 物件傳遞至 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 不包含組件名稱，則不會呼叫 <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">如果未提供 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>，則會執行標準組件解析。</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意：不要從未知或未受信任的呼叫端傳遞方法。</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">這樣做可能會提高惡意程式碼的權限。</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">只使用您所提供或熟悉的方法。</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">從 <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> 或標準組件解析傳回的組件，找出並傳回由 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 指定之類型的方法。</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">如果未提供任何組件，方法會提供一個組件。</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 至該參數。</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意：不要從未知或未受信任的呼叫端傳遞方法。</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示找不到該類型時擲回例外狀況，而 <ph id="ph2">&lt;see langword="false" /&gt;</ph> 則表示傳回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">指定 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 也會隱藏其他某些例外狀況條件，但並不是全部。</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">取得具有指定名稱的類型，指定找不到類型時是否擲回例外狀況，同時選擇性提供自訂方法來解析組件和類型。</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">具有指定名稱的類型。</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">如果找不到該類型，<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 參數會指定是要傳回 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或是擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">在某些情況下，不論 <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 的值為何，都會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">這個方法，以及詳細資料的使用方式案例<ph id="ph1">`assemblyResolver`</ph>和<ph id="ph2">`typeResolver`</ph>參數位於<ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`ignoreCase`</ph> parameter.</source>
          <target state="translated">呼叫這個方法多載會呼叫相同<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載，並指定<ph id="ph2">`false`</ph>如<ph id="ph3">`ignoreCase`</ph>參數。</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到類型。</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效字元，例如內嵌的定位字元。</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 是空字串。</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 代表大小無效的陣列類型。</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表 <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> 的陣列。</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">將 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效的語法 (例如 "MyType[,*,]")。</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型以指標類型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> 類型或 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> 做為其中一個類型引數。</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型具有不正確的類型引數數目。</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到組件或組件的其中一個相依性。</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 包含無效的組件名稱。</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 是有效的組件名稱，沒有型別名稱。</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">找到組件或其相依性的其中一個，但無法載入。</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">組件或組件的其中一個相依性無效。</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">要取得之類型的名稱。</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">如果已提供 <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> 參數，則類型名稱可為 <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> 能解析的任何字串。</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">如果已提供 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> 參數或已使用標準類型解析，<bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 就必須是組件限定名稱 (請參閱 <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">方法，會找出並傳回 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 中指定的組件。</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">組件名稱做為 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 物件傳遞至 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 不包含組件名稱，則不會呼叫 <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">如果未提供 <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>，則會執行標準組件解析。</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意：不要從未知或未受信任的呼叫端傳遞方法。</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">這樣做可能會提高惡意程式碼的權限。</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">只使用您所提供或熟悉的方法。</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">從 <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> 或標準組件解析傳回的組件，找出並傳回由 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 指定之類型的方法。</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">如果未提供任何組件，方法會提供一個組件。</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> is passed to that parameter.</source>
          <target state="translated">這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> 的值至該參數。</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意：不要從未知或未受信任的呼叫端傳遞方法。</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示找不到該類型時擲回例外狀況，而 <ph id="ph2">&lt;see langword="false" /&gt;</ph> 則表示傳回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">指定 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 也會隱藏其他某些例外狀況條件，但並不是全部。</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示對 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 執行不區分大小寫的搜尋，<ph id="ph2">&lt;see langword="false" /&gt;</ph> 表示對 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 執行區分大小寫的搜尋。</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">取得具有指定名稱的類型，指定是否執行區分大小寫的搜尋以及找不到類型時是否擲回例外狀況，同時選擇性提供自訂方法來解析組件和類型。</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">具有指定名稱的類型。</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">如果找不到該類型，<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 參數會指定是要傳回 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或是擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">在某些情況下，不論 <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 的值為何，都會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use this method overload and its associated overloads (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) to replace the default implementation of the <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> method with more flexible implementations.</source>
          <target state="translated">使用這個方法多載，以及其相關聯的多載 (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) 來取代的預設實作<ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph>與更有彈性的實作方法。</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</source>
          <target state="translated">您可以藉由提供您自己解析型別名稱和包含它們的組件名稱的方法，執行下列作業：</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Control which version of an assembly a type is loaded from.</source>
          <target state="translated">控制項類型從載入的組件的版本。</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Provide another place to look for a type name that does not include an assembly name.</source>
          <target state="translated">提供查閱不包含組件名稱的型別名稱的另一個位置。</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Load assemblies using partial assembly names.</source>
          <target state="translated">載入組件使用部分的組件名稱。</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the common language runtime (CLR).</source>
          <target state="translated">傳回的子類別<ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph>，不由 common language runtime (CLR) 建立。</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</source>
          <target state="translated">比方說，在版本相容序列化這個方法可讓您使用的部分名稱來搜尋"best fit"的組件。</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Other overloads of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method require an assembly-qualified type name, which includes the version number.</source>
          <target state="translated">其他多載<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法需要組件限定類型名稱，其中包含的版本號碼。</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Alternate implementations of the type system may need to return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the CLR; all types that are returned by other overloads of the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method are runtime types.</source>
          <target state="translated">型別系統的替代實作可能要傳回的子類別<ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph>，不會建立由 CLR; 所有類型的其他多載會傳回<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>方法屬於執行階段類型。</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Usage Notes</source>
          <target state="translated">使用注意事項</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method overload and its associated overloads parse <ph id="ph1">`typeName`</ph> into the name of a type and the name of an assembly, and then resolve the names.</source>
          <target state="translated">這個方法多載，以及其相關聯的多載剖析<ph id="ph1">`typeName`</ph>成的型別和組件名稱的名稱，再解析名稱。</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</source>
          <target state="translated">組件名稱的解析就會發生型別名稱，解析之前，因為型別名稱必須解析組件的內容中。</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you are unfamiliar with the concept of assembly-qualified type names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property.</source>
          <target state="translated">如果您不熟悉的組件限定類型名稱的概念，請參閱<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is not an assembly-qualified name, assembly resolution is skipped.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>不是組件限定名稱，則會略過組件解析。</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <ph id="ph1">`typeResolver`</ph> parameter.</source>
          <target state="translated">可以 Mscorlib.dll 或目前正在執行的組件的內容中解析不合格的型別名稱，或您可以選擇性地提供中的組件<ph id="ph1">`typeResolver`</ph>參數。</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section.</source>
          <target state="translated">要包含或省略不同種類的名稱解析會顯示為資料表中的組件名稱的效果<bpt id="p1">[</bpt>混合的名稱解析<ept id="p1">](#mixed_name_resolution)</ept>&gt; 一節。</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>General usage notes:</source>
          <target state="translated">一般使用方式附註：</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Do not pass methods to <ph id="ph1">`assemblyResolver`</ph> or <ph id="ph2">`typeResolver`</ph> if they come from unknown or untrusted callers.</source>
          <target state="translated">不要傳遞至方法<ph id="ph1">`assemblyResolver`</ph>或<ph id="ph2">`typeResolver`</ph>他們是來自未知或不受信任的呼叫端。</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">只使用您所提供或熟悉的方法。</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</source>
          <target state="translated">使用來自未知或未受信任的呼叫者方法可能會導致提高權限的惡意程式碼。</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you omit the <ph id="ph1">`assemblyResolver`</ph> and/or <ph id="ph2">`typeResolver`</ph> parameters, the value of the <ph id="ph3">`throwOnError`</ph> parameter is passed to the methods that perform the default resolution.</source>
          <target state="translated">如果您省略<ph id="ph1">`assemblyResolver`</ph>及/或<ph id="ph2">`typeResolver`</ph>參數、 值<ph id="ph3">`throwOnError`</ph>參數傳遞至此執行預設解析的方法。</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`throwOnError`</ph> is <ph id="ph2">`true`</ph>, this method throws a <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> when <ph id="ph4">`typeResolver`</ph> returns <ph id="ph5">`null`</ph>, and a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> when <ph id="ph7">`assemblyResolver`</ph> returns <ph id="ph8">`null`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`throwOnError`</ph>是<ph id="ph2">`true`</ph>，這個方法會擲回<ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph>時<ph id="ph4">`typeResolver`</ph>傳回<ph id="ph5">`null`</ph>，和<ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph>時<ph id="ph7">`assemblyResolver`</ph>傳回<ph id="ph8">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method does not catch exceptions thrown by <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">這個方法不會攔截擲回例外狀況<ph id="ph1">`assemblyResolver`</ph>和<ph id="ph2">`typeResolver`</ph>。</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You are responsible for any exceptions that are thrown by the resolver methods.</source>
          <target state="translated">您必須負責解析程式方法所擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Assemblies</source>
          <target state="translated">解析組件</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method receives an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, which is produced by parsing the string assembly name that is included in <ph id="ph3">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph>方法會接收<ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>物件，它會藉由剖析字串組件名稱包含在產生<ph id="ph3">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not contain an assembly name, <ph id="ph2">`assemblyResolver`</ph> is not called and <ph id="ph3">`null`</ph> is passed to <ph id="ph4">`typeResolver`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>不包含組件名稱，<ph id="ph2">`assemblyResolver`</ph>則不會呼叫和<ph id="ph3">`null`</ph>傳遞至<ph id="ph4">`typeResolver`</ph>。</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is not supplied, standard assembly probing is used to locate the assembly.</source>
          <target state="translated">如果<ph id="ph1">`assemblyResolver`</ph>不提供標準的組件探查用來找出組件。</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method does not do standard probing; in that case you must ensure that your <ph id="ph3">`assemblyResolver`</ph> can handle all the assemblies you pass to it.</source>
          <target state="translated">如果<ph id="ph1">`assemblyResolver`</ph>提供，則<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>方法不會進行一般探查; 在此情況下您必須確定您<ph id="ph3">`assemblyResolver`</ph>可以處理傳遞給它的所有組件。</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method should return <ph id="ph2">`null`</ph> if the assembly cannot be resolved.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph>方法應傳回<ph id="ph2">`null`</ph>如果無法解析的組件。</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called and no further processing occurs; additionally, if <ph id="ph4">`throwOnError`</ph> is <ph id="ph5">`true`</ph>, a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">如果<ph id="ph1">`assemblyResolver`</ph>傳回<ph id="ph2">`null`</ph>，<ph id="ph3">`typeResolver`</ph>則不會呼叫並不進行任何處理就會發生; 此外，如果<ph id="ph4">`throwOnError`</ph>是<ph id="ph5">`true`</ph>、<ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph>就會擲回。</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> that is passed to <ph id="ph2">`assemblyResolver`</ph> is a partial name, one or more of its parts are <ph id="ph3">`null`</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>傳遞至<ph id="ph2">`assemblyResolver`</ph>是部分名稱、 一或多個其各部分的<ph id="ph3">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if it has no version, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">例如，如果不有任何版本，<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph>屬性是<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> property, and the <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> method all return <ph id="ph4">`null`</ph>, then only the simple name of the assembly was supplied.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph>屬性，<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph>屬性，而<ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph>方法都會傳回<ph id="ph4">`null`</ph>，然後提供組件的簡單名稱。</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method can use or ignore all parts of the assembly name.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph>方法可以使用或忽略所有組件的組件名稱。</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different assembly resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">不同的組件解析選項的效果會顯示為資料表中<bpt id="p1">[</bpt>混合的名稱解析<ept id="p1">](#mixed_name_resolution)</ept>區段中的，簡單且組件限定類型名稱。</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Types</source>
          <target state="translated">解析型別</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not specify an assembly name, <ph id="ph2">`typeResolver`</ph> is always called.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>未指定組件名稱，<ph id="ph2">`typeResolver`</ph>一律會呼叫。</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> specifies an assembly name, <ph id="ph2">`typeResolver`</ph> is called only when the assembly name is successfully resolved.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>指定組件名稱，<ph id="ph2">`typeResolver`</ph>只有順利解析組件名稱時，才會呼叫。</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> or standard assembly probing returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called.</source>
          <target state="translated">如果<ph id="ph1">`assemblyResolver`</ph>或標準的組件探查傳回<ph id="ph2">`null`</ph>，<ph id="ph3">`typeResolver`</ph>則不會呼叫。</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method receives three arguments:</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph>方法會接收三個引數：</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly to search or <ph id="ph1">`null`</ph> if <ph id="ph2">`typeName`</ph> does not contain an assembly name.</source>
          <target state="translated">要搜尋的組件或<ph id="ph1">`null`</ph>如果<ph id="ph2">`typeName`</ph>不包含組件名稱。</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The simple name of the type.</source>
          <target state="translated">簡單類型的名稱。</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a nested type, this is the outermost containing type.</source>
          <target state="translated">當巢狀型別，這是最外層包含型別。</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a generic type, this is the simple name of the generic type.</source>
          <target state="translated">當泛型型別，這是泛型類型的簡單名稱。</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A Boolean value that is <ph id="ph1">`true`</ph> if the case of type names is to be ignored.</source>
          <target state="translated">布林值，是<ph id="ph1">`true`</ph>如果型別名稱的情況下會被忽略。</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The implementation determines the way these arguments are used.</source>
          <target state="translated">實作可決定使用這些引數的方式。</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method should return <ph id="ph2">`null`</ph> if it cannot resolve the type.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph>方法應傳回<ph id="ph2">`null`</ph>若無法解析型別。</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeResolver`</ph> returns <ph id="ph2">`null`</ph> and <ph id="ph3">`throwOnError`</ph> is <ph id="ph4">`true`</ph>, this overload of <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`typeResolver`</ph>傳回<ph id="ph2">`null`</ph>和<ph id="ph3">`throwOnError`</ph>是<ph id="ph4">`true`</ph>的這個多載<ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph>會擲回<ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different type resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">不同的型別解析選項的效果會顯示為資料表中<bpt id="p1">[</bpt>混合的名稱解析<ept id="p1">](#mixed_name_resolution)</ept>區段中的，簡單且組件限定類型名稱。</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Nested Types</source>
          <target state="translated">解析巢狀的類型</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is a nested type, only the name of the outermost containing type is passed to <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`typeName`</ph>是巢狀型別名稱的最外層包含型別傳遞至<ph id="ph2">`typeResolver`</ph>。</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>When <ph id="ph1">`typeResolver`</ph> returns this type, the <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> method is called recursively until the innermost nested type has been resolved.</source>
          <target state="translated">當<ph id="ph1">`typeResolver`</ph>傳回此型別，<ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>之前已解決的最內層的巢狀的類型，方法稱為遞迴運作。</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Generic Types</source>
          <target state="translated">正在解析的泛型型別</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>稱為遞迴解析泛型型別： 首先要解決泛型類型本身，然後解決它的型別引數。</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a type argument is generic, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve its type arguments, and so on.</source>
          <target state="translated">如果型別引數是泛型，<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>稱為遞迴解析其型別引數，等等。</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The combination of <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> that you provide must be capable of resolving all levels of this recursion.</source>
          <target state="translated">組合<ph id="ph1">`assemblyResolver`</ph>和<ph id="ph2">`typeResolver`</ph>您提供必須能夠解決這類遞迴的所有層級。</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, suppose you supply an <ph id="ph1">`assemblyResolver`</ph> that controls the loading of <ph id="ph2">`MyAssembly`</ph>.</source>
          <target state="translated">例如，假設您提供<ph id="ph1">`assemblyResolver`</ph>所控制的載入<ph id="ph2">`MyAssembly`</ph>。</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Suppose you want to resolve the generic type <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> in Visual Basic).</source>
          <target state="translated">假設您想要解決的泛型型別<ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph>(<ph id="ph2">`Dictionary(Of String, MyType)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You might pass the following generic type name:</source>
          <target state="translated">您可能會傳遞下列泛型類型名稱：</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Notice that <ph id="ph1">`MyType`</ph> is the only assembly-qualified type argument.</source>
          <target state="translated">請注意，<ph id="ph1">`MyType`</ph>是只有組件限定型別引數。</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The names of the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph2">&lt;xref:System.String&gt;</ph> classes are not assembly-qualified.</source>
          <target state="translated">名稱<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>和<ph id="ph2">&lt;xref:System.String&gt;</ph>類別不是組件限定。</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Your <ph id="ph1">`typeResolver`</ph> must be able handle either an assembly or <ph id="ph2">`null`</ph>, because it will receive <ph id="ph3">`null`</ph> for <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">您<ph id="ph1">`typeResolver`</ph>必須能夠處理其中任一組件或<ph id="ph2">`null`</ph>，因為它會接收<ph id="ph3">`null`</ph>如<ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>和<ph id="ph5">&lt;xref:System.String&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>It can handle that case by calling an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</source>
          <target state="translated">它可以處理此情況下所呼叫的多載<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>取用一個字串，因為這兩個不合格的類型名稱都 Mscorlib.dll 中的方法：</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph>不會呼叫方法的字典類型和字串類型，因為這些型別名稱不是組件限定。</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Now suppose that instead of <ph id="ph1">`System.String`</ph>, the first generic argument type is <ph id="ph2">`YourType`</ph>, from <ph id="ph3">`YourAssembly`</ph>:</source>
          <target state="translated">現在假設，而不是<ph id="ph1">`System.String`</ph>，第一個泛型引數類型是<ph id="ph2">`YourType`</ph>，從<ph id="ph3">`YourAssembly`</ph>:</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve <ph id="ph1">`YourType`</ph> without an assembly-qualified name.</source>
          <target state="translated">這個組件是目前執行的組件都 Mscorlib.dll，因為無法解析<ph id="ph1">`YourType`</ph>沒有組件限定名稱。</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because your <ph id="ph1">`assemblyResolve`</ph> will be called recursively, it must be able to handle this case.</source>
          <target state="translated">因為您<ph id="ph1">`assemblyResolve`</ph>會遞迴呼叫，它必須能夠處理這種情況。</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Instead of returning <ph id="ph1">`null`</ph> for assemblies other than <ph id="ph2">`MyAssembly`</ph>, it now performs an assembly load using the supplied <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object.</source>
          <target state="translated">而不是傳回<ph id="ph1">`null`</ph>以外的組件<ph id="ph2">`MyAssembly`</ph>，它現在會執行使用提供的組件載入<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">回到<bpt id="p1">[</bpt>使用注意事項<ept id="p1">](#usage_notes)</ept>。</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Type Names with Special Characters</source>
          <target state="translated">正在解析的型別名稱，含有特殊字元</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Certain characters have special meanings in assembly-qualified names.</source>
          <target state="translated">某些字元有特殊意義，在組件限定名稱。</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</source>
          <target state="translated">如果是簡單類型名稱包含這些字元，字元的簡單名稱是組件限定名稱的一部分時，就會造成剖析錯誤。</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">若要避免剖析錯誤，您必須逸出特殊字元以反斜線之前您可以將傳遞的組件限定名稱<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if a type is named <ph id="ph1">`Strange]Type`</ph>, the escape character must be added ahead of the square bracket as follows: <ph id="ph2">`Strange\]Type`</ph>.</source>
          <target state="translated">例如，如果型別為<ph id="ph1">`Strange]Type`</ph>，逸出字元必須加入晚於方括號，如下所示： <ph id="ph2">`Strange\]Type`</ph>。</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</source>
          <target state="translated">無法在 Visual Basic 或 C# 中，建立具有這類特殊字元的名稱，但可由使用 Microsoft intermediate language (MSIL)，或發出動態組件。</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table shows the special characters for type names.</source>
          <target state="translated">下表顯示類型名稱的特殊字元。</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Character</source>
          <target state="translated">字元</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">意義</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`,`</ph> (comma)</source>
          <target state="translated"><ph id="ph1">`,`</ph> （逗號）</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for assembly-qualified names.</source>
          <target state="translated">分隔符號組件限定名稱。</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`[]`</ph> (square brackets)</source>
          <target state="translated"><ph id="ph1">`[]`</ph> （方括號）</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</source>
          <target state="translated">做成對的後置詞，指出陣列型別。分隔符號組中，為封入泛型引數清單和組件限定名稱。</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`&amp;`</ph> (ampersand)</source>
          <target state="translated"><ph id="ph1">`&amp;`</ph> （連字號）</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a reference type.</source>
          <target state="translated">做為尾碼，表示型別是參考型別。</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`*`</ph> (asterisk)</source>
          <target state="translated"><ph id="ph1">`*`</ph> （星號）</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a pointer type.</source>
          <target state="translated">做為尾碼，表示型別是指標類型。</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`+`</ph> (plus)</source>
          <target state="translated"><ph id="ph1">`+`</ph> （加號）</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for nested types.</source>
          <target state="translated">巢狀類型的分隔符號。</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`\`</ph> (backslash)</source>
          <target state="translated"><ph id="ph1">`\`</ph> （反斜線）</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">逸出字元。</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Properties such as <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> return correctly escaped strings.</source>
          <target state="translated">屬性，例如<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>傳回正確逸出字串。</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You must pass correctly escaped strings to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">您必須傳遞正確逸出的字串<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In turn, the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method passes correctly escaped names to <ph id="ph2">`typeResolver`</ph> and to the default type resolution methods.</source>
          <target state="translated">接著，<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>方法會傳遞至的正確逸出的名稱<ph id="ph2">`typeResolver`</ph>以及預設的型別解析方法。</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you need to compare a name to an unescaped name in <ph id="ph1">`typeResolver`</ph>, you must remove the escape characters.</source>
          <target state="translated">如果您要比較的名稱中的未逸出名稱<ph id="ph1">`typeResolver`</ph>，您必須移除逸出字元。</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">回到<bpt id="p1">[</bpt>使用注意事項<ept id="p1">](#usage_notes)</ept>。</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Mixed Name Resolution</source>
          <target state="translated">混合的名稱解析</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table summarizes the interactions between <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>, and default name resolution, for all combinations of type name and assembly name in <ph id="ph3">`typeName`</ph>:</source>
          <target state="translated">下表摘要說明之間的互動<ph id="ph1">`assemblyResolver`</ph>， <ph id="ph2">`typeResolver`</ph>，和型別名稱和組件名稱中的所有組合的預設名稱解析<ph id="ph3">`typeName`</ph>:</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Contents of type name</source>
          <target state="translated">型別名稱的內容</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Assembly resolver method</source>
          <target state="translated">組件解析程式方法</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Type resolver method</source>
          <target state="translated">型別解析程式方法</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Result</source>
          <target state="translated">結果</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">型別，組件</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">相當於呼叫<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">型別，組件</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">提供</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> 傳回的組件，或傳回<ph id="ph2">`null`</ph>若無法解析組件。</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</source>
          <target state="translated">如果組件解析，<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph>方法多載用來從組件載入的型別; 否則就不會嘗試解析類型。</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">型別，組件</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">提供</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to converting the assembly name to an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph> method overload to get the assembly.</source>
          <target state="translated">相當於組件名稱，以轉換<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>物件並呼叫<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph>方法多載，以取得組件。</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">如果組件已解決，將它傳遞至<ph id="ph1">`typeResolver`</ph>，否則<ph id="ph2">`typeResolver`</ph>則不會呼叫，而且沒有任何進一步嘗試解析類型。</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">型別，組件</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">提供</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">提供</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> 傳回的組件，或傳回<ph id="ph2">`null`</ph>若無法解析組件。</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">如果組件已解決，將它傳遞至<ph id="ph1">`typeResolver`</ph>，否則<ph id="ph2">`typeResolver`</ph>則不會呼叫，而且沒有任何進一步嘗試解析類型。</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">類型</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">提供 null</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">相當於呼叫<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</source>
          <target state="translated">因為未提供組件名稱，會搜尋才 Mscorlib.dll 和目前執行的組件。</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">如果<ph id="ph1">`assemblyResolver`</ph>提供，則會忽略它。</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">類型</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">提供 null</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">提供</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> is called, and <ph id="ph2">`null`</ph> is passed for the assembly.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> 呼叫時，和<ph id="ph2">`null`</ph>傳遞的組件。</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> can provide a type from any assembly, including assemblies it loads for the purpose.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> 可以從任何組件，包括它的目的會自動載入的組件提供的類型。</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">如果<ph id="ph1">`assemblyResolver`</ph>提供，則會忽略它。</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>assembly</source>
          <target state="translated">組件</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">提供 null</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">提供 null</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>擲回，因為組件名稱會剖析如同一般組件限定類型名稱。</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This results in an invalid assembly name.</source>
          <target state="translated">這會導致無效的組件名稱。</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to: <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>Resolving Assemblies<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>Resolving Types<ept id="p3">](#resolving_types)</ept>.</source>
          <target state="translated">回到：<bpt id="p1">[</bpt>使用注意事項<ept id="p1">](#usage_notes)</ept>，<bpt id="p2">[</bpt>解析組件<ept id="p2">](#resolving_assemblies)</ept>，<bpt id="p3">[</bpt>解析型別的<ept id="p3">](#resolving_types)</ept>。</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到類型。</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效字元，例如內嵌的定位字元。</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 是空字串。</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 代表大小無效的陣列類型。</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表 <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> 的陣列。</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">將 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 剖析成型別名稱和組件名稱 (例如，簡單型別名稱中包含未逸出特殊字元) 時，就會發生錯誤。</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效的語法 (例如 "MyType[,*,]")。</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型以指標類型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> 類型或 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> 做為其中一個類型引數。</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型具有不正確的類型引數數目。</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到組件或組件的其中一個相依性。</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">找到組件或其相依性的其中之一，但無法載入。</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 包含無效的組件名稱。</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 是有效的組件名稱，沒有型別名稱。</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">組件或組件的其中一個相依性無效。</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of objects whose types to determine.</source>
          <target state="translated">要決定類型之物件的陣列。</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>Gets the types of the objects in the specified array.</source>
          <target state="translated">取得指定陣列中物件的類型。</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the types of the corresponding elements in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件的陣列，代表 <ph id="ph2">&lt;paramref name="args" /&gt;</ph> 中對應項目的類型。</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method to list the types of the elements of an array.</source>
          <target state="translated">下列程式碼範例示範如何使用<ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph>列出陣列的項目類型的方法。</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>One or more of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> 的其中一或多個項目為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The class initializers are invoked and at least one throws an exception.</source>
          <target state="translated">叫用了類別初始設定式，並至少有一個會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The type whose underlying type code to get.</source>
          <target state="translated">要取得其基礎類型程式碼的類型。</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>Gets the underlying type code of the specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得指定的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎類型程式碼。</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The code of the underlying type, or <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">基礎類型程式碼，如果 <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph> 是 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 則為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can change the behavior of this method by overriding the <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> method.</source>
          <target state="translated">當您繼承自<ph id="ph1">&lt;xref:System.Type&gt;</ph>，您可以藉由覆寫來變更此方法的行為<ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The following code example demonstrates how the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumeration can be used.</source>
          <target state="translated">下列程式碼範例示範如何<ph id="ph1">&lt;xref:System.TypeCode&gt;</ph>可以用於列舉型別。</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>In a decision block inside the <ph id="ph1">`WriteObjectInfo`</ph> method, the <ph id="ph2">&lt;xref:System.TypeCode&gt;</ph> of an <ph id="ph3">&lt;xref:System.Object&gt;</ph> parameter is examined, and an appropriate message is written to the console.</source>
          <target state="translated">在決策區塊<ph id="ph1">`WriteObjectInfo`</ph>方法，<ph id="ph2">&lt;xref:System.TypeCode&gt;</ph>的<ph id="ph3">&lt;xref:System.Object&gt;</ph>參數會檢查，並有適當錯誤訊息寫入至主控台。</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>Returns the underlying type code of this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> instance.</source>
          <target state="translated">傳回此 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 執行個體的基礎型別碼。</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>The type code of the underlying type.</source>
          <target state="translated">基礎類型的型別碼。</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>This method provides the implementation for the <ph id="ph1">`static`</ph> (in C#) or <ph id="ph2">`Shared`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> method.</source>
          <target state="translated">這個方法提供實作<ph id="ph1">`static`</ph>（C# 中） 或<ph id="ph2">`Shared`</ph>（在 Visual Basic)<ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can override this method to provide your own implementation of <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</source>
          <target state="translated">當您繼承自<ph id="ph1">&lt;xref:System.Type&gt;</ph>，您可以覆寫這個方法以提供您自己實作<ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">取得與指定的類別識別項 (CLSID) 關聯的類型。</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">要取得之類型的 CLSID。</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">取得與指定的類別識別項 (CLSID) 關聯的類型。</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>，不論 CLSID 是否有效。</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">您可以擷取的值<ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph>屬性來判斷這個方法所傳回的型別是否為 COM 物件。</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">您可以呼叫<ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the<ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">取得<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表<ph id="ph2">`__ComObject`</ph>藉由呼叫對應至 CLSID<ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph>方法來具現化 COM 物件。</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>See the example for an illustration.</source>
          <target state="translated">如需範例，請參閱。</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> overload ignores any exception that may occur when instantiating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object based on the <ph id="ph3">`clsid`</ph> argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph>多載會忽略任何會具現化時，可能會發生例外狀況<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件根據<ph id="ph3">`clsid`</ph>引數。</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Note that no exception is thrown if <ph id="ph1">`clsid`</ph> is not found in the registry.</source>
          <target state="translated">請注意，如果將會擲回任何例外狀況<ph id="ph1">`clsid`</ph>登錄中找不到。</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">下列範例會使用 Microsoft Word 的 CLSID<bpt id="p1">[</bpt>應用程式物件<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept>擷取代表 Microsoft Word 應用程式的 COM 類型。</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">它接著會執行個體化類型呼叫<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>方法，並將它關閉藉由呼叫<bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept>方法。</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">所有受管理的物件，包括為 COM 可見的 (也就是其<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph>屬性是<ph id="ph2">&lt;see langword="true" /&gt;</ph>) 由 guid<ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">雖然此方法會傳回<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>適用於.NET Framework 對應至 GUID 的物件，您不能使用該<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>物件以建立類型執行個體，藉由呼叫<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>方法，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">相反地，<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>物件傳遞至<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>方法必須代表 unmanaged 的 COM 物件。</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">要取得之類型的 CLSID。</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>，擲回任何會發生的例外狀況。</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> 則忽略任何會發生的例外狀況。</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">取得與指定的類別識別項 (CLSID) 關聯的類型，並指定如果載入類型時發生錯誤是否擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>，不論 CLSID 是否有效。</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">您可以擷取的值<ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph>屬性來判斷這個方法所傳回的型別是否為 COM 物件。</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">您可以呼叫<ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">取得<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表<ph id="ph2">`__ComObject`</ph>藉由呼叫對應至 CLSID<ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph>方法來具現化 COM 物件。</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>See the example for an illustration.</source>
          <target state="translated">如需範例，請參閱。</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">例外狀況，例如<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>指定時就會擲回<ph id="ph2">`true`</ph>如<ph id="ph3">`throwOnError`</ph>，但不是將取消登錄 Clsid 的失敗。</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">下列範例會使用 Microsoft Word 的 CLSID<bpt id="p1">[</bpt>應用程式物件<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept>擷取代表 Microsoft Word 應用程式的 COM 類型。</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">它接著會執行個體化類型呼叫<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>方法，並將它關閉藉由呼叫<bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept>方法。</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">如果在載入類型時發生錯誤，則會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">所有受管理的物件，包括為 COM 可見的 (也就是其<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph>屬性是<ph id="ph2">&lt;see langword="true" /&gt;</ph>) 由 guid<ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">雖然此方法會傳回<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>適用於.NET Framework 對應至 GUID 的物件，您不能使用該<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>物件以建立類型執行個體，藉由呼叫<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>方法，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">相反地，<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>物件傳遞至<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>方法必須代表 unmanaged 的 COM 物件。</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">要取得之類型的 CLSID。</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">要載入類型的伺服器。</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">如果伺服器名稱為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，此方法將會自動還原成本機電腦 (Local Machine)。</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server.</source>
          <target state="translated">從指定的伺服器中，取得與指定的類別識別項 (CLSID) 相關聯的類型。</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>，不論 CLSID 是否有效。</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">您可以擷取的值<ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph>屬性來判斷這個方法所傳回的型別是否為 COM 物件。</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">您可以呼叫<ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">取得<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表<ph id="ph2">`__ComObject`</ph>藉由呼叫對應至 CLSID<ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph>方法來具現化 COM 物件。</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">下列範例會使用 Microsoft Word 的 CLSID<bpt id="p1">[</bpt>應用程式物件<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept>擷取代表從名為 computer17.central.contoso.com 伺服器的 Microsoft Word 應用程式的 COM 類型。它接著會執行個體化類型呼叫<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>方法，並將它關閉藉由呼叫<bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept>方法。</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">所有受管理的物件，包括為 COM 可見的 (也就是其<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph>屬性是<ph id="ph2">&lt;see langword="true" /&gt;</ph>) 由 guid<ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">雖然此方法會傳回<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>適用於.NET Framework 對應至 GUID 的物件，您不能使用該<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>物件以建立類型執行個體，藉由呼叫<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>方法，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">相反地，<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>物件傳遞至<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>方法必須代表 unmanaged 的 COM 物件。</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">要取得之類型的 CLSID。</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">要載入類型的伺服器。</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">如果伺服器名稱為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，此方法將會自動還原成本機電腦 (Local Machine)。</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>，擲回任何會發生的例外狀況。</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> 則忽略任何會發生的例外狀況。</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">從指定的伺服器中，取得與指定的類別識別項 (CLSID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>，不論 CLSID 是否有效。</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法支援晚期繫結存取 unmanaged 的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">COM 類別的類別識別項被定義於登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">您可以擷取的值<ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph>屬性來判斷這個方法所傳回的型別是否為 COM 物件。</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">您可以呼叫<ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph>方法的晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">具現化 unmanaged 的 COM 物件的 CLSID 為兩個步驟：</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">取得<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表<ph id="ph2">`__ComObject`</ph>藉由呼叫對應至 CLSID<ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph>方法來具現化 COM 物件。</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">例外狀況，例如<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>指定時就會擲回<ph id="ph2">`true`</ph>如<ph id="ph3">`throwOnError`</ph>，但不是將取消登錄 Clsid 的失敗。</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">下列範例會使用 Microsoft Word 的 CLSID<bpt id="p1">[</bpt>應用程式物件<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept>擷取代表從名為 computer17.central.contoso.com 伺服器的 Microsoft Word 應用程式的 COM 類型。它接著會執行個體化類型呼叫<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>方法，並將它關閉藉由呼叫<bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept>方法。</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">如果在載入類型時發生錯誤，則會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">使用 COM 物件，不能搭配.NET Framework 物件時，這個方法僅供使用。</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">所有受管理的物件，包括為 COM 可見的 (也就是其<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph>屬性是<ph id="ph2">&lt;see langword="true" /&gt;</ph>) 由 guid<ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Although the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> method returns a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for a particular managed object, you can't use that <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">雖然<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>方法會傳回<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>對應於特定的受管理物件 GUID 的物件不能使用該<ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>物件以建立類型執行個體，藉由呼叫<ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>方法，如下列範例顯示。</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">相反地，<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>物件傳遞至<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>方法必須代表 unmanaged 的 COM 物件。</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The object that refers to the type.</source>
          <target state="translated">參考類型的物件。</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>Gets the type referenced by the specified type handle.</source>
          <target state="translated">取得指定的類型控制代碼所參考的類型。</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The type referenced by the specified <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> property of <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">由指定 <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph> 參考的類型，如果 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 的 <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> 屬性為 <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> 則為 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">控制代碼是有效的只有在所取得的應用程式定義域。</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object from a <ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph> provided by the <ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph>方法來取得<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件從<ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph>提供<ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified program identifier (ProgID).</source>
          <target state="translated">取得與指定的程式識別項 (ProgID) 相關聯的類型。</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">要取得之類型的 ProgID。</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得與指定的程式識別項 (ProgID) 相關聯的類型；如果在載入 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 時發生錯誤，則傳回 null。</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The type associated with the specified ProgID, if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> 在登錄中是有效項目，而且有類型與它相關聯，則為與指定的 ProgID 相關聯的類型，否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">這個方法會提供用於 COM 支援。</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">因為已取代的命名空間概念 Progid 不會使用 Microsoft.NET Framework 中。</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">要取得之類型的 ProgID。</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>，擲回任何會發生的例外狀況。</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> 則忽略任何會發生的例外狀況。</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">取得與指定的程式識別項 (ProgID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (ProgID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">這個方法會提供用於 COM 支援。</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</source>
          <target state="translated">下列範例會擷取藉由傳遞 ProgID，指定是否要擲回例外狀況，如果是無效的 ProgID 的類型。</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, along with any applicable exception message.</source>
          <target state="translated">此範例接著會顯示相關的 ProgID，以及任何適用的例外狀況的訊息，ClassID。</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The specified ProgID is not registered.</source>
          <target state="translated">指定的 ProgID 未註冊。</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The progID of the type to get.</source>
          <target state="translated">要取得之類型的 progID。</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">要載入類型的伺服器。</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">如果伺服器名稱為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，此方法將會自動還原成本機電腦 (Local Machine)。</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</source>
          <target state="translated">從指定的伺服器中，取得與指定的程式識別項 (progID) 相關聯的類型；如果在載入類型時發生錯誤，則傳回 null。</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">這個方法會提供用於 COM 支援。</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">下列範例會擷取藉由傳遞的 ProgID 和伺服器名稱的型別。</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">然後範例會顯示 ProgID 與 ClassID，或如果的 ProgID 或伺服器名稱無效，會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The progID of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">要取得之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的 progID。</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">要載入類型的伺服器。</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">如果伺服器名稱為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，此方法將會自動還原成本機電腦 (Local Machine)。</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>，擲回任何會發生的例外狀況。</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> 則忽略任何會發生的例外狀況。</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">從指定的伺服器中，取得與指定的程式識別項 (progID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">這個方法會提供用於 COM 支援。</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">因為已取代的命名空間概念的程式識別碼不會使用 Microsoft.NET Framework 中。</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">下列範例會擷取藉由傳遞的 ProgID 和伺服器名稱的型別。</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">此範例接著會顯示相關的 ProgID，指定是否要擲回例外狀況的 ProgID 或伺服器名稱不正確的 ClassID。</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The specified progID is not registered.</source>
          <target state="translated">未註冊指定的 progID。</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The object for which to get the type handle.</source>
          <target state="translated">要取得其類型控制代碼的物件。</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>Gets the handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of a specified object.</source>
          <target state="translated">取得指定物件的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的控制代碼。</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">指定 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 之 <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> 的控制代碼。</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">控制代碼是有效的只有在所取得的應用程式定義域。</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The following example defines the class <ph id="ph1">`MyClass1`</ph>, gets an instance of it, and retrieves the runtime handle of the object.</source>
          <target state="translated">下列範例會定義類別<ph id="ph1">`MyClass1`</ph>、 取得其執行個體，和擷取之物件的執行階段控制代碼。</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" uid="P:System.Type.GUID">
          <source>Gets the GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得與 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 相關聯的 GUID。</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">與 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 相關聯的 GUID。</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>A GUID is associated with a type using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> attribute.</source>
          <target state="translated">GUID 是與使用類型相關聯<ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The following example creates the class <ph id="ph1">`MyClass1`</ph> with a public method, creates a <ph id="ph2">`Type`</ph> object corresponding to <ph id="ph3">`MyClass1`</ph>, and gets the <ph id="ph4">&lt;xref:System.Guid&gt;</ph> structure using the <ph id="ph5">`GUID`</ph> property of the <ph id="ph6">`Type`</ph> class.</source>
          <target state="translated">下列範例會建立類別<ph id="ph1">`MyClass1`</ph>的公用方法，建立<ph id="ph2">`Type`</ph>物件對應至<ph id="ph3">`MyClass1`</ph>，並取得<ph id="ph4">&lt;xref:System.Guid&gt;</ph>結構使用<ph id="ph5">`GUID`</ph>屬性<ph id="ph6">`Type`</ph>類別。</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="P:System.Type.HasElementType">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">取得值，指出目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否內含或參考其他類型；也就是說，目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否為陣列、指標或以傳址方式傳遞。</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是陣列、指標或以傳址方式傳遞，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>For example, Type.GetType("Int32[]").HasElementType returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementType returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">例如，Type.GetType("Int32[]")。傳回 HasElementType <ph id="ph1">`true`</ph>，但 Type.GetType("Int32")。傳回 HasElementType <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>HasElementType also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">HasElementType 也會傳回<ph id="ph1">`true`</ph>如"Int32 *"和"Int32 （&amp; s) 」。</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>The following example returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph> depending on whether or not the object is an array, a reference type, or a pointer.</source>
          <target state="translated">下列範例會傳回<ph id="ph1">`true`</ph>或<ph id="ph2">`false`</ph>根據物件是否為陣列、 參考類型或指標。</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> property and determines whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">在衍生類別中覆寫時，實作 <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> 屬性並判斷目前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否內含或參考其他類型；也就是說，目前 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 是否為陣列、指標或以傳址方式傳遞。</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是陣列、指標或以傳址方式傳遞，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>For example, Type.GetType("Int32[]").HasElementTypeImpl returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementTypeImpl returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">例如，Type.GetType("Int32[]")。傳回 HasElementTypeImpl <ph id="ph1">`true`</ph>，但 Type.GetType("Int32")。傳回 HasElementTypeImpl <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>HasElementTypeImpl also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">HasElementTypeImpl 也會傳回<ph id="ph1">`true`</ph>如"Int32 *"和"Int32 （&amp; s) 」。</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The following example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">下列範例會定義類別<ph id="ph1">`MyTypeDelegator`</ph>，它會覆寫<ph id="ph2">`HasElementTypeImpl`</ph>方法。</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">主要的類別會檢查<ph id="ph1">`HasElementType`</ph>屬性，並顯示型別。</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Invokes a specific member of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">叫用目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的特定成員。</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">空字串 ("")，要叫用預設成員。</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">對 <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> 成員表示 DispID 的字串，例如 "[DispID=3]"。</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">該存取可以是其中一個 <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>，例如 <ph id="ph2">&lt;see langword="Public" /&gt;</ph>、<ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>、<ph id="ph4">&lt;see langword="Private" /&gt;</ph>、<ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetField" /&gt;</ph> 等等。</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">不需要指定查閱的類型。</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">如果省略查閱的類型，則會使用 <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">請注意，可能需要明確定義 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> 物件，才能順利以變數引數叫用方法多載。</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">要在其上叫用指定成員的物件。</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">包含引數的陣列，這些引數會傳遞給要叫用的成員。</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</source>
          <target state="translated">使用指定的繫結條件約束並符合指定的引數清單，來叫用指定的成員。</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">表示叫用的成員之傳回值的物件。</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">您無法使用<ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>叫用泛型方法。</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的成員：</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用成員。</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用成員 （也就是 private 和 protected 成員）。</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>来包含在階層中向上的靜態成員。</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的成員<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的成員。</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>引動過程旗標可以用來代表要與成員採取什麼動作：</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> 叫用建構函式。</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> 已忽略。</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">與其他引動過程旗標無效。</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> 叫用方法，但不是建構函式或類型初始設定式。</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetField`</ph>或<ph id="ph2">`SetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">如果<ph id="ph1">`InvokeMethod`</ph>單獨使用時，指定<ph id="ph2">`BindingFlags.Public`</ph>， <ph id="ph3">`BindingFlags.Instance`</ph>，和<ph id="ph4">`BindingFlags.Static`</ph>會自動加入。</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> 若要取得欄位的值。</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetField`</ph>。</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> 若要設定欄位的值。</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`GetField`</ph>。</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> 若要取得的屬性。</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> 若要設定屬性。</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`GetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">如果兩個下列條件成立，就會叫用方法：</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">方法宣告中的參數數目等於引數在數目<ph id="ph1">`args`</ph>陣列 (除非在成員上定義預設引數和<ph id="ph2">`BindingFlags.OptionalParamBinding`</ph>指定)。</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">每個引數的類型可以轉換型別參數的繫結器。</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">繫結器將會尋找所有相符的方法。</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">這些方法找到要求的繫結的類型為基礎 (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>值<ph id="ph2">`InvokeMethod`</ph>，<ph id="ph3">`GetProperty`</ph>等等)。</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">選取方法之後，它會叫用。</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">協助工具會在該點檢查。</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph>方法<ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph>類別會負責選取方法被叫用。</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">預設繫結器選取最適合的相符項目。</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和叫用透過<ph id="ph1">&lt;xref:System.Reflection&gt;</ph>每當程式碼受到完全信任。</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">您可以使用<ph id="ph1">`Type.InvokeMember`</ph>將欄位設定為特定值，藉由指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是<ph id="ph1">`String`</ph>，您可以使用程式碼，例如：</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">如果 F <ph id="ph1">`String[]`</ph>，您可以使用程式碼，例如：</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">這將會初始化欄位 F 此新陣列。</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">您也可以使用<ph id="ph1">`Type.InvokeMember`</ph>設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">這會變更陣列 F 保留字串"b"中的字串"z"。</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">當您叫用<ph id="ph1">`IDispatch`</ph>成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">叫用成員的 DispID 的速度比依名稱查閱的成員。</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用成員，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following example uses <ph id="ph1">`InvokeMember`</ph> to access members of a type.</source>
          <target state="translated">下列範例會使用<ph id="ph1">`InvokeMember`</ph>存取類型的成員。</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph>不包含 <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>，且 <ph id="ph3">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 屬性。</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 不包含下列其中一個繫結旗標：<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> 或 <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含與 <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> 或 <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> 合併的 <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 同時包含 <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 同時包含 <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含與 <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph> 合併的 <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含 <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> 且 <ph id="ph3">&lt;paramref name="args" /&gt;</ph> 具有一個以上的項目。</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>、<ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>、<ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>、<ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">其中一個具名參數陣列包含的字串是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">指定的成員是類別初始設定式。</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">找不到欄位或屬性。</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">找不到符合 <ph id="ph1">&lt;paramref name="args" /&gt;</ph> 中之引數的方法。</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件代表包含開啟類型參數的類型，亦即，<ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 傳回 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">無法在 <ph id="ph1">&lt;paramref name="target" /&gt;</ph> 上叫用指定的成員。</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">有一個以上的方法符合繫結準則。</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The .NET Compact Framework does not currently support this method.</source>
          <target state="translated">.NET Compact Framework 目前不支援這個方法。</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所表示的方法有一或多個未指定的泛型類型參數。</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，方法的 <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> 屬性傳回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">用於存取非公用成員，不論其授權集。</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>to call unmanaged code.</source>
          <target state="translated">呼叫 unmanaged 程式碼。</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">空字串 ("")，要叫用預設成員。</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">對 <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> 成員表示 DispID 的字串，例如 "[DispID=3]"。</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">該存取可以是其中一個 <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>，例如 <ph id="ph2">&lt;see langword="Public" /&gt;</ph>、<ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>、<ph id="ph4">&lt;see langword="Private" /&gt;</ph>、<ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetField" /&gt;</ph> 等等。</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">不需要指定查閱的類型。</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">如果省略查閱的類型，則會使用 <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用 <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">請注意，可能需要明確定義 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> 物件，才能順利以變數引數叫用方法多載。</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">要在其上叫用指定成員的物件。</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">包含引數的陣列，這些引數會傳遞給要叫用的成員。</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">表示要使用之全球化地區設定的物件，它可能是地區設定特性轉換所需要的，例如將數值 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 轉換成 <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (Visual Basic 中的 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用目前執行緒的 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</source>
          <target state="translated">使用指定的繫結條件約束並符合指定的引數清單和文化特性 (Culture) 來叫用指定的成員。</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">表示叫用的成員之傳回值的物件。</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph2">`culture`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`culture`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>(<ph id="ph2">`culture`</ph>參數)，您可以使用抽象<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph4">`culture`</ph>。</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">您無法使用<ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>叫用泛型方法。</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的成員：</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用成員。</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>来包含在階層中向上的靜態成員。</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的成員<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的成員。</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>引動過程旗標可以用來代表要與成員採取什麼動作：</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> 叫用建構函式。</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> 已忽略。</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">與其他引動過程旗標無效。</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> 叫用方法，但不是建構函式或類型初始設定式。</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetField`</ph>或<ph id="ph2">`SetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">如果<ph id="ph1">`InvokeMethod`</ph>單獨使用時，指定<ph id="ph2">`BindingFlags.Public`</ph>， <ph id="ph3">`BindingFlags.Instance`</ph>，和<ph id="ph4">`BindingFlags.Static`</ph>會自動加入。</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> 若要取得欄位的值。</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetField`</ph>。</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> 若要設定欄位的值。</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`GetField`</ph>。</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> 若要取得的屬性。</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> 若要設定屬性。</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`GetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">如果兩個下列條件成立，就會叫用方法：</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">方法宣告中的參數數目等於引數在數目<ph id="ph1">`args`</ph>陣列 (除非在成員上定義預設引數和<ph id="ph2">`BindingFlags.OptionalParamBinding`</ph>指定)。</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">每個引數的類型可以轉換型別參數的繫結器。</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">繫結器將會尋找所有相符的方法。</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">這些方法找到要求的繫結的類型為基礎 (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>值<ph id="ph2">`InvokeMethod`</ph>，<ph id="ph3">`GetProperty`</ph>等等)。</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">選取方法之後，它會叫用。</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">協助工具會在該點檢查。</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph>方法<ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph>類別會負責選取方法被叫用。</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">預設繫結器選取最適合的相符項目。</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</source>
          <target state="translated">完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和每當程式碼受到完全信任時，透過反映來叫用。</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">您可以使用<ph id="ph1">`Type.InvokeMember`</ph>將欄位設定為特定值，藉由指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph> you can use code such as:</source>
          <target state="translated">例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是<ph id="ph1">`String`</ph>您可以使用程式碼，例如：</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">如果 F <ph id="ph1">`String[]`</ph>，您可以使用程式碼，例如：</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">這將會初始化欄位 F 此新陣列。</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">您也可以使用<ph id="ph1">`Type.InvokeMember`</ph>設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">這會變更陣列 F 保留字串"b"中的字串"z"。</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">當您叫用<ph id="ph1">`IDispatch`</ph>成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">叫用成員的 DispID 的速度比依名稱查閱的成員。</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用成員，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph>不包含 <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>，且 <ph id="ph3">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 屬性。</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 不包含下列其中一個繫結旗標：<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> 或 <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含與 <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> 或 <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> 合併的 <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 同時包含 <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 同時包含 <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含與 <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph> 合併的 <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含 <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> 且 <ph id="ph3">&lt;paramref name="args" /&gt;</ph> 具有一個以上的項目。</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>、<ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>、<ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>、<ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">其中一個具名參數陣列包含的字串是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member is a class initializer.</source>
          <target state="translated">指定的成員是類別初始設定式。</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The field or property cannot be found.</source>
          <target state="translated">找不到欄位或屬性。</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">找不到符合 <ph id="ph1">&lt;paramref name="args" /&gt;</ph> 中之引數的方法。</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件代表包含開啟類型參數的類型，亦即，<ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 傳回 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">無法在 <ph id="ph1">&lt;paramref name="target" /&gt;</ph> 上叫用指定的成員。</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">有一個以上符合繫結準則的方法。</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所表示的方法有一或多個未指定的泛型類型參數。</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，方法的 <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> 屬性傳回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">用於存取非公用成員，不論其授權集。</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>to call unmanaged code.</source>
          <target state="translated">呼叫 unmanaged 程式碼。</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">空字串 ("")，要叫用預設成員。</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">對 <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> 成員表示 DispID 的字串，例如 "[DispID=3]"。</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">位元遮罩，由一或多個 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 組成，而這些旗標會指定執行搜尋的方式。</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">該存取可以是其中一個 <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>，例如 <ph id="ph2">&lt;see langword="Public" /&gt;</ph>、<ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>、<ph id="ph4">&lt;see langword="Private" /&gt;</ph>、<ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetField" /&gt;</ph> 等等。</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">不需要指定查閱的類型。</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">如果省略查閱的類型，則會使用 <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (Nothing in Visual Basic), to use the <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (在 Visual Basic 中為 Nothing)，可使用 <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">請注意，可能需要明確定義 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> 物件，才能順利以變數引數叫用方法多載。</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">要在其上叫用指定成員的物件。</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">包含引數的陣列，這些引數會傳遞給要叫用的成員。</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> 物件的陣列，表示在 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 陣列中與對應元素產生關聯的屬性。</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter's associated attributes are stored in the member's signature.</source>
          <target state="translated">參數的關聯屬性儲存在成員的簽章中。</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder processes this parameter only when calling a COM component.</source>
          <target state="translated">預設繫結器只會在呼叫 COM 元件時處理這個參數。</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> 物件，代表要使用的全球化地區設定，進行特定地區設定轉換時可能需要這個物件，例如將數值的 String 轉換成 Double。</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">Null 參考 (Visual Basic 中的 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)，可使用目前執行緒的 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the names of the parameters to which the values in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array are passed.</source>
          <target state="translated">陣列，包含 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 陣列中的值所要傳遞之目標參數的名稱。</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</source>
          <target state="translated">在衍生類別中覆寫時，使用指定的繫結條件約束並符合指定的引數清單、修飾詞和文化特性，來叫用指定的成員。</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">表示叫用的成員之傳回值的物件。</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> 呼叫建構函式或方法成員、 取得或設定之屬性成員，取得或設定資料欄位成員，或取得或設定陣列成員的項目。</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">您無法使用<ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>叫用泛型方法。</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">當您叫用<ph id="ph1">`IDispatch`</ph>成員，您可以指定 DispID，而不是成員名稱使用的字串格式"[DispID = # #]"。</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">例如，如果 MyComMethod 的 DispID 為 3，您可以指定字串"[DispID = 3]"而不是"MyComMethod"。</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">叫用成員的 DispID 的速度比依名稱查閱的成員。</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">在複雜的彙總的情況下，DispID 有時是唯一的方式來叫用所需的成員。</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph3">`modifiers`</ph> and <ph id="ph4">`culture`</ph> parameters), you can use the abstract <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph6">`modifiers`</ph> and <ph id="ph7">`culture`</ph>.</source>
          <target state="translated">雖然預設繫結器不會處理<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>或<ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph>(<ph id="ph3">`modifiers`</ph>和<ph id="ph4">`culture`</ph>參數)，您可以使用抽象<ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>類別來撰寫並處理的自訂繫結器<ph id="ph6">`modifiers`</ph>和<ph id="ph7">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <ph id="ph1">`namedParameters`</ph> array gets the value in the corresponding element in the <ph id="ph2">`args`</ph> array.</source>
          <target state="translated">每個 <ph id="ph1">`namedParameters`</ph> 中的參數都取得 <ph id="ph2">`args`</ph> 陣列中對應元素的值。</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <ph id="ph1">`args`</ph> is greater than the length of <ph id="ph2">`namedParameters`</ph>, the remaining argument values are passed in order.</source>
          <target state="translated">如果 <ph id="ph1">`args`</ph> 的長度大於 <ph id="ph2">`namedParameters`</ph> 的長度，剩餘的引數值會依順序傳遞。</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`namedParameters`</ph> array can be used to change the order of arguments in an input array.</source>
          <target state="translated"><ph id="ph1">`namedParameters`</ph>陣列可以用來變更輸入陣列中的引數的順序。</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, given the method <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> in Visual Basic) and the input array <ph id="ph3">`{ 42, "x" }`</ph>, the input array can be passed unchanged to <ph id="ph4">`args`</ph> if the array <ph id="ph5">`{ "b", "a" }`</ph> is supplied for <ph id="ph6">`namedParameters`</ph>.</source>
          <target state="translated">例如，給定方法<ph id="ph1">`M(string a, int b)`</ph>(<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph>在 Visual Basic 中) 並輸入的陣列<ph id="ph3">`{ 42, "x" }`</ph>，輸入的陣列可以傳遞至不變<ph id="ph4">`args`</ph>如果陣列<ph id="ph5">`{ "b", "a" }`</ph>提供給<ph id="ph6">`namedParameters`</ph>。</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>篩選旗標可以用來定義要包含在搜尋中的成員：</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>来包含在搜尋中的公用成員。</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>来包含在階層中向上的靜態成員。</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾詞旗標可以用來變更搜尋的運作方式：</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 若要忽略大小寫的<ph id="ph2">`name`</ph>。</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 若要搜尋才上宣告的成員<ph id="ph2">&lt;xref:System.Type&gt;</ph>，不只是繼承的成員。</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>引動過程旗標可以用來代表要與成員採取什麼動作：</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> 叫用建構函式。</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> 已忽略。</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">與其他引動過程旗標無效。</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> 叫用方法，但不是建構函式或類型初始設定式。</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetField`</ph>或<ph id="ph2">`SetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">如果<ph id="ph1">`InvokeMethod`</ph>單獨使用時，指定<ph id="ph2">`BindingFlags.Public`</ph>， <ph id="ph3">`BindingFlags.Instance`</ph>，和<ph id="ph4">`BindingFlags.Static`</ph>會自動加入。</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> 若要取得欄位的值。</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetField`</ph>。</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> 若要設定欄位的值。</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`GetField`</ph>。</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> 若要取得的屬性。</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`SetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> 若要設定屬性。</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">不適用於<ph id="ph1">`GetProperty`</ph>。</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">如果兩個下列條件成立，就會叫用方法：</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">方法宣告中的參數數目等於引數在數目<ph id="ph1">`args`</ph>陣列 (除非在成員上定義預設引數和<ph id="ph2">`BindingFlags.OptionalParamBinding`</ph>指定)。</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">每個引數的類型可以轉換型別參數的繫結器。</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">繫結器將會尋找所有相符的方法。</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">這些方法找到要求的繫結的類型為基礎 (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>值<ph id="ph2">`InvokeMethod`</ph>，<ph id="ph3">`GetProperty`</ph>等等)。</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">選取方法之後，它會叫用。</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">協助工具會在該點檢查。</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph>方法<ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph>類別會負責選取方法被叫用。</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">預設繫結器選取最適合的相符項目。</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> can be used to invoke methods with parameters that have default values.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> 可用來叫用其參數具有預設值的方法。</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To bind to these methods, Reflection requires <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph> to be specified.</source>
          <target state="translated">若要繫結至這些方法，需要反映<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph>指定。</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For a parameter that has a default value, you can either supply a different value, or supply <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph> to use the default value.</source>
          <target state="translated">預設值是參數，您可以提供不同的值，或提供<ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph>使用預設值。</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, consider a method such as MyMethod(int x, float y = 2.0).</source>
          <target state="translated">例如，請考慮方法，例如 MyMethod (x，float y int = 2.0)。</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <ph id="ph1">`Missing.Value`</ph> for the second argument.</source>
          <target state="translated">要叫用這個方法，只有第一個引數為 MyMethod(4)，需傳遞其中一個以上的繫結旗標，並將兩個引數，也就是 4 的第一個引數傳遞和<ph id="ph1">`Missing.Value`</ph>第二個引數。</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Unless you use <ph id="ph1">`Missing.Value`</ph>, you may not omit optional parameters with the <ph id="ph2">`Invoke`</ph> method.</source>
          <target state="translated">除非您使用<ph id="ph1">`Missing.Value`</ph>，您不可以省略選擇性參數與<ph id="ph2">`Invoke`</ph>方法。</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If you must do so, use <ph id="ph1">`InvokeMember`</ph> instead.</source>
          <target state="translated">如果您必須這麼做，使用<ph id="ph1">`InvokeMember`</ph>改為。</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">完全信任的程式碼; 會忽略存取限制也就是私用建構函式、 方法、 欄位和屬性可以存取和叫用透過<ph id="ph1">&lt;xref:System.Reflection&gt;</ph>每當程式碼受到完全信任。</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">您可以使用<ph id="ph1">`Type.InvokeMember`</ph>將欄位設定為特定值，藉由指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">例如，如果您想要設定名為 F C 和 F 類別上的公用執行個體欄位是<ph id="ph1">`String`</ph>，您可以使用程式碼，例如：</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">如果 F <ph id="ph1">`String[]`</ph>，您可以使用程式碼，例如：</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">這將會初始化欄位 F 此新陣列。</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">您也可以使用<ph id="ph1">`Type.InvokeMember`</ph>設定陣列中的位置，藉由使用像是下列程式碼提供的索引值，然後按一下 下一個值：</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">這會變更陣列 F 保留字串"b"中的字串"z"。</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用成員，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph>不包含 <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>，且 <ph id="ph3">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> 的長度不同。</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 屬性。</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 不包含下列其中一個繫結旗標：<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> 或 <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含與 <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> 或 <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> 合併的 <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 同時包含 <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 同時包含 <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> 和 <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含與 <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph> 合併的 <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> 包含 <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> 且 <ph id="ph3">&lt;paramref name="args" /&gt;</ph> 具有一個以上的項目。</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The named parameter array is larger than the argument array.</source>
          <target state="translated">具名參數陣列大於引數陣列。</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>、<ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>、<ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>、<ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">其中一個具名參數陣列包含的字串是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">指定的成員是類別初始設定式。</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">找不到欄位或屬性。</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">找不到符合 <ph id="ph1">&lt;paramref name="args" /&gt;</ph> 中之引數的方法。</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No member can be found that has the argument names supplied in <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph>.</source>
          <target state="translated">找不到具有 <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph> 中所提供引數名稱的成員。</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件代表包含開啟類型參數的類型，亦即，<ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 傳回 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">無法在 <ph id="ph1">&lt;paramref name="target" /&gt;</ph> 上叫用指定的成員。</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">有一個以上符合繫結準則的方法。</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所表示的方法有一或多個未指定的泛型類型參數。</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，方法的 <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> 屬性傳回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">用於存取非公用成員，不論其授權集。</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>to call unmanaged code.</source>
          <target state="translated">呼叫 unmanaged 程式碼。</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="P:System.Type.IsAbstract">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is abstract and must be overridden.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為抽象並且必須被覆寫。</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is abstract; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是抽象，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> in the following cases:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>在下列情況：</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</source>
          <target state="translated">目前的類型是抽象的。也就是說，它無法具現化，但只可做為衍生類別的基底類別。</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>In C#, abstract classes are marked with the <bpt id="p1">[</bpt>abstract<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> keyword; in Visual Basic, they are marked with the <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> keyword.</source>
          <target state="translated">在 C# 中，抽象類別會以標記<bpt id="p1">[</bpt>抽象<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept>關鍵字; 在 Visual Basic 中，它們會標示<bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept>關鍵字。</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is an interface.</source>
          <target state="translated">目前的類型是介面。</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The following example creates an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent the following types:contains type returns <ph id="ph2">`true`</ph> if the specified object is <ph id="ph3">`abstract`</ph>; otherwise, it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">下列範例會建立的陣列<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表下列類型的物件： 包含類型傳回<ph id="ph2">`true`</ph>的指定的物件是否<ph id="ph3">`abstract`</ph>; 否則它會傳回<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`AbstractClass`</ph>, an abstract class (a class marked as <ph id="ph2">`abstract`</ph> in C# and <ph id="ph3">`MustInherit`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">`AbstractClass`</ph>抽象類別 (類別標示為<ph id="ph2">`abstract`</ph>在 C# 和<ph id="ph3">`MustInherit`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`DerivedClass`</ph>, a class that inherits from <ph id="ph2">`AbstractClass`</ph>.</source>
          <target state="translated"><ph id="ph1">`DerivedClass`</ph>繼承自一個類別<ph id="ph2">`AbstractClass`</ph>。</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`SingleClass`</ph>, a non-inheritable class.</source>
          <target state="translated"><ph id="ph1">`SingleClass`</ph>不可繼承的類別。</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>It is defined as <ph id="ph1">`sealed`</ph> in C# and <ph id="ph2">`NotInheritable`</ph> in Visual Basic.</source>
          <target state="translated">它定義為<ph id="ph1">`sealed`</ph>在 C# 和<ph id="ph2">`NotInheritable`</ph>在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ITypeInfo`</ph>, an interface.</source>
          <target state="translated"><ph id="ph1">`ITypeInfo`</ph>介面。</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ImplementingClass`</ph>, a class that implements the <ph id="ph2">`ITypeInfo`</ph> interface.</source>
          <target state="translated"><ph id="ph1">`ImplementingClass`</ph>實作的類別<ph id="ph2">`ITypeInfo`</ph>介面。</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The method returns <ph id="ph1">`true`</ph> only for <ph id="ph2">`AbstractClass`</ph>, the abstract class, and <ph id="ph3">`ITypeInfo`</ph>, the interface.</source>
          <target state="translated">方法會傳回<ph id="ph1">`true`</ph>僅適用於<ph id="ph2">`AbstractClass`</ph>，抽象類別，和<ph id="ph3">`ITypeInfo`</ph>，介面。</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="P:System.Type.IsAnsiClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得值，指出是否為 <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> 選取字串格式屬性 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果為 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 選取字串格式屬性 <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph>，則為 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph>選取字串格式屬性。</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">字串格式屬性定義如何解譯字串增強互通性。</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型型別，這個屬性與從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The following example gets the field information and checks for the <ph id="ph1">`AnsiClass`</ph> attribute.</source>
          <target state="translated">下列範例會取得欄位資訊，並檢查<ph id="ph1">`AnsiClass`</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" uid="P:System.Type.IsArray">
          <source>Gets a value that indicates whether the type is an array.</source>
          <target state="translated">取得值，以表示類型是否為陣列。</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is an array; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果目前的類型是陣列則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the <ph id="ph3">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph>屬性會傳回<ph id="ph2">`false`</ph>如<ph id="ph3">&lt;xref:System.Array&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>It also returns <ph id="ph1">`false`</ph> if the current instance is a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a collection type or an interface designed to work with collections, such as <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">它也會傳回<ph id="ph1">`false`</ph>如果目前的執行個體<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，表示集合型別或設計來搭配集合，例如介面<ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph>或<ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>To check for an array, use code such as:</source>
          <target state="translated">若要檢查的陣列，使用程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果目前的型別代表泛型類型或類型參數的泛型類型或泛型方法定義中，這個屬性永遠傳回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property.</source>
          <target state="translated">下列範例示範如何使用<ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array.</source>
          <target state="translated">在衍生類別中覆寫時，實作 <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> 屬性並判斷 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否為陣列。</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是陣列，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class must return <ph id="ph2">`false`</ph> because it is an object, not an array.</source>
          <target state="translated">執行個體<ph id="ph1">&lt;xref:System.Array&gt;</ph>類別必須傳回<ph id="ph2">`false`</ph>因為它是一個物件，而非陣列。</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>The following example overrides the <ph id="ph1">`IsArrayImpl`</ph> method in the <ph id="ph2">`MyTypeDelegator`</ph> class, checks if a variable is an array, and displays the result.</source>
          <target state="translated">下列範例會覆寫<ph id="ph1">`IsArrayImpl`</ph>方法中的<ph id="ph2">`MyTypeDelegator`</ph>類別，如果變數是陣列，並顯示結果的檢查。</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">要與目前的類型比較的類型。</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Determines whether an instance of a specified type can be assigned to an instance of the current type.</source>
          <target state="translated">判斷指定類型的執行個體是否可以指派給目前類型的執行個體。</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> (下列任何條件成立時)：</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> and the current instance represent the same type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> 和目前執行個體代表相同類型。</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived either directly or indirectly from the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> 直接或間接衍生自目前執行個體。</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived directly from the current instance if it inherits from the current instance; <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> 會直接衍生自目前的執行個體 (如果它繼承自目前的執行個體)，<ph id="ph2">&lt;paramref name="c" /&gt;</ph> 會間接衍生自目前的執行個體 (如果它繼承自目前的執行個體所繼承的一或多個一連串類別)。</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The current instance is an interface that <ph id="ph1">&lt;paramref name="c" /&gt;</ph> implements.</source>
          <target state="translated">目前執行個體是 <ph id="ph1">&lt;paramref name="c" /&gt;</ph> 實作的介面。</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is a generic type parameter, and the current instance represents one of the constraints of <ph id="ph2">&lt;paramref name="c" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> 是泛型類型參數，而且目前執行個體代表 <ph id="ph2">&lt;paramref name="c" /&gt;</ph> 的其中一個條件約束。</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>In the following example, the current instance is a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> class.</source>
          <target state="translated">在下列範例中，目前的執行個體是 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，代表 <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 類別。</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> is a generic type whose generic type parameter must be of type    <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> 泛型型別，其泛型型別參數必須是型別 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Passing its generic type parameter to the <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> indicates that  an instance of the generic type parameter can be assigned to an <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">傳遞其泛型型別參數至 <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> 表示泛型型別參數的執行個體可以指派給 <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> represents a value type, and the current instance represents <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (<bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> 代表實值類型，而且目前執行個體代表 <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (在 Visual Basic 中為 <bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept>)。</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are true, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果以上條件都不成立，或者 <ph id="ph2">&lt;paramref name="c" /&gt;</ph> 為 <ph id="ph1">&lt;see langword="false" /&gt;</ph>，則為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method can be used to determine whether an instance of <ph id="ph2">`c`</ph> can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>方法可以用來判斷執行個體是否<ph id="ph2">`c`</ph>可以指派至目前型別的執行個體，方法當處理的物件在設計階段未知的型別便最有用並允許條件式指派，如下列範例會顯示。</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method thus ensures that a line of code like the following will execute at runtime without throwing an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> exception or a similar exception:</source>
          <target state="translated">這個方法因此可確保一行程式碼，如下列會在執行階段執行而不擲回<ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph>或類似的例外狀況的例外狀況：</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>A generic type definition is not assignable from a closed constructed type.</source>
          <target state="translated">無法從封閉式的建構類型可指派的泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>That is, you cannot assign the closed constructed type <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) to a variable of type <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</source>
          <target state="translated">也就是說，您無法將指派封閉式的建構的類型<ph id="ph1">`MyGenericList&lt;int&gt;`</ph>(<ph id="ph2">`MyGenericList(Of Integer)`</ph>在 Visual Basic 中) 類型的變數至<ph id="ph3">`MyGenericList&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>If the <ph id="ph1">`c`</ph> parameter is of type <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, the result is based on the type that is to be built.</source>
          <target state="translated">如果<ph id="ph1">`c`</ph>參數的類型是<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>，結果根據用來建立的類型。</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following code example demonstrates this using a built type named <ph id="ph1">`B`</ph>.</source>
          <target state="translated">下列程式碼範例示範此使用名為內建型別<ph id="ph1">`B`</ph>。</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following example demonstrates the <ph id="ph1">`IsAssignableFrom`</ph> method using defined classes, integer arrays, and generics.</source>
          <target state="translated">下列範例會示範<ph id="ph1">`IsAssignableFrom`</ph>類別、 整數陣列，與泛型方法使用定義。</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得值，指出是否為 <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> 選取字串格式屬性 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果為 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 選取字串格式屬性 <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph>，則為 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph>選取字串格式屬性。</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">字串格式屬性定義如何解譯字串增強互通性。</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</source>
          <target state="translated">取得表示目前類型的欄位是否已由 Common Language Runtime 自動配置版面的值。</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果目前類型的 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 屬性包含 <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> 則為 <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">為了方便起見，已提供這個屬性。</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">或者，您可以使用<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph>列舉值，以選取型別配置屬性，然後測試是否<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>設定。</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>，<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>列舉值會指出類型的欄位配置記憶體中的方式。</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">動態類型，您可以指定<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>當您建立的類型。</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</source>
          <target state="translated">在程式碼，套用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>屬性附帶<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph>列舉值的型別，可讓執行階段判斷適當的方式來配置的類別。</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">您無法使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>方法，以判斷是否<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>已套用至類型。</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由 <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The following example creates an instance of the type and displays the <ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph> property.</source>
          <target state="translated">下列範例會建立類型的執行個體，並顯示<ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" uid="P:System.Type.IsByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否以傳址方式傳遞。</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是以傳址方式傳遞，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>To get to the actual type, dereference the type that was passed by reference, and then call <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> on that type.</source>
          <target state="translated">若要取得實際的型別，由參考所傳遞的型別取值 （dereference），然後呼叫<ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph>該型別上。</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsByRef`</ph> property to check whether a specified type is passed by reference.</source>
          <target state="translated">下列範例會示範使用<ph id="ph1">`IsByRef`</ph>屬性檢查指定的型別傳址方式傳遞。</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">此範例會定義類別<ph id="ph1">`MyTypeDelegator`</ph>，它會覆寫<ph id="ph2">`HasElementTypeImpl`</ph>方法。</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">主要的類別會檢查<ph id="ph1">`HasElementType`</ph>屬性，並顯示型別。</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">在衍生類別中覆寫時，實作 <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> 屬性並判斷 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否以傳址方式傳遞。</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是以傳址方式傳遞，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="P:System.Type.IsClass">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a class or a delegate; that is, not a value type or interface.</source>
          <target state="translated">取得值，表示 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是類別或委派，也就是非實值類型或介面。</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a class; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是類別，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for classes as well as delegates.</source>
          <target state="translated">這個屬性會傳回<ph id="ph1">`true`</ph>類別，以及委派。</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>It returns <ph id="ph1">`false`</ph> for value types (for structures and enumerations) even if they are boxed.</source>
          <target state="translated">它會傳回<ph id="ph1">`false`</ph>實值型別 （適用於結構和列舉型別） 即使 boxing 處理。</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`true`</ph>.If the current <ph id="ph3">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns <ph id="ph4">`true`</ph> if the generic type definition is a class definition; that is, it does not define an interface or a value type.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`true`</ph>。如果目前<ph id="ph3">&lt;xref:System.Type&gt;</ph>代表建構的泛型型別，這個屬性會傳回<ph id="ph4">`true`</ph>如果泛型類型定義為類別定義; 也就是說，它不會定義介面或實值類型。</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for <ph id="ph2">`Type`</ph> instances that represent the <ph id="ph3">&lt;xref:System.Enum&gt;</ph> and <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> classes.</source>
          <target state="translated">這個屬性會傳回<ph id="ph1">`true`</ph>如<ph id="ph2">`Type`</ph>執行個體表示<ph id="ph3">&lt;xref:System.Enum&gt;</ph>和<ph id="ph4">&lt;xref:System.ValueType&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</source>
          <target state="translated">這兩個類別列舉的基底類型和實值類型，分別是，但不是列舉型別或值型別本身。</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> properties.</source>
          <target state="translated">如需詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph>列舉值區分型別宣告為類別或介面。不過，類別和實值類型會標示<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If you retrieve the value of a type's Attributes property and use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> value to determine whether a type is a class instead of a value type, you must also call the <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> property.</source>
          <target state="translated">如果您在擷取值的型別屬性屬性然後使用<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph>值，以判斷是否為類別，而不是實值類型的類型，您也必須呼叫<ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The example for the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration contains additional information as well as anexample.</source>
          <target state="translated">如範例<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph>列舉包含的其他資訊，以及 anexample。</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The following example creates an instance of a type and indicates whether the type is a class.</source>
          <target state="translated">下列範例會建立類型的執行個體，並指出類型是否為類別。</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" uid="P:System.Type.IsCOMObject">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為 COM 物件。</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是 COM 物件，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">這個方法會傳回<ph id="ph1">`false`</ph>的 COM 介面，因為它們不是物件。</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">可以由 Microsoft.NET Framework 物件實作 COM 介面。</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>You can also load a COM class and get a <ph id="ph1">`Type`</ph> object for that COM class by using the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
          <target state="translated">您也可以載入 COM 類別，並取得<ph id="ph1">`Type`</ph>使用該 COM 類別的物件<bpt id="p1">[</bpt>Tlbimp.exe （類型程式庫匯入工具）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>工具。</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">在衍生類別中覆寫時，實作 <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> 屬性並判斷 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否為 COM 物件。</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是 COM 物件，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">這個方法會傳回<ph id="ph1">`false`</ph>的 COM 介面，因為它們不是物件。</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">可以由 Microsoft.NET Framework 物件實作 COM 介面。</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">取得值，指出這個物件是否表示建構的泛型類型。</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>You can create instances of a constructed generic type.</source>
          <target state="translated">您可以建立已建構之泛型類型的執行個體。</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果這個物件代表建構的泛型類型，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>A constructed generic type has had explicit types supplied for all of its generic type parameters.</source>
          <target state="translated">建構的泛型類型已明確提供給所有泛型型別參數的類型。</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>It is also referred to as a closed generic type.</source>
          <target state="translated">它也稱為封閉泛型類型。</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>When this property is <ph id="ph1">`true`</ph>, you can create instances of the current type; when it is <ph id="ph2">`false`</ph>, you can't.</source>
          <target state="translated">當這個屬性是<ph id="ph1">`true`</ph>，您可以建立執行個體目前的類型; 當它是<ph id="ph2">`false`</ph>，您不能。</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" uid="P:System.Type.IsContextful">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated">取得值，指出在內容中是否可以裝載 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果在內容中可以裝載 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</source>
          <target state="translated">內容會攔截呼叫類別的成員，並強制執行原則會套用至類別，例如同步處理。</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>For more detailed information on remoting contexts, see <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</source>
          <target state="translated">如需詳細遠端內容的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">下列範例會示範<ph id="ph1">`IsContextful`</ph>， <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph>屬性<ph id="ph4">&lt;xref:System.Type&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated">實作 <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> 屬性並判斷在內容中是否可以裝載 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果在內容中可以裝載 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</source>
          <target state="translated">內容會攔截呼叫類別的成員，並強制執行原則會套用至類別，例如同步處理。</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsContextfulImpl`</ph> method.</source>
          <target state="translated">下列範例會示範使用<ph id="ph1">`IsContextfulImpl`</ph>方法。</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" uid="P:System.Type.IsEnum">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration.</source>
          <target state="translated">取得值，指出目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否表示列舉類型。</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果目前 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 代表列舉，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property returns <ph id="ph1">`true`</ph> for an enumeration, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">這個屬性會傳回<ph id="ph1">`true`</ph>列舉型別，但不是適合用於<ph id="ph2">&lt;xref:System.Enum&gt;</ph>型別本身。</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>The following example demonstrates how to use the <ph id="ph1">`IsEnum`</ph> property.</source>
          <target state="translated">下列範例示範如何使用<ph id="ph1">`IsEnum`</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The value to be tested.</source>
          <target state="translated">要測試的值。</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>Returns a value that indicates whether the specified value exists in the current enumeration type.</source>
          <target state="translated">傳回值，這個值表示指定的值是否存在於目前的列舉類型中。</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is a member of the current enumeration type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果指定的值是目前列舉型別的成員，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">目前的類型不是列舉。</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that cannot be the underlying type of an enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 屬於的型別不得為列舉的基礎型別。</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The COM type that is tested for equivalence with the current type.</source>
          <target state="translated">進行測試以確定是否和目前類型等價的 COM 類型。</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Determines whether two COM types have the same identity and are eligible for type equivalence.</source>
          <target state="translated">判斷兩個 COM 類型是否具有相同的識別以及是否適合類型等價。</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the COM types are equivalent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 COM 類型相等，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</source>
          <target state="translated">如果一個類型位於已載入來執行的組件中，而另一個類型位於已載入至純反映性的內容的組件中，這個方法也會傳回 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</source>
          <target state="translated">開頭為<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，通用語言執行平台支援的 managed 組件，而不需要 managed 組件，以取得 interop 從 COM 類型的型別資訊直接將 COM 類型的類型資訊內嵌組件。</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</source>
          <target state="translated">因為內嵌類型資訊僅包含 Managed 組件實際所使用的類型和成員，所以兩個 Managed 組件可能對於相同的 COM 類型會有非常不同的檢視。</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Each managed assembly has a different <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to represent its view of the COM type.</source>
          <target state="translated">每個 Managed 組件有不同的 <ph id="ph1">&lt;xref:System.Type&gt;</ph> 物件以代表其 COM 類型檢視。</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</source>
          <target state="translated">通用語言執行平台支援介面、結構、列舉和委派等這些不同檢視之間的類型等價。</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</source>
          <target state="translated">類型等價表示從一個 Managed 組件傳到另一個的 COM 物件，可以在接收的組件中轉換成適當的 Managed 類型。</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph>方法可讓以判斷 COM 物件取得另一個組件具有相同的 COM 識別做為第一個組件的自己內嵌 interop 類型，其中的組件，因此可以轉換成該類型。</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Type Equivalence and Embedded Interop Types<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>類型等價和內嵌 Interop 類型<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" uid="P:System.Type.IsExplicitLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</source>
          <target state="translated">取得表示目前類型的欄位是否已在明確指定之位移配置版面的值。</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果目前類型的 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 屬性包含 <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> 則為 <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">為了方便起見，已提供這個屬性。</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">或者，您可以使用<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph>列舉值，以選取型別配置屬性，然後測試是否<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>設定。</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>列舉值會指出類型的欄位配置記憶體中的方式。</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">動態類型，您可以指定<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>當您建立的類型。</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</source>
          <target state="translated">在程式碼，套用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>屬性附帶<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>的型別，來指定欄位開始的位移會明確指定的列舉值。</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">您無法使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>方法，以判斷是否<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>已套用至類型。</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The following example creates an instance of a type and displays the value of its <ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph> property.</source>
          <target state="translated">下列範例會建立類型的執行個體，並顯示的值及其<ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>It uses the <ph id="ph1">`MySystemTime`</ph> class, which is also in the code example for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>.</source>
          <target state="translated">它會使用<ph id="ph1">`MySystemTime`</ph>類別，這也是在程式碼範例中為<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericParameter">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or method.</source>
          <target state="translated">取得值，指出目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否表示泛型類型或泛型方法定義中的類型參數。</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type definition or generic method definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 物件表示泛型型別或泛型方法定義中的型別參數，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent generic type parameters can be obtained by calling the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition, or the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> 您可以取得物件，代表泛型型別參數呼叫<ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>方法<ph id="ph3">&lt;xref:System.Type&gt;</ph>物件，代表泛型類型定義，或<ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph>方法<ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph>物件，代表泛型方法定義。</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a generic type or method definition, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for every element of the resulting array.</source>
          <target state="translated">泛型類型或方法定義<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>結果陣列的每一個元素。</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a closed constructed type or method, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for every element of the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">封閉式建構的類型或方法，如<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>屬性會傳回<ph id="ph2">`false`</ph>所傳回之陣列的每個項目的<ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</source>
          <target state="translated">對於開放式建構的類型或方法，陣列的某些項目可能是特定類型，而且其他人可能型別參數。</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> returns <ph id="ph2">`false`</ph> for the types and <ph id="ph3">`true`</ph> for the type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> 傳回<ph id="ph2">`false`</ph>類型和<ph id="ph3">`true`</ph>的型別參數。</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property demonstrates a generic class with a mixture of types and type parameters.</source>
          <target state="translated">程式碼範例<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性示範具有混合型別與型別參數的泛型類別。</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性備註。</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to test for generic type parameters in a generic type.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>以測試是否為泛型類型的泛型型別參數的屬性。</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">取得值，指出目前類型是否為泛型類型。</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is a generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果目前的類型是泛型型別。否則， <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents a generic type.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>屬性來判斷是否<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件代表泛型類型。</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents an open constructed type or a closed constructed type.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性來判斷是否<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件都代表開放式建構的類型或封閉式的建構的類型。</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> if the immediate type is not generic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>屬性會傳回<ph id="ph2">`false`</ph>如果立即的型別不是泛型。</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose elements are of type <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> in Visual Basic) is not itself a generic type.</source>
          <target state="translated">例如，其項目屬於型別陣列<ph id="ph1">`A&lt;int&gt;`</ph>(<ph id="ph2">`A(Of Integer)`</ph>在 Visual Basic 中) 是本身不是泛型類型。</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table summarizes the invariant conditions for common terms used in generic reflection.</source>
          <target state="translated">下表摘要說明在反映中泛型使用的通用詞彙的非變異條件。</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Term</source>
          <target state="translated">詞彙</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariant</source>
          <target state="translated">非變異值</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type definition</source>
          <target state="translated">Generic Type Definition - 泛型類型定義</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> 屬性為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Defines a generic type.</source>
          <target state="translated">定義泛型類型。</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>A constructed type is created by calling the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition and specifying an array of type arguments.</source>
          <target state="translated">建構的類型由呼叫<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，代表泛型類型定義，並指定型別引數的陣列。</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be called only on generic type definitions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> 只有在泛型類型定義上，可以被呼叫。</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Any generic type definition is a generic type (the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>), but the converse is not true.</source>
          <target state="translated">任何泛型類型定義為泛型類型 (<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>屬性是<ph id="ph2">`true`</ph>)，但反之不然，則為 true。</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type</source>
          <target state="translated">Generic Type - 泛型類型</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be a generic type definition, an open constructed type, or a closed constructed type.</source>
          <target state="translated">可以是泛型類型定義、 開放式建構的類型或封閉式的建構的類型。</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that an array type whose element type is generic is not itself a generic type.</source>
          <target state="translated">請注意，陣列類型的項目型別為泛型本身並不是泛型型別。</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The same is true of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing a pointer to a generic type.</source>
          <target state="translated">也是如此的<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表泛型類型的指標。</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>open constructed type</source>
          <target state="translated">開放式建構的類型</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 屬性為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">範例包括有未指派的型別參數的泛型型別、 開放式建構類型，或泛型類型定義中巢狀類型或泛型類型具有其型別引數<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性是<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>It is not possible to create an instance of an open constructed type.</source>
          <target state="translated">您不可能建立開放式建構類型的執行個體。</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that not all open constructed types are generic.</source>
          <target state="translated">請注意，並非所有開放式建構的類型的泛型。</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</source>
          <target state="translated">例如，其項目類型是泛型類型定義陣列不是泛型，而開放式建構類型的指標不是泛型。</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>closed constructed type</source>
          <target state="translated">封閉式建構的類型</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 屬性為 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When examined recursively, the type has no unassigned generic parameters.</source>
          <target state="translated">當遞迴檢查，型別沒有任何未指派的泛型參數。</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type parameter</source>
          <target state="translated">Generic Type Parameter - 泛型型別參數</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> 屬性為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 屬性為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>In a generic type definition, a placeholder for a type that will be assigned later.</source>
          <target state="translated">在泛型類型定義中，將於之後指定類型的預留位置。</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type argument</source>
          <target state="translated">Generic Type Argument - 泛型類型引數</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be any type, including a generic type parameter.</source>
          <target state="translated">可以是任何類型，包括泛型類型參數。</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Type arguments are specified as an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method when creating a constructed generic type.</source>
          <target state="translated">型別引數所指定的陣列為<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件傳遞至<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法建立已建構的泛型型別時。</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>If instances of the resulting type are to be created, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property must be <ph id="ph2">`false`</ph> for all the type arguments.</source>
          <target state="translated">如果執行個體的產生的型別建立，<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性必須是<ph id="ph2">`false`</ph>所有型別引數。</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example and table illustrate some of these terms and invariants.</source>
          <target state="translated">下列程式碼範例及下表說明部分這些條款及非變異值。</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">`Derived`</ph> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</source>
          <target state="translated"><ph id="ph1">`Derived`</ph>類別是特別感興趣的因為其基底類型是具有型別和型別參數的混合，其型別引數清單中的建構的類型。</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table shows examples that use and build on the classes <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, and <ph id="ph3">`G`</ph>.</source>
          <target state="translated">下表顯示範例會使用的類別上建立<ph id="ph1">`Base`</ph>， <ph id="ph2">`Derived`</ph>，和<ph id="ph3">`G`</ph>。</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When the C++ and C# code is the same, only one entry is shown.</source>
          <target state="translated">當 c + + 和 C# 程式碼都相同時，則會顯示只有一個項目。</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Example</source>
          <target state="translated">範例</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariants</source>
          <target state="translated">非變異值</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">此型別：</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> 為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">此型別：</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> 為 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For the type of variable <ph id="ph1">`d`</ph>:</source>
          <target state="translated">類型的變數<ph id="ph1">`d`</ph>:</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because <ph id="ph3">`d`</ph> is an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 是<ph id="ph2">`false`</ph>因為<ph id="ph3">`d`</ph>是陣列。</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> 為 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 為 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, and <ph id="ph3">`V`</ph> (everywhere they appear)</source>
          <target state="translated"><ph id="ph1">`T`</ph><ph id="ph2">`U`</ph>，和<ph id="ph3">`V`</ph>（everywhere 它們會顯示）</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> 為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because there is no way to constrain a type parameter to generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 是<ph id="ph2">`false`</ph>因為沒有任何方法來限制泛型類型的型別參數。</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> 為 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, and <ph id="ph5">`V`</ph> are themselves generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 是<ph id="ph2">`true`</ph>因為<ph id="ph3">`T`</ph>， <ph id="ph4">`U`</ph>，和<ph id="ph5">`V`</ph>本身也是泛型型別參數。</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This does not imply anything about type arguments that are assigned to them later.</source>
          <target state="translated">這不表示任何關於稍後指派給它們的型別引數。</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The type of field <ph id="ph1">`F`</ph></source>
          <target state="translated">欄位的類型 <ph id="ph1">`F`</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph> because a type has been assigned to the type parameter of <ph id="ph3">`G`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> 是<ph id="ph2">`false`</ph>因為型別已被指派至類型參數的<ph id="ph3">`G`</ph>。</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that this is equivalent to having called the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">請注意，這相當於呼叫<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the type of field <ph id="ph3">`F`</ph> has a type argument that is an open constructed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 是<ph id="ph2">`true`</ph>因為欄位的型別<ph id="ph3">`F`</ph>已是開放式建構的類型的型別引數。</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The constructed type is open because its type argument (that is, <ph id="ph1">`Base`</ph>) is a generic type definition.</source>
          <target state="translated">建構的類型為開放式因為其型別引數 (也就是<ph id="ph1">`Base`</ph>) 是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">下列說明處理遞迴性質<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The nested class <ph id="ph1">`Nested`</ph></source>
          <target state="translated">巢狀的類別 <ph id="ph1">`Nested`</ph></target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>, even though the <ph id="ph3">`Nested`</ph> class has no generic type parameters of its own, because it is nested in a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 是<ph id="ph2">`true`</ph>，即使<ph id="ph3">`Nested`</ph>類別具有自己的任何泛型類型參數，因為它巢狀在泛型型別。</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> 為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>That is, you can call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method and supply the type parameter of the enclosing type, <ph id="ph2">`Derived`</ph>.</source>
          <target state="translated">也就是說，您可以呼叫<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法並提供封入類型的型別參數<ph id="ph2">`Derived`</ph>。</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the enclosing type, <ph id="ph3">`Derived`</ph>, has generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> 是<ph id="ph2">`true`</ph>封入類型，因為<ph id="ph3">`Derived`</ph>，泛型類型參數。</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">下列說明處理遞迴性質<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example displays the value of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> properties for the types described in the Remarks section.</source>
          <target state="translated">下列程式碼範例顯示的值<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>&lt; 備註 &gt; 一節所述之類型的屬性。</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For explanations of the property values, see the accompanying table in Remarks.</source>
          <target state="translated">屬性值的說明，請參閱 &lt; 備註 &gt; 中的表格。</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type definition, from which other generic types can be constructed.</source>
          <target state="translated">取得值，指出目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否表示可用於建構其他泛型類型的泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 物件表示泛型類型定義，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">泛型類型定義是用於建構其他類型的範本。</target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic), by calling the <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with a generic argument list containing the <ph id="ph7">&lt;xref:System.Int32&gt;</ph> type.</source>
          <target state="translated">例如，從泛型類型定義<ph id="ph1">`G&lt;T&gt;`</ph>（以表示 C# 語法。<ph id="ph2">`G(Of T)`</ph>在 Visual Basic 或<ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph>c + + 中) 您可以建構並具現化類型<ph id="ph4">`G&lt;int&gt;`</ph>(<ph id="ph5">`G(Of Integer)`</ph>在 Visual Basic 中)，藉由呼叫<ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>與包含泛型引數清單的方法<ph id="ph7">&lt;xref:System.Int32&gt;</ph>型別。</target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method gets the generic type definition back again.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表這個建構的型別，<ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>方法會取得泛型類型定義傳回一次。</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property to determine whether you can create new types from the current type.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>屬性來判斷您是否可以從目前的型別來建立新的類型。</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, you can call the <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create new generic types.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>，您可以呼叫<ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法來建立新的泛型型別。</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性備註。</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>The following example displays information about a type, including whether or not it is a generic type definition.</source>
          <target state="translated">下列範例會顯示類型，包括這是泛型類型定義的相關資訊。</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</source>
          <target state="translated">建構的類型、 其泛型型別定義，以及一般型別，會顯示資訊。</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" uid="P:System.Type.IsImport">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> attribute applied, indicating that it was imported from a COM type library.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否套用了 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> 屬性 (Attribute)，亦即其是否從 COM 類型程式庫匯入。</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 具有 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，則為 <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由 <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The object to compare with the current type.</source>
          <target state="translated">要與目前的類型比較的物件。</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>Determines whether the specified object is an instance of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">判斷指定的物件是否為目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的執行個體。</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> is in the inheritance hierarchy of the object represented by <ph id="ph3">&lt;paramref name="o" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an interface that <ph id="ph5">&lt;paramref name="o" /&gt;</ph> implements.</source>
          <target state="translated">如果在目前 <ph id="ph2">&lt;see langword="Type" /&gt;</ph> 位於 <ph id="ph3">&lt;paramref name="o" /&gt;</ph> 所代表之物件的階層架構中，或者目前 <ph id="ph4">&lt;see langword="Type" /&gt;</ph> 位於 <ph id="ph5">&lt;paramref name="o" /&gt;</ph> 支援的介面中，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if neither of these conditions is the case, if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an open generic type (that is, <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph6">&lt;see langword="true" /&gt;</ph>).</source>
          <target state="translated">如果都不是這些情況，或者如果 <ph id="ph2">&lt;paramref name="o" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，又或者如果目前 <ph id="ph4">&lt;see langword="Type" /&gt;</ph> 為開放式泛型類型 (亦即 <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 會傳回 <ph id="ph6">&lt;see langword="true" /&gt;</ph>)，則為 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>A constructed type is not an instance of its generic type definition.</source>
          <target state="translated">建構的類型不是其泛型型別定義的執行個體。</target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>That is, <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) is not an instance of <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">也就是說， <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph>在 Visual Basic 中) 不是執行個體的<ph id="ph3">`MyGenericList&lt;T&gt;`</ph>(<ph id="ph4">`MyGenericList(Of T)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The following example demonstrates the use of the <ph id="ph1">`IsInstanceOfType`</ph> method.</source>
          <target state="translated">下列範例示範 <ph id="ph1">`IsInstanceOfType`</ph> 方法的用法。</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" uid="P:System.Type.IsInterface">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; that is, not a class or a value type.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為介面；也就是說，不是類別或實值類型。</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是介面，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> distinguishes a type declaration as class, interface or value type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph>區分型別宣告為類別、 介面或實值類型。</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The following example creates an interface, checks for the interface type, and indicates whether a class has the <ph id="ph1">`IsInterface`</ph> property set.</source>
          <target state="translated">下列範例會建立一個介面、 檢查介面類型，並指出類別是否具有<ph id="ph1">`IsInterface`</ph>屬性集。</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" uid="P:System.Type.IsLayoutSequential">
          <source>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</source>
          <target state="translated">取得表示目前類型的欄位是否已依為其定義或發出至中繼資料之順序，循序配置版面的值。</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果目前類型的 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 屬性包含 <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> 則為 <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>This property is provided as a convenience.</source>
          <target state="translated">為了方便起見，已提供這個屬性。</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">或者，您可以使用<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph>列舉值，以選取型別配置屬性，然後測試是否<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>設定。</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>列舉值會指出類型的欄位配置記憶體中的方式。</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">動態類型，您可以指定<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>當您建立的類型。</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that layout is sequential.</source>
          <target state="translated">在程式碼，套用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>屬性附帶<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>的型別，以指定該版面配置是循序的列舉值。</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">您無法使用<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>方法，以判斷是否<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>已套用至類型。</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">如需詳細資訊，請參閱章節 9.1.2 通用語言基礎結構 (CLI) 文件 &lt; 磁碟分割第二部分： 中繼資料定義和語意 &gt; 規格。</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">您可以線上取得這份文件；請參閱 MSDN 上的 <bpt id="p1">[</bpt>ECMA C# 和通用語言基礎結構標準<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>，以及 Ecma International 網站上的<bpt id="p2">[</bpt>標準 ECMA-335 - 通用語言基礎結構 (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>。</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The following example creates an instance of a class for which the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> class has been set, checks for the <ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph> property, and displays the result.</source>
          <target state="translated">下列範例會建立類別的執行個體的<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>中的列舉值<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>類別已設定，會檢查是否有<ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph>屬性，並顯示結果。</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" uid="P:System.Type.IsMarshalByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否以傳址方式封送處理。</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是以傳址方式進行封送處理，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">下列範例會示範<ph id="ph1">`IsContextful`</ph>， <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph>屬性<ph id="ph4">&lt;xref:System.Type&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated">實作 <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> 屬性，判斷 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否以傳址方式封送處理。</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是以傳址方式進行封送處理，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>The following example determines whether the given type is marshaled by reference and displays the result.</source>
          <target state="translated">下列範例會判斷是否會依參考封送處理指定的型別，並顯示結果。</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" uid="P:System.Type.IsNested">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type whose definition is nested inside the definition of another type.</source>
          <target state="translated">取得值，表示目前的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件代表的類型之定義是否位於另一個類型的定義內部。</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested inside another type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 巢狀於另一個類型中，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for all nested types, regardless of visibility.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>所有巢狀類型，不論可見性。</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>To test for nesting and visibility at the same time, use the related properties <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</source>
          <target state="translated">若要同時測試巢狀結構和可見性，使用 相關的屬性<ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>，或<ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> enumeration member selects the visibility attributes for a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph>列舉成員選取類型的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">然後它會擷取的可見性相關的數字的值<ph id="ph1">&lt;xref:System.Type&gt;</ph>父類型和其巢狀類型的每個屬性。</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedAssembly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為巢狀，並只在它自己的組件內為可見。</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是巢狀並只在它自己的組件內為可見，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 選取的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">然後它會擷取的可見性相關的數字的值<ph id="ph1">&lt;xref:System.Type&gt;</ph>父類型和其巢狀類型的每個屬性。</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamANDAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為巢狀，並只對同時屬於它自己家族和它自己組件的類別為可見。</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是巢狀並只對同時屬於它自己家族和它自己組件的類別為可見，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 選取的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</source>
          <target state="translated">C# 和 Visual Basic 語言不包含可讓您定義的巢狀的類型，是只在它自己組件中受保護的類型為可見的語意。</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">`protected internal`</ph> visibility in C# and <ph id="ph2">`Protected Friend`</ph> visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</source>
          <target state="translated"><ph id="ph1">`protected internal`</ph> 在 C# 中的可見性和<ph id="ph2">`Protected Friend`</ph>可見性，在 Visual Basic 中的定義的巢狀的類型，會顯示受保護的類型和相同的組件中的型別。</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件的系列會定義為相同的所有物件<ph id="ph2">&lt;xref:System.Type&gt;</ph>和及其子型別。</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">然後它會擷取的可見性相關的數字的值<ph id="ph1">&lt;xref:System.Type&gt;</ph>父類型和其巢狀類型的每個屬性。</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamily">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為巢狀，並只在它自己的系列內為可見。</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是巢狀並只在它自己的家族內為可見，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 選取的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件的系列定義為所有物件的完全相同<ph id="ph2">&lt;xref:System.Type&gt;</ph>和及其子型別。</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">然後它會擷取的可見性相關的數字的值<ph id="ph1">&lt;xref:System.Type&gt;</ph>父類型和其巢狀類型的每個屬性。</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamORAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to either its own family or to its own assembly.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為巢狀並只對屬於它自己家族或它自己組件的類別為可見。</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是巢狀並只對屬於它自己家族或它自己組件的類別為可見，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the visibility of a type is <ph id="ph1">`protected internal`</ph> in C# or <ph id="ph2">`Protected Friend`</ph> in Visual Basic, the <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">如果類型的可見性會<ph id="ph1">`protected internal`</ph>在 C# 或<ph id="ph2">`Protected Friend`</ph>在 Visual Basic 中<ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>屬性會傳回<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 選取的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件的系列定義為所有物件的完全相同<ph id="ph2">&lt;xref:System.Type&gt;</ph>和及其子型別。</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">然後它會擷取的可見性相關的數字的值<ph id="ph1">&lt;xref:System.Type&gt;</ph>父類型和其巢狀類型的每個屬性。</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPrivate">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為巢狀並且宣告為私用。</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是巢狀並且宣告為私用，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 選取的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">然後它會擷取的可見性相關的數字的值<ph id="ph1">&lt;xref:System.Type&gt;</ph>父類型和其巢狀類型的每個屬性。</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPublic">
          <source>Gets a value indicating whether a class is nested and declared public.</source>
          <target state="translated">取得值，指出類別是否為巢狀 (Nest) 並且宣告為公用 (Public)。</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the class is nested and declared public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果類別是巢狀並且宣告為公用，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 選取的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">下列範例會建立外部的類別，以有各種類型的可見性的巢狀類別的數字。</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">然後它會擷取的可見性相關的數字的值<ph id="ph1">&lt;xref:System.Type&gt;</ph>父類型和其巢狀類型的每個屬性。</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="P:System.Type.IsNotPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否未宣告為公用。</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 尚未宣告為公用而且不是巢狀類型，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Do not use this property with nested types; use the <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> property instead.</source>
          <target state="translated">請勿使用這個屬性與巢狀類型;使用<ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>屬性改為。</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性會傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>This example usesthe <ph id="ph1">`IsNotPublic`</ph> property to get the visibility of the type.</source>
          <target state="translated">此範例用途<ph id="ph1">`IsNotPublic`</ph>来取得之類型的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The following code example demonstrates why you cannot use <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> for nested classes.</source>
          <target state="translated">下列程式碼範例示範為何無法使用<ph id="ph1">`IsPublic`</ph>和<ph id="ph2">`IsNotPublic`</ph>巢狀類別。</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">`IsNestedPublic`</ph> and <ph id="ph4">`IsNestedPrivate`</ph>.</source>
          <target state="translated">巢狀類別，略過的結果<ph id="ph1">`IsPublic`</ph>和<ph id="ph2">`IsNotPublic`</ph>和結果的注意<ph id="ph3">`IsNestedPublic`</ph>和<ph id="ph4">`IsNestedPrivate`</ph>。</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The reflection output for this code fragment would be as follows:</source>
          <target state="translated">此程式碼片段的反映輸出應如下所示：</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Class</source>
          <target state="translated">類別</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNotPublic</source>
          <target state="translated">IsNotPublic</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsPublic</source>
          <target state="translated">IsPublic</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPublic</source>
          <target state="translated">IsNestedPublic</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPrivate</source>
          <target state="translated">IsNestedPrivate</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>A</source>
          <target state="translated">A</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>B</source>
          <target state="translated">B</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" uid="P:System.Type.IsPointer">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為指標。</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是指標，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>The following example shows a use of the <ph id="ph1">`IsPointer`</ph> property.</source>
          <target state="translated">下列範例會示範搭配<ph id="ph1">`IsPointer`</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">在衍生類別中覆寫時，實作 <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> 屬性並判斷 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否為指標。</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是指標，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" uid="P:System.Type.IsPrimitive">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為其中一個基本類型 (Primitive Type)。</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是其中一個基本類型，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, and <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">基本類型為<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>， <ph id="ph2">&lt;xref:System.Byte&gt;</ph>， <ph id="ph3">&lt;xref:System.SByte&gt;</ph>， <ph id="ph4">&lt;xref:System.Int16&gt;</ph>， <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>， <ph id="ph6">&lt;xref:System.Int32&gt;</ph>， <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>， <ph id="ph8">&lt;xref:System.Int64&gt;</ph>， <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>， <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>， <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>， <ph id="ph12">&lt;xref:System.Char&gt;</ph>，<ph id="ph13">&lt;xref:System.Double&gt;</ph>，和<ph id="ph14">&lt;xref:System.Single&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型類型或型別參數的泛型類型或泛型方法定義中這個屬性一律會傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">下列範例會示範<ph id="ph1">`IsContextful`</ph>， <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph>屬性<ph id="ph4">&lt;xref:System.Type&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">它會檢查是否裝載內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">在衍生類別中覆寫時，實作 <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> 屬性並判斷 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否為其中一個基本類型。</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是其中一個基本類型，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, and <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">基本類型為<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>， <ph id="ph2">&lt;xref:System.Byte&gt;</ph>， <ph id="ph3">&lt;xref:System.SByte&gt;</ph>， <ph id="ph4">&lt;xref:System.Int16&gt;</ph>， <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>， <ph id="ph6">&lt;xref:System.Int32&gt;</ph>， <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>， <ph id="ph8">&lt;xref:System.Int64&gt;</ph>， <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>， <ph id="ph10">&lt;xref:System.Char&gt;</ph>， <ph id="ph11">&lt;xref:System.Double&gt;</ph>，和<ph id="ph12">&lt;xref:System.Single&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The following example determines whether the given type is a primitive type and displays the result.</source>
          <target state="translated">下列範例會判斷指定的型別是否為基本類型，並顯示結果。</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" uid="P:System.Type.IsPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared public.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否宣告為公用。</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 已宣告為公用而且不是巢狀類型，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>Do not use with nested types; use <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> instead.</source>
          <target state="translated">請勿使用巢狀型別。使用<ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>改為。</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性會傳回<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 選取的可見性屬性。</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph>, checks for the <ph id="ph2">`IsPublic`</ph> property, and displays the result.</source>
          <target state="translated">下列範例會建立的執行個體<ph id="ph1">`MyTestClass`</ph>，檢查是否有<ph id="ph2">`IsPublic`</ph>屬性，並顯示結果。</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>.</source>
          <target state="translated">巢狀類別，略過的結果<ph id="ph1">`IsPublic`</ph>和<ph id="ph2">`IsNotPublic`</ph>和結果的注意<ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>和<ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" uid="P:System.Type.IsSealed">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否宣告為密封。</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 宣告為密封，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型型別，這個屬性永遠傳回<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>The following example creates an instance of a <ph id="ph1">`sealed`</ph> class, checks for the <ph id="ph2">`IsSealed`</ph> property, and displays the result.</source>
          <target state="translated">下列範例會建立的執行個體<ph id="ph1">`sealed`</ph>類別，檢查有無<ph id="ph2">`IsSealed`</ph>屬性，並顯示結果。</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">取得值，這個值表示目前類型在目前信任層級上是否為安全性關鍵或安全性安全關鍵，因而可以執行重要的作業。</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">如果目前類型在目前信任層級上為安全性關鍵或安全性安全關鍵，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，如果是安全性透明，則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">這些屬性的組合是下表所示：</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">安全性層級</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">安全關鍵</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">組件和其所有類型都視為透明的。</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">如需有關反映和透明度的詳細資訊，請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度的相關資訊，請參閱<bpt id="p1">[</bpt>安全性變更<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">取得值，這個值表示目前類型在目前信任層級上是否為安全性安全關鍵，也就是說，它是否能執行重要作業並由安全性透明的程式碼存取。</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">如果目前類型在目前信任層級上為安全性安全關鍵，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果為安全性關鍵或安全性透明，則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">這些屬性的組合是下表所示：</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">安全性層級</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">安全關鍵</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">組件和其所有類型都視為透明的。</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">如需有關反映和透明度的詳細資訊，請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度的相關資訊，請參閱<bpt id="p1">[</bpt>安全性變更<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">取得值，這個值表示目前類型在目前信任層級上是否為透明，因此無法執行重要作業。</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果型別在目前信任層級上為安全性透明，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果這個屬性會傳回<ph id="ph1">`true`</ph>、<ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>屬性傳回<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段會忽略組件的安全性註釋。</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">組件和其所有類型都視為透明的。</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">如需有關反映和透明度的詳細資訊，請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度的相關資訊，請參閱<bpt id="p1">[</bpt>安全性變更<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="P:System.Type.IsSerializable">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is serializable.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否可序列化。</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is serializable; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 可序列化，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Types that are defined in the .NET Standard are not marked with <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>.</source>
          <target state="translated">在.NET 標準所定義的類型未標示有<ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Instead, each .NET implementation determines whether a type is serializable.</source>
          <target state="translated">相反地，每個.NET 實作可決定是否可序列化類型。</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>At run time, you can use the <ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph> property to determine whether that implementation supports serialization of an instance of the type.</source>
          <target state="translated">在執行階段，您可以使用<ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph>屬性來決定是否該實作會支援序列化之型別的執行個體。</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to determine if a .NET Standard object is serializable<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>.</source>
          <target state="translated">如需詳細資訊和範例，請參閱<bpt id="p1">[</bpt>如何判斷是否可序列化的.NET 標準物件<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph> class, sets the [Serializable] attribute, and checks the <ph id="ph2">`IsSerializable`</ph> property for <ph id="ph3">`true`</ph> or <ph id="ph4">`false`</ph>.</source>
          <target state="translated">下列範例會建立的執行個體<ph id="ph1">`MyTestClass`</ph>類別，設定 [Serializable] 屬性，並檢查<ph id="ph2">`IsSerializable`</ph>屬性<ph id="ph3">`true`</ph>或<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" uid="P:System.Type.IsSpecialName">
          <source>Gets a value indicating whether the type has a name that requires special handling.</source>
          <target state="translated">取得值，表示類型是否具有需要特殊處理的名稱。</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type has a name that requires special handling; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果類型具有需要特殊處理的名稱，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</source>
          <target state="translated">開頭或包含底線字元 (_)、 屬性存取子和運算子多載方法的名稱是由某些編譯器需要特殊處理的類型的範例。</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">要與目前的類型比較的類型。</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Determines whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> derives from the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">判斷目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否衍生自指定的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> derives from <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果目前 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 衍生自 <ph id="ph2">&lt;see langword="Type" /&gt;</ph>，則為 <ph id="ph3">&lt;paramref name="c" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> and the current <ph id="ph3">&lt;see langword="Type" /&gt;</ph> are equal.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 和目前 <ph id="ph2">&lt;paramref name="c" /&gt;</ph> 相等，這個方法也會傳回 <ph id="ph3">&lt;see langword="Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to determine any of the following:</source>
          <target state="translated">您可以呼叫<ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph>方法，以判斷下列任一項：</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether one class derives from another.</source>
          <target state="translated">是否從另一個衍生一個類別。</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">型別是否衍生自<ph id="ph1">&lt;xref:System.ValueType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> is a more efficient way to determine whether a type is a value type.</source>
          <target state="translated">不過，<ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph>是更有效率的方式來決定類型是否為實值類型。</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
          <target state="translated">型別是否衍生自<ph id="ph1">&lt;xref:System.Enum&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> method is a more efficient way to determine whether a type is an enumeration.</source>
          <target state="translated">不過，<ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>方法是更有效率的方式來決定類型是否為列舉型別。</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type is a delegate, that is, whether it derives from either <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> or <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</source>
          <target state="translated">是否為型別是一種委派，也就是是否從它衍生<ph id="ph1">&lt;xref:System.Delegate&gt;</ph>或<ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph>方法無法用來判斷是否介面衍生自另一個介面，或者類別是否實作介面。</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method for that purpose, as the following example shows.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>基於這個目的，如下列範例所示的方法。</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> if it has no class constraint.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示型別參數中的泛型類型或泛型方法定義，其衍生自其類別條件約束，或從<ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>如果它沒有類別條件約束。</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Except when used with interfaces, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> is the converse of <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</source>
          <target state="translated">介面，搭配使用時，除非<ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph>是反向<ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>That is, if <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> is <ph id="ph2">`true`</ph>, then <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> is also <ph id="ph4">`true`</ph>.</source>
          <target state="translated">也就是說，如果<ph id="ph1">`t1.IsSubclassOf(t2)`</ph>是<ph id="ph2">`true`</ph>，然後<ph id="ph3">`t2.IsAssignableFrom(t1)`</ph>也<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">在衍生類別可以覆寫這個方法。</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The following example creates a class named <ph id="ph1">`Class1`</ph> and a derived class named <ph id="ph2">`DerivedC1`</ph>.</source>
          <target state="translated">下列範例會建立名為類別<ph id="ph1">`Class1`</ph>和衍生的類別，名為<ph id="ph2">`DerivedC1`</ph>。</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>It calls the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to show that <ph id="ph2">`DerivedC1`</ph> is a subclass of <ph id="ph3">`Class1`</ph>.</source>
          <target state="translated">它會呼叫<ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph>方法，以顯示，<ph id="ph2">`DerivedC1`</ph>是子類別的<ph id="ph3">`Class1`</ph>。</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" uid="P:System.Type.IsUnicodeClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得值，指出是否為 <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> 選取字串格式屬性 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果為 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 選取字串格式屬性 <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph>，則為 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> is used to select the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph>用來選取字串格式屬性。</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">字串格式屬性定義如何解譯字串增強互通性。</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" uid="P:System.Type.IsValueType">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a value type.</source>
          <target state="translated">取得值，指出 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否為實值類型。</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是實值類型，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</source>
          <target state="translated">實值型別會表示為位元; 順序的型別實值類型不是類別或介面。</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are referred to as "structs" in some programming languages.</source>
          <target state="translated">實值型別稱為 「 結構 」 中的某些程式設計語言。</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Enums are a special case of value types.</source>
          <target state="translated">列舉是特殊案例的實值類型。</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`false`</ph> for the <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> class, because <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> is not a value type itself.</source>
          <target state="translated">這個屬性會傳回<ph id="ph1">`false`</ph>如<ph id="ph2">&lt;xref:System.ValueType&gt;</ph>類別，因為<ph id="ph3">&lt;xref:System.ValueType&gt;</ph>不是實值型別本身。</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>It is the base class for all value types, and therefore any value type can be assigned to it.</source>
          <target state="translated">它是所有的實值類型的基底類別，因此任何實值類型，可以指派給它。</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This would not be possible if <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> itself was a value type.</source>
          <target state="translated">這並不是可能如果<ph id="ph1">&lt;xref:System.ValueType&gt;</ph>本身是實值類型。</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are boxed when they are assigned to a field of type <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">會在指派給欄位的類型時，會進行 boxed 處理實值類型<ph id="ph1">&lt;xref:System.ValueType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`true`</ph> for enumerations, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">這個屬性會傳回<ph id="ph1">`true`</ph>列舉型別，但不是適合用於<ph id="ph2">&lt;xref:System.Enum&gt;</ph>型別本身。</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>For an example that demonstrates this behavior, see <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</source>
          <target state="translated">如需示範此行為的範例，請參閱<ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>The following example creates a variable of type <ph id="ph1">`MyEnum`</ph>, checks for the <ph id="ph2">`IsValueType`</ph> property, and displays the result.</source>
          <target state="translated">下列範例會建立類型的變數<ph id="ph1">`MyEnum`</ph>，檢查是否有<ph id="ph2">`IsValueType`</ph>屬性，並顯示結果。</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; that is, not a class or an interface.</source>
          <target state="translated">實作 <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> 屬性並判斷 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是否為實值類型；也就是說，不是類別或介面。</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是實值類型，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>This method is provided to enable the implementation of alternate type systems.</source>
          <target state="translated">這個方法被提供來啟用其他的型別系統的實作。</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>It is not generally used in application code.</source>
          <target state="translated">它是不通常用於應用程式程式碼。</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" uid="P:System.Type.IsVisible">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be accessed by code outside the assembly.</source>
          <target state="translated">取得一個值，表示位於組件之外的程式碼是否能存取 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a public type or a public nested type such that all the enclosing types are public; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果目前 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是公用類型或公用巢狀類型 (所有封入類型均為公用)，則為 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>Use this property to determine whether a type is part of the public interface of a component assembly.</source>
          <target state="translated">使用這個屬性來決定類型是否為公用介面的元件組件的一部分。</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>The following code example tests two classes, only one of which is visible outside the assembly.</source>
          <target state="translated">下列程式碼範例會測試兩個類別，其中只有一個外部是可見的組件。</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">傳回代表目前類型之陣列的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">傳回 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，代表由目前類型組成的一維陣列，其下限為零。</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，代表由目前類型組成的一維陣列，其下限為零。</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>方法可用來產生執行階段計算其項目類型的陣列型別。</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>請注意<ept id="p1">**</ept>common language runtime 會區別向量 （也就是一維陣列，都以零為起始） 和多維度陣列。</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">Vector 中，永遠只有一個維度，其不是剛好只有一個維度的多維陣列相同。</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>This method overload can only be used to create vector types, and it is the only way to create a vector type.</source>
          <target state="translated">這個方法多載只可用來建立的向量類型，這是唯一的方式建立的向量類型。</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> method overload to create multidimensional array types.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph>方法多載來建立多維陣列型別。</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">下列程式碼範例會建立陣列， <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph>在 Visual Basic 中)，以及指標的類型<ph id="ph3">`Test`</ph>類別。</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">衍生類別必須提供實作。</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">目前的類型為 <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">目前的類型為 <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> 類型。</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> 會傳回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">陣列的維度數目。</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>This number must be less than or equal to 32.</source>
          <target state="translated">這個數字必須小於或等於 32。</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">傳回 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，代表由目前類型組成且為指定維度個數的陣列。</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>An object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">物件，代表由目前類型組成且為指定維度個數的陣列。</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>方法可用來產生執行階段計算其項目類型的陣列型別。</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated">Common language runtime 會區別向量 （也就是一維陣列，都以零為起始） 和多維度陣列。</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">Vector 中，永遠只有一個維度，其不是剛好只有一個維度的多維陣列相同。</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>You cannot use this method overload to create a vector type; if <ph id="ph1">`rank`</ph> is 1, this method overload returns a multidimensional array type that happens to have one dimension.</source>
          <target state="translated">您無法使用這個方法多載來建立的向量類型。如果<ph id="ph1">`rank`</ph>為 1，這個方法多載會傳回剛好有一個維度的多維陣列類型。</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> method overload to create vector types.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph>方法多載來建立的向量類型。</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">下列程式碼範例會建立陣列， <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph>在 Visual Basic 中)，以及指標的類型<ph id="ph3">`Test`</ph>類別。</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>For example, 0 or negative.</source>
          <target state="translated">例如，0 或負數。</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">目前的類型為 <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">目前的類型為 <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> 類型。</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> 傳回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is greater than 32.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> 大於 32。</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated">傳回 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，當做 <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (Visual Basic 中的 <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph>) 參數傳遞時，代表目前的類型。</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，當做 <ph id="ph2">&lt;see langword="ref" /&gt;</ph> 參數 (在 Visual Basic 中為 <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> 參數) 傳遞時，代表目前的類型。</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>方法可用來產生<ph id="ph2">`ref`</ph>類型 (<ph id="ph3">`ByRef`</ph>在 Visual Basic 中) 的參數清單。</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32&amp;`</ph>.</source>
          <target state="translated">如果使用的語法的 Microsoft 中繼語言 (MSIL)，目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表<ph id="ph2">&lt;xref:System.Int32&gt;</ph>，這個方法會傳回<ph id="ph3">&lt;xref:System.Type&gt;</ph>物件，代表<ph id="ph4">`Int32&amp;`</ph>。</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">下列程式碼範例會建立陣列， <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph>在 Visual Basic 中)，以及指標的類型<ph id="ph3">`Test`</ph>類別。</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">目前的類型為 <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">目前的類型為 <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> 類型。</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> 會傳回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type.</source>
          <target state="translated">由類型組成的陣列，用來取代目前泛型類型的型別參數。</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the resulting constructed type.</source>
          <target state="translated">用類型陣列的項目取代目前泛型類型定義的類型參數，並傳回代表所得結果建構類型的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，表示用 <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> 的項目取代目前泛型類型之類型參數所得到的建構類型。</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a particular constructed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法可讓您撰寫程式碼，將特定類型指派給類型參數的泛型類型定義，以便建立<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，代表特定建構的類型。</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to create run-time instances of the constructed type.</source>
          <target state="translated">您可以使用這個<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件建立的建構類型的執行階段執行個體。</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Types constructed with <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</source>
          <target state="translated">使用類型建構<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>可以在開啟，也就是其類型引數部分可以是封入泛型方法或類型的型別參數。</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You might use such open constructed types when you emit dynamic assemblies.</source>
          <target state="translated">發出動態組件時，您可以使用這類開放式建構的類型。</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For example, consider the classes <ph id="ph1">`Base`</ph> and <ph id="ph2">`Derived`</ph> in the following code.</source>
          <target state="translated">例如，請考慮類別<ph id="ph1">`Base`</ph>和<ph id="ph2">`Derived`</ph>下列程式碼。</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To generate <ph id="ph1">`Derived`</ph> in a dynamic assembly, it is necessary to construct its base type.</source>
          <target state="translated">若要產生<ph id="ph1">`Derived`</ph>在動態組件，就需要建構其基底類型。</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To do this, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the class <ph id="ph3">`Base`</ph>, using the generic type arguments <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and the type parameter <ph id="ph5">`V`</ph> from <ph id="ph6">`Derived`</ph>.</source>
          <target state="translated">若要這樣做，請呼叫<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.Type&gt;</ph>代表類別物件<ph id="ph3">`Base`</ph>，使用泛型型別引數<ph id="ph4">&lt;xref:System.Int32&gt;</ph>和型別參數<ph id="ph5">`V`</ph>從<ph id="ph6">`Derived`</ph>。</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Because types and generic type parameters are both represented by <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, an array containing both can be passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">因為型別和泛型型別參數都表示所<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，包含這兩個陣列可以傳遞至<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A constructed type such as <ph id="ph1">`Base&lt;int, V&gt;`</ph> is useful when emitting code, but you cannot call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on this type because it is not a generic type definition.</source>
          <target state="translated">建構的類型，例如<ph id="ph1">`Base&lt;int, V&gt;`</ph>有用時發出程式碼，但您不能呼叫<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>這個類型上的方法，所以不是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create a closed constructed type that can be instantiated, first call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the generic type definition and then call <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> with the desired type arguments.</source>
          <target state="translated">若要建立封閉式的建構的類型可具現化，請先呼叫<ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>方法來取得<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，代表泛型類型定義，然後呼叫<ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>所需的型別引數。</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object returned by <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> is the same as the <ph id="ph3">&lt;xref:System.Type&gt;</ph> obtained by calling the <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> method of the resulting constructed type, or the <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph> method of any constructed type that was created from the same generic type definition using the same type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph>所傳回物件<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>相同<ph id="ph3">&lt;xref:System.Type&gt;</ph>藉由呼叫取得<ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph>建構類型，所產生的方法或<ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph>建構建立從相同泛型類型的任何的方法。使用相同的型別引數的型別定義。</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of generic types is not itself a generic type.</source>
          <target state="translated">泛型型別的陣列本身並不是泛型型別。</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You cannot call <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on an array type such as <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">您不能呼叫<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>陣列上輸入，例如<ph id="ph2">`C&lt;T&gt;[]`</ph>(<ph id="ph3">`Dim ac() As C(Of T)`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a closed generic type from <ph id="ph1">`C&lt;T&gt;[]`</ph>, call <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> to obtain the generic type definition <ph id="ph3">`C&lt;T&gt;`</ph>; call <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on the generic type definition to create the constructed type; and finally call the <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method on the constructed type to create the array type.</source>
          <target state="translated">若要建構從封閉泛型類型<ph id="ph1">`C&lt;T&gt;[]`</ph>，呼叫<ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph>可取得泛型類型定義<ph id="ph3">`C&lt;T&gt;`</ph>; 呼叫<ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>泛型類型定義，來建立建構的類型，最後呼叫<ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>方法要建立陣列類型的建構的類型。</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The same is true of pointer types and <ph id="ph1">`ref`</ph> types (<ph id="ph2">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated">也是如此的指標類型和<ph id="ph1">`ref`</ph>類型 (<ph id="ph2">`ByRef`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> 屬性備註。</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Nested Types</source>
          <target state="translated">巢狀類型</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</source>
          <target state="translated">如果使用 C#、 c + + 或 Visual Basic 定義泛型類型，其巢狀的類型是所有泛型。</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</source>
          <target state="translated">即使巢狀型別有沒有自己的型別參數，因為所有的三種語言包含巢狀類型的型別參數清單中封入類型的型別參數，也是如此。</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following classes:</source>
          <target state="translated">請考慮下列類別：</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The type parameter list of the nested class <ph id="ph1">`Inner`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, the first of which is the type parameter of its enclosing class.</source>
          <target state="translated">巢狀類別的型別參數清單<ph id="ph1">`Inner`</ph>有兩個類型參數，<ph id="ph2">`T`</ph>和<ph id="ph3">`U`</ph>，其中第一個是其封入類別的型別參數。</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Similarly, the type parameter list of the nested class <ph id="ph1">`Innermost1`</ph> has three type parameters, <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, and <ph id="ph4">`V`</ph>, with <ph id="ph5">`T`</ph> and <ph id="ph6">`U`</ph> coming from its enclosing classes.</source>
          <target state="translated">同樣地，巢狀類別的型別參數清單<ph id="ph1">`Innermost1`</ph>有三個類型參數， <ph id="ph2">`T`</ph>， <ph id="ph3">`U`</ph>，和<ph id="ph4">`V`</ph>，與<ph id="ph5">`T`</ph>和<ph id="ph6">`U`</ph>來自其封入類別。</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The nested class <ph id="ph1">`Innermost2`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, which come from its enclosing classes.</source>
          <target state="translated">巢狀的類別<ph id="ph1">`Innermost2`</ph>有兩個類型參數，<ph id="ph2">`T`</ph>和<ph id="ph3">`U`</ph>，這是來自其封入類別。</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</source>
          <target state="translated">如果封入類型的參數清單中有一個以上的型別參數，在順序中的所有型別參數會包含巢狀類型的型別參數清單中。</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a generic type from the generic type definition for a nested type, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</source>
          <target state="translated">若要建構的泛型型別從巢狀類型的泛型類型定義，請呼叫<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>與陣列方法形成串連在型別引數陣列的所有封入類型，最外層的泛型型別，開頭和結束必須有它自己的型別參數之型別本身的巢狀類型引數陣列。</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create an instance of <ph id="ph1">`Innermost1`</ph>, call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing three types, to be assigned to T, U, and V. To create an instance of <ph id="ph3">`Innermost2`</ph>, call the <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing two types, to be assigned to T and U.</source>
          <target state="translated">若要建立的執行個體<ph id="ph1">`Innermost1`</ph>，呼叫<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>與陣列，其中包含要指派給 T、 U 和 V 的三種類型的方法。若要建立的執行個體<ph id="ph3">`Innermost2`</ph>，呼叫<ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法的陣列，其中包含兩個型別，以指派給 T 和 u。</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</source>
          <target state="translated">語言傳播以這種方式中封入類型，因此您可以使用以定義巢狀類型的欄位的封入類型的型別參數的型別參數。</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Otherwise, the type parameters would not be in scope within the bodies of the nested types.</source>
          <target state="translated">否則，型別參數不會有巢狀類型的主體內的範圍內。</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">可定義巢狀型別沒有傳播封入類型，透過發出動態組件中的程式碼或使用的型別參數<bpt id="p1">[</bpt>Ilasm.exe （IL 組譯工具）<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>。</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following code for the MSIL assembler:</source>
          <target state="translated">MSIL 組譯工具，請考慮下列程式碼：</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>In this example, it is not possible to define a field of type <ph id="ph1">`T`</ph> or <ph id="ph2">`U`</ph> in class <ph id="ph3">`Innermost`</ph>, because those type parameters are not in scope.</source>
          <target state="translated">在此範例中，就不可以定義類型的欄位<ph id="ph1">`T`</ph>或<ph id="ph2">`U`</ph>類別中<ph id="ph3">`Innermost`</ph>，因為這些型別參數不在範圍內。</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</source>
          <target state="translated">下列的組譯工具程式碼定義的行為會在 c + +、 Visual Basic 和 C# 中定義的巢狀的類別：</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine nested classes defined in the high-level languages and observe this naming scheme.</source>
          <target state="translated">您可以使用<bpt id="p1">[</bpt>Ildasm.exe （IL 解譯器）<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>檢查高階語言中定義的巢狀的類別，並觀察這個命名配置。</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create a constructed type from the generic type definition for the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>方法來建立從泛型類型定義建構的型別<ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>型別。</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The constructed type represents a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`Test`</ph> objects with string keys.</source>
          <target state="translated">建構的類型代表<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>的<ph id="ph2">`Test`</ph>字串索引鍵的物件。</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The current type does not represent a generic type definition.</source>
          <target state="translated">目前類型不代表泛型型別定義。</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> 會傳回 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 的任何項目是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters in the current generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 中的元素個數與目前泛型型別定義中的型別參數個數不同。</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 中的所有元素都不符合目前泛型型別對應之型別參數所設定的條件。</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> contains an element that is a pointer type (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>), a by-ref type (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>), or <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 中包含的項目是指標型別 (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> 傳回 <ph id="ph3">&lt;see langword="true" /&gt;</ph>)、by-ref 型別 (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> 傳回 <ph id="ph5">&lt;see langword="true" /&gt;</ph>) 或<ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">衍生類別必須提供實作。</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">傳回 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，代表指向目前類型的指標。</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件，代表指向目前類型的指標。</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>方法可用來產生參數清單的指標類型。</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32*`</ph>.</source>
          <target state="translated">如果使用的語法的 Microsoft 中繼語言 (MSIL)，目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表<ph id="ph2">&lt;xref:System.Int32&gt;</ph>，這個方法會傳回<ph id="ph3">&lt;xref:System.Type&gt;</ph>物件，代表<ph id="ph4">`Int32*`</ph>。</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">下列程式碼範例會建立陣列， <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph>在 Visual Basic 中)，以及指標的類型<ph id="ph3">`Test`</ph>類別。</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">目前的類型為 <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">目前的類型為 <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> 類型。</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> 會傳回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" uid="P:System.Type.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">取得一個 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> 值，代表這個成員是類型或巢狀類型。</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">一個 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> 值，代表這個成員是類型或巢狀類型。</target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">這個屬性會覆寫<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects—for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>—the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph> when a given member is a nested type.</source>
          <target state="translated">因此，當您檢查一組<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>物件 — 例如，將所傳回的陣列<ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>—<ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph>屬性會傳回<ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph>時指定的成員是巢狀的類型。</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性套用至從中建構的類型是泛型類型定義。</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">例如，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph>在 Visual Basic 中)，這個屬性的值由<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性永遠傳回<ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>The following code example shows the <ph id="ph1">`MemberType`</ph> field as a parameter to the <ph id="ph2">`GetMember`</ph> method:</source>
          <target state="translated">下列程式碼範例示範<ph id="ph1">`MemberType`</ph>欄位當做參數<ph id="ph2">`GetMember`</ph>方法：</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>Represents a missing value in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> information.</source>
          <target state="translated">表示在 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 資訊中的遺漏值。</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>This field is read-only.</source>
          <target state="translated">此欄位為唯讀。</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>Use the <ph id="ph1">`Missing`</ph> field for invocation through reflection to obtain the default value of a parameter.</source>
          <target state="translated">使用<ph id="ph1">`Missing`</ph>欄位以供透過反映來取得參數的預設值的引動過程。</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>If the <ph id="ph1">`Missing`</ph> field is passed in for a parameter value and there is no default value for that parameter, an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> is thrown.</source>
          <target state="translated">如果<ph id="ph1">`Missing`</ph>欄位會傳入輸入參數值，而且沒有預設值為該參數，<ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>就會擲回。</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>The following code example shows the use of the <ph id="ph1">`Missing`</ph> field to invoke a method with its default arguments.</source>
          <target state="translated">下列程式碼範例示範使用<ph id="ph1">`Missing`</ph>欄位來叫用具有預設引數的方法。</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>This code produces the following output:</source>
          <target state="translated">此程式碼會產生下列輸出：</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 55.3 c = 12</source>
          <target state="translated">= 10 b = 55.3 c = 12</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.3 c = 1</source>
          <target state="translated">a = 10 b = 1.3 c = 1</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.2 c = 1</source>
          <target state="translated">a = 10 b = 1.2 c = 1</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="P:System.Type.Module">
          <source>Gets the module (the DLL) in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">在已定義的目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 中取得模組 (DLL)。</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>The module in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">在目前已定義之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 中的模組。</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性會傳回已定義的泛型類型定義所在的模組。</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>For example, if you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property for the constructed type returns the module in which <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> is defined.</source>
          <target state="translated">例如，如果您建立的執行個體<ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>、<ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph>建構的類型的屬性會傳回模組中<ph id="ph3">`MyGenericStack&lt;T&gt;`</ph>定義。</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">同樣地，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型參數<ph id="ph2">`T`</ph>，這個屬性會傳回包含定義的泛型類型的組件<ph id="ph3">`T`</ph>。</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">`Module`</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">下列範例示範使用<ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph>和<ph id="ph2">`Module`</ph>屬性和<ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph>方法<ph id="ph4">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" uid="P:System.Type.Namespace">
          <source>Gets the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的命名空間。</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>The namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>; <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current instance has no namespace or represents a generic parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的命名空間；如果目前執行個體沒有命名空間或代表泛型參數，則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</source>
          <target state="translated">命名空間是邏輯設計階段命名慣例，主要用來定義應用程式中的範圍和組織中類別和其他類型的單一階層式結構。</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>From the viewpoint of the runtime, there are no namespaces.</source>
          <target state="translated">從執行階段的觀點來看，沒有命名空間。</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表建構的泛型類型，這個屬性會傳回包含泛型類型定義的命名空間。</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the namespace that contains the generic type definition that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">同樣地，如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型參數<ph id="ph2">`T`</ph>，這個屬性會傳回包含定義的泛型類型定義的命名空間<ph id="ph3">`T`</ph>。</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件代表泛型參數，則這個屬性會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>This following example demonstrates a use of the <ph id="ph1">`Namespace`</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">下列範例示範使用<ph id="ph1">`Namespace`</ph>和<ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph>屬性和<ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph>方法<ph id="ph4">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">要比較的第一個物件。</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">要比較的第二個物件。</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are equal.</source>
          <target state="translated">表示兩個 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件是否相等。</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等於 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，則為 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">要比較的第一個物件。</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">要比較的第二個物件。</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are not equal.</source>
          <target state="translated">表示兩個 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 物件是否不相等。</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 不等於 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，則為 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" uid="P:System.Type.ReflectedType">
          <source>Gets the class object that was used to obtain this member.</source>
          <target state="translated">取得用來取得這個成員的類別物件。</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>The <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object through which this <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object was obtained.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Type" /&gt;</ph> 物件，用來取得這個 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>For <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, the value of this property is always the same as the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property.</source>
          <target state="translated">如<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，這個屬性的值一律是相同的值<ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>This example displays the reflected type of a nested class.</source>
          <target state="translated">此範例會顯示巢狀類別的反映型別。</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">要取得之 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的組件限定名稱。</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw a <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph> if the type cannot be found; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to return <ph id="ph4">&lt;see langword="null" /&gt;</ph> if the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示找不到類型時擲回 <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph>，<ph id="ph3">&lt;see langword="false" /&gt;</ph> 表示找不到類型時傳回 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">指定 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 也會隱藏其他某些例外狀況條件，但並不是全部。</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示對 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 執行不區分大小寫的搜尋，<ph id="ph2">&lt;see langword="false" /&gt;</ph> 表示對 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 執行區分大小寫的搜尋。</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</source>
          <target state="translated">取得具有指定名稱的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，指定是否執行區分大小寫的搜尋，以及若找不到該類型時是否擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type is loaded for reflection only, not for execution.</source>
          <target state="translated">載入此類型的目的在於反映，而不是執行。</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">具有指定名稱的類型 (如有找到)，否則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">如果找不到該類型，<ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> 參數會指定是要傳回 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或是擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph>.</source>
          <target state="translated">在某些情況下，不論 <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> 的值為何，都會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">請參閱＜例外狀況＞一節。</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly containing the type is not already loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> method is equivalent to first loading the assembly for reflection only, using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, and then loading the type by calling the assembly's <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">包含類型的組件尚未載入到僅限反映的內容，如果使用<ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph>方法是相當於第一個載入的組件反映，使用<ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>方法，並接著藉由呼叫載入型別組件的<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For information about assembly-qualified names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">如需組件限定名稱的資訊，請參閱<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For additional details on specifying type names, see the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">如需指定類型名稱的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</source>
          <target state="translated">如果已執行載入組件，另一個複本已載入僅限反映的內容。</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwIfNotFound`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwIfNotFound`</ph>參數會指定時會發生什麼事型別找不到，而且也會隱藏其他某些例外狀況條件，例外狀況 &gt; 一節中所述。</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwIfNotFound`</ph>.</source>
          <target state="translated">某些例外狀況的值為何<ph id="ph1">`throwIfNotFound`</ph>。</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the assembly is not valid, a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> is thrown even if <ph id="ph2">`throwIfNotFound`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">例如，如果組件無效，<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>就會擲回即使<ph id="ph2">`throwIfNotFound`</ph>是<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For more information about using the reflection-only context, see <bpt id="p1">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</source>
          <target state="translated">如需使用僅限反映之內容的詳細資訊，請參閱<bpt id="p1">[</bpt>如何： 載入組件放入 Reflection-Only 內容<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>。</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">叫用類別初始設定式並擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到類型。</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效字元，例如內嵌的定位字元。</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 是空字串。</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 代表大小無效的陣列類型。</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表 <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> 物件的陣列。</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> does not include the assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 不包含組件名稱。</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax; for example, "MyType[,*,]".</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且 <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> 包含無效語法 (例如 "MyType[,*,]")。</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型以指標類型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> 類型或 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> 做為其中一個類型引數。</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表的泛型類型具有不正確的類型引數數目。</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，而且找不到組件或組件的其中一個相依性。</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">找到組件或其相依性的其中一個，但無法載入。</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">組件或組件的其中一個相依性無效。</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the layout of the current type.</source>
          <target state="translated">取得描述目前類型配置的 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the gross layout features of the current type.</source>
          <target state="translated">取得描述目前類型概略配置特性的 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> is not returned by the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> 不會傳回<ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Instead, use this property to get it.</source>
          <target state="translated">相反地，使用這個屬性，讓它。</target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</source>
          <target state="translated">下列程式碼範例會先定義類別、 結構，以及具有特殊的版面配置屬性 （在類別中，巢狀結構） 的結構。</target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph> property to obtain a <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> for each type, and displays the properties of the attributes.</source>
          <target state="translated">然後此範例使用<ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph>屬性，以取得<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>每個類型，以及顯示屬性的屬性。</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">基底類別不支援叫用的方法。</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">保留供未來使用。</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必須是 IID_NULL。</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">要對應之傳入的名稱陣列。</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">要對應的名稱計數。</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">用於解譯名稱的地區設定內容。</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">呼叫端配置的陣列，用於接收對應於名稱的 ID。</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">如需有關<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>，請參閱 MSDN Library。</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支援使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 介面進行晚期繫結的存取。</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">要傳回的類型資訊。</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">類型資訊的地區設定識別項。</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>A pointer to the requested type information object.</source>
          <target state="translated">所要求類型資訊物件的指標。</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">擷取物件的類型資訊，可以用來取得介面的類型資訊。</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">如需有關<ph id="ph1">`IDispatch::GetTypeInfo`</ph>，請參閱 MSDN Library。</target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支援使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 介面進行晚期繫結的存取。</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">指向接收物件提供的類型資訊介面數目的位置。</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">擷取物件提供的類型資訊介面數目 (0 或 1)。</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">如需有關<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>，請參閱 MSDN Library。</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支援使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 介面進行晚期繫結的存取。</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">辨識成員。</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">保留供未來使用。</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必須是 IID_NULL。</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">地區設定內容，用於解譯引數。</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">描述呼叫之內容的旗標。</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">指向用於儲存結果之位置的指標。</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">包含例外狀況資訊的結構指標。</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">第一個有錯誤的引數索引。</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">提供物件所公開的屬性和方法的存取權。</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">如需有關<ph id="ph1">`IDispatch::Invoke`</ph>，請參閱 MSDN Library。</target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支援使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 介面進行晚期繫結的存取。</target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>Returns a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</source>
          <target state="translated">傳回表示目前 <ph id="ph1">&lt;see langword="String" /&gt;</ph> 的名稱的 <ph id="ph2">&lt;see langword="Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">表示目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的名稱的 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This method returns the fully qualified common language runtime namespace and name for all primitive types.</source>
          <target state="translated">這個方法會傳回完整的通用語言執行階段命名空間和名稱的所有基本型別。</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>For example, the C# instruction, <ph id="ph1">`(long)0.Type().ToString()`</ph> returns "System.Int64" instead of merely "Int64".</source>
          <target state="translated">例如，C# 指令<ph id="ph1">`(long)0.Type().ToString()`</ph>傳回"System.Int64"，而不是只是 「 Int64"。</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表泛型型別、 類型和其型別引數限定的命名空間和巢狀類型，但不是由組件。</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表型別參數定義中的泛型類型或泛型方法，這個方法會傳回型別參數的非限定的名稱。</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">`ToString`</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">下列範例示範使用<ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph>屬性和<ph id="ph3">`ToString`</ph>方法<ph id="ph4">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">下列範例會比較所傳回的字串<ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph>方法和<ph id="ph2">`Name`</ph>， <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>Gets the handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的控制代碼。</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的控制代碼。</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source><ph id="ph1">`TypeHandle`</ph> encapsulates a pointer to an internal data structure that represents the type.</source>
          <target state="translated"><ph id="ph1">`TypeHandle`</ph> 封裝代表類型的內部資料結構的指標。</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>This handle is unique during the process lifetime.</source>
          <target state="translated">這個控制代碼的處理序存留期間是唯一的。</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle is valid only in the application domain in which it was obtained.</source>
          <target state="translated">控制代碼無效，只有在當初取得應用程式定義域。</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</source>
          <target state="translated">下列範例會傳回對應的型別控制代碼，並控制代碼傳遞至方法，以取得控制代碼的類型，並顯示它。</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>The .NET Compact Framework does not currently support this property.</source>
          <target state="translated">.NET Compact Framework 目前不支援這個屬性。</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" uid="P:System.Type.TypeInitializer">
          <source>Gets the initializer for the type.</source>
          <target state="translated">取得類型的初始設定式。</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>An object that contains the name of the class constructor for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">物件，包含 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的類別建構函式名稱。</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>Class initializers are also available through the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, or through overloads of the <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> methods that take <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> as a parameter.</source>
          <target state="translated">類別初始設定式也會提供透過<ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph>方法，或透過多載<ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>，和<ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>方法會採用<ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph>做為參數。</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果目前<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示的類型參數的泛型類型或泛型方法定義中這個屬性會傳回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" uid="P:System.Type.UnderlyingSystemType">
          <source>Indicates the type provided by the common language runtime that represents this type.</source>
          <target state="translated">指示類型，該類型是由表示這個類型的 Common Language Runtime 所提供的。</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.UnderlyingSystemType">
          <source>The underlying system type for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 的基礎系統類型。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>