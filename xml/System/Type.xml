<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a9cfa9bb7ba77fd040870101bf9c45695fabf7a2" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51939846" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表類型宣告：類別類型、介面類型、陣列類型、值類型、列舉類型、類型參數、泛型類型定義，以及開放式或封閉式的建構泛型類型。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` 是的根<xref:System.Reflection>功能主要的方法來存取中繼資料。 使用的成員<xref:System.Type>取得型別宣告，成員的類型 （例如建構函式、 方法、 欄位、 屬性和事件的類別） 的詳細資訊，以及模組和組件部署所在的類別。  
  
 不不需要使用反映來取得資訊類型和成員，無論其存取層級的程式碼的任何權限。 不不需要使用反映來存取公用成員或其存取層級會讓它們顯示在一般的編譯期間的其他成員的程式碼的任何權限。 不過，為了讓程式碼以使用反映來存取成員，通常會無法存取，例如私用或內部的方法，或受保護類型的欄位不會繼承您的類別，您的程式碼必須<xref:System.Security.Permissions.ReflectionPermission>。 請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。  
  
 `Type` 是抽象基底類別，可讓多個實作。 系統一律會提供衍生的類別`RuntimeType`。 在反映中，執行階段的字為開頭的所有類別都建立一次，每個系統及支援的比較作業中的物件。  
  
> [!NOTE]
>  在多執行緒的情況下，不會鎖定<xref:System.Type>物件，若要同步處理存取`static`資料。 其他的程式碼中，然後再對其，您有任何控制項，也可能會鎖定您的類別類型。 這可能會導致死結。 相反地，同步處理靜態資料的存取權鎖定私用`static`物件。  
  
> [!NOTE]
>  在衍生的類別可以存取受保護的成員呼叫的程式碼基底類別。 此外，呼叫程式碼的組件的組件成員被允許存取。 一般而言，如果您允許存取在早期繫結程式碼，然後您也可以存取晚期繫結程式碼中。  
  
> [!NOTE]
>  擴充其他介面的介面不會繼承擴充介面中定義的方法。  
  
 本節內容：  
  
 [型別物件代表何種類型？](#WhatTypes)   
 [擷取型別物件](#Retrieve)   
 [比較相等的型別物件](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>型別物件代表何種類型？  
 此類別具備執行緒安全;多個執行緒可以同時讀取這種類型的執行個體。 執行個體<xref:System.Type>類別可代表任何下列類型：  
  
-   類別  
  
-   值類型  
  
-   陣列  
  
-   介面  
  
-   列舉  
  
-   委派  
  
-   建構泛型型別和泛型類型定義  
  
-   型別引數和型別參數的建構泛型類型、 泛型類型定義，以及泛型方法定義  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>擷取型別物件  
 <xref:System.Type>特定型別相關聯的物件可以透過下列方式取得：  
  
-   執行個體<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法會傳回<xref:System.Type>物件，表示執行個體的類型。 因為所有的 managed 型別衍生自<xref:System.Object>，則<xref:System.Object.GetType%2A>可以在任何類型的執行個體上呼叫方法。  
  
     下列範例會呼叫<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法，以判斷物件陣列中每個物件的執行階段類型。  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   靜態<xref:System.Type.GetType%2A?displayProperty=nameWithType>方法會傳回<xref:System.Type>物件，表示其完整名稱所指定的型別。  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>， <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>，並<xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType>方法會傳回`Type`代表模組中定義之類型的物件。 第一種方法可以用來取得各種<xref:System.Type>的所有公用和私用類型的模組中定義的物件。 (您可以取得的執行個體`Module`透過<xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType>或是<xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>方法，或透過<xref:System.Type.Module%2A?displayProperty=nameWithType>屬性。)  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType>物件包含數個方法來擷取組件，包括中定義的類別<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>， <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>。  
  
-   <xref:System.Type.FindInterfaces%2A>方法會傳回型別所支援的介面類型的篩選的清單。  
  
-   <xref:System.Type.GetElementType%2A>方法會傳回`Type`物件，表示項目。  
  
-   <xref:System.Type.GetInterfaces%2A>並<xref:System.Type.GetInterface%2A>方法會傳回<xref:System.Type>代表類型所支援的介面類型的物件。  
  
-   <xref:System.Type.GetTypeArray%2A>方法傳回的陣列<xref:System.Type>代表任意一組物件所指定類型的物件。 物件會指定類型的陣列與<xref:System.Object>。  
  
-   <xref:System.Type.GetTypeFromProgID%2A>和<xref:System.Type.GetTypeFromCLSID%2A>方法可供 COM 互通性。 它們會傳回<xref:System.Type>物件，表示所指定的型別`ProgID`或`CLSID`。  
  
-   <xref:System.Type.GetTypeFromHandle%2A>方法提供互通性。 它會傳回`Type`物件，表示類別的控制代碼所指定的型別。  
  
-   C#`typeof`運算子，c + +`typeid`運算子，以及 Visual Basic`GetType`運算子取得`Type`型別的物件。  
  
-   <xref:System.Type.MakeGenericType%2A>方法會傳回<xref:System.Type>物件，表示建構的泛型類型，也就是開放式建構的類型，如果其<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`，和封閉式建構類型否則。 只有當它已關閉，可以具現化泛型型別。  
  
-   <xref:System.Type.MakeArrayType%2A>， <xref:System.Type.MakePointerType%2A>，並<xref:System.Type.MakeByRefType%2A>方法會傳回<xref:System.Type>分別代表指定的型別、 指定的型別和參考參數的類型的指標陣列的物件 (`ref`以 C# `ByRef`在 Visual Basic 中)。  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>比較相等的型別物件  
 A<xref:System.Type>代表類型是唯一的物件，也就是兩個<xref:System.Type>物件參考會參考相同的物件，如果且只有它們代表相同的型別。 這是用來比較<xref:System.Type>物件，使用參考相等。 下列範例會比較<xref:System.Type>表示的整數值，以判斷它們是否相同類型的數字的物件。  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 下列範例顯示一些具代表性的功能的<xref:System.Type>。 C#`typeof`運算子 (`GetType` Visual Basic 中的運算子`typeid`Visual c + + 運算子) 用來取得<xref:System.Type>物件，表示<xref:System.String>。 從此<xref:System.Type>物件，<xref:System.Type.GetMethod%2A>方法來取得<xref:System.Reflection.MethodInfo>代表<xref:System.String.Substring%2A>多載，起始的位置和長度。  
  
 若要識別多載簽章，程式碼範例會建立暫存陣列，包含兩個<xref:System.Type>物件代表`int`(`Integer` Visual Basic 中)。  
  
> [!NOTE]
>  若要精確地說，陣列會包含兩個執行個體的參考<xref:System.Type>表示`int`目前的應用程式定義域中。 對於任何類型，沒有只有一個執行個體<xref:System.Type>每個應用程式網域。  
  
 此程式碼範例會使用<xref:System.Reflection.MethodInfo>叫用<xref:System.String.Substring%2A>方法在字串"Hello，World ！"，並顯示結果。  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <block subset="none" type="overrides">
      <para>當您繼承自<see langword="Type" />，您必須覆寫下列成員： 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">檢視類型資訊</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Type" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式是由衍生類別類型物件的建構期間叫用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得宣告此類型的 <see cref="T:System.Reflection.Assembly" />。 若為泛型類型，則取得定義此泛型類型的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <value>
          <see cref="T:System.Reflection.Assembly" /> 執行個體，描述包含目前類型的組件。 若為泛型類型，則此執行個體描述的是含有泛型類型定義的組件，而不是建立與使用特定建構類型的組件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>物件代表建構的泛型型別，這個屬性會傳回包含泛型型別定義的組件。 例如，假設您建立名為 MyGenerics.dll 包含泛型型別定義的組件`MyGenericStack<T>`(`MyGenericStack(Of T)` Visual Basic 中`generic<T> ref class MyGenericStack`c + + 中)。 如果您建立的執行個體`MyGenericStack<int>`(`MyGenericStack(Of Integer)` Visual Basic 中) 中另一個組件，<xref:System.Type.Assembly%2A>建構類型的屬性會傳回<xref:System.Reflection.Assembly>表示 MyGenerics.dll 物件。  
  
 同樣地，如果目前<xref:System.Type>物件表示未指派的泛型參數`T`，這個屬性會傳回包含泛型型別定義的組件`T`。  
  
 如果<xref:System.Type.Assembly%2A?displayProperty=nameWithType>屬性並不適用於特定的.NET 實作，例如.NET Core 或通用 Windows 平台，請使用<xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>屬性改為。      
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會顯示與類別相關聯的組件名稱和型別的完整的名稱。  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得類型的組件限定名稱，包含載入 <see cref="T:System.Type" /> 的組件名稱。</summary>
        <value>
          <see cref="T:System.Type" /> 的組件限定名稱，包含載入 <see cref="T:System.Type" /> 的組件名稱，如果目前的執行個體表示泛型類型參數，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型的組件限定名稱是由型別名稱，包括其命名空間，後面接著逗號，後面接著組件的顯示名稱所組成。 使用取得組件的顯示名稱<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。 請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
 支援通用語言執行平台的所有編譯器都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|逗號 （，）|後面接著組件名稱。|  
|加號 （+）|在之前的巢狀的類別。|  
|句號 （.）|表示命名空間識別項。|  
|括號 ([])|在類型名稱之後，即表示該類型的陣列。<br /><br /> -或-<br /><br /> 對於泛型類型，封入泛型型別引數清單。<br /><br /> -或-<br /><br /> 在類型引數清單中，將組件限定型別。|  
  
 例如，類別的組件限定名稱可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 如果命名空間包含加號時，例如 TopNamespace.Sub+Namespace 則加號 （+） 會加上逸出字元 (\\) 以防止它被解譯為巢狀分隔符號。 反映會發出此字串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 "+ +"會變成"\\+\\+"，和 「\\」 變成 「\\\\"。  
  
 這個限定的名稱可以保存和更新版本用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>使用型別名稱只有或使用組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與型別名稱只會尋找<xref:System.Type>呼叫者的組件中，然後在系統組件中。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 類型名稱可能包含行尾字元來表示的類型，例如類型是否為參考型別、 指標類型或陣列類型的其他資訊。 若要擷取的型別名稱，而不需要這些後置字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。  
  
 空格是相關的組件名稱以外的所有型別名稱元件。 在組件名稱 '，' 分隔符號之前的空格是相關的但是 '，' 分隔符號之後的空格會被忽略。  
  
 泛型引數的泛型型別本身都是由組件名稱所限定。 例如，在組件限定類型名稱`MyGenericClass<int>`(`MyGenericClass(Of Integer)` Visual Basic 中)，`int`展開的組件限定類型名稱為<xref:System.Int32>。  
  
 如果目前<xref:System.Type>物件代表泛型參數，則這個屬性會傳回`null`。  
  
   
  
## Examples  
 下列範例會顯示與類別相關聯的組件名稱和型別的完整的名稱。  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與 <see cref="T:System.Type" /> 關聯的屬性。</summary>
        <value>代表 <see cref="T:System.Reflection.TypeAttributes" /> 屬性集的 <see cref="T:System.Type" /> 物件；若 <see cref="T:System.Type" /> 代表的是泛型型別參數，則這個值就是未指定的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些成員<xref:System.Reflection.TypeAttributes>列舉型別都代表一組值的遮罩。 每個群組包含一個成員，其基礎值為零。 比方說，基礎值的<xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType>中的成員<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>群組為零，因為<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>中的成員<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>群組。 基於這個原因，您必須使用之前先測試這些值的遮罩。 這個範例將提供說明。  
  
> [!TIP]
>  大部分用途而言，屬性，例如<xref:System.Type.IsClass%2A>，<xref:System.Type.IsAutoLayout%2A>，和<xref:System.Type.IsSpecialName%2A>容易使用與型別屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性傳回的泛型類型定義的屬性。 例如，將傳回的屬性`MyGenericClass<int>`(`MyGenericClass(Of Integer)` Visual Basic 中) 的屬性是`MyGenericClass<T>`(`MyGenericClass(Of T)` Visual Basic 中)。  
  
 如果目前<xref:System.Type>代表泛型類型參數，也就是如果<xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`—<xref:System.Reflection.TypeAttributes>未指定這個屬性所傳回的值。  
  
   
  
## Examples  
 下列範例使用<xref:System.Type.Attributes%2A>屬性。  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 所直接繼承的類型。</summary>
        <value>目前 <see cref="T:System.Type" /> 直接繼承自的 <see cref="T:System.Type" />，如果目前 <see langword="null" /> 表示 <see langword="Type" /> 類別或介面，則為 <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基底型別是從其目前的型別直接繼承的型別。 <xref:System.Object> 是唯一的類型，並沒有基底類型，因此`null`會傳回基底型別<xref:System.Object>。  
  
 介面繼承自零或多個基底介面。因此，這個屬性會傳回`null`如果`Type`物件表示的介面。 基底介面可以判斷與<xref:System.Type.GetInterfaces%2A>或<xref:System.Type.FindInterfaces%2A>。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，基底型別反映的泛型引數。 例如，請考慮下列宣告：  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 建構的類型`C<int>`(`C(Of Integer)` Visual Basic 中)，則<xref:System.Type.BaseType%2A>屬性會傳回`B<int>`。  
  
 如果目前<xref:System.Type>代表的泛型類型定義的型別參數<xref:System.Type.BaseType%2A>傳回類別條件約束，也就是將型別參數必須繼承的類別。 如果沒有類別條件約束中，<xref:System.Type.BaseType%2A>傳回<xref:System.Object?displayProperty=nameWithType>。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Type.BaseType%2A>屬性。  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 下列範例會使用遞迴來列出每個類別的組件中找到完整的繼承階層架構。 此範例會定義名為類別`C`衍生自類別，名為`B`，它會接著衍生自類別，名為`A`。  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，該值指出目前的 <see cref="T:System.Type" /> 物件是否有尚未被特定類型取代的類型參數。</summary>
        <value>如果 <see langword="true" /> 物件本身為泛型類型參數或包含尚未提供特定類型的類型參數則為 <see cref="T:System.Type" />否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立類型的執行個體，必須沒有泛型類型定義或開放式建構的類型中的類型引數型別本身，在任何封入泛型型別，或在任何項目型別。 另一種說法是，當檢查以遞迴方式、 型別必須包含沒有泛型類型參數。  
  
 因為類型可能很複雜，做出這個決定並不容易。 為了方便起見，並減少錯誤的機會<xref:System.Type.ContainsGenericParameters%2A>屬性會提供標準的方式來區別封閉式建構類型，可以具現化，並開啟建構類型，不能。 如果<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`，類型無法具現化。  
  
 <xref:System.Type.ContainsGenericParameters%2A>以遞迴方式型別參數的屬性搜尋。 例如，它會傳回`true`其項目是型別陣列`A<T>`(`A(Of T)` Visual Basic 中)，即使陣列不是泛型本身。 與此相反的行為與<xref:System.Type.IsGenericType%2A>屬性，會傳回`false`陣列。  
  
 範例類別和一個表格，顯示的值的一組<xref:System.Type.ContainsGenericParameters%2A>屬性，請參閱<xref:System.Type.IsGenericType%2A>。  
  
   
  
## Examples  
 下列範例定義具有兩個類型參數的泛型類別，並接著定義第二個泛型類別衍生自第一個類別。 在衍生的類別的基底類別具有兩個類型引數： 第一個是<xref:System.Int32>第二個是衍生型別的型別參數。 此範例會顯示這些泛型類別的相關資訊，包括位置報告<xref:System.Type.GenericParameterPosition%2A>屬性。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果目前的 <see cref="T:System.Reflection.MethodBase" /> 表示泛型方法的類型參數，則取得表示宣告方法的 <see cref="T:System.Type" />。</summary>
        <value>如果目前的 <see cref="T:System.Type" /> 表示泛型方法的類型參數，則為表示宣告方法的 <see cref="T:System.Reflection.MethodBase" />否則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 宣告的方法是泛型方法定義。 也就是說，如果<xref:System.Type.DeclaringMethod%2A>不會傳回`null`，然後`DeclaringMethod.IsGenericMethodDefinition`傳回`true`。  
  
 <xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性識別的泛型型別定義或泛型類型參數原本定義所在的泛型方法定義：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>，、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件都代表該泛型方法定義的型別參數。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，則<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。  
  
-   取得<xref:System.Type.DeclaringMethod%2A>型別上的屬性其<xref:System.Type.IsGenericParameter%2A>屬性是`false`就會擲回<xref:System.InvalidOperationException>。  
  
 <xref:System.Reflection.MethodBase>傳回的<xref:System.Type.DeclaringMethod%2A>屬性是<xref:System.Reflection.MethodInfo>如果是泛型方法，或<xref:System.Reflection.ConstructorInfo>在泛型建構函式的情況下。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，不支援泛型建構函式。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例會定義泛型方法，將型別引數指派給該方法，並叫用產生的建構泛型方法的類別。 它也會顯示泛型方法定義和建構的方法的相關資訊。 當顯示的相關資訊的型別參數的泛型方法定義，在`DisplayGenericMethodInfo`方法，範例程式碼顯示的值<xref:System.Type.DeclaringMethod%2A>方法的泛型類型參數的屬性。  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得宣告目前巢狀類型或泛型型別參數的類型。</summary>
        <value>若目前的類型是巢狀類型，即為表示封入類型的 <see cref="T:System.Type" /> 物件，若目前的類型是泛型類型的類型參數，則為泛型類型定義，而若目前的類型是泛型方法的類型參數，則為宣告泛型方法的類型，若以上皆否，便為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>物件表示泛型型別的型別參數，則這個屬性會傳回泛型型別定義。  
  
 如果目前<xref:System.Type>物件代表泛型方法的類型參數，這個屬性會傳回包含泛型方法定義的型別。 如果類型是泛型，則會傳回泛型型別定義。 也就是說，下列程式碼會傳回的泛型類型定義<xref:System.Collections.Generic.List%601>泛型類別，其中包含<xref:System.Collections.Generic.List%601.ConvertAll%2A>泛型方法：  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 如果目前<xref:System.Type>表示泛型類型或泛型方法定義中的類型參數<xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性可識別其中泛型型別參數的泛型型別定義或泛型方法定義原本定義：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>，、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件都代表該泛型方法定義的型別參數。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，則<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。  
  
-   取得<xref:System.Type.DeclaringType%2A>型別上的屬性其<xref:System.Type.IsGenericParameter%2A>屬性是`false`就會擲回<xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 此範例中會顯示在衍生類別中方法的宣告型別。  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得預設繫結器 (Binder) 的參考，它會實作內部規則來選取由 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> 呼叫的適當成員。</summary>
        <value>系統使用的預設繫結器之參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設繫結器提供與 common language runtime 是適用於所有最特殊的情況下除外。 如果您需要不同於提供的預設繫結器，如下所示規則定義的繫結器型別衍生自<xref:System.Reflection.Binder>類別，並將該類型使用的執行個體傳遞`binder`參數的其中一個<xref:System.Type.InvokeMember%2A>多載。  
  
 反映模型一般類型系統的存取範圍規則。 比方說，如果呼叫端在相同的組件中，呼叫端不會不需要特殊權限的內部成員。 否則，呼叫端需要<xref:System.Security.Permissions.ReflectionPermission>。 這是一致的受保護的成員查閱、 私用等等。  
  
 一般原則是<xref:System.Reflection.Binder.ChangeType%2A>擴展轉換，不會遺失資料只應該執行。 擴展轉換的範例轉換為 64 位元帶正負號的整數值的 32 位元帶正負號的整數的值。 這被區別縮小轉換，可能會遺失資料。 縮小轉換的範例 32 位元帶正負號的整數轉換為 64 位元帶正負號的整數。  
  
 下表列出預設繫結器所支援的轉換。  
  
|來源類型|目標類型|  
|-----------------|-----------------|  
|任何型別|基底類型。|  
|任何型別|它所實作的介面。|  
|Char|Unt16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double|  
|Byte|Char、 Unt16、 Int16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double|  
|SByte|Int16、Int32、Int64、Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64、Single、Double|  
|Int16|Int32、Int64、Single、Double|  
|UInt32|UInt64、Int64、Single、Double|  
|Int32|Int64、Single、Double|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|Double|  
|非參考|參考。|  
  
   
  
## Examples  
 下列範例會取得預設繫結器，從`DefaultBinder`屬性，並叫用 MyClass 的成員，藉由傳遞`DefaultBinder`做為參數的值<xref:System.Type.InvokeMember%2A>。  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>分隔 <see cref="T:System.Type" /> 的命名空間中的名稱。 此欄位為唯讀。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.Type" /> 類型的空陣列。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例所示`EmptyTypes`欄位中的其中一個使用`GetConstructor`方法，以取得不採用任何參數的建構函式。  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷目前 <see cref="T:System.Type" /> 的基礎系統類型，是否與指定的 <see cref="T:System.Object" /> 或 <see cref="T:System.Type" /> 的基礎系統類型相同。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">其基礎系統類型將與目前 <see cref="T:System.Type" /> 的基礎系統類型比較的物件。 為使比較成功，<c>o</c> 必須可以轉型或轉換為 <see cref="T:System.Type" /> 型別的物件。</param>
        <summary>判斷目前 <see cref="T:System.Type" /> 物件的基礎系統類型，是否與指定的 <see cref="T:System.Object" /> 的基礎系統類型相同。</summary>
        <returns>如果 <see langword="true" /> 的基礎系統類型與目前 <paramref name="o" /> 的基礎系統類型相同，則為 <see cref="T:System.Type" />否則為 <see langword="false" />。 下列條件成立時，此方法也會傳回 <see langword="false" />：  
  
-   <paramref name="o" /> 為 <see langword="null" />。  
  
-   <paramref name="o" /> 無法轉換為 <see cref="T:System.Type" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。 它會轉換`o`物件的型別<xref:System.Type>，並呼叫<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.Equals%28System.Object%29>來比較各種<xref:System.Type>物件執行個體，使用各種<xref:System.Object>執行個體。  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 特別值得一提的相關範例，是兩件事：  
  
-   比較<xref:System.Type>物件，表示整數<xref:System.Reflection.TypeInfo>物件，表示傳回的整數`true`因為<xref:System.Reflection.TypeInfo>衍生自<xref:System.Type>。  
  
-   比較<xref:System.Type>物件，表示<xref:System.Collections.Generic.IList%601>物件 （開放式的泛型型別）`List(Of String)`物件 （封閉式泛型型別） 傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">其基礎系統類型將與目前 <see cref="T:System.Type" /> 的基礎系統類型比較的物件。</param>
        <summary>判斷目前 <see cref="T:System.Type" /> 的基礎系統類型，是否與指定的 <see cref="T:System.Type" /> 之基礎系統類型相同。</summary>
        <returns>如果 <see langword="true" /> 的基礎系統類型與目前 <paramref name="o" /> 的基礎系統類型相同，則為 <see cref="T:System.Type" />否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會使用`Equals`來比較兩個型別。  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用在屬性 (Attribute) 上的成員篩選條件。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此欄位保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。 這個委派所封裝方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件的第二個則`Object`。 這個方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。 `Object`可能會指派任何一種類別欄位的值<xref:System.Reflection.FieldAttributes>， <xref:System.Reflection.MethodAttributes>，或<xref:System.Reflection.MethodImplAttributes>。  
  
 例如，`Object`可以從欄位的值指派給`FieldAttributes`例如 Public。 在此情況下，當`FilterAttribute`叫用委派時，它會傳回`true`所表示的方法時，才`MemberInfo`物件以公用欄位屬性裝飾中繼資料中。  
  
   
  
## Examples  
 下列範例會取得`FilterAttribute`委派，將它傳遞做為參數<xref:System.Type.FindMembers%2A>方法，並顯示指定的成員和其屬性。  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用於名稱上的有區分大小寫的成員篩選條件。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此欄位保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。 這個委派所封裝方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件的第二個則`Object`。 這個方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。 `Object`指派字串值，其中可能包含尾端"*"萬用字元。 只有萬用字元結束字串支援比對。  
  
 比方說，`Object`可能會將值指派給 「 位元組 *"。 在此情況下，當`FilterName`叫用委派時，它會傳回`true`所表示的方法時，才`MemberInfo`物件具有名稱開頭為"Byte"。  
  
   
  
## Examples  
 下列程式碼範例會取得相關聯的使用者定義的方法`Application`型別。  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用在名稱上的不區分大小寫的成員篩選條件。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此欄位保留所使用的委派的參考<xref:System.Type.FindMembers%2A>方法。 這個委派所封裝方法會採用兩個參數： 第一個是<xref:System.Reflection.MemberInfo>物件的第二個則`Object`。 這個方法會判斷是否`MemberInfo`物件名稱符合所指定的準則`Object`。 `Object`指派字串值，其中可能包含尾端"*"萬用字元。 只有萬用字元結束字串支援比對。  
  
 比方說，`Object`可能會將值指派給 「 位元組 *"。 在此情況下，當`FilterName`叫用委派時，它只會傳回，則為 true 所表示的方法如果`MemberInfo`物件具有名稱開頭為"byte"，忽略大小寫。  
  
   
  
## Examples  
 下列範例會取得`MemberFilter`委派，將它傳遞做為參數<xref:System.Type.FindMembers%2A>方法，並顯示方法和其屬性`String`開頭字母"c"，忽略大小寫的類別。  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">根據 <c>filterCriteria</c> 比較介面的委派。</param>
        <param name="filterCriteria">判斷在傳回陣列中是否應包含介面的搜尋準則。</param>
        <summary>傳回 <see cref="T:System.Type" /> 物件的陣列，表示由目前 <see cref="T:System.Type" /> 所實作或繼承的介面的篩選清單。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，表示由目前的 <see cref="T:System.Type" /> 所實作或繼承之介面的篩選清單，如果由目前的 <see cref="T:System.Type" /> 所實作或繼承之介面都不符合篩選器，則為 <see cref="T:System.Type" /> 的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫此方法。  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>並<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>所提供的委派<xref:System.Reflection.Module?displayProperty=nameWithType>類別可能也會使用，在的 lieu<xref:System.Reflection.TypeFilter?displayProperty=nameWithType>委派。  
  
 所有由這個類別所實作的介面會被視為在搜尋期間，是否為基底類別或此類別本身所宣告。  
  
 這個方法會搜尋基底類別階層中，傳回每個相符的介面以及所有比對的每個類別會實作這些介面實作的每個介面 （也就是會傳回相符的介面的遞移封閉）。 會不傳回任何重複的介面。  
  
 如果目前<xref:System.Type>表示泛型類型或泛型方法定義中的類型參數<xref:System.Type.FindInterfaces%2A>搜尋所有介面在宣告類型參數條件約束，並透過介面繼承的所有介面在條件約束中宣告。 如果目前<xref:System.Type>代表泛型類型的類型引數<xref:System.Type.FindInterfaces%2A>是否符合條件約束，搜尋所有的型別所實作的介面。  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> 可傳回泛型介面，即使在不是泛型的型別上。 例如，可能會實作非泛型型別`IEnumerable<int>`(`IEnumerable(Of Integer)` Visual Basic 中)。  
  
   
  
## Examples  
 下列範例會尋找指定的介面實作或繼承之指定的類型，並接著會顯示介面名稱。  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">靜態初始設定式已叫用並擲回了例外狀況。</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">物件，表示要搜尋的成員類型。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="filter">執行比較的委派，如果目前進行檢查的成員符合 <c>filterCriteria</c>，則傳回 <see langword="true" />；否則傳回 <see langword="false" />。 您可以使用這個類別所提供的 <see langword="FilterAttribute" />、<see langword="FilterName" /> 和 <see langword="FilterNameIgnoreCase" /> 委派。 第一個委派使用 <see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的欄位做為搜尋準則，而其他兩個委派則使用 <see langword="String" /> 物件做為搜尋準則。</param>
        <param name="filterCriteria">判斷在 <see langword="MemberInfo" /> 物件的陣列中是否傳回成員的搜尋準則。  
  
<see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的欄位可以與這個類別所提供的 <see langword="FilterAttribute" /> 委派結合使用。</param>
        <summary>傳回指定成員類型的 <see cref="T:System.Reflection.MemberInfo" /> 物件的篩選陣列。</summary>
        <returns>指定之成員類型的 <see cref="T:System.Reflection.MemberInfo" /> 物件篩選陣列。  
  
-或- 
<see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列，如果目前 <see cref="T:System.Type" /> 沒有符合篩選條件的 <paramref name="memberType" /> 類型的成員。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫此方法。  
  
 成員包含屬性、 方法、 欄位、 事件等等。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的成員：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Instance`来包含在搜尋中的執行個體成員。  
  
-   指定`BindingFlags.Static`要在搜尋中包含靜態成員。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只在宣告的成員，才<xref:System.Type>，不只是繼承的成員。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 有效值<xref:System.Type.MemberType%2A>中所定義<xref:System.Reflection.MemberInfo>。 如果找不到任何這類成員，則會傳回空陣列。  
  
 若要取得使用此方法的類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>表示泛型類型或泛型方法的類型參數<xref:System.Type.FindMembers%2A>處理任何由類別條件約束和介面條件約束的型別參數宣告的成員。  
  
   
  
## Examples  
 下列範例會尋找符合指定的搜尋準則，類別中的所有成員，並接著會顯示相符的成員。  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得類型的完整名稱 (包括其命名空間，但不包括其組件)。</summary>
        <value>類型的完整名稱 (包括其命名空間，但不包括其組件)；如果目前執行個體代表泛型類型參數、陣列類型、指標類型、根據類型參數的 <see langword="null" /> 類型，或不是泛型類型定義但包含未解析類型參數的泛型類型，則為 <see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，完整的名稱的<xref:System.String>型別是`System.String`。 這與傳回的組件限定名稱相反<xref:System.Type.AssemblyQualifiedName%2A>屬性，其中包含的完整名稱，再加上完整的組件名稱。  
  
 如果目前的型別代表封閉泛型型別，在字串中的類型引數傳回<xref:System.Type.FullName%2A>屬性是其完整的組件名稱限定，即使所有未限定的泛型型別本身的字串表示組件名稱。 下列範例說明代表泛型類型定義的類型，而另一個代表封閉泛型類型的 FullName 屬性中的差異。  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 這個屬性會傳回`null`如果：  
  
-   目前<xref:System.Type>物件代表泛型型別的型別參數。  
  
     下列範例會擷取的型別參數<xref:System.Nullable%601>型別，並且嘗試顯示其<xref:System.Type.FullName%2A>屬性。  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   目前<xref:System.Type>物件都代表陣列類型、 指標類型或`byref`為基礎的泛型類型參數的型別。  
  
     下列範例會定義泛型型別， `Generictype1<T>`，以三個方法： `Display(T[])`，傳遞的型別 T，陣列`HandleT(T)`，傳遞 T 物件和`ChangeValue(ref T)`，這傳址方式傳遞的 T 物件。 因為 C# 和 Visual Basic 不允許我們定義 T 中的指標`HandleT`方法中，我們必須呼叫<xref:System.Type.MakePointerType%2A>方法<xref:System.Type>物件，表示方法的參數類型，若要建立泛型類型的指標。 範例輸出所顯示的是，所有的三種情況下，在<xref:System.Type.FullName%2A>屬性是`null`。  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   目前的型別包含有尚未被特定類型取代的泛型類型參數 (亦即<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`)，但類型不是泛型類型定義 (也就是<xref:System.Type.IsGenericTypeDefinition%2A>屬性會傳回 `false`  
  
     在下列範例中，`Derived<T>`繼承自`Base<T>`。 <xref:System.Type.BaseType%2A>屬性取得<xref:System.Type>物件，代表基底型別`Derived<T>`，並將其<xref:System.Type.FullName%2A>屬性會傳回`null`。  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     若要取得<xref:System.Type.FullName%2A>不是`null`，您可以使用<xref:System.Type.GetGenericTypeDefinition%2A>方法以取得泛型型別定義，如範例所示。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會顯示指定之型別的完整名稱。  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得一組 <see cref="T:System.Reflection.GenericParameterAttributes" /> 旗標，敘述目前泛型類型參數的共變數與特殊條件約束。</summary>
        <value>
          <see cref="T:System.Reflection.GenericParameterAttributes" /> 值的位元組合，描述目前泛型型別參數的共變數和特殊條件約束。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的值包含旗標，敘述目前泛型類型參數是否是 covariant 和其他特殊條件約束的旗標。 使用 <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType>值加入選取的共變數旗標，並使用<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType>選取條件約束旗標的值。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例會定義泛型型別`Test`具有兩個具有不同的條件約束的型別參數。 當程式執行時，條件約束會檢查使用<xref:System.Type.GenericParameterAttributes%2A>屬性和<xref:System.Type.GetGenericParameterConstraints%2A>方法。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前的 <see cref="T:System.Type" /> 物件不是泛型型別參數。 亦即，<see cref="P:System.Type.IsGenericParameter" /> 屬性會傳回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當 <see cref="T:System.Type" /> 物件表示泛型類型或泛型方法的型別參數時，在宣告參數的泛型類型或泛型方法之型別參數清單中，取得型別參數的位置。</summary>
        <value>型別參數在宣告參數的泛型類型或方法之型別參數清單中的位置。 位置編號從 0 開始。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A>屬性會傳回型別參數的位置中的泛型型別定義或泛型方法定義的參數清單的型別參數原本定義。 <xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>屬性識別的泛型型別或方法定義：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回<xref:System.Reflection.MethodInfo>，、 該<xref:System.Reflection.MethodInfo>代表泛型方法定義，以及目前<xref:System.Type>物件都代表該泛型方法定義的型別參數。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>屬性會傳回`null`，則<xref:System.Type.DeclaringType%2A>屬性一律會傳回<xref:System.Type>物件，代表泛型類型定義和目前<xref:System.Type>物件都代表該泛型類型的型別參數定義。  
  
 若要提供正確的內容值的<xref:System.Type.GenericParameterPosition%2A>屬性，就必須找出的泛型類型或方法所屬的型別參數。 例如，請考慮泛型方法的傳回值`GetSomething`下列程式碼：  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 傳回的型別`GetSomething`取決於提供給類別的型別引數`A`以及`GetSomething`本身。 您可以取得<xref:System.Reflection.MethodInfo>針對`GetSomething`，以及您可以從所取得的傳回型別。 當您檢查型別參數的傳回型別，<xref:System.Type.GenericParameterPosition%2A>兩者會傳回 0。 位置`V`為 0，因為`V`類別的型別參數清單中的第一個型別參數`A`。 位置`X`為 0，因為`X`的型別參數清單中的第一個型別參數`GetSomething`。  
  
> [!NOTE]
>  呼叫<xref:System.Type.GenericParameterPosition%2A>屬性會造成例外狀況，如果目前<xref:System.Type>不代表型別參數。 當您檢查開放式建構類型的類型引數時，使用<xref:System.Type.IsGenericParameter%2A>告訴它們在型別參數，以及這是類型的屬性。 <xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`型別參數; 您可以接著使用<xref:System.Type.GenericParameterPosition%2A>方法來取得它的位置，並使用<xref:System.Type.DeclaringMethod%2A>和<xref:System.Type.DeclaringType%2A>來判斷泛型方法或類型定義中定義的屬性.  
  
   
  
## Examples  
 下列範例會定義具有兩個類型參數的泛型類別，並定義第二個泛型類別衍生自第一個類別。 在衍生的類別的基底類別具有兩個類型引數： 第一個是<xref:System.Int32>，第二個是衍生型別的型別參數。 此範例會顯示這些泛型類別的相關資訊，包括位置報告<xref:System.Type.GenericParameterPosition%2A>屬性。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前類型不代表型別參數。 亦即，<see cref="P:System.Type.IsGenericParameter" /> 會傳回 <see langword="false" />。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此類型之泛型型別引數的陣列。</summary>
        <value>這個類型之泛型型別引數的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會取得僅泛用型別引數;也就是由目前類型的泛型型別參數尚未指定的類型。 如果目前的類型是泛型類型定義，則這個屬性會傳回空陣列。  
  
> [!NOTE]
>  如果另一種泛型類型或泛型方法中使用泛型型別，則其泛型型別引數的一些可能的封入方法或類型的泛型型別參數。  
  
 若要取得的類型，代表泛型類型定義的泛型類型參數，請使用<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>屬性。 若要取得<xref:System.Reflection.TypeInfo>目前的物件<xref:System.Type>物件，請使用<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>擴充方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得陣列中的維度數目。</summary>
        <returns>包含目前類型中之維度數目的整數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示在陣列中的維度數目。  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個方法的功能不受基底類別的支援，因此必須改為在衍生類別中實作。</exception>
        <exception cref="T:System.ArgumentException">目前的類型不是陣列。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.Attributes" /> 屬性並取得位元遮罩，指示與 <see cref="T:System.Type" /> 關聯的屬性。</summary>
        <returns>
          <see cref="T:System.Reflection.TypeAttributes" /> 物件，代表 <see cref="T:System.Type" /> 的屬性集。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的特定建構函式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">由 <see cref="T:System.Type" /> 物件組成的陣列，表示所要建構函式參數的數目、順序和類型。  
  
-或- 
由 <see cref="T:System.Type" /> 物件組成的空陣列，用來取得不需任何參數的建構函式。 這種供陣列是由 <see langword="static" /> 欄位 <see cref="F:System.Type.EmptyTypes" /> 提供的。</param>
        <summary>搜尋其參數符合在指定陣列中的類型的公用執行個體建構函式。</summary>
        <returns>物件，表示其參數符合參數類型陣列中之類型的公用執行個體建構函式 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載會尋找公用的執行個體建構函式，並無法用來取得類別初始設定式 (.cctor)。 若要取得類別初始設定式，使用多載採用<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果要求的建構函式為非公用，則這個方法會傳回`null`。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有由適當的型別引數取代型別參數。 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法永遠傳回`null`。  
  
   
  
## Examples  
 下列範例會取得的型別`MyClass`，取得<xref:System.Reflection.ConstructorInfo>物件，並顯示建構函式簽章。  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。  
  
-或- 
用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。  
  
-或- 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，代表在參數類型陣列中與對應項目關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束 (Constraint) 搜尋其參數符合指定的引數類型和修飾詞 (Modifier) 的建構函式。</summary>
        <returns>
          <see cref="T:System.Reflection.ConstructorInfo" /> 物件，代表符合指定之需求的建構函式 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`，就可以選取 相符項目陣列。 如果`binder`無法選取相符項目，然後`null`會傳回。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的建構函式：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有由適當的型別引數取代型別參數。 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法永遠傳回`null`。  
  
   
  
## Examples  
 下列程式會取得的型別`MyClass1`類別，取得<xref:System.Reflection.ConstructorInfo>物件比對指定的繫結旗標，並顯示建構函式的簽章。  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。  
  
-或- 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="callConvention">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及清除堆疊。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。  
  
-或- 
用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束和指定的呼叫慣例，搜尋其參數符合指定的引數類型和修飾詞的建構函式。</summary>
        <returns>物件，代表符合指定之需求的建構函式 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`，就可以選取 相符項目陣列。 如果`binder`無法選取相符項目，然後`null`會傳回。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的建構函式：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用此方法的類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有由適當的型別引數取代型別參數。 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個方法永遠傳回`null`。  
  
   
  
## Examples  
 下列範例會取得的型別`MyClass1`，取得<xref:System.Reflection.ConstructorInfo>符合指定的繫結旗標，並顯示建構函式簽章的物件。  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。  
  
-或- 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="callConvention">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及清除堆疊。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之建構函式的參數數目、順序和類型。  
  
-或- 
用以取得沒有參數的建構函式之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束和指定的呼叫慣例，搜尋其參數符合指定的引數類型和修飾詞的建構函式。</summary>
        <returns>
          <see cref="T:System.Reflection.ConstructorInfo" /> 物件，代表符合指定之需求的建構函式 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`，就可以選取 相符項目陣列。 如果`binder`無法選取相符項目，然後`null`會傳回。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的建構函式：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 這個方法會實作 <xref:System.Type.GetConstructor%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。  
  
-或- 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <exception cref="T:System.NotSupportedException">目前的類型為 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的建構函式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回所有定義給目前 <see cref="T:System.Type" /> 的公用建構函式。</summary>
        <returns>由 <see cref="T:System.Reflection.ConstructorInfo" /> 物件組成的陣列，表示定義給目前 <see cref="T:System.Type" /> 的所有公用執行個體建構函式，但不含類型初始設定式 (靜態建構函式)。 如果目前的 <see cref="T:System.Type" /> 沒有定義任何公用執行個體建構函式，或目前的 <see cref="T:System.Type" /> 表示泛型類型或泛型方法定義中的型別參數，則會傳回 <see cref="T:System.Reflection.ConstructorInfo" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>方法不會傳回特定的順序，例如依宣告順序的建構函式。 您的程式碼不得相依於建構函式會傳回的順序，因為順序不同。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 這個方法多載會呼叫<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>方法多載，以<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> Visual Basic 中)。 它將無法找到類別初始設定式 (.cctor)。 類別初始設定式，請使用採用多載<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有由適當的型別引數取代型別參數的物件。 例如，如果類別`C<T>`的建構函式`C(T t1)`(`Sub New(ByVal t1 As T)`在 Visual Basic 中)，則呼叫<xref:System.Type.GetConstructors%2A>上`C<int>`傳回<xref:System.Reflection.ConstructorInfo>表示`C(int t1)`C# 中 (`Sub New(ByVal t1 As Integer)` Visual Basic 中)。  
  
 如果目前<xref:System.Type>代表泛型類型參數，<xref:System.Type.GetConstructors%2A>方法會傳回空陣列。  
  
   
  
## Examples  
 此範例中顯示的輸出<xref:System.Type.GetConstructors%2A>自類別具有兩個執行個體建構函式和一個靜態的建構函式多載。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 此程式碼的輸出為：  
  
 2  
  
 False  
  
 False  
  
 因為<xref:System.Type.GetConstructors>只會使用多載<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>並<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，靜態建構函式都不會計算所`for`運算式評估，也不`IsStatic`。  
  
 若要尋找靜態建構函式，請使用<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>多載，並傳遞組合 (邏輯`OR`) 的<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，如下列程式碼範例所示：  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 現在則輸出為：  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的 <see cref="T:System.Type" />，搜尋定義給目前 <see langword="BindingFlags" /> 的建構函式。</summary>
        <returns>
          <see cref="T:System.Reflection.ConstructorInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有建構函式，包括類型初始設定式 (如果已定義)。 如果目前的 <see cref="T:System.Reflection.ConstructorInfo" /> 沒有定義建構函式，或所定義的建構函式都不符合繫結條件約束，或目前的 <see cref="T:System.Type" /> 表示泛型類型或泛型方法定義中的型別參數，則傳回 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>方法不會傳回特定的順序，例如依宣告順序的建構函式。 您的程式碼不得相依於建構函式會傳回的順序，因為順序不同。  
  
 `bindingAttr` 可用來指定是否要傳回只有公用建構函式或公用和非公用建構函式。  
  
 如果沒有完全相符，`binder`會嘗試強制轉型中指定的參數類型`types`，就可以選取 相符項目陣列。 如果`binder`無法選取相符項目，然後`null`會傳回。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的建構函式：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用建構函式。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用建構函式 （也就是私用、 內部和受保護建構函式）。 不會傳回基底類別建構函式。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.ConstructorInfo>具有由適當的型別引數取代型別參數的物件。 例如，如果類別`C<T>`的建構函式`C(T t1)`(`Sub New(ByVal t1 As T)`在 Visual Basic 中)，則呼叫<xref:System.Type.GetConstructors%2A>上`C<int>`傳回<xref:System.Reflection.ConstructorInfo>表示`C(int t1)`C# 中 (`Sub New(ByVal t1 As Integer)` Visual Basic 中)。  
  
 如果目前<xref:System.Type>代表泛型類型參數，<xref:System.Type.GetConstructors%2A>方法會傳回空陣列。  
  
   
  
## Examples  
 此範例中顯示的輸出<xref:System.Type.GetConstructors>自類別具有兩個執行個體建構函式和一個靜態的建構函式多載。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 此程式碼的輸出為：  
  
 2  
  
 False  
  
 False  
  
 因為<xref:System.Type.GetConstructors%2A>只會使用多載<xref:System.Reflection.BindingFlags.Public>並<xref:System.Reflection.BindingFlags.Instance>，靜態建構函式都不會計算所`for`運算式評估，也不`IsStatic`。  
  
 若要尋找靜態建構函式，請使用<xref:System.Type.GetConstructors%2A>多載，並將它傳遞 (邏輯 OR) 的組合<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，如下列程式碼範例所示：  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 現在則輸出為：  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>搜尋定義給目前 <see cref="T:System.Type" /> 的成員，而它的 <see cref="T:System.Reflection.DefaultMemberAttribute" /> 已設定。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有預設成員。  
  
-或- 
<see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有預設成員)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A>方法不會傳回成員以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 在衍生類別可以覆寫此方法。  
  
 成員包含屬性、 方法、 欄位、 事件等等。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有由適當的型別引數取代型別參數的物件。 比方說，如果類別`C<T>`具有屬性`P`會傳回`T`，則呼叫<xref:System.Type.GetDefaultMembers%2A>上`C<int>`傳回`int P`在 C# (`Property P As Integer` Visual Basic 中)。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的成員或成員<xref:System.Object>是否沒有類別條件約束。  
  
   
  
## Examples  
 下列範例會取得的預設成員資訊`MyClass`並顯示的預設成員。  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，傳回由目前陣列、指標或參考類型所包含或參考物件的 <see cref="T:System.Type" />。</summary>
        <returns>目前的陣列、指標或參考類型所內含或參考之物件的 <see cref="T:System.Type" />，如果目前的 <see langword="null" /> 不是陣列或指標、未以傳址方式傳遞，或表示泛型類型或泛型類型或泛型方法定義中之類型參數，則為 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回`null`針對<xref:System.Array>類別。  
  
   
  
## Examples  
 下列範例示範如何使用`GetElementType`方法。  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要擷取其名稱的值。</param>
        <summary>針對目前的列舉類型，傳回具有指定值之常數的名稱。</summary>
        <returns>具有指定值之目前列舉類型的成員名稱，如果找不到這類常數，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。  
  
-或- 
 <paramref name="value" /> 既不是目前類型，也沒有相同的基礎類型做為目前類型。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前列舉類型之成員的名稱。</summary>
        <returns>包含列舉之成員名稱的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回值陣列的項目會依列舉常數的二進位值 （也就是不帶正負號的值） 排序。 如果陣列包含具有相同值的列舉的常數，其對應的名稱的順序是未指定。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前列舉類型的基礎類型。</summary>
        <returns>目前列舉的基礎類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，在 C# 和 Visual Basic 中列舉的基礎型別是<xref:System.Int32>。 您可以指定其他整數類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。  
  
-或- 
列舉類型無效，因為它包含一個以上的執行個體欄位。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前列舉類型中常數的值陣列。</summary>
        <returns>包含值的陣列。 陣列的項目依列舉常數的二進位值 (也就是不帶正負號值) 排序。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的特定事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，其中包含由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件名稱。</param>
        <summary>傳回代表指定公用事件的 <see cref="T:System.Reflection.EventInfo" /> 物件。</summary>
        <returns>如果找到，則表示由目前 <see cref="T:System.Type" /> 所宣告或繼承之指定公用事件的物件；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件會被視為公用反映，是否至少一個方法或公用存取子。 否則，事件會視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體事件。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的事件。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.EventInfo>物件，並取得指定之事件的按鈕類別的事件。  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含目前 <see cref="T:System.Type" /> 所宣告或繼承之事件的名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，傳回表示指定事件的 <see cref="T:System.Reflection.EventInfo" /> 物件。</summary>
        <returns>如果找到，則表示由目前 <see cref="T:System.Type" /> 所宣告或繼承之指定事件的物件；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義所要包含在搜尋事件：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用事件。  
  
-   指定`BindingFlags.NonPublic`在搜尋中包含非公用事件 （也就是私用、 內部和受保護的事件）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只上宣告的事件<xref:System.Type>，不只是繼承的事件。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 事件會被視為公用反映，是否至少一個方法或公用存取子。 否則，事件會視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的事件。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>方法來搜尋的公用或非公用事件名為"Click"不是型別`static`(`Shared` Visual Basic 中)。  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得由目前 <see cref="T:System.Type" /> 所宣告或繼承的所有公用事件。</summary>
        <returns>
          <see cref="T:System.Reflection.EventInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所宣告或繼承的所有公用事件。  
  
-或- 
<see cref="T:System.Reflection.EventInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有公用事件)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件會被視為公用反映，是否至少一個方法或公用存取子。 否則，事件會視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 <xref:System.Type.GetEvents%2A>方法沒有傳回事件特定的順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於事件會傳回的順序，因為順序不同。  
  
 在衍生類別可以覆寫此方法。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的事件。  
  
   
  
## Examples  
 下列範例會取得陣列<xref:System.Reflection.EventInfo>物件，則會取得所有事件`Button`類別，並顯示事件名稱。 若要編譯 Visual Basic 範例，請使用下列命令列：  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋由目前 <see cref="T:System.Type" /> 所宣告或繼承的事件。</summary>
        <returns>
          <see cref="T:System.Reflection.EventInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所宣告或繼承之符合指定繫結條件約束的所有事件。  
  
-或- 
如果目前 <see cref="T:System.Reflection.EventInfo" /> 沒有事件，或沒有事件符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A>方法沒有傳回事件特定的順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於事件會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義所要包含在搜尋事件：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用事件。  
  
-   指定`BindingFlags.NonPublic`在搜尋中包含非公用事件 （也就是私用、 內部和受保護的事件）。 只有受保護，而且會傳回基底類別上的內部事件;不會傳回基底類別上的私用事件。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只上宣告的事件<xref:System.Type>，不只是繼承的事件。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 事件會被視為公用反映，是否至少一個方法或公用存取子。 否則，事件會視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.EventInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的事件。  
  
   
  
## Examples  
 下列範例會取得陣列<xref:System.Reflection.EventInfo>符合指定的繫結旗標的物件取得的所有事件`Button`類別，並顯示事件名稱。 若要編譯 Visual Basic 範例，請使用下列命令列：  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的特定欄位。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的資料欄位的名稱。</param>
        <summary>搜尋具有指定名稱的公用欄位。</summary>
        <returns>物件，代表具有指定之名稱的公用欄位 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體欄位。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的欄位。  
  
   
  
## Examples  
 下列範例會取得`Type`物件指定的類別，取得<xref:System.Reflection.FieldInfo>欄位的物件，並顯示欄位的值。  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">這個 <see cref="T:System.Type" /> 物件是 <see cref="T:System.Reflection.Emit.TypeBuilder" />，尚未呼叫其 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的資料欄位的名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>使用指定的繫結條件約束搜尋指定的欄位。</summary>
        <returns>代表符合指定之需求欄位的物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的欄位：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`搜尋範圍包含公用欄位。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用欄位 （也就是私用、 內部和受保護欄位）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只上宣告的欄位<xref:System.Type>，不只是繼承的欄位。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的欄位。  
  
   
  
## Examples  
 下列範例會取得`Type`物件指定的類別，取得<xref:System.Reflection.FieldInfo>符合指定的繫結旗標，並顯示欄位的值之欄位的物件。  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的欄位。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Type" /> 的所有公用欄位。</summary>
        <returns>
          <see cref="T:System.Reflection.FieldInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義的所有公用欄位。  
  
-或- 
<see cref="T:System.Reflection.FieldInfo" /> 類型的空陣列 (如果沒有為目前 <see cref="T:System.Type" /> 定義公用欄位)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於欄位會傳回的順序，因為順序不同。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的公用欄位。  
  
   
  
## Examples  
 下列範例示範使用`GetFields()`方法。  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的欄位。</summary>
        <returns>
          <see cref="T:System.Reflection.FieldInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有欄位。  
  
-或- 
如果沒有任何欄位定義給目前 <see cref="T:System.Reflection.FieldInfo" /> 的欄位，或沒有已定義的欄位符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於欄位會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的欄位：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`搜尋範圍包含公用欄位。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用欄位 （也就是私用、 內部和受保護欄位）。 只有受保護，而且會傳回基底類別上的內部欄位;不會傳回基底類別上的私用欄位。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只上宣告的欄位<xref:System.Type>，不只是繼承的欄位。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.FieldInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的公用欄位。  
  
   
  
## Examples  
 下列範例示範使用`GetFields(BindingFlags)`方法。  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Type" /> 物件的陣列，代表封閉泛型類型的型別引數，或泛型類型定義的型別參數。</summary>
        <returns>由 <see cref="T:System.Type" /> 物件組成的陣列，代表泛型類型的類型引數。 如果目前的類型不是泛型類型，則傳回空的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列項目會以其出現在類型引數的泛型型別清單的順序傳回。  
  
-   如果目前的型別是封閉式的建構型別 (亦即<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`false`)，所傳回的陣列<xref:System.Type.GetGenericArguments%2A>方法包含已指派給泛型類型定義的泛型類型參數的型別.  
  
-   如果目前的類型是泛型類型定義，陣列會包含型別參數。  
  
-   如果目前的型別是開放式建構的類型 (亦即<xref:System.Type.ContainsGenericParameters%2A>屬性會傳回`true`) 中的所有型別參數和封閉式泛型類型或方法的型別參數尚未指派哪一個特定的類型，此陣列包含型別和型別參數。 使用<xref:System.Type.IsGenericParameter%2A>辨別這兩者的屬性。 如需示範此案例中，請參閱的程式碼範例<xref:System.Type.ContainsGenericParameters%2A>屬性。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Type.GetGenericArguments%2A>来顯示的型別引數建構的型別以及其泛型型別定義的類型參數的方法。  
  
 此程式碼範例是針對提供之較大範例的一部分<xref:System.Type.IsGenericTypeDefinition%2A>屬性。 請參閱範例輸出的較大範例。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回由 <see cref="T:System.Type" /> 物件組成的陣列，這些物件代表對目前泛型類型參數所設下的條件約束。</summary>
        <returns>由 <see cref="T:System.Type" /> 物件組成的陣列，這些物件代表對目前泛型型別參數所設下的條件約束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型類型參數上的每個條件約束會表示為<xref:System.Type>物件。 使用<xref:System.Type.IsClass%2A>屬性來判斷條件約束是否是基底類別條件約束; 如果這個屬性傳回`false`，條件約束是介面條件約束。 如果類型參數有沒有類別條件約束和介面條件約束，則會傳回空陣列。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例會定義泛型型別`Test`具有兩個具有不同的條件約束的型別參數。 當程式執行時，條件約束會檢查使用<xref:System.Type.GenericParameterAttributes%2A>屬性和<xref:System.Type.GetGenericParameterConstraints%2A>方法。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前的 <see cref="T:System.Type" /> 物件不是泛型型別參數。 亦即，<see cref="P:System.Type.IsGenericParameter" /> 屬性會傳回 <see langword="false" />。</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回代表泛型類型定義的 <see cref="T:System.Type" /> 物件，利用此泛型類型定義就可以建構出目前的泛型類型。</summary>
        <returns>代表泛型類型的 <see cref="T:System.Type" /> 物件，利用此泛型類型就可以建構出目前的類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型類型定義是可從中建構其他類型的範本。 例如，從泛型類型定義`G<T>`（以 C# 語法;`G(Of T)`在 Visual Basic 或`generic <typename T> ref class G`c + + 中) 您可以建構和具現化型別`G<int>`(`G(Of Integer)` Visual Basic 中)。 給定<xref:System.Type>物件，代表這個建構的型別，<xref:System.Type.GetGenericTypeDefinition%2A>方法會傳回泛型型別定義。  
  
 如果兩個建構的型別會建立從相同的泛型類型定義中，使用相同的型別引數，<xref:System.Type.GetGenericTypeDefinition%2A>方法會傳回相同<xref:System.Type>這兩種類型的物件。  
  
 如果您呼叫<xref:System.Type.GetGenericTypeDefinition%2A>方法<xref:System.Type>物件，已表示泛型類型定義，它會傳回目前<xref:System.Type>。  
  
> [!IMPORTANT]
>  泛型類型的陣列不是泛型本身。 在 C# 程式碼`A<int>[] v;`或 Visual Basic 程式碼`Dim v() As A(Of Integer)`，變數的型別`v`不是泛型。 使用<xref:System.Type.IsGenericType%2A>來判斷類型是否為泛型之前先呼叫<xref:System.Type.GetGenericTypeDefinition%2A>。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列程式碼範例會建構類型的執行個體建立使用一般的執行個體建立，並接著會使用<xref:System.Type.GetType%2A>和<xref:System.Type.GetGenericTypeDefinition%2A>方法來擷取建構的型別和泛型型別定義。 此範例中使用泛型<xref:System.Collections.Generic.Dictionary%602>型別，建構的型別代表<xref:System.Collections.Generic.Dictionary%602>的`Test`具有字串索引鍵的物件。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前的類型不是泛型類型。  亦即，<see cref="P:System.Type.IsGenericType" /> 傳回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個執行個體的雜湊碼。</summary>
        <returns>這個執行個體的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例顯示的雜湊碼`System.Windows.Forms.Button`類別。  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得由目前 <see cref="T:System.Type" /> 所實作或繼承的特定介面。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的介面名稱。 若為泛型介面，則為 mangled 名稱。</param>
        <summary>搜尋具有指定名稱的介面。</summary>
        <returns>物件，代表具有指定之名稱的介面是由目前 <see cref="T:System.Type" /> 所實作或繼承的 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數定義中的泛型類型或泛型方法，這個方法會搜尋介面條件約束和繼承自類別或介面條件約束的任何介面。  
  
> [!NOTE]
>  泛型介面，如`name`參數是損害的名稱，結尾抑音符號 (\`) 和型別參數數目。 這是泛型介面定義和建構的泛型介面，則為 true。 例如，若要尋找`IExample<T>`(`IExample(Of T)` Visual Basic 中) 或`IExample<string>`(`IExample(Of String)` Visual Basic 中)，搜尋``"IExample`1"``。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Type.GetInterface%28System.String%29>方法來搜尋<xref:System.Collections.Hashtable>類別<xref:System.Runtime.Serialization.IDeserializationCallback>介面，並列出介面的方法。  
  
 在程式碼範例也會示範<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法多載和<xref:System.Type.GetInterfaceMap%2A>方法。  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">目前的 <see cref="T:System.Type" /> 代表實作具有不同型別引數之相同泛型介面的類型。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的介面名稱。 若為泛型介面，則為 mangled 名稱。</param>
        <param name="ignoreCase">
          <see langword="true" />，便會忽略 <c>name</c> 中指定簡單介面名稱之該部分的大小寫 (指定命名空間的部分必須使用正確的大小寫)。  
  
-或- 
 <see langword="false" /> 表示對 <c>name</c> 的所有部分執行區分大小寫的搜尋。</param>
        <summary>在衍生類別中覆寫時，指定是否針對介面名稱以不區分大小寫的方式來搜尋指定的介面。</summary>
        <returns>物件，代表具有指定之名稱的介面是由目前 <see cref="T:System.Type" /> 所實作或繼承的 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase`參數只適用於簡單介面名稱，不到命名空間。 部分`name`指定命名空間必須有正確的大小寫，或將找不到介面。 例如，字串"System.icomparable 」 尋找<xref:System.IComparable>介面，但字串"system.icomparable 」 沒有作用。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數定義中的泛型類型或泛型方法，這個方法會搜尋介面條件約束和繼承自類別或介面條件約束的任何介面。  
  
> [!NOTE]
>  泛型介面，如`name`參數是損害的名稱，結尾抑音符號 (\`) 和型別參數數目。 這是泛型介面定義和建構的泛型介面，則為 true。 例如，若要尋找`IExample<T>`(`IExample(Of T)` Visual Basic 中) 或`IExample<string>`(`IExample(Of String)` Visual Basic 中)，搜尋`"IExample`1"'。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法來執行不區分大小寫的搜尋<xref:System.Collections.Hashtable>類別<xref:System.Collections.IEnumerable>介面。  
  
 在程式碼範例也會示範<xref:System.Type.GetInterface%28System.String%29>方法多載和<xref:System.Type.GetInterfaceMap%2A>方法。  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">目前的 <see cref="T:System.Type" /> 代表實作具有不同型別引數之相同泛型介面的類型。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">要擷取對應的介面類型。</param>
        <summary>傳回指定介面類型的介面對應。</summary>
        <returns>物件，表示 <paramref name="interfaceType" /> 的介面對應。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 介面對應代表介面如何對應到實際的成員上實作該介面的類別。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，會依適當的型別引數中的項目來取代參數的型別<xref:System.Reflection.InterfaceMapping>這個方法所傳回。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Type.GetInterfaceMap%2A>方法，以判斷如何<xref:System.IFormatProvider>介面會對應至<xref:System.Globalization.CultureInfo>方法，以及如何<xref:System.IAppDomainSetup>介面對應至<xref:System.AppDomainSetup>屬性。 請注意，因為<xref:System.IAppDomainSetup>介面會定義一組屬性，傳回<xref:System.Reflection.InterfaceMapping>物件包含個別<xref:System.Reflection.MethodInfo>屬性的 get 和 set 存取子物件。  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> 不會由目前類型實作。  
  
-或- 
<paramref name="interfaceType" /> 引數未參考介面。  
  
-或-

目前的執行個體或 <paramref name="interfaceType" /> 引數是開放式泛型型別，也就是 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性會傳回 <see langword="true" />。

-或-


 <paramref name="interfaceType" /> 是泛型介面，且目前的類型是陣列類型。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">目前 <see cref="T:System.Type" /> 代表泛型型別參數；也就是說，<see cref="P:System.Type.IsGenericParameter" /> 是 <see langword="true" />。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，取得由目前 <see cref="T:System.Type" /> 所實作或繼承的所有介面。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 所實作或繼承的所有介面。  
  
-或- 
<see cref="T:System.Type" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 未實作或繼承介面)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A>方法不會傳回介面以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於介面會傳回的順序，因為順序不同。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Type>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數定義中的泛型類型或泛型方法，這個方法會搜尋介面條件約束和繼承自類別或介面條件約束的任何介面。  
  
   
  
## Examples  
 下列範例會取得指定類別的型別，並顯示的型別會實作或繼承的所有介面。 若要編譯 Visual Basic 範例，請使用下列的編譯器命令：  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">靜態初始設定式已叫用並擲回了例外狀況。</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的指定成員。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用成員名稱。</param>
        <summary>搜尋具有指定名稱的公用成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體成員。  
  
 成員包含屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 這個方法多載不會尋找類別初始設定式 (.cctor)。 類別初始設定式，請使用採用多載<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的成員或成員<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  如需泛型的方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋之成員的文字名稱 」`MyMethod<int>`"，而不是方法，名為`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例顯示的所有成員`String`以字母 c 開頭的類別  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的成員名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，表示傳回空陣列。</param>
        <summary>使用指定的繫結條件約束搜尋指定的成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫此方法。  
  
 成員包含屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的成員：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只在宣告的成員，才<xref:System.Type>，不只是繼承的成員。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定 「.cctor 」 `name`，並<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic 中) 如`bindingAttr`。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的成員或成員<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  如需泛型的方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋之成員的文字名稱 」`MyMethod<int>`"，而不是方法，名為`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例顯示的所有公用靜態成員`myString`以字母 c 開頭的類別  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的成員名稱。</param>
        <param name="type">要搜尋的值。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，表示傳回空陣列。</param>
        <summary>使用指定的繫結條件約束，搜尋指定成員類型的指定成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表具有指定之名稱的公用成員 (如有找到)，否則為空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成員包含屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMember%2A>方法不會傳回成員以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的成員：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只在宣告的成員，才<xref:System.Type>，不只是繼承的成員。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定 「.cctor 」 `name`， <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`，以及<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>中Visual Basic) 的`bindingAttr`。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的成員或成員<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  如需泛型的方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋之成員的文字名稱 」`MyMethod<int>`"，而不是方法，名為`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例顯示的所有方法`myString`以字母 c 開頭的類別  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">衍生類別必須提供實作。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的成員 (屬性、方法、欄位、事件等等)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Type" /> 的所有公用成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有公用成員。  
  
-或- 
<see cref="T:System.Reflection.MemberInfo" /> 類型的空陣列 (如果目前 <see cref="T:System.Type" /> 沒有公用成員)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成員包含屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMembers%2A>方法不會傳回成員以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 這個方法多載會呼叫<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法多載，以<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Visual Basic 中)。 它將無法找到類別初始設定式 (.cctor)。 類別初始設定式，請使用採用多載<xref:System.Reflection.BindingFlags>，並指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MemberInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的成員或成員<xref:System.Object>是否沒有類別條件約束。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Type.GetMembers>方法多載來收集指定之類別的所有公用成員的相關資訊。  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零 (<see cref="F:System.Reflection.BindingFlags.Default" />)，表示傳回空陣列。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有成員。  
  
-或- 
如果沒有任何成員定義給目前的 <see cref="T:System.Reflection.MemberInfo" />，或沒有已定義的成員符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成員包含屬性、 方法、 欄位、 事件等等。  
  
 <xref:System.Type.GetMembers%2A>方法不會傳回成員以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於成員會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的成員：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。 只有受保護，而且會傳回基底類別上的內部成員;不會傳回基底類別上的私用成員。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只在宣告的成員，才<xref:System.Type>，不只是繼承的成員。  
  
 呼叫這個方法只有`Public`旗標] 或 [僅`NonPublic`旗標將會傳回指定的成員，而且不需要任何其他旗標。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要取得使用這個方法多載類別初始設定式 (.cctor)，您必須指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 您也可以取得類別初始設定式使用<xref:System.Type.TypeInitializer%2A>屬性。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.MemberInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的成員或成員<xref:System.Object>是否沒有類別條件約束。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法多載來收集指定之類別的所有公用執行個體成員的相關資訊。  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的特定方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用方法名稱。</param>
        <summary>搜尋具有指定名稱的公用方法。</summary>
        <returns>物件，代表具有指定之名稱的公用方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體方法。  
  
 如果方法多載，而且有一個以上的公用方法，<xref:System.Type.GetMethod%28System.String%29>方法會擲回<xref:System.Reflection.AmbiguousMatchException>例外狀況。 在下列範例中，例外狀況會擲回多個公用的多載，所以<xref:System.Int32.ToString%2A?displayProperty=nameWithType>方法。  相反地，因為`Person.ToString`方法覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>，因此不會多載，則<xref:System.Type.GetMethod%28System.String%29>方法可擷取<xref:System.Reflection.MethodInfo>物件。  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 您可以執行下列命令來擷取特定方法的其中一個：  
  
-   呼叫<xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29>方法並指定`bindingAttr`唯一識別方法的引數。 例如，如果因為類型都有靜態和執行個體的多載，則會擲回例外狀況，您可以指定`bindingAttr`引數<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>。  
  
-   呼叫的多載<xref:System.Type.GetMethod%2A>方法，其中包含`types`參數會定義方法的參數型別。  
  
-   呼叫<xref:System.Type.GetMethods>方法來擷取陣列，包含所有屬於類型的公用方法。 然後您可以重複用於識別重複的方法，名為`name`。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  如需泛型的方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋之成員的文字名稱 」`MyMethod<int>`"，而不是方法，名為`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例會取得名為`MethodA`。  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的方法名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>使用指定的繫結條件約束搜尋指定的方法。</summary>
        <returns>物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的方法：  
  
-   您必須指定<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>以取得傳回值。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用方法。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在搜尋中包括非公用方法 （也就是私用、 內部和受保護的方法）。  
  
-   指定<xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType>包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 忽略大小寫的`name`。  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 搜尋僅方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果多載方法，而且多個多載符合所指定的條件約束`bindingAttr`引數，方法會擲回<xref:System.Reflection.AmbiguousMatchException>例外狀況。 在下列範例中，因為，會擲回例外狀況：  
  
-   `TestClass`型別有兩個的公用執行個體的多載`DisplayValue`方法，`DisplayValue(String)`和`DisplayValue(String, Object[])`。  
  
-   `TestClass`型別有兩個的公用執行個體的多載`Equals`方法，其中繼承自<xref:System.Object>:`Equals(TestClass)`和`Equals(Object)`。  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 您可以執行下列命令來擷取特定方法的其中一個：  
  
-   變更繫結條件約束。 在上述範例中，嘗試擷取的公用執行個體`Equals`類型所宣告且不會成功地繼承的方法會擷取`Equals(TestClass)`。  
  
-   呼叫的多載<xref:System.Type.GetMethod%2A>方法，其中包含`types`參數會定義方法的參數型別。  
  
-   呼叫<xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>方法來擷取陣列，包含所有屬於型別具有指定的繫結屬性的方法。 然後您可以重複用於識別重複的方法，名為`name`。 這種方法說明上述的範例處理常式<xref:System.Reflection.AmbiguousMatchException>例外狀況。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MethodInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  如需泛型的方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋之成員的文字名稱 」`MyMethod<int>`"，而不是方法，名為`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例會取得符合指定的繫結旗標的方法。  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用方法名稱。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
-或- 
<see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</param>
        <summary>搜尋指定的公用方法，其參數符合指定的引數類型。</summary>
        <returns>代表其參數符合指定之引數類型的公用方法物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體方法。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.MethodInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  `name`參數不能包含型別引數。 例如，C# 程式碼`GetMethod("MyGenericMethod<int>")`搜尋方法，以使用的文字名稱"`MyGenericMethod<int>`"，而不是方法，名為`MyGenericMethod`具有一個泛型類型引數`int`。 請改用`GetMethod("MyGenericMethod")`中的適當參數與`types`陣列。  
  
   
  
## Examples  
 下列範例會尋找特定的多載`MethodA`，指定各種不同的引數型別。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 下列範例會擷取<xref:System.Reflection.MethodInfo>物件來代表`Add`非泛型型別的方法 (<xref:System.Collections.ArrayList>類別)，開放式泛型類型 (<xref:System.Collections.Generic.List%601>類別)，和封閉式的泛型型別 (`List(Of String)`型別。  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 此範例會定義`GetAddMethod`方法，可擷取適當<xref:System.Reflection.MethodInfo>物件。 若要提供`types`它會呼叫開放式泛型類型引數，<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>方法。 若要提供`types`封閉式的泛型型別引數，它會擷取的值<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱及指定參數的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用方法名稱。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
-或- 
<see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。 預設的繫結器不會處理這個參數。</param>
        <summary>搜尋指定的公用方法，其參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的公用方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體方法。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  如需泛型的方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMethod("MyMethod<int>")`搜尋之成員的文字名稱 」`MyMethod<int>`"，而不是方法，名為`MyMethod`具有一個泛型類型引數`int`。 請改用`GetMethod("MyMethod")`中的適當參數與`types`陣列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱及指定參數的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的方法名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
-或- 
<see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的方法：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用方法。  
  
-   指定`BindingFlags.NonPublic`在搜尋中包括非公用方法 （也就是私用、 內部和受保護的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 搜尋僅方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  如需泛型的方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋之成員的文字名稱 」`MyMethod<int>`"，而不是方法，名為`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例會尋找特定的多載`MethodA`，指定繫結條件約束和各種不同的引數型別。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的方法名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="callConvention">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及如何清除堆疊。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
-或- 
<see cref="T:System.Type" /> 物件的空陣列 (由 <see cref="F:System.Type.EmptyTypes" /> 欄位提供)，可取得不採用參數的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 只用於透過 COM Interop 進行呼叫以及只處理以傳址方式傳遞的參數。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束和指定的呼叫慣例，來搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 下表顯示基底類別成員會傳回由`GetXXX`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的方法：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用方法。  
  
-   指定`BindingFlags.NonPublic`在搜尋中包括非公用方法 （也就是私用、 內部和受保護的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 搜尋僅方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>是否沒有類別條件約束。  
  
> [!NOTE]
>  如需泛型的方法，不包括中的型別引數`name`。 例如，C# 程式碼`GetMember("MyMethod<int>")`搜尋之成員的文字名稱 」`MyMethod<int>`"，而不是方法，名為`MyMethod`具有一個泛型類型引數`int`。  
  
   
  
## Examples  
 下列範例會尋找特定的多載`MethodA`、 指定繫結條件約束、 呼叫慣例和各種不同的引數型別。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]範例需要`/unsafe`編譯器選項。  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的方法名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="callConvention">物件，其指定一組所要使用的規則，而這些規則是關於引數的順序和配置、如何傳遞傳回值、引數使用哪些暫存器以及哪一個處理程序清除堆疊。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之方法的參數數目、順序和類型。  
  
-或- 
用以取得沒有參數的方法之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。  
  
-或- 
 <see langword="null" />. 如果 <c>types</c> 為 <see langword="null" />，則引數不相符。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束和指定的呼叫慣例搜尋指定的方法，而該方法的參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的方法 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 如果 `types` 為 `null`，則引數不相符。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的方法：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用方法。  
  
-   指定`BindingFlags.NonPublic`在搜尋中包括非公用方法 （也就是私用、 內部和受保護的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 搜尋僅方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的方法，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。  
  
-或- 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的長度不同。</exception>
        <exception cref="T:System.NotSupportedException">目前的類型為 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Type" /> 的所有公用方法。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義的所有公用方法。  
  
-或- 
<see cref="T:System.Reflection.MethodInfo" /> 類型的空陣列 (如果沒有為目前 <see cref="T:System.Type" /> 定義公用方法)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>方法不會傳回方法特定的順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於方法會傳回的順序，因為順序不同。  
  
 建構函式不包含陣列中的這個呼叫所傳回的方法。 請個別呼叫`GetConstructors()`取得建構函式方法。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>是否沒有類別條件約束。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋定義給目前 <see cref="T:System.Type" /> 的方法。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> 物件的陣列，代表為目前 <see cref="T:System.Type" /> 定義之符合指定繫結條件約束的所有方法。  
  
-或- 
如果沒有任何方法定義給目前的 <see cref="T:System.Reflection.MethodInfo" />，或沒有已定義的方法符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>方法不會傳回方法特定的順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於方法會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的方法：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用方法。  
  
-   指定`BindingFlags.NonPublic`在搜尋中包括非公用方法 （也就是私用、 內部和受保護的方法）。 只有受保護，而且會傳回基底類別上的內部方法;不會傳回基底類別上的私用方法。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 搜尋僅方法上宣告<xref:System.Type>，不只是繼承的方法。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查詢建構函式和方法時，您不能省略參數。 叫用時，您只可以省略參數。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.MethodInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>代表型別參數的泛型類型或泛型方法，這個方法定義中搜尋類別條件約束的方法或方法的<xref:System.Object>是否沒有類別條件約束。  
  
   
  
## Examples  
 下列範例會建立具有兩個公用方法和一個受保護的方法的類別，會建立`Type`物件對應至`MyTypeClass`、 取得所有的公用和非公用方法，並顯示其名稱。  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讓特定類型在目前的 <see cref="T:System.Type" /> 內變成巢狀。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含要取得之巢狀類型名稱的字串。</param>
        <summary>搜尋具有指定名稱的公用巢狀類型。</summary>
        <returns>物件，代表具有指定名稱的巢狀類型 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。  
  
 使用巢狀類別的簡單名稱`name`。 不會限定外部類別的名稱取代它。 泛型的巢狀類別中，使用 損壞的名稱 — 也就是附加抑音符號以及泛型引數數目。 例如，使用字串"內部\`1"以取得一般巢狀類別`Inner<T>`(`Inner(Of T)` Visual Basic 中)。 不包含型別參數的特定語言的語法。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。  
  
 如果巢狀型別是泛型，則這個方法會傳回其泛型型別定義。 這是 true，即使封入泛型型別是封閉式的建構型別。  
  
> [!NOTE]
>  如果目前<xref:System.Type>代表泛型類型定義在 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。 不一定是動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 如需巢狀泛型類型，及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">包含要取得之巢狀類型名稱的字串。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束搜尋指定的巢狀類型。</summary>
        <returns>物件，代表符合指定之需求的巢狀類型 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用巢狀類別的簡單名稱`name`。 不會限定外部類別的名稱取代它。 泛型的巢狀類別中，使用 損壞的名稱 — 也就是附加抑音符號以及泛型參數的數目。 例如，使用字串"內部\`1"以取得一般巢狀類別`Inner<T>`(`Inner(Of T)` Visual Basic 中)。 不包含型別參數的特定語言的語法。  
  
 下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選器旗標可以用來定義的巢狀類型：  
  
-   您必須指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>取得傳回值。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用巢狀型別。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要在搜尋中包含非公用巢狀的類型 （也就是私用、 內部和受保護巢狀型別）。  
  
 這個方法會傳回目前的類型中巢狀型別。 它不會搜尋目前類型的基底類別。 若要尋找的巢狀型別的基底類別中，您必須逐步繼承階層中，呼叫<xref:System.Type.GetNestedType%2A>每個層級。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>都會被忽略。  
  
 呼叫這個方法只有<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>旗標] 或 [僅<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>旗標將會傳回指定的巢狀類型，並不需要任何其他旗標。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。  
  
 如果巢狀型別是泛型，則這個方法會傳回其泛型型別定義。 這是 true，即使封入泛型型別是封閉式的建構型別。  
  
> [!NOTE]
>  如果目前<xref:System.Type>代表泛型類型定義在 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。 不一定是動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 如需巢狀泛型類型，及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讓其在目前的 <see cref="T:System.Type" /> 內變成巢狀之類型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回在目前 <see cref="T:System.Type" /> 內形成巢狀的公用類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中的巢狀公用類型 (搜尋不是遞迴的)；如果目前 <see cref="T:System.Type" /> 中沒有巢狀公用類型，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A>方法沒有傳回型別特定的順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於類型會傳回的順序，因為順序不同。  
  
 只有在目前的類型中巢狀的公用型別會傳回;搜尋不是遞迴。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。  
  
 如果巢狀型別是泛型，則這個方法會傳回其泛型型別定義。 這是 true，即使封入泛型型別是封閉式的建構型別。  
  
> [!NOTE]
>  如果目前<xref:System.Type>代表泛型類型定義在 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。 不一定是動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 如需巢狀泛型類型，及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。  
  
   
  
## Examples  
 下列範例會定義巢狀的類別和`struct`中`MyClass`，然後取得使用的型別之巢狀類型的物件和`MyClass`。  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋在目前 <see cref="T:System.Type" /> 內形成巢狀的類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中符合指定繫結條件約束的所有巢狀類型 (搜尋不是遞迴的)；如果找不到符合繫結條件約束的巢狀類型，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋巢狀類型不是遞迴的。  
  
 <xref:System.Type.GetNestedTypes%2A>方法沒有傳回型別特定的順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於類型會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選器旗標可以用來定義的巢狀類型：  
  
-   您必須指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>取得傳回值。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>来包含在搜尋中的公用巢狀型別。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要在搜尋中包含非公用巢狀的類型 （也就是私用、 內部和受保護巢狀型別）。  
  
 這個方法會傳回目前的類型中巢狀型別。 它不會搜尋目前類型的基底類別。 若要尋找的巢狀型別的基底類別中，您必須逐步繼承階層中，呼叫<xref:System.Type.GetNestedTypes%2A>每個層級。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>都會被忽略。  
  
 呼叫這個方法只有<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>旗標] 或 [僅<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>旗標將會傳回指定的巢狀類型，並不需要任何其他旗標。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的巢狀的類型。  
  
 如果巢狀型別是泛型，則這個方法會傳回其泛型型別定義。 這是 true，即使封入泛型型別是封閉式的建構型別。  
  
> [!NOTE]
>  如果目前<xref:System.Type>代表泛型類型定義在 C#、 Visual Basic 或 c + +，其巢狀的類型是所有泛型，即使它們沒有自己的泛型參數。 不一定是動態組件中定義，或使用編譯的巢狀型別的[Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 如需巢狀泛型類型，及建構其泛型型別定義的巢狀泛型類型的資訊，請參閱<xref:System.Type.MakeGenericType%2A>。  
  
   
  
## Examples  
 下列範例會建立兩個巢狀公用類別和兩個巢狀的受保護的類別，，並顯示符合指定的繫結條件約束的類別的資訊。  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Type" /> 的所有公用屬性。</summary>
        <returns>
          <see cref="T:System.Reflection.PropertyInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 的所有公用屬性。  
  
-或- 
類型 <see cref="T:System.Reflection.PropertyInfo" /> 的空陣列，如果目前 <see cref="T:System.Type" /> 並沒有公用屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個多載就相當於呼叫<xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29>多載`bindingAttr`引數等於`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`在 C# 和`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`Visual Basic 中。 它會傳回所有公用執行個體和靜態屬性，表示由目前類型所定義這兩個所<xref:System.Type>物件，以及繼承自其基底類型。  
  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 <xref:System.Type.GetProperties%2A>方法沒有傳回屬性以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於屬性會傳回的順序，因為順序不同。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
   
  
## Examples  
 下列範例示範 `GetProperties` 方法的用法。  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束，搜尋目前 <see cref="T:System.Type" /> 的屬性。</summary>
        <returns>
          <see cref="T:System.Reflection.PropertyInfo" /> 物件的陣列，代表目前 <see cref="T:System.Type" /> 中符合指定繫結條件約束的所有屬性。  
  
-或- 
如果目前 <see cref="T:System.Reflection.PropertyInfo" /> 沒有屬性，或沒有屬性符合繫結條件約束，則為 <see cref="T:System.Type" /> 類型的空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 <xref:System.Type.GetProperties%2A>方法沒有傳回屬性以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於屬性會傳回的順序，因為順序不同。  
  
 下列<xref:System.Reflection.BindingFlags>来包含在搜尋中的篩選器旗標可以用來定義的巢狀類型：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用屬性。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。 只有受保護，而且會傳回基底類別上的內部屬性;不會傳回基底類別上的私用屬性。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.DeclaredOnly` 搜尋僅屬性宣告上<xref:System.Type>，不只是繼承的屬性。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 如果目前的 T:System.Type 代表建構的泛型型別，則這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數的物件。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
   
  
## Examples  
 下列範例會定義名為的類別`PropertyClass`包含六個屬性： 兩個都是公用、 其中一個是私用、 一個受保護的、 有內部 (`Friend` Visual Basic 中)，且其中一個受保護內部 (`Protected Friend` Visual Basic 中)。 接著會顯示一些基本的屬性資訊 (屬性名稱和型別，是否讀取/寫入，以及是否可看到其`get`和`set`存取子) 符合指定的繫結條件約束的屬性。  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的特定屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <summary>搜尋具有指定名稱的公用屬性。</summary>
        <returns>物件，代表具有指定之名稱的公用屬性 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
 情況下會<xref:System.Reflection.AmbiguousMatchException>，就會發生如下：  
  
-   類型包含兩個索引的屬性具有相同名稱但不同數量的參數。 若要解決模稜兩可，使用的多載<xref:System.Type.GetProperty%2A>方法所指定的參數類型。  
  
-   衍生的型別宣告會隱藏繼承的屬性具有相同的名稱，使用屬性`new`修飾詞 (`Shadows` Visual Basic 中)。 若要解決模稜兩可，請使用<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>方法多載，並新增<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>旗標，以將搜尋限制不會繼承的成員。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]簡化了存取索引的屬性的語法，並允許一個索引的屬性，是其類型的預設值。 比方說，如果變數`myList`是指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)` Visual Basic 中) 會擷取具有索引為 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為 「 索引子，並不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性來變更中繼資料中的索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>，則<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會擷取`Type`物件的使用者定義的類別，擷取該類別的屬性，並顯示屬性名稱。  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 就內部而言，這個屬性被指在中繼資料名稱 」 項目 」。 嘗試取得`PropertyInfo`使用反映必須指定此內部名稱才能正確地傳回`PropertyInfo`屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的屬性名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <summary>使用指定的繫結條件約束搜尋指定的屬性。</summary>
        <returns>代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要在搜尋中包含的屬性：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用屬性。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 搜尋僅屬性宣告上<xref:System.Type>，不只是繼承的屬性。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
 情況下會<xref:System.Reflection.AmbiguousMatchException>，就會發生如下：  
  
-   類型包含兩個索引的屬性具有相同名稱但不同數量的參數。 若要解決模稜兩可，使用的多載<xref:System.Type.GetProperty%2A>方法所指定的參數類型。  
  
-   衍生的型別宣告屬性，它會隱藏繼承的屬性具有相同的名稱，使用`new`修飾詞 (`Shadows` Visual Basic 中)。 若要解決模稜兩可，包括<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>以將搜尋限制不會繼承的成員。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]簡化了存取索引的屬性的語法，並允許一個索引的屬性，是其類型的預設值。 比方說，如果變數`myList`是指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)` Visual Basic 中) 會擷取具有索引為 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為 「 索引子，並不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性來變更中繼資料中的索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>，則<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會擷取使用者定義的類別的型別、 擷取該類別的內容並顯示根據指定的繫結條件約束的屬性名稱。  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <summary>搜尋具有指定名稱和傳回型別的公用屬性。</summary>
        <returns>物件，代表具有指定之名稱的公用屬性 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]簡化了存取索引的屬性的語法，並允許一個索引的屬性，是其類型的預設值。 比方說，如果變數`myList`是指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)` Visual Basic 中) 會擷取具有索引為 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為 「 索引子，並不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性來變更中繼資料中的索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>，則<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會定義具有一個屬性的類別，並擷取屬性的類型與名稱。  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 是 <see langword="null" />，或 <paramref name="returnType" /> 是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
-或- 
用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <summary>搜尋指定的公用屬性，其參數符合指定的引數類型。</summary>
        <returns>代表其參數符合指定之引數類型的公用屬性物件 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]簡化了存取索引的屬性的語法，並允許一個索引的屬性，是其類型的預設值。 比方說，如果變數`myList`是指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)` Visual Basic 中) 會擷取具有索引為 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為 「 索引子，並不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性來變更中繼資料中的索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>，則<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會擷取`Type`物件的使用者定義的類別，該類別的屬性與擷取並顯示屬性名稱和屬性的型別所傳遞的引數指定`GetProperty`。  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱，且符合指定引數類型的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的項目是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
-或- 
用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <summary>搜尋指定的公用屬性，其參數符合指定的引數類型。</summary>
        <returns>代表其參數符合指定之引數類型的公用屬性物件 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]簡化了存取索引的屬性的語法，並允許一個索引的屬性，是其類型的預設值。 比方說，如果變數`myList`是指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)` Visual Basic 中) 會擷取具有索引為 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為 「 索引子，並不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性來變更中繼資料中的索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>，則<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱，且符合指定引數類型的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的項目是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的公用屬性名稱。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
-或- 
用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>搜尋指定的公用屬性，其參數符合指定的引數類型和修飾詞。</summary>
        <returns>物件，代表符合指定之需求的公用屬性 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 搜尋`name`會區分大小寫。 搜尋包含 public static 和 public 的執行個體屬性。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]簡化了存取索引的屬性的語法，並允許一個索引的屬性，是其類型的預設值。 比方說，如果變數`myList`是指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)` Visual Basic 中) 會擷取具有索引為 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為 「 索引子，並不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性來變更中繼資料中的索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>，則<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
   
  
## Examples  
 下列範例會取得`Type`物件對應至`MyPropertyClass`，並使用引數傳遞給擷取之索引的屬性，這個類別的`GetProperty`方法。  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上具有指定名稱，且符合指定引數類型和修飾詞的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。  
  
-或- 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 長度不同。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的項目是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的屬性名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
-或- 
用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>使用指定的繫結條件約束搜尋指定的屬性，而該屬性的參數符合指定的引數類型和修飾詞。</summary>
        <returns>代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會被視為公用反映，如果有至少一個存取子是公用。 否則屬性會被視為私用，而且您必須使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，使用值的結合`Or`) 來取得它。  
  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要在搜尋中包含的屬性：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用屬性。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 搜尋僅屬性宣告上<xref:System.Type>，不只是繼承的屬性。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果目前<xref:System.Type>代表建構的泛型型別，這個方法會傳回<xref:System.Reflection.PropertyInfo>具有由適當的型別引數取代型別參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義，這個方法會搜尋類別條件約束的屬性。  
  
## <a name="indexers-and-default-properties"></a>索引子和預設屬性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]簡化了存取索引的屬性的語法，並允許一個索引的屬性，是其類型的預設值。 比方說，如果變數`myList`是指<xref:System.Collections.ArrayList>，語法`myList[3]`(`myList(3)` Visual Basic 中) 會擷取具有索引為 3 的項目。 您可以多載的屬性。  
  
 在 C# 中，這項功能稱為 「 索引子，並不能以名稱來參考。 根據預設，C# 索引子會出現在中繼資料當做名為"Item"的索引屬性。 不過，類別庫開發人員可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>屬性來變更中繼資料中的索引子名稱。 例如，<xref:System.String>類別具有名為索引子<xref:System.String.Chars%2A>。 使用 C# 以外的語言建立索引的屬性可以有名稱以外的項目。  
  
 若要判斷型別是否具有預設屬性，請使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法來測試<xref:System.Reflection.DefaultMemberAttribute>屬性。 如果類型具有<xref:System.Reflection.DefaultMemberAttribute>，則<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>屬性會傳回預設屬性的名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。  
  
-或- 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 長度不同。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的項目是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要取得的屬性名稱。</param>
        <param name="bindingAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。  
  
-或- 
零，傳回 <see langword="null" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載成員的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。</param>
        <param name="returnType">屬性的傳回型別。</param>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列，代表所要取得之索引屬性的參數數目、順序和類型。  
  
-或- 
用以取得未編製索引的屬性之 <see cref="T:System.Type" /> 類型的空陣列 (也就是，Type[] types = new Type[0])。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>types</c> 陣列中與對應元素產生關聯的屬性。 預設的繫結器不會處理這個參數。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束搜尋指定的屬性，而該屬性的參數符合指定的引數類型和修飾詞的建構函式。</summary>
        <returns>代表符合指定之需求屬性的物件 (如有找到)；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>(`modifiers`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`。 `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要在搜尋中包含的屬性：  
  
-   您必須指定`BindingFlags.Instance`或`BindingFlags.Static`以取得傳回值。  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用屬性。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用屬性 （也就是私用、 內部和受保護的屬性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包含`public`和`protected`階層; 的靜態成員`private`中繼承類別的靜態成員不包含。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 搜尋僅屬性宣告上<xref:System.Type>，不只是繼承的屬性。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到一個以上的屬性，其具有指定名稱，且符合指定繫結條件約束。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="types" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="types" /> 的其中一個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多維的。  
  
-或- 
 <paramref name="modifiers" /> 是多維的。  
  
-或- 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 沒有相同的長度。</exception>
        <exception cref="T:System.NotSupportedException">目前的類型為 <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得代表指定類型的 <see cref="T:System.Type" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前的 <see cref="T:System.Type" />。</summary>
        <returns>目前的 <see cref="T:System.Type" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的組件限定名稱。 請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</param>
        <summary>取得具有指定名稱的 <see cref="T:System.Type" />，執行區分大小寫的搜尋。</summary>
        <returns>具有指定名稱的類型 (如有找到)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道可從其組件限定名稱<xref:System.Type.AssemblyQualifiedName>。 <xref:System.Type.GetType%2A> 會導致在指定的組件載入`typeName`。 您也可以載入組件<xref:System.Reflection.Assembly.Load%2A>方法，然後使用<xref:System.Type.GetType%2A>或是<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>類別，以取得<xref:System.Type>物件。 如果類型是在編譯時期已知到您的程式組件中，它是在 C# 中，使用更有效率<xref:System.Type.GetType%2A>在 Visual Basic 或 c + + 中。  
  
> [!NOTE]
>  如果`typeName`找不到，呼叫<xref:System.Type.GetType%28System.String%29>方法會傳回`null`。 它不會擲回例外狀況。 若要控制是否發生例外狀況，請呼叫的多載<xref:System.Type.GetType%2A>方法具有`throwOnError`參數。  
  
 <xref:System.Type.GetType%2A> 僅適用於從磁碟載入的組件。 如果您呼叫<xref:System.Type.GetType%2A>查閱使用定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會收到不一致的行為。 行為取決於動態組件是持續性的也就是，使用建立`RunAndSave`或是`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。 如果動態組件是持續性，並已寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件中，而且該組件中擷取的型別。 如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。 `GetType` 不了解暫時性動態組件;因此，呼叫`GetType`若要擷取型別中的暫時性動態組件傳回`null`。  
  
 若要使用`GetType`上的動態模組，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件，並呼叫`GetType`在儲存之前。 否則，您會得到兩個組件的複本在記憶體中。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 陣列或 COM 型別不會搜尋除非它們已經被載入資料表可用的類別。  
  
 `typeName` 可以在型別名稱來限定其命名空間或組件限定名稱，其中包含組件名稱規格。 請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包含命名空間，但不是組件名稱，這個方法會依此順序搜尋只呼叫物件的組件和 Mscorlib.dll。 如果部分或完整的組件名稱完整限定類型名稱，這個方法會搜尋指定的組件中。 如果組件具有強式名稱，完整的組件的名稱是必要。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀型別、 組件名稱和泛型型別引數。 支援通用語言執行平台的所有編譯器將都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。 您也可以藉由建立載入類型<xref:System.Reflection.AssemblyName>物件，並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。 您可以接著使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。 請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|倒單引號 （'）|前面有一或多個位數表示的型別參數，位於結尾的泛型型別名稱的數目。|  
|括號 ([])|將建構的泛型類型; 泛型型別引數清單在類型引數清單中，將組件限定型別。|  
|逗號 （，）|後面接著組件名稱。|  
|句號 （.）|表示命名空間識別項。|  
|加號 （+）|在之前的巢狀的類別。|  
  
 例如，類別的完整格式的名稱可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空間已 TopNamespace.Sub+Namespace，則字串會有之前加號 （+），以逸出字元 (\\) 以防止它被解譯為巢狀分隔符號。 反映會發出此字串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"會變成"\\+\\+"，和 「\\」 變成 「\\\\"。  
  
 這個限定的名稱可以保存和更新版本用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>使用型別名稱只有或使用組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與型別名稱只會尋找<xref:System.Type>呼叫者的組件中，然後在系統組件中。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 類型名稱可能包含行尾字元來表示的類型，例如類型是否為參考型別、 指標類型或陣列類型的其他資訊。 若要擷取的型別名稱，而不需要這些後置字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。  
  
 空格是相關的組件名稱以外的所有型別名稱元件。 在組件名稱 '，' 分隔符號之前的空格是相關的但是 '，' 分隔符號之後的空格會被忽略。  
  
 泛型型別名稱的結尾倒引號 (\`) 後面接著數字，代表泛型類型引數數目。 此名稱的損害的目的是讓編譯器支援泛型型別具有相同名稱但具有不同數目的型別參數，在相同的範圍內發生。 例如，反映會傳回損害的名稱`Tuple`1` and `Tuple`2`的泛型方法`Tuple(Of T)`並`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。  
  
 為泛型類型，類型引數清單以括號、，並以逗號分隔的類型引數。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能如下表示：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定型別引數清單中的組件限定型別，請將括號括住的組件限定型別。 否則，逗號分隔的組件限定名稱的組件會被視為分隔其他的型別引數。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`fromMyAssembly.dll，類型的索引鍵聯<xref:System.String>，可能會以下面方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  組件限定型別可以括在括弧，它必須出現在類型參數清單中。 搜尋組件限定的不合格的型別的型別參數清單中的規則並符合規定及不合格的非泛型類型的規則相同。  
  
 可為 null 的型別是泛型類型的特殊案例。 例如，可為 null <xref:System.Int32> "System.Nullable'1[System.Int32]"的字串表示。  
  
> [!NOTE]
>  在 C#、 c + + 和 Visual Basic 中，您也可以取得可為 null 的型別使用型別運算子。 比方說，可為 null<xref:System.Boolean>型別由`typeof(Nullable<bool>)`在 C# 中，依`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`Visual Basic 中。  
  
 下表顯示您所使用的語法`GetType`為各種型別。  
  
|若要取得|使用|  
|------------|---------|  
|可為 null <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Unmanaged 的指標 `MyType`|`Type.GetType("MyType*")`|  
|指標的 unmanaged 的指標 `MyType`|`Type.GetType("MyType**")`|  
|Managed 的指標或參考 `MyType`|`Type.GetType("MyType&")`. 請注意，參考與指標不同，僅限一個層級。|  
|父類別和巢狀的類別|`Type.GetType("MyParentClass+MyNestedClass")`|  
|一維陣列，其下限為 0|`Type.GetType("MyType[]")`|  
|下限不明的一維陣列|`Type.GetType("MyType[*]")`|  
|N 維陣列|逗號 （，） 的 n-1 次數總計的方括號內。 例如，`System.Object[,,]`代表三維`Object`陣列。|  
|陣列的一維陣列|`Type.GetType("MyType[][]")`|  
|矩形的二維陣列下限不明|`Type.GetType("MyType[,]")`|  
|具有一個型別引數的泛型型別|``Type.GetType("MyGenericType`1[MyType]")``|  
|兩個類型引數的泛型型別|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有兩個組件限定型別引數的泛型型別|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|使用組件限定型別引數，組件限定的泛型類型|' Type.GetType (「 MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|其類型引數是具有兩個類型引數的泛型型別是泛型型別|' Type.GetType (「 MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")'|  
  
   
  
## Examples  
 下列範例會擷取的型別`System.Int32`並使用該型別物件來顯示<xref:System.Type.FullName%2A>屬性`System.Int32`。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
-或- 
 <paramref name="typeName" /> 代表泛型類型，而其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
-或- 
目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的組件限定名稱。 請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。 指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。 請參閱＜例外狀況＞一節。</param>
        <summary>取得具有指定名稱的 <see cref="T:System.Type" />，執行區分大小寫的搜尋，並設定找不到該類型時，是否應擲回例外狀況。</summary>
        <returns>具有指定名稱的類型。 如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道可從其組件限定名稱<xref:System.Type.AssemblyQualifiedName>。 <xref:System.Type.GetType%2A> 會導致在指定的組件載入`typeName`。 您也可以載入組件<xref:System.Reflection.Assembly.Load%2A>方法，然後使用<xref:System.Type.GetType%2A>或是<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>類別，以取得<xref:System.Type>物件。 如果類型是在編譯時期已知到您的程式組件中，會使用更有效率`typeof`在 C# 中，<xref:System.Type.GetType%2A>在 Visual Basic 中，或`typeid`c + + 中。  
  
 `GetType` 僅適用於從磁碟載入的組件。 如果您呼叫`GetType`查閱使用定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會收到不一致的行為。 行為取決於動態組件是持續性的也就是，使用建立`RunAndSave`或是`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。 如果動態組件是持續性，並已寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件中，而且該組件中擷取的型別。 如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。 `GetType` 不了解暫時性動態組件;因此，呼叫`GetType`若要擷取型別中的暫時性動態組件傳回`null`。  
  
 若要使用`GetType`上的動態模組，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件，並呼叫`GetType`在儲存之前。 否則，您會得到兩個組件的複本在記憶體中。  
  
 `throwOnError`參數會指定時會發生什麼事的型別找不到，並會隱藏其他某些例外情況，例外狀況 」 一節中所述。 某些例外狀況的值為何`throwOnError`。 例如，如果找到的型別，但無法載入，<xref:System.TypeLoadException>就會擲回即使`throwOnError`是`false`。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 陣列或 COM 型別不會搜尋除非它們已經被載入資料表可用的類別。  
  
 `typeName` 可以在型別名稱來限定其命名空間或組件限定名稱，其中包含組件名稱規格。 請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包含命名空間，但不是組件名稱，這個方法會依此順序搜尋只呼叫物件的組件和 Mscorlib.dll。 如果部分或完整的組件名稱完整限定類型名稱，這個方法會搜尋指定的組件中。 如果組件具有強式名稱，完整的組件的名稱是必要。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀型別、 組件名稱和泛型引數。 支援通用語言執行平台的所有編譯器將都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。 您也可以藉由建立載入類型<xref:System.Reflection.AssemblyName>物件，並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。 您可以接著使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。 請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|倒單引號 （'）|前面有一或多個位數表示的型別參數，位於結尾的泛型型別名稱的數目。|  
|括號 ([])|將建構的泛型類型; 泛型型別引數清單在類型引數清單中，將組件限定型別。|  
|逗號 （，）|後面接著組件名稱。|  
|句號 （.）|表示命名空間識別項。|  
|加號 （+）|在之前的巢狀的類別。|  
  
 例如，類別的完整格式的名稱可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空間已 TopNamespace.Sub+Namespace，則字串會有之前加號 （+），以逸出字元 (\\) 以防止它被解譯為巢狀分隔符號。 反映會發出此字串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"會變成"\\+\\+"，和 「\\」 變成 「\\\\"。  
  
 這個限定的名稱可以保存和更新版本用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>使用型別名稱只有或使用組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與型別名稱只會尋找<xref:System.Type>呼叫者的組件中，然後在系統組件中。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 類型名稱可能包含行尾字元來表示的類型，例如類型是否為參考型別、 指標類型或陣列類型的其他資訊。 若要擷取的型別名稱，而不需要這些後置字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。  
  
 空格是相關的組件名稱以外的所有型別名稱元件。 在組件名稱 '，' 分隔符號之前的空格是相關的但是 '，' 分隔符號之後的空格會被忽略。  
  
 泛型型別名稱的結尾倒引號 (\`) 後面接著數字，代表泛型類型引數數目。 此名稱的損害的目的是讓編譯器支援泛型型別具有相同名稱但具有不同數目的型別參數，在相同的範圍內發生。 例如，反映會傳回損害的名稱`Tuple`1` and `Tuple`2`的泛型方法`Tuple(Of T)`並`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。  
  
 為泛型類型，類型引數清單以括號、，並以逗號分隔的類型引數。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能如下表示：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定型別引數清單中的組件限定型別，請將括號括住的組件限定型別。 否則，逗號分隔的組件限定名稱的組件會被視為分隔其他的型別引數。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`MyAssembly.dll 中，使用索引鍵的類型從<xref:System.String>，可能會以下面方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  組件限定型別可以括在括弧，它必須出現在類型參數清單中。 搜尋組件限定的不合格的型別的型別參數清單中的規則並符合規定及不合格的非泛型類型的規則相同。  
  
 可為 null 的型別是泛型類型的特殊案例。 例如，可為 null <xref:System.Int32> "System.Nullable'1[System.Int32]"的字串表示。  
  
> [!NOTE]
>  在 C#、 c + + 和 Visual Basic 中，您也可以取得可為 null 的型別使用型別運算子。 比方說，可為 null<xref:System.Boolean>型別由`typeof(Nullable<bool>)`在 C# 中，依`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`Visual Basic 中。  
  
 下表顯示您所使用的語法`GetType`為各種型別。  
  
|若要取得|使用|  
|------------|---------|  
|可為 null <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Unmanaged 的指標 `MyType`|`Type.GetType("MyType*")`|  
|指標的 unmanaged 的指標 `MyType`|`Type.GetType("MyType**")`|  
|Managed 的指標或參考 `MyType`|`Type.GetType("MyType&")`. 請注意，參考與指標不同，僅限一個層級。|  
|父類別和巢狀的類別|`Type.GetType("MyParentClass+MyNestedClass")`|  
|一維陣列，其下限為 0|`Type.GetType("MyArray[]")`|  
|下限不明的一維陣列|`Type.GetType("MyArray[*]")`|  
|N 維陣列|逗號 （，） 的 n-1 次數總計的方括號內。 例如，`System.Object[,,]`代表三維`Object`陣列。|  
|二維陣列的陣列|`Type.GetType("MyArray[][]")`|  
|矩形的二維陣列下限不明|`Type.GetType("MyArray[,]")`|  
|具有一個型別引數的泛型型別|``Type.GetType("MyGenericType`1[MyType]")``|  
|兩個類型引數的泛型型別|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有兩個組件限定型別引數的泛型型別|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|使用組件限定型別引數，組件限定的泛型類型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|其類型引數是具有兩個類型引數的泛型型別是泛型型別|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 下列範例會擷取的型別`System.Int32`並使用該型別物件來顯示<xref:System.Type.FullName%2A>屬性`System.Int32`。 如果不存在的組件參考的型別物件，此範例會擲回例外狀況。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。 
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
-或- 
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效的語法。 例如，"MyType[,*,]"。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
-或- 
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
-或- 
目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的組件限定名稱。 請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果此類型位在目前執行的組件或 Mscorlib.dll 中，則提供其命名空間所限定的類型名稱便已足夠。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。指定 <see langword="false" /> 還會隱藏一些其他例外情況，但不是全部。 請參閱＜例外狀況＞一節。</param>
        <param name="ignoreCase">
          <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</param>
        <summary>取得具有指定名稱的 <see cref="T:System.Type" />，指定找不到類型時是否要擲回例外狀況，以及是否要執行區分大小寫的搜尋。</summary>
        <returns>具有指定名稱的類型。 如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Type.GetType%2A>方法，以取得<xref:System.Type>中另一個組件，類型的物件，如果您知道可從其組件限定名稱<xref:System.Type.AssemblyQualifiedName>。 <xref:System.Type.GetType%2A> 會導致在指定的組件載入`typeName`。 您也可以載入組件<xref:System.Reflection.Assembly.Load%2A>方法，然後使用<xref:System.Type.GetType%2A>或是<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>類別，以取得<xref:System.Type>物件。 如果類型是在編譯時期已知到您的程式組件中，會使用更有效率`typeof`在 C# 中，<xref:System.Type.GetType%2A>在 Visual Basic 中，或`typeid`c + + 中。  
  
 `GetType` 僅適用於從磁碟載入的組件。 如果您呼叫`GetType`查閱使用定義動態組件中定義的型別<xref:System.Reflection.Emit>服務，您可能會收到不一致的行為。 行為取決於動態組件是持續性的也就是，使用建立`RunAndSave`或是`Save`存取模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列舉型別。 如果動態組件是持續性，並已寫入磁碟之前`GetType`是呼叫，載入器在磁碟上找到儲存的組件、 載入該組件中，而且該組件中擷取的型別。 如果組件尚未儲存至磁碟`GetType`呼叫時，此方法會傳回`null`。 `GetType` 不了解暫時性動態組件;因此，呼叫`GetType`若要擷取型別中的暫時性動態組件傳回`null`。  
  
 若要使用`GetType`上的動態模組，訂閱<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件，並呼叫`GetType`在儲存之前。 否則，您會得到兩個組件的複本在記憶體中。  
  
 `throwOnError`參數會指定時會發生什麼事的型別找不到，並會隱藏其他某些例外情況，例外狀況 」 一節中所述。 某些例外狀況的值為何`throwOnError`。 例如，如果找到的型別，但無法載入，<xref:System.TypeLoadException>就會擲回即使`throwOnError`是`false`。  
  
 下表顯示基底類別成員會傳回由`Get`反映型別上時的方法。  
  
|成員類型|Static|非靜態|  
|-----------------|------------|-----------------|  
|建構函式|否|否|  
|欄位|否|可以。 欄位永遠是依名稱和簽章隱藏。|  
|Event - 事件|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
|方法|否|可以。 （虛擬和非虛擬） 的方法可以隱藏依名稱或依名稱和簽章隱藏。|  
|巢狀的類型|否|否|  
|屬性|不適用|一般類型系統規則是繼承實作屬性的方法相同。 反映會視為由名稱和簽章隱藏屬性。 請參閱附註 2。|  
  
1.  依名稱和簽章隱藏會考慮所有組件的簽章，包括自訂修飾詞，傳回類型、 參數類型、 sentinels 和 unmanaged 呼叫慣例。 這是二進位比較。  
  
2.  反映的屬性和事件會依名稱和簽章隱藏。 如果您同時有 get 和 set 存取子的屬性在基底類別中，但衍生的類別有只有 get 存取子，在衍生的類別的屬性會隱藏基底類別屬性中，並不能存取的基底類別的 setter。  
  
3.  自訂屬性不屬於一般類型系統。  
  
 陣列或 COM 型別不會搜尋除非它們已經被載入資料表可用的類別。  
  
 `typeName` 可以在型別名稱來限定其命名空間或組件限定名稱，其中包含組件名稱規格。 請參閱 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包含命名空間，但不是組件名稱，這個方法會依此順序搜尋只呼叫物件的組件和 Mscorlib.dll。 如果部分或完整的組件名稱完整限定類型名稱，這個方法會搜尋指定的組件中。 如果組件具有強式名稱，完整的組件的名稱是必要。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>屬性會傳回完整的型別名稱，包括巢狀型別、 組件名稱和型別引數。 支援通用語言執行平台的所有編譯器將都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，它不包含在所傳回的字串<xref:System.Type.AssemblyQualifiedName%2A>屬性，因為相容性。 您也可以藉由建立載入類型<xref:System.Reflection.AssemblyName>物件，並將其傳遞至適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。 您可以接著使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法來載入組件類型。 請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|倒單引號 （'）|前面有一或多個位數表示的型別參數，位於結尾的泛型型別名稱的數目。|  
|括號 ([])|將建構的泛型類型; 泛型型別引數清單在類型引數清單中，將組件限定型別。|  
|逗號 （，）|後面接著組件名稱。|  
|句號 （.）|表示命名空間識別項。|  
|加號 （+）|在之前的巢狀的類別。|  
  
 例如，類別的完整格式的名稱可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空間已 TopNamespace.Sub+Namespace，則字串會有之前加號 （+），以逸出字元 (\\) 以防止它被解譯為巢狀分隔符號。 反映會發出此字串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"會變成"\\+\\+"，和 「\\」 變成 「\\\\"。  
  
 這個限定的名稱可以保存和更新版本用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>使用型別名稱只有或使用組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與型別名稱只會尋找<xref:System.Type>呼叫者的組件中，然後在系統組件中。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 類型名稱可能包含行尾字元來表示的類型，例如類型是否為參考型別、 指標類型或陣列類型的其他資訊。 若要擷取的型別名稱，而不需要這些後置字元，請使用`t.GetElementType().ToString()`，其中`t`是型別。  
  
 空格是相關的組件名稱以外的所有型別名稱元件。 在組件名稱 '，' 分隔符號之前的空格是相關的但是 '，' 分隔符號之後的空格會被忽略。  
  
 泛型型別名稱的結尾倒引號 (\`) 後面接著數字，代表泛型類型引數數目。 此名稱的損害的目的是讓編譯器支援泛型型別具有相同名稱但具有不同數目的型別參數，在相同的範圍內發生。 例如，反映會傳回損害的名稱`Tuple`1` and `Tuple`2`的泛型方法`Tuple(Of T)`並`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和 Tuple`\<T0, T1>` Visual C# 中。  
  
 為泛型類型，類型引數清單以括號、，並以逗號分隔的類型引數。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>有兩個類型參數。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`類型的索引鍵聯<xref:System.String>可能如下表示：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定型別引數清單中的組件限定型別，請將括號括住的組件限定型別。 否則，逗號分隔的組件限定名稱的組件會被視為分隔其他的型別引數。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`MyAssembly.dll 中，使用索引鍵的類型從<xref:System.String>，可能會以下面方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  組件限定型別可以括在括弧，它必須出現在類型參數清單中。 搜尋組件限定的不合格的型別的型別參數清單中的規則並符合規定及不合格的非泛型類型的規則相同。  
  
 可為 null 的型別是泛型類型的特殊案例。 例如，可為 null <xref:System.Int32> "System.Nullable'1[System.Int32]"的字串表示。  
  
> [!NOTE]
>  在 C#、 c + + 和 Visual Basic 中，您也可以取得可為 null 的型別使用型別運算子。 比方說，可為 null<xref:System.Boolean>型別由`typeof(Nullable<bool>)`在 C# 中，依`Nullable<Boolean>::typeid`c + + 和`GetType(Nullable(Of Boolean))`Visual Basic 中。  
  
 下表顯示您所使用的語法`GetType`為各種型別。  
  
|若要取得|使用|  
|------------|---------|  
|可為 null <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Unmanaged 的指標 `MyType`|`Type.GetType("MyType*")`|  
|指標的 unmanaged 的指標 `MyType`|`Type.GetType("MyType**")`|  
|Managed 的指標或參考 `MyType`|`Type.GetType("MyType&")`. 請注意，參考與指標不同，僅限一個層級。|  
|父類別和巢狀的類別|`Type.GetType("MyParentClass+MyNestedClass")`|  
|一維陣列，其下限為 0|`Type.GetType("MyArray[]")`|  
|下限不明的一維陣列|`Type.GetType("MyArray[*]")`|  
|N 維陣列|逗號 （，） 的 n-1 次數總計的方括號內。 例如，`System.Object[,,]`代表三維`Object`陣列。|  
|二維陣列的陣列|`Type.GetType("MyArray[][]")`|  
|矩形的二維陣列下限不明|`Type.GetType("MyArray[,]")`|  
|具有一個型別引數的泛型型別|``Type.GetType("MyGenericType`1[MyType]")``|  
|兩個類型引數的泛型型別|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有兩個組件限定型別引數的泛型型別|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|使用組件限定型別引數，組件限定的泛型類型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|其類型引數是具有兩個類型引數的泛型型別是泛型型別|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。 
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
-或- 
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效的語法。 例如，"MyType[,*,]"。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
-或- 
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
-或- 
目前載入的通用語言執行平台是 2.0 版或更新的版本，但用來編譯組件的卻是更新的版本。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的名稱。 如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。 如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</param>
        <param name="assemblyResolver">方法，會找出並傳回 <c>typeName</c> 中指定的組件。 組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。 如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。  
  
注意：不要從未知或未受信任的呼叫端傳遞方法。 這樣做可能會提高惡意程式碼的權限。 只使用您所提供或熟悉的方法。</param>
        <param name="typeResolver">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。 如果未提供任何組件，<c>typeResolver</c> 方法會提供一個組件。 這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <see langword="false" /> 至該參數。  
  
注意：不要從未知或未受信任的呼叫端傳遞方法。</param>
        <summary>取得具有指定名稱的類型，並選擇性提供自訂方法來解析組件和類型。</summary>
        <returns>具有指定名稱的類型；如果找不到類型，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法和詳細的使用案例`assemblyResolver`並`typeResolver`參數可在<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。  
  
> [!NOTE]
>  如果`typeName`找不到，呼叫<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>方法會傳回`null`。 它不會擲回例外狀況。 若要控制是否發生例外狀況，請呼叫的多載<xref:System.Type.GetType%2A>方法具有`throwOnError`參數。  
  
 呼叫這個方法多載等同於呼叫<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，並指定`false`for`throwOnError`和`ignoreCase`參數。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentException">將 <paramref name="typeName" /> 剖析成類型名稱和組件名稱時 (例如簡單類型名稱包含未逸出的特殊字元時) 發生錯誤。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
-或- 
 <paramref name="typeName" /> 代表泛型類型，而其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或組件的其中一個相依性，但無法加以載入。  
  
-或- 
 <paramref name="typeName" /> 包含無效組件名稱。  
  
-或- 
 <paramref name="typeName" /> 是不具類型名稱的有效組件名稱。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
-或- 
用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的名稱。 如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。 如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</param>
        <param name="assemblyResolver">方法，會找出並傳回 <c>typeName</c> 中指定的組件。 組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。 如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。  
  
注意：不要從未知或未受信任的呼叫端傳遞方法。 這樣做可能會提高惡意程式碼的權限。 只使用您所提供或熟悉的方法。</param>
        <param name="typeResolver">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。 如果未提供任何組件，方法會提供一個組件。 這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <see langword="false" /> 至該參數。  
  
注意：不要從未知或未受信任的呼叫端傳遞方法。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。 指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。 請參閱＜例外狀況＞一節。</param>
        <summary>取得具有指定名稱的類型，指定找不到類型時是否擲回例外狀況，同時選擇性提供自訂方法來解析組件和類型。</summary>
        <returns>具有指定名稱的類型。 如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法和詳細的使用案例`assemblyResolver`並`typeResolver`參數可在<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。  
  
 呼叫這個方法多載等同於呼叫<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，並指定`false`如`ignoreCase`參數。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。 
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
-或- 
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.ArgumentException">將 <paramref name="typeName" /> 剖析成類型名稱和組件名稱 (例如簡單類型名稱包含未逸出的特殊字元) 時發生錯誤。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效語法 (例如 "MyType[,*,]")。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
-或- 
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或其相依性的其中之一。  
  
-或- 
 <paramref name="typeName" /> 包含無效組件名稱。  
  
-或- 
 <paramref name="typeName" /> 是不具類型名稱的有效組件名稱。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
-或- 
用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之類型的名稱。 如果已提供 <c>typeResolver</c> 參數，則類型名稱可為 <c>typeResolver</c> 能解析的任何字串。 如果已提供 <c>assemblyResolver</c> 參數或已使用標準類型解析，<c>typeName</c> 就必須是組件限定名稱 (請參閱 <see cref="P:System.Type.AssemblyQualifiedName" />)，除非類型位於目前正在執行的組件或 Mscorlib.dll 中，這種情況時，此類型就能提供本身命名空間限定的類型名稱。</param>
        <param name="assemblyResolver">方法，會找出並傳回 <c>typeName</c> 中指定的組件。 組件名稱做為 <see cref="T:System.Reflection.AssemblyName" /> 物件傳遞至 <c>assemblyResolver</c>。 如果 <c>typeName</c> 不包含組件名稱，則不會呼叫 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，則會執行標準組件解析。  
  
注意：不要從未知或未受信任的呼叫端傳遞方法。 這樣做可能會提高惡意程式碼的權限。 只使用您所提供或熟悉的方法。</param>
        <param name="typeResolver">從 <c>assemblyResolver</c> 或標準組件解析傳回的組件，找出並傳回由 <c>typeName</c> 指定之類型的方法。 如果未提供任何組件，方法會提供一個組件。 這個方法也使用參數來指定是否執行不區分大小寫的搜尋。會傳遞 <c>ignoreCase</c> 的值至該參數。  
  
注意：不要從未知或未受信任的呼叫端傳遞方法。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。 指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。 請參閱＜例外狀況＞一節。</param>
        <param name="ignoreCase">
          <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</param>
        <summary>取得具有指定名稱的類型，指定是否執行區分大小寫的搜尋以及找不到類型時是否擲回例外狀況，同時選擇性提供自訂方法來解析組件和類型。</summary>
        <returns>具有指定名稱的類型。 如果找不到該類型，<paramref name="throwOnError" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwOnError" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法多載和其相關聯的多載 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>並<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) 來取代的預設實作<xref:System.Type.GetType%2A>具有更具彈性的實作方法。 藉由提供您自己解決類型名稱和包含它們的組件名稱的方法，您可以執行下列作業：  
  
-   控制型別會從載入的組件的版本。  
  
-   提供了另一個位置尋找不包含組件名稱的型別名稱。  
  
-   使用部分組件名稱的組件載入。  
  
-   傳回的子類別<xref:System.Type?displayProperty=nameWithType>，不由 common language runtime (CLR) 建立。  
  
 比方說，在版本相容序列化這個方法可讓您使用的部分名稱來搜尋"best fit"的組件。 其他多載<xref:System.Type.GetType%2A>方法需要的組件限定類型名稱，其中包含的版本號碼。  
  
 型別系統的替代實作可能要傳回的子<xref:System.Type?displayProperty=nameWithType>，不會建立由 CLR; 所有類型的其他多載會傳回<xref:System.Type.GetType%2A>方法都是執行階段型別。  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>使用方式附註  
 這個方法多載和其相關聯的多載剖析`typeName`至型別和組件名稱的名稱，然後解析名稱。 解析的型別名稱之前, 的事件，是因為型別名稱必須解析組件的內容中發生的組件名稱的解析。  
  
> [!NOTE]
>  如果您熟悉管理組件限定類型名稱的概念，請參閱<xref:System.Type.AssemblyQualifiedName%2A>屬性。  
  
 如果`typeName`不是組件限定名稱，就會略過組件解析。 可以 Mscorlib.dll 或目前正在執行的組件的內容中解析不合格的類型名稱，或您可以選擇性地提供中的組件`typeResolver`參數。 要包含或省略的組件名稱，不同類型的名稱解析會以表格形式顯示的效果[混合的名稱解析](#mixed_name_resolution)一節。  
  
 一般使用方式附註：  
  
-   不要傳遞至方法`assemblyResolver`或`typeResolver`如果它們是來自未知或不受信任呼叫端。 只使用您所提供或熟悉的方法。  
  
    > [!CAUTION]
    >  使用來自未知或不受信任呼叫端的方法，可能會造成提高權限的惡意程式碼。  
  
-   如果您省略`assemblyResolver`及/或`typeResolver`參數、 值`throwOnError`參數傳遞至此執行預設的解析的方法。  
  
-   如果`throwOnError`是`true`，這個方法會擲回<xref:System.TypeLoadException>當`typeResolver`會傳回`null`，和<xref:System.IO.FileNotFoundException>當`assemblyResolver`傳回`null`。  
  
-   這個方法不會攔截擲回例外狀況`assemblyResolver`和`typeResolver`。 您負責的解析程式方法所擲回任何例外狀況。  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>解析組件  
 `assemblyResolver`方法會接收<xref:System.Reflection.AssemblyName>物件，它會藉由剖析字串組件名稱包含在產生`typeName`。 如果`typeName`不包含組件名稱，`assemblyResolver`就不會呼叫並`null`傳遞給`typeResolver`。  
  
 如果`assemblyResolver`不提供標準的組件探查用來尋找組件。 如果`assemblyResolver`提供，則<xref:System.Type.GetType%2A>方法不會執行標準探查; 在此情況下，您必須確定，您`assemblyResolver`可以處理您傳遞給它的所有組件。  
  
 `assemblyResolver`方法應傳回`null`如果無法解析組件。 如果`assemblyResolver`會傳回`null`，`typeResolver`就不會呼叫並不進行任何處理就會發生; 此外，如果`throwOnError`是`true`、<xref:System.IO.FileNotFoundException>就會擲回。  
  
 如果<xref:System.Reflection.AssemblyName>傳遞至`assemblyResolver`是部分名稱、 一或多個其組件是`null`。 例如，如果不有任何版本中，<xref:System.Reflection.AssemblyName.Version%2A>屬性是`null`。 如果<xref:System.Reflection.AssemblyName.Version%2A>屬性，<xref:System.Reflection.AssemblyName.CultureInfo%2A>屬性，而<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>方法都會傳回`null`，然後提供組件的簡單名稱。 `assemblyResolver`方法可以使用或忽略所有組件的組件名稱。  
  
 不同的組件解析選項的效果會顯示以表格形式[混合的名稱解析](#mixed_name_resolution)區段中的，針對簡單和組件限定類型名稱。  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>解析型別  
 如果`typeName`未指定組件名稱，`typeResolver`一定會呼叫。 如果`typeName`指定組件名稱，`typeResolver`只有成功解析組件名稱時，才會呼叫。 如果`assemblyResolver`或 探查傳回的標準組件`null`，`typeResolver`就不會呼叫。  
  
 `typeResolver`方法接收的三個引數：  
  
-   要搜尋的組件或`null`如果`typeName`不包含組件名稱。  
  
-   簡單類型的名稱。 當巢狀型別，這是最外層包含型別。 當泛型型別，這是泛型類型的簡單名稱。  
  
-   布林值，是`true`型別名稱的大小寫是否要忽略。  
  
 實作會判定這些引數使用的方式。 `typeResolver`方法應傳回`null`若無法解析型別。 如果`typeResolver`會傳回`null`並`throwOnError`是`true`的這個多載<xref:System.Type.GetType%2A>就會擲回<xref:System.TypeLoadException>。  
  
 不同的型別解析選項的效果會顯示以表格形式[混合的名稱解析](#mixed_name_resolution)區段中的，針對簡單和組件限定類型名稱。  
  
#### <a name="resolving-nested-types"></a>解析巢狀型別  
 如果`typeName`是巢狀的類型，而只有名稱的最外層包含型別傳遞至`typeResolver`。 當`typeResolver`會傳回這個型別，<xref:System.Type.GetNestedType%2A>方法會呼叫遞迴，直到最內層的巢狀型別已解決。  
  
#### <a name="resolving-generic-types"></a>解析泛型型別  
 <xref:System.Type.GetType%2A>稱為遞迴運作來解決泛型型別： 首先要解決的泛型型別本身，然後解決它的型別引數。 如果型別引數是泛型，<xref:System.Type.GetType%2A>稱為遞迴運作來解決其型別引數，等等。  
  
 組合`assemblyResolver`和`typeResolver`您提供必須能夠解析這類遞迴的所有層級。 例如，假設您提供`assemblyResolver`控制載入`MyAssembly`。 假設您想要解析的泛型型別`Dictionary<string, MyType>`(`Dictionary(Of String, MyType)` Visual Basic 中)。 您可能會傳遞下列泛型型別名稱：  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 請注意，`MyType`是只有組件限定型別引數。 名稱<xref:System.Collections.Generic.Dictionary%602>和<xref:System.String>類別不是組件限定。 您`typeResolver`必須是其中任一組件無法控制代碼或`null`，因為它會接收`null`如<xref:System.Collections.Generic.Dictionary%602>和<xref:System.String>。 它可以處理這種情況下，藉由呼叫的多載<xref:System.Type.GetType%2A>取用一個字串，因為這兩個非限定的類型名稱是在 Mscorlib.dll 中的方法：  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver`不會呼叫方法的字典類型和字串類型，因為這些型別名稱不是組件限定。  
  
 現在假設，而不是`System.String`，第一個泛型引數類型是`YourType`，從`YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 因為此組件 Mscorlib.dll 或目前正在執行的組件都不，您不能解決`YourType`不含組件限定名稱。 因為您`assemblyResolve`會遞迴呼叫，它必須能夠處理這種情況。 而不是傳回`null`以外的組件`MyAssembly`，它現在會執行使用所提供的組件載入<xref:System.Reflection.AssemblyName>物件。  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 回到[使用方式附註](#usage_notes)。  
  
#### <a name="resolving-type-names-with-special-characters"></a>解析含有特殊字元的類型名稱  
 某些字元在組件限定名稱中具有特殊意義。 如果是簡單類型名稱會包含這些字元，字元的簡單名稱組件限定名稱的一部分時，就會導致剖析錯誤。 若要避免發生剖析錯誤，您必須逸出特殊字元加上反斜線之前您可以將傳遞的組件限定名稱<xref:System.Type.GetType%2A>方法。 例如，如果名為的型別`Strange]Type`，逸出字元必須加入括號前面，如下所示： `Strange\]Type`。  
  
> [!NOTE]
>  無法在 Visual Basic 或 C# 中，建立含有這類特殊字元的名稱，但可由使用 Microsoft intermediate language (MSIL)，或發出動態組件。  
  
 下表顯示型別名稱的特殊字元。  
  
|字元|意義|  
|---------------|-------------|  
|`,` （逗號）|組件限定名稱的分隔符號。|  
|`[]` （方括弧）|為後置詞組，表示陣列型別;分隔符號組中，為封入泛型引數清單和組件限定名稱。|  
|`&` （連字號）|當做尾碼，表示型別是參考型別。|  
|`*` （星號）|做為尾碼，表示為型別是指標類型。|  
|`+` （加號）|巢狀類型的分隔符號。|  
|`\` （反斜線）|逸出字元。|  
  
 屬性，例如<xref:System.Type.AssemblyQualifiedName%2A>傳回正確逸出字串。 您必須傳遞正確逸出的字串<xref:System.Type.GetType%2A>方法。 依次<xref:System.Type.GetType%2A>方法會傳遞到的正確逸出的名稱`typeResolver`以及預設型別解析方法。 如果您要比較的名稱中的未逸出名稱`typeResolver`，您必須先移除逸出字元。  
  
 回到[使用方式附註](#usage_notes)。  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>混合的名稱解析  
 下表摘要說明之間的互動`assemblyResolver`， `typeResolver`，和預設名稱解析的型別名稱和組件名稱中的所有組合`typeName`:  
  
|型別名稱的內容|組件解析程式方法|類型解析程式方法|結果|  
|---------------------------|------------------------------|--------------------------|------------|  
|型別，組件|null|null|相當於呼叫<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載。|  
|型別，組件|提供|null|`assemblyResolver` 傳回組件，則傳回`null`若無法解析組件。 如果組件已解決，<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載用來從組件載入的型別; 否則就不會嘗試解析的型別。|  
|型別，組件|null|提供|相當於將轉換的組件名稱<xref:System.Reflection.AssemblyName>物件並呼叫<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>方法多載，以取得組件。 如果組件已解決，請將它傳遞給`typeResolver`; 否則即為`typeResolver`就不會呼叫，而且沒有任何進一步嘗試解析的型別。|  
|型別，組件|提供|提供|`assemblyResolver` 傳回組件，則傳回`null`若無法解析組件。 如果組件已解決，請將它傳遞給`typeResolver`; 否則即為`typeResolver`就不會呼叫，而且沒有任何進一步嘗試解析的型別。|  
|類型|null、 提供|null|相當於呼叫<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載。 因為未提供組件名稱，就會搜尋只有 Mscorlib.dll 和目前執行的組件。 如果`assemblyResolver`提供，則會忽略它。|  
|類型|null、 提供|提供|`typeResolver` 呼叫時，和`null`傳遞組件。 `typeResolver` 可以提供任何組件，包括它的目的載入的組件中的型別。 如果`assemblyResolver`提供，則會忽略它。|  
|組件|null、 提供|null、 提供|A<xref:System.IO.FileLoadException>擲回，因為組件名稱會剖析一樣的組件限定類型名稱。 這會導致無效的組件名稱。|  
  
 回到：[使用方式附註](#usage_notes)，[解析組件](#resolving_assemblies)，[解析型別](#resolving_types)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。 
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
-或- 
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 的陣列。</exception>
        <exception cref="T:System.ArgumentException">將 <paramref name="typeName" /> 剖析成類型名稱和組件名稱 (例如簡單類型名稱包含未逸出的特殊字元) 時發生錯誤。  
  
-或- 
 <paramref name="throwOnError" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效語法 (例如 "MyType[,*,]")。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
-或- 
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或其相依性的其中之一，但無法載入。  
  
-或- 
 <paramref name="typeName" /> 包含無效組件名稱。  
  
-或- 
 <paramref name="typeName" /> 是不具類型名稱的有效組件名稱。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
-或- 
用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">要決定類型之物件的陣列。</param>
        <summary>取得指定陣列中物件的類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件的陣列，代表 <paramref name="args" /> 中對應項目的類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Type.GetTypeArray%2A>列出陣列的項目類型的方法。  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="args" /> 的其中一或多個項目為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用了類別初始設定式，並至少有一個會擲回例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要取得其基礎類型程式碼的類型。</param>
        <summary>取得指定的 <see cref="T:System.Type" /> 的基礎類型程式碼。</summary>
        <returns>基礎類型程式碼，如果 <see cref="F:System.TypeCode.Empty" /> 是 <paramref name="type" /> 則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您繼承自<xref:System.Type>，您可以藉由覆寫來變更此方法的行為<xref:System.Type.GetTypeCodeImpl%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.TypeCode>列舉型別可用。 在決策區塊`WriteObjectInfo`方法中，<xref:System.TypeCode>的<xref:System.Object>會檢查參數，並適當的訊息寫入至主控台。  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回此 <see cref="T:System.Type" /> 執行個體的基礎型別碼。</summary>
        <returns>基礎類型的型別碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法提供實作`static`（在 C# 中) 或`Shared`（在 Visual Basic)<xref:System.Type.GetTypeCode%28System.Type%29>方法。 當您繼承自<xref:System.Type>，您可以覆寫此方法以提供您自己實作<xref:System.Type.GetTypeCode%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得與指定的類別識別項 (CLSID) 關聯的類型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">要取得之類型的 CLSID。</param>
        <summary>取得與指定的類別識別項 (CLSID) 關聯的類型。</summary>
        <returns>
          <see langword="System.__ComObject" /> (不論 CLSID 是否有效)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取未受管理的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。  COM 類別的類別識別項被定義在登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。 您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。  
  
> [!TIP]
>  您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法以晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。  
  
 具現化 unmanaged 的 COM 物件的 CLSID 是兩步驟程序：  
  
1.  取得<xref:System.Type>物件，表示`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法具現化 COM 物件。  
  
 請參閱圖的範例。  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29>多載會忽略任何會具現化時，可能會發生例外狀況<xref:System.Type>物件，根據`clsid`引數。 請注意，如果將會擲回任何例外狀況`clsid`在登錄中找不到。  
  
   
  
## Examples  
 下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)擷取代表 Microsoft Word 應用程式的 COM 類型。 它接著會執行個體化類型藉由呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>這個方法是用於使用 COM 物件，不會與.NET Framework 物件。 所有受管理的物件，包括為 COM 可見的 (也就是他們<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。 雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件來建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。  
  
[！ 的程式碼 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [！ 的程式碼 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">要取得之類型的 CLSID。</param>
        <param name="throwOnError">
          <see langword="true" />，擲回任何會發生的例外狀況。  
  
-或- 
 <see langword="false" /> 則忽略任何會發生的例外狀況。</param>
        <summary>取得與指定的類別識別項 (CLSID) 關聯的類型，並指定如果載入類型時發生錯誤是否擲回例外狀況。</summary>
        <returns>
          <see langword="System.__ComObject" /> (不論 CLSID 是否有效)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取未受管理的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。  COM 類別的類別識別項被定義在登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。 您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。  
  
> [!TIP]
>  您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法以晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。  
  
 具現化 unmanaged 的 COM 物件的 CLSID 是兩步驟程序：  
  
1.  取得<xref:System.Type>物件，表示`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法具現化 COM 物件。  
  
 請參閱圖的範例。  
  
 這類例外狀況<xref:System.OutOfMemoryException>指定時就會擲回`true`如`throwOnError`，但不是會取消註冊的 Clsid 為失敗。  
  
   
  
## Examples  
 下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)擷取代表 Microsoft Word 應用程式的 COM 類型。 它接著會執行個體化類型藉由呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法。 如果在載入類型時發生錯誤，則會擲回例外狀況。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>這個方法是用於使用 COM 物件，不會與.NET Framework 物件。 所有受管理的物件，包括為 COM 可見的 (也就是他們<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。 雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件來建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。  
  
[！ 的程式碼 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [！ 的程式碼 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">要取得之類型的 CLSID。</param>
        <param name="server">要載入類型的伺服器。 如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</param>
        <summary>從指定的伺服器中，取得與指定的類別識別項 (CLSID) 相關聯的類型。</summary>
        <returns>
          <see langword="System.__ComObject" /> (不論 CLSID 是否有效)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取未受管理的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。  COM 類別的類別識別項被定義在登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。 您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。  
  
> [!TIP]
>  您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法以晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。  
  
 具現化 unmanaged 的 COM 物件的 CLSID 是兩步驟程序：  
  
1.  取得<xref:System.Type>物件，表示`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法具現化 COM 物件。  
  
   
  
## Examples  
 下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)擷取代表 Microsoft Word 應用程式，從名為 computer17.central.contoso.com 伺服器 COM 型別。 它接著會執行個體化類型藉由呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>這個方法是用於使用 COM 物件，不會與.NET Framework 物件。 所有受管理的物件，包括為 COM 可見的 (也就是他們<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。 雖然此方法會傳回<see cref="T:System.Type" />適用於.NET Framework 對應至 GUID 的物件，您不能使用該<see cref="T:System.Type" />物件來建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例所示。  
  
[！ 的程式碼 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [！ 的程式碼 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">要取得之類型的 CLSID。</param>
        <param name="server">要載入類型的伺服器。 如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</param>
        <param name="throwOnError">
          <see langword="true" />，擲回任何會發生的例外狀況。  
  
-或- 
 <see langword="false" /> 則忽略任何會發生的例外狀況。</param>
        <summary>從指定的伺服器中，取得與指定的類別識別項 (CLSID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</summary>
        <returns>
          <see langword="System.__ComObject" /> (不論 CLSID 是否有效)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支援晚期繫結存取未受管理的 COM 物件從.NET Framework 應用程式時您知道 COM 物件的類別識別項 (CLSID)。  COM 類別的類別識別項被定義在登錄的 HKEY_CLASSES_ROOT\CLSID 索引鍵。 您可以擷取的值<xref:System.Type.IsCOMObject%2A>屬性來判斷這個方法所傳回的型別是否為 COM 物件。  
  
> [!TIP]
>  您可以呼叫<xref:System.Type.GetTypeFromProgID%2A>方法以晚期繫結存取 COM 物件程式設計識別項 (ProgID) 您知道。  
  
 具現化 unmanaged 的 COM 物件的 CLSID 是兩步驟程序：  
  
1.  取得<xref:System.Type>物件，表示`__ComObject`藉由呼叫對應至 CLSID<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  呼叫<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法具現化 COM 物件。  
  
 這類例外狀況<xref:System.OutOfMemoryException>指定時就會擲回`true`如`throwOnError`，但不是會取消註冊的 Clsid 為失敗。  
  
   
  
## Examples  
 下列範例會使用 Microsoft Word 的 CLSID[應用程式物件](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)擷取代表 Microsoft Word 應用程式，從名為 computer17.central.contoso.com 伺服器 COM 型別。 它接著會執行個體化類型藉由呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並將它關閉藉由呼叫[Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法。 如果在載入類型時發生錯誤，則會擲回例外狀況。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>這個方法是用於使用 COM 物件，不會與.NET Framework 物件。 所有受管理的物件，包括為 COM 可見的 (也就是他們<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />屬性是<see langword="true" />) 由 guid<see cref="P:System.Type.GUID" />屬性。 雖然<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />方法會傳回<see cref="T:System.Type" />物件，對應至特定的受管理物件的 GUID 不能使用該<see cref="T:System.Type" />物件來建立類型執行個體，藉由呼叫<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下列範例顯示。  
  
[！ 的程式碼 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [！ 的程式碼 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反地，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只應該用來擷取的 unmanaged 的 COM 物件，與產生的 GUID<see cref="T:System.Type" />物件傳遞至<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必須代表 unmanaged 的 COM 物件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">參考類型的物件。</param>
        <summary>取得指定的類型控制代碼所參考的類型。</summary>
        <returns>由指定 <see cref="T:System.RuntimeTypeHandle" /> 參考的類型，如果 <see langword="null" /> 的 <see cref="P:System.RuntimeTypeHandle.Value" /> 屬性為 <paramref name="handle" /> 則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 點只在它們所取得的應用程式定義域中是有效的。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.GetTypeFromHandle%2A>方法來取得<xref:System.Type>物件<xref:System.RuntimeTypeHandle>所提供<xref:System.Type.GetTypeHandle%2A>方法。  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得與指定的程式識別項 (ProgID) 相關聯的類型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要取得之類型的 ProgID。</param>
        <summary>取得與指定的程式識別項 (ProgID) 相關聯的類型；如果在載入 <see cref="T:System.Type" /> 時發生錯誤，則傳回 null。</summary>
        <returns>如果 <paramref name="progID" /> 在登錄中是有效項目，而且有類型與它相關聯，則為與指定的 ProgID 相關聯的類型，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法提供用於 COM 支援。 Progid 不會使用 Microsoft.NET Framework 中因為已取代命名空間的概念。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">要取得之類型的 ProgID。</param>
        <param name="throwOnError">
          <see langword="true" />，擲回任何會發生的例外狀況。  
  
-或- 
 <see langword="false" /> 則忽略任何會發生的例外狀況。</param>
        <summary>取得與指定的程式識別項 (ProgID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</summary>
        <returns>如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法提供用於 COM 支援。 因為已取代命名空間的概念，程式識別碼不會使用 Microsoft.NET Framework 中。  
  
   
  
## Examples  
 下列範例會擷取藉由傳遞 ProgID，指定是否要擲回例外狀況，如果是無效的 ProgID 的型別。 此範例接著會顯示相關的 ProgID，以及任何適用的例外狀況訊息的 ClassID。  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定的 ProgID 未註冊。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要取得之類型的 progID。</param>
        <param name="server">要載入類型的伺服器。 如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</param>
        <summary>從指定的伺服器中，取得與指定的程式識別項 (progID) 相關聯的類型；如果在載入類型時發生錯誤，則傳回 null。</summary>
        <returns>如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法提供用於 COM 支援。 因為已取代命名空間的概念，程式識別碼不會使用 Microsoft.NET Framework 中。  
  
   
  
## Examples  
 下列範例會擷取藉由傳遞的 ProgID 和伺服器名稱的型別。 範例接著會顯示相關的 progid，ClassID，或如果 ProgID 或的伺服器名稱無效，會擲回例外狀況。  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">要取得之 <see cref="T:System.Type" /> 的 progID。</param>
        <param name="server">要載入類型的伺服器。 如果伺服器名稱為 <see langword="null" />，此方法將會自動還原成本機電腦 (Local Machine)。</param>
        <param name="throwOnError">
          <see langword="true" />，擲回任何會發生的例外狀況。  
  
-或- 
 <see langword="false" /> 則忽略任何會發生的例外狀況。</param>
        <summary>從指定的伺服器中，取得與指定的程式識別項 (progID) 相關聯的類型，並指定如果在載入類型時發生錯誤是否擲回例外狀況。</summary>
        <returns>如果 <paramref name="progID" /> 在登錄中是有效的項目，且有與其相關聯的類型，則為與指定的程式識別項 (progID) 相關聯的類型，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法提供用於 COM 支援。 因為已取代命名空間的概念，程式識別碼不會使用 Microsoft.NET Framework 中。  
  
   
  
## Examples  
 下列範例會擷取藉由傳遞的 ProgID 和伺服器名稱的型別。 此範例接著會顯示相關的 ProgID，指定是否要擲回例外狀況，如果 ProgID 或的伺服器名稱是無效的 ClassID。  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">未註冊指定的 progID。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">要取得其類型控制代碼的物件。</param>
        <summary>取得指定物件的 <see cref="T:System.Type" /> 的控制代碼。</summary>
        <returns>指定 <see cref="T:System.Type" /> 之 <see cref="T:System.Object" /> 的控制代碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 點只在它們所取得的應用程式定義域中是有效的。  
  
   
  
## Examples  
 下列範例會定義類別`MyClass1`、 取得執行個體，和擷取物件的執行階段控制代碼。  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與 <see cref="T:System.Type" /> 相關聯的 GUID。</summary>
        <value>與 <see cref="T:System.Type" /> 相關聯的 GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID 是型別，使用相關聯<xref:System.Runtime.InteropServices.GuidAttribute>屬性。  
  
   
  
## Examples  
 下列範例會建立類別`MyClass1`的公用方法，會建立`Type`物件對應至`MyClass1`，並取得<xref:System.Guid>結構使用`GUID`屬性`Type`類別。  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前 <see cref="T:System.Type" /> 是否內含或參考其他類型；也就是說，目前 <see cref="T:System.Type" /> 是否為陣列、指標或以傳址方式傳遞。</summary>
        <value>如果 <see langword="true" /> 是陣列、指標或以傳址方式傳遞，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比方說，Type.GetType("Int32[]")。HasElementType 傳回`true`，但 Type.GetType("Int32")。傳回 HasElementType `false`。 HasElementType 也會傳回`true`為 「 Int32 *"和"Int32 &"。  
  
 如果目前<xref:System.Type>代表泛型類型或類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例會傳回`true`或`false`根據物件是否為陣列、 參考類型或指標。  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.HasElementType" /> 屬性並判斷目前 <see cref="T:System.Type" /> 是否內含或參考其他類型；也就是說，目前 <see cref="T:System.Type" /> 是否為陣列、指標或以傳址方式傳遞。</summary>
        <returns>如果 <see langword="true" /> 是陣列、指標或以傳址方式傳遞，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比方說，Type.GetType("Int32[]")。HasElementTypeImpl 傳回`true`，但 Type.GetType("Int32")。傳回 HasElementTypeImpl `false`。 HasElementTypeImpl 也會傳回`true`為 「 Int32 *"和"Int32 &"。  
  
   
  
## Examples  
 下列範例會定義類別`MyTypeDelegator`，它會覆寫`HasElementTypeImpl`方法。 主要的類別會檢查`HasElementType`屬性，並顯示項目類型。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>叫用目前 <see cref="T:System.Type" /> 的特定成員。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。  
  
-或- 
空字串 ("")，要叫用預設成員。  
  
-或- 
對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</param>
        <param name="invokeAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。 該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。 不需要指定查閱的類型。 如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。 請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</param>
        <param name="target">要在其上叫用指定成員的物件。</param>
        <param name="args">包含引數的陣列，這些引數會傳遞給要叫用的成員。</param>
        <summary>使用指定的繫結條件約束並符合指定的引數清單，來叫用指定的成員。</summary>
        <returns>表示叫用的成員之傳回值的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的成員：  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是 private 和 protected 成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只在宣告的成員，才<xref:System.Type>，不只是繼承的成員。  
  
 下列<xref:System.Reflection.BindingFlags>引動過程的旗標可以用來表示要與成員採取什麼動作：  
  
-   `CreateInstance` 若要叫用建構函式。 `name` 會被忽略。 與其他引動過程旗標無效。  
  
-   `InvokeMethod` 若要叫用方法，但不是建構函式或類型初始設定式。 使用不正確`SetField`或`SetProperty`。 如果`InvokeMethod`本身，由`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動包含在內。  
  
-   `GetField` 若要取得欄位的值。 與無效`SetField`。  
  
-   `SetField` 若要設定欄位的值。 與無效`GetField`。  
  
-   `GetProperty` 若要取得的屬性。 與無效`SetProperty`。  
  
-   `SetProperty` 若要設定的屬性。 與無效`GetProperty`。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果兩個下列條件成立，就會叫用方法：  
  
-   在方法宣告中的參數數目等於中的引數的數目`args`陣列 (除非該成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每個引數的類型可以轉換為參數的型別繫結器。  
  
 繫結器將會尋找所有相符的方法。 這些方法會找到根據要求的繫結的類型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。 一組方法會依名稱、 目的引數，以及一組繫結器中所定義的搜尋修飾詞進行篩選。  
  
 方法選取之後，它會叫用。 協助工具會在該點檢查。 搜尋可能會控制哪一組方法會搜尋根據與方法關聯的協助工具屬性。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法的<xref:System.Reflection.Binder>類別會負責選取要叫用方法。 預設繫結器會選取最特定的相符項目。  
  
 存取限制，會忽略完全信任的程式碼;也就是私用建構函式、 方法、 欄位和屬性可以存取和透過叫用<xref:System.Reflection>每當程式碼受到完全信任。  
  
 您可以使用`Type.InvokeMember`設定設為特定值的欄位，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果您想要設定名為 F C 和 F 的類別上的公用執行個體欄位是`String`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 如果 F `String[]`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 這會將這個新的陣列欄位 F 的初始化。 您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用如下所示的程式碼中提供的索引值，然後按一下 [下一步] 的值：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 這會變更 F 保留字串"b"陣列中的字串"z"。  
  
 當您叫用`IDispatch`成員，您可以指定的 DispID，而不是成員名稱中，使用字串格式"[Dispid=3 = # #]"。 比方說，如果 DispID 的 MyComMethod 為 3，您可以指定字串"[Dispid=3 = 3]"而不是 「 MyComMethod"。 叫用成員的 DispID 的速度比依名稱查閱的成員。 在複雜的彙總的情況下，DispID 有時是唯一的方法來叫用所需的成員。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用成員的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會使用`InvokeMember`存取類型的成員。  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。  
  
-或- 
 <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。  
  
-或- 
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
-或- 
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。  
  
-或- 
已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
-或- 
其中一個具名參數陣列包含的字串是 <see langword="null" />。</exception>
        <exception cref="T:System.MethodAccessException">指定的成員是類別初始設定式。</exception>
        <exception cref="T:System.MissingFieldException">找不到欄位或屬性。</exception>
        <exception cref="T:System.MissingMethodException">找不到符合 <paramref name="args" /> 中之引數的方法。  
  
-或- 
目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">無法在 <paramref name="target" /> 上叫用指定的成員。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">有一個以上的方法符合繫結準則。</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 目前不支援這個方法。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 表示的方法有一或多個未指定的泛型型別參數。 亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用於存取非公用成員，不論其權限授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。  
  
-或- 
空字串 ("")，要叫用預設成員。  
  
-或- 
對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</param>
        <param name="invokeAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。 該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。 不需要指定查閱的類型。 如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，可使用 <see cref="P:System.Type.DefaultBinder" />。 請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</param>
        <param name="target">要在其上叫用指定成員的物件。</param>
        <param name="args">包含引數的陣列，這些引數會傳遞給要叫用的成員。</param>
        <param name="culture">表示要使用之全球化地區設定的物件，它可能是地區設定特性轉換所需要的，例如將數值 <see cref="T:System.String" /> 轉換成 <see cref="T:System.Double" />。  
  
-或- 
Null 參考 (Visual Basic 中的 <see langword="Nothing" />)，可使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <summary>使用指定的繫結條件約束並符合指定的引數清單和文化特性 (Culture) 來叫用指定的成員。</summary>
        <returns>表示叫用的成員之傳回值的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然預設繫結器不會處理<xref:System.Globalization.CultureInfo>(`culture`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`culture`。  
  
> [!NOTE]
>  您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的成員：  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只在宣告的成員，才<xref:System.Type>，不只是繼承的成員。  
  
 下列<xref:System.Reflection.BindingFlags>引動過程的旗標可以用來表示要與成員採取什麼動作：  
  
-   `CreateInstance` 若要叫用建構函式。 `name` 會被忽略。 與其他引動過程旗標無效。  
  
-   `InvokeMethod` 若要叫用方法，但不是建構函式或類型初始設定式。 使用不正確`SetField`或`SetProperty`。 如果`InvokeMethod`本身，由`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動包含在內。  
  
-   `GetField` 若要取得欄位的值。 與無效`SetField`。  
  
-   `SetField` 若要設定欄位的值。 與無效`GetField`。  
  
-   `GetProperty` 若要取得的屬性。 與無效`SetProperty`。  
  
-   `SetProperty` 若要設定的屬性。 與無效`GetProperty`。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果兩個下列條件成立，就會叫用方法：  
  
-   在方法宣告中的參數數目等於中的引數的數目`args`陣列 (除非該成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每個引數的類型可以轉換為參數的型別繫結器。  
  
 繫結器將會尋找所有相符的方法。 這些方法會找到根據要求的繫結的類型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。 一組方法會依名稱、 目的引數，以及一組繫結器中所定義的搜尋修飾詞進行篩選。  
  
 方法選取之後，它會叫用。 協助工具會在該點檢查。 搜尋可能會控制哪一組方法會搜尋根據與方法關聯的協助工具屬性。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法的<xref:System.Reflection.Binder>類別會負責選取要叫用方法。 預設繫結器會選取最特定的相符項目。  
  
 存取限制，會忽略完全信任的程式碼;也就是私用建構函式、 方法、 欄位和屬性可以存取和完全信任程式碼時，透過反映叫用。  
  
 您可以使用`Type.InvokeMember`設定設為特定值的欄位，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果您想要設定名為 F C 和 F 的類別上的公用執行個體欄位是`String`您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 如果 F `String[]`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 這會將這個新的陣列欄位 F 的初始化。 您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用如下所示的程式碼中提供的索引值，然後按一下 [下一步] 的值：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 這會變更 F 保留字串"b"陣列中的字串"z"。  
  
 當您叫用`IDispatch`成員，您可以指定的 DispID，而不是成員名稱中，使用字串格式"[Dispid=3 = # #]"。 比方說，如果 DispID 的 MyComMethod 為 3，您可以指定字串"[Dispid=3 = 3]"而不是 「 MyComMethod"。 叫用成員的 DispID 的速度比依名稱查閱的成員。 在複雜的彙總的情況下，DispID 有時是唯一的方法來叫用所需的成員。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用成員的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。  
  
-或- 
 <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。  
  
-或- 
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
-或- 
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。  
  
-或- 
已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
-或- 
其中一個具名參數陣列包含的字串是 <see langword="null" />。</exception>
        <exception cref="T:System.MethodAccessException">指定的成員是類別初始設定式。</exception>
        <exception cref="T:System.MissingFieldException">找不到欄位或屬性。</exception>
        <exception cref="T:System.MissingMethodException">找不到符合 <paramref name="args" /> 中之引數的方法。  
  
-或- 
目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">無法在 <paramref name="target" /> 上叫用指定的成員。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">有一個以上符合繫結準則的方法。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 所表示的方法有一或多個未指定的泛型類型參數。 亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用於存取非公用成員，不論其權限授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">字串，包含要叫用的建構函式、方法、屬性或欄位成員的名稱。  
  
-或- 
空字串 ("")，要叫用預設成員。  
  
-或- 
對 <see langword="IDispatch" /> 成員表示 DispID 的字串，例如 "[DispID=3]"。</param>
        <param name="invokeAttr">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。 該存取可以是其中一個 <see langword="BindingFlags" />，例如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" />、<see langword="GetField" /> 等等。 不需要指定查閱的類型。 如果省略查閱的類型，則會使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">定義一組屬性並啟用繫結的物件，可包含多載方法的選擇、引數類型的強制，以及透過反映的成員引動過程。  
  
-或- 
Null 參考 (在 Visual Basic 中為 Nothing)，可使用 <see cref="P:System.Type.DefaultBinder" />。 請注意，可能需要明確定義 <see cref="T:System.Reflection.Binder" /> 物件，才能順利以變數引數叫用方法多載。</param>
        <param name="target">要在其上叫用指定成員的物件。</param>
        <param name="args">包含引數的陣列，這些引數會傳遞給要叫用的成員。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 物件的陣列，表示在 <c>args</c> 陣列中與對應元素產生關聯的屬性。 參數的關聯屬性儲存在成員的簽章中。  
  
預設繫結器只會在呼叫 COM 元件時處理這個參數。</param>
        <param name="culture">
          <see cref="T:System.Globalization.CultureInfo" /> 物件，代表要使用的全球化地區設定，進行特定地區設定轉換時可能需要這個物件，例如將數值的 String 轉換成 Double。  
  
-或- 
Null 參考 (Visual Basic 中的 <see langword="Nothing" />)，可使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="namedParameters">陣列，包含 <c>args</c> 陣列中的值所要傳遞之目標參數的名稱。</param>
        <summary>在衍生類別中覆寫時，使用指定的繫結條件約束並符合指定的引數清單、修飾詞和文化特性，來叫用指定的成員。</summary>
        <returns>表示叫用的成員之傳回值的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` 呼叫建構函式或方法成員，取得或設定之屬性成員，取得或設定資料欄位成員，或取得或設定陣列成員的項目。  
  
> [!NOTE]
>  您無法使用<xref:System.Type.InvokeMember%2A>叫用泛型方法。  
  
 當您叫用`IDispatch`成員，您可以指定的 DispID，而不是成員名稱中，使用字串格式"[Dispid=3 = # #]"。 比方說，如果 DispID 的 MyComMethod 為 3，您可以指定字串"[Dispid=3 = 3]"而不是 「 MyComMethod"。 叫用成員的 DispID 的速度比依名稱查閱的成員。 在複雜的彙總的情況下，DispID 有時是唯一的方法來叫用所需的成員。  
  
 雖然預設繫結器不會處理<xref:System.Reflection.ParameterModifier>或<xref:System.Globalization.CultureInfo>(`modifiers`並`culture`參數)，您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>類別，以寫入未處理的自訂繫結器`modifiers`和`culture`. `ParameterModifier` 透過 COM interop 呼叫時才會使用和處理傳址方式傳遞的參數。  
  
 `namedParameters` 陣列中的每個參數會在 `args` 陣列中取得對應項目的值。 如果 `args` 的長度大於 `namedParameters` 的長度，則會依序傳遞其餘引數值。  
  
 `namedParameters`陣列可以用來變更輸入陣列中的引數的順序。 例如，假設方法`M(string a, int b)`(`M(ByVal a As String, ByVal b As Integer)` Visual Basic 中) 與輸入的陣列`{ 42, "x" }`，不變，可傳遞的輸入的陣列`args`如果陣列`{ "b", "a" }`提供`namedParameters`。  
  
 下列<xref:System.Reflection.BindingFlags>篩選器旗標可以用來定義要包含在搜尋中的成員：  
  
-   指定`BindingFlags.Public`来包含在搜尋中的公用成員。  
  
-   指定`BindingFlags.NonPublic`要在搜尋中包含非公用成員 （也就是私用、 內部和受保護成員）。  
  
-   指定`BindingFlags.FlattenHierarchy`来包含在階層中向上的靜態成員。  
  
 下列<xref:System.Reflection.BindingFlags>輔助鍵旗標可以用來變更搜尋的運作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略大小寫的`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜尋只在宣告的成員，才<xref:System.Type>，不只是繼承的成員。  
  
 下列<xref:System.Reflection.BindingFlags>引動過程的旗標可以用來表示要與成員採取什麼動作：  
  
-   `CreateInstance` 若要叫用建構函式。 `name` 會被忽略。 與其他引動過程旗標無效。  
  
-   `InvokeMethod` 若要叫用方法，但不是建構函式或類型初始設定式。 使用不正確`SetField`或`SetProperty`。 如果`InvokeMethod`本身，由`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`會自動包含在內。  
  
-   `GetField` 若要取得欄位的值。 與無效`SetField`。  
  
-   `SetField` 若要設定欄位的值。 與無效`GetField`。  
  
-   `GetProperty` 若要取得的屬性。 與無效`SetProperty`。  
  
-   `SetProperty` 若要設定的屬性。 與無效`GetProperty`。  
  
 如需詳細資訊，請參閱 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果兩個下列條件成立，就會叫用方法：  
  
-   在方法宣告中的參數數目等於中的引數的數目`args`陣列 (除非該成員上定義預設引數和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每個引數的類型可以轉換為參數的型別繫結器。  
  
 繫結器將會尋找所有相符的方法。 這些方法會找到根據要求的繫結的類型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`，`GetProperty`等等)。 一組方法會依名稱、 目的引數，以及一組繫結器中所定義的搜尋修飾詞進行篩選。  
  
 方法選取之後，它會叫用。 協助工具會在該點檢查。 搜尋可能會控制哪一組方法會搜尋根據與方法關聯的協助工具屬性。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法的<xref:System.Reflection.Binder>類別會負責選取要叫用方法。 預設繫結器會選取最特定的相符項目。  
  
 `InvokeMember` 可用來叫用其參數具有預設值的方法。 若要繫結至這些方法，需要反映<xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>指定。 預設值是參數，您可以提供不同的值，或提供<xref:System.Reflection.Missing.Value?displayProperty=nameWithType>可使用預設值。  
  
 例如，請考慮 MyMethod 之類的方法 (int，float y x = 2.0)。 要叫用這個方法僅於第一個引數作為 MyMethod(4) 時，傳遞下列其中一個以上的繫結旗標，並傳遞兩個引數，也就是第一個引數的 4 和`Missing.Value`第二個引數。 除非您使用`Missing.Value`，您不可以省略選擇性參數`Invoke`方法。 如果您必須這麼做，請使用`InvokeMember`改。  
  
 存取限制，會忽略完全信任的程式碼;也就是私用建構函式、 方法、 欄位和屬性可以存取和透過叫用<xref:System.Reflection>每當程式碼受到完全信任。  
  
 您可以使用`Type.InvokeMember`設定設為特定值的欄位，藉由指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果您想要設定名為 F C 和 F 的類別上的公用執行個體欄位是`String`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 如果 F `String[]`，您可以使用程式碼，例如：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 這會將這個新的陣列欄位 F 的初始化。 您也可以使用`Type.InvokeMember`設定陣列中的位置，藉由使用如下所示的程式碼中提供的索引值，然後按一下 [下一步] 的值：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 這會變更 F 保留字串"b"陣列中的字串"z"。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用成員的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />不包含 <see langword="CreateInstance" />，且 <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> 和 <paramref name="modifiers" /> 的長度不同。  
  
-或- 
 <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 屬性。  
  
-或- 
 <paramref name="invokeAttr" /> 不包含下列其中一個繫結旗標：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含與 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 合併的 <see langword="CreateInstance" />。  
  
-或- 
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
-或- 
 <paramref name="invokeAttr" /> 同時包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含與 <see langword="SetField" /> 或 <see langword="SetProperty" /> 合併的 <see langword="InvokeMethod" />。  
  
-或- 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" /> 且 <paramref name="args" /> 具有一個以上的項目。  
  
-或- 
具名參數陣列大於引數陣列。  
  
-或- 
已在 COM 物件上呼叫此方法且下列其中一個繫結旗標未傳入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
-或- 
其中一個具名參數陣列包含的字串是 <see langword="null" />。</exception>
        <exception cref="T:System.MethodAccessException">指定的成員是類別初始設定式。</exception>
        <exception cref="T:System.MissingFieldException">找不到欄位或屬性。</exception>
        <exception cref="T:System.MissingMethodException">找不到符合 <paramref name="args" /> 中之引數的方法。  
  
-或- 
找不到具有 <paramref name="namedParameters" /> 中所提供引數名稱的成員。  
  
-或- 
目前的 <see cref="T:System.Type" /> 物件代表包含開啟類型參數的類型，亦即，<see cref="P:System.Type.ContainsGenericParameters" /> 傳回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">無法在 <paramref name="target" /> 上叫用指定的成員。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">有一個以上符合繫結準則的方法。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 所表示的方法有一或多個未指定的泛型類型參數。 亦即，方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 屬性傳回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用於存取非公用成員，不論其權限授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為抽象並且必須被覆寫。</summary>
        <value>如果 <see cref="T:System.Type" /> 是抽象，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A>屬性會傳回`true`在下列情況：  
  
-   目前的類型是抽象的;也就是它無法具現化，但只可以做為衍生類別的基底類別。 在 C# 中，抽象類別會標示[抽象](~/docs/csharp/language-reference/keywords/abstract.md)關鍵字，在 Visual Basic 中，所以會標示[MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)關鍵字。  
  
-   目前的類型是介面。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例會建立的陣列<xref:System.Type>代表下列類型的物件： 包含型別傳回`true`指定的物件是否`abstract`; 否則它會傳回`false`。  
  
-   `AbstractClass`抽象類別 (標示為類別`abstract`在 C# 和`MustInherit`Visual Basic 中)。  
  
-   `DerivedClass`繼承自類別`AbstractClass`。  
  
-   `SingleClass`不可繼承的類別。 它指`sealed`在 C# 和`NotInheritable`Visual Basic 中。  
  
-   `ITypeInfo`介面。  
  
-   `ImplementingClass`實作的類別`ITypeInfo`介面。  
  
 此方法會傳回`true`僅適用於`AbstractClass`，抽象類別，以及`ITypeInfo`，介面。  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否為 <see langword="AnsiClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</summary>
        <value>如果為 <see langword="true" /> 選取字串格式屬性 <see langword="AnsiClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>選取字串格式屬性。 字串格式屬性增強互通性，藉由定義應該如何解譯字串。  
  
 如果目前<xref:System.Type>表示泛型型別，這個屬性與從中建構類型的泛型類型定義。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例會取得欄位資訊，並檢查`AnsiClass`屬性。  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，以表示類型是否為陣列。</summary>
        <value>如果目前的類型是陣列則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A>屬性會傳回`false`如<xref:System.Array>類別。 它也會傳回`false`如果目前的執行個體<xref:System.Type>物件，表示集合型別或介面設計用於搭配集合，例如<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>。  
  
 若要檢查的陣列，使用程式碼類似如下所示：  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 如果目前的型別代表泛型類型或類型參數的泛型類型或泛型方法定義中，這個屬性一律傳回`false`。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Type.IsArray%2A>屬性。  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsArray" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為陣列。</summary>
        <returns>如果 <see langword="true" /> 是陣列，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行個體<xref:System.Array>類別必須傳回`false`因為它是一個物件，而不是陣列。  
  
   
  
## Examples  
 下列範例會覆寫`IsArrayImpl`方法中的`MyTypeDelegator`類別，如果變數是陣列，並顯示結果的檢查。  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">要與目前的類型比較的類型。</param>
        <summary>判斷指定類型的執行個體是否可以指派給目前類型的執行個體。</summary>
        <returns>
          <see langword="true" /> (下列任何條件成立時)： 
-   <paramref name="c" /> 與目前的執行個體代表相同的型別。  
  
-   <paramref name="c" /> 直接或間接衍生自目前執行個體。 <paramref name="c" /> 會直接衍生自目前的執行個體 (如果它繼承自目前的執行個體)，<paramref name="c" /> 會間接衍生自目前的執行個體 (如果它繼承自目前的執行個體所繼承的一或多個一連串類別)。  
  
-   目前執行個體是 <paramref name="c" /> 實作的介面。  
  
-   <paramref name="c" /> 是泛型類型參數，而且目前執行個體代表 <paramref name="c" /> 的其中一個條件約束。  
  
在下列範例中，目前的執行個體是 <see cref="T:System.Type" /> 物件，代表 <see cref="T:System.IO.Stream" /> 類別。 <c>GenericWithConstraint</c> 泛型型別，其泛型型別參數必須是型別 <see cref="T:System.IO.Stream" />。 傳遞其泛型型別參數至 <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> 表示泛型型別參數的執行個體可以指派給 <see cref="T:System.IO.Stream" /> 物件。  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> 代表實值型別，而目前執行個體代表 <c>Nullable&lt;c&gt;</c> (在 Visual Basic 中為 <c>Nullable(Of c)</c>)。  
  
 如果以上條件都不成立，或者 <paramref name="c" /> 為 <see langword="false" />，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A>方法可用來判斷執行個體`c`可被指派目前型別的執行個體，方法是最有用，當您處理要知道其類型，這是在設計階段的物件並允許條件式指派，如下列範例會顯示。  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 這個方法因此可確保程式碼，例如下列時，會執行在執行階段上，而不擲回<xref:System.InvalidCastException>例外狀況或類似的例外狀況：  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 在衍生類別可以覆寫此方法。  
  
> [!NOTE]
>  無法從封閉式建構類型可指派的泛型類型定義。 也就是說，您無法將封閉式建構的類型的指派`MyGenericList<int>`(`MyGenericList(Of Integer)` Visual Basic 中) 至型別的變數`MyGenericList<T>`。  
  
 如果`c`參數的類型是<xref:System.Reflection.Emit.TypeBuilder>，結果為基礎建置的型別。 下列程式碼範例示範此使用內建的類型，名為`B`。  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 下列範例示範`IsAssignableFrom`類別、 整數陣列和泛型方法使用定義。  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否為 <see langword="AutoClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</summary>
        <value>如果為 <see langword="true" /> 選取字串格式屬性 <see langword="AutoClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>選取字串格式屬性。 字串格式屬性增強互通性，藉由定義應該如何解譯字串。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前類型的欄位是否已由 Common Language Runtime 自動配置版面的值。</summary>
        <value>如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了方便起見提供這個屬性。 或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取類型版面配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>設定。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>，<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值，表示類型的欄位配置記憶體中的方式。  
  
 動態類型，您可以指定<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>當您建立的類型。 在程式碼中，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性搭配<xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType>列舉值的型別，以便判斷適當的方式來配置類別的執行階段。  
  
> [!NOTE]
>  您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至型別。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic 中)，這個屬性的值由 `MyGenericType<T>.`  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例會建立類型的執行個體，並顯示<xref:System.Type.IsAutoLayout%2A>屬性。  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">中繼資料和自我描述元件</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否以傳址方式傳遞。</summary>
        <value>如果 <see cref="T:System.Type" /> 是以傳址方式傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得實際的型別，由參考所傳遞的型別取值 （dereference），然後呼叫<xref:System.Type.GetElementType%2A>該型別上。  
  
   
  
## Examples  
 下列範例示範使用`IsByRef`來檢查指定的型別傳址方式傳遞的屬性。 此範例會定義類別`MyTypeDelegator`，它會覆寫`HasElementTypeImpl`方法。 主要的類別會檢查`HasElementType`屬性，並顯示項目類型。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsByRef" /> 屬性並判斷 <see cref="T:System.Type" /> 是否以傳址方式傳遞。</summary>
        <returns>如果 <see cref="T:System.Type" /> 是以傳址方式傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示 <see cref="T:System.Type" /> 是類別或委派，也就是非實值類型或介面。</summary>
        <value>如果 <see cref="T:System.Type" /> 是類別，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`true`類別，以及委派。 它會傳回`false`實值型別 （適用於結構和列舉型別） 即使 boxing 處理。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`true`。如果目前<xref:System.Type>代表建構的泛型型別，這個屬性會傳回`true`如果泛型類型定義是類別定義; 也就是它不會定義介面或實值型別。  
  
> [!NOTE]
>  這個屬性會傳回`true`for`Type`執行個體，代表<xref:System.Enum>和<xref:System.ValueType>類別。 這兩個類別的基底類型的列舉型別和實值類型，分別是，但不是列舉型別或實值型別本身。 如需詳細資訊，請參閱 <<c0> <xref:System.Type.IsValueType%2A> 和<xref:System.Type.IsEnum%2A>屬性。  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>列舉值會區分型別宣告為類別或介面。不過，類別和實值類型會標示<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>屬性。 如果您擷取的型別屬性的屬性，然後使用值<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>值，以判斷是否為型別而不是實值型別為類別，您還必須呼叫<xref:System.Type.IsValueType%2A>屬性。 範例<xref:System.Reflection.TypeAttributes>列舉包含的其他資訊，以及 anexample。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會建立類型的執行個體，並指出類型是否為類別。  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為 COM 物件。</summary>
        <value>如果 <see langword="true" /> 是 COM 物件，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回`false`的 COM 介面，因為它們不是物件。 可以由 Microsoft.NET Framework 物件實作 COM 介面。  
  
 您也可以載入 COM 類別，並取得`Type`使用該 COM 類別的物件[Tlbimp.exe （型別程式庫匯入工具）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int`> (`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsCOMObject" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為 COM 物件。</summary>
        <returns>如果 <see langword="true" /> 是 COM 物件，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回`false`的 COM 介面，因為它們不是物件。 可以由 Microsoft.NET Framework 物件實作 COM 介面。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個物件是否表示建構的泛型類型。 您可以建立已建構之泛型類型的執行個體。</summary>
        <value>如果這個物件代表建構的泛型類型，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建構的泛型類型已明確提供給所有的泛型類型參數的類型。 它也稱為封閉式的泛型型別。  
  
 當這個屬性是`true`，您可以建立目前類型的執行個體; 時`false`，您不能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出在內容中是否可以裝載 <see cref="T:System.Type" />。</summary>
        <value>如果在內容中可以裝載 <see cref="T:System.Type" />，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 內容會攔截對類別成員的呼叫，並強制執行原則會套用至類別，例如同步處理。 如需詳細遠端內容的詳細資訊，請參閱<xref:System.Runtime.Remoting.Contexts.Context>。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，並<xref:System.Type.IsPrimitive%2A>的屬性<xref:System.Type>類別。 它會檢查是否裝載於內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>實作 <see cref="P:System.Type.IsContextful" /> 屬性並判斷在內容中是否可以裝載 <see cref="T:System.Type" />。</summary>
        <returns>如果在內容中可以裝載 <see cref="T:System.Type" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫此方法。  
  
 內容會攔截對類別成員的呼叫，並強制執行原則，套用至類別，例如同步處理。  
  
   
  
## Examples  
 下列範例示範使用`IsContextfulImpl`方法。  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前的 <see cref="T:System.Type" /> 是否表示列舉類型。</summary>
        <value>如果目前 <see langword="true" /> 代表列舉，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`true`列舉型別，但不是適合用於<xref:System.Enum>型別。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例示範如何使用`IsEnum`屬性。  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要測試的值。</param>
        <summary>傳回值，這個值表示指定的值是否存在於目前的列舉類型中。</summary>
        <returns>如果指定的值是目前列舉類型的成員，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">目前的類型不是列舉。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 的類型不能是列舉的基礎類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">進行測試以確定是否和目前類型等價的 COM 類型。</param>
        <summary>判斷兩個 COM 類型是否具有相同的識別以及是否適合類型等價。</summary>
        <returns>如果 COM 類型相等，則為 <see langword="true" />，否則為 <see langword="false" />。 如果一個類型位於已載入來執行的組件中，而另一個類型位於已載入至純反映性的內容的組件中，這個方法也會傳回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，common language runtime 支援內嵌 COM 類型的型別資訊，直接將 managed 組件，而不需要 managed 組件從 interop 取得適用於 COM 類型的類型資訊組件。 因為內嵌類型資訊僅包含 Managed 組件實際所使用的類型和成員，所以兩個 Managed 組件可能對於相同的 COM 類型會有非常不同的檢視。 每個 Managed 組件有不同的 <xref:System.Type> 物件以代表其 COM 類型檢視。 通用語言執行平台支援介面、結構、列舉和委派等這些不同檢視之間的類型等價。  
  
 類型等價表示從一個 Managed 組件傳到另一個的 COM 物件，可以在接收的組件中轉換成適當的 Managed 類型。 <xref:System.Type.IsEquivalentTo%2A>方法讓組件以判斷 COM 物件，從另一個組件中取得具有相同的 COM 識別，做為其中一個第一組件的自己內嵌 interop 類型，並因此可以轉型為該型別。  
  
 如需詳細資訊，請參閱 <<c0> [ 類型等價和內嵌 Interop 類型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前類型的欄位是否已在明確指定之位移配置版面的值。</summary>
        <value>如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了方便起見提供這個屬性。 或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取類型版面配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>設定。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>， <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值，表示類型的欄位配置記憶體中的方式。  
  
 動態類型，您可以指定<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>當您建立的類型。 在程式碼中，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性搭配<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>的型別，來指定欄位開始的位移會明確指定的列舉值。  
  
> [!NOTE]
>  您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至型別。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例會建立類型的執行個體，並顯示的值及其<xref:System.Type.IsExplicitLayout%2A>屬性。 它會使用`MySystemTime`類別，這也是在程式碼範例中，針對<xref:System.Runtime.InteropServices.StructLayoutAttribute>。  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">中繼資料和自我描述元件</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前的 <see cref="T:System.Type" /> 是否表示泛型類型或泛型方法定義中的型別參數。</summary>
        <value>如果 <see cref="T:System.Type" /> 物件表示泛型型別或泛型方法定義中的型別參數，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> 物件表示泛型型別參數，可由呼叫<xref:System.Type.GetGenericArguments%2A>方法<xref:System.Type>物件，代表泛型類型定義，或有<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>方法<xref:System.Reflection.MethodInfo>物件，代表泛型方法定義。  
  
-   泛型型別或方法定義<xref:System.Type.IsGenericParameter%2A>屬性會傳回`true`產生陣列的每個項目。  
  
-   封閉式建構的類型或方法，如<xref:System.Type.IsGenericParameter%2A>屬性會傳回`false`所傳回的陣列的每個項目的<xref:System.Type.GetGenericArguments%2A>方法。  
  
-   對於開放式建構的類型或方法，陣列的某些項目可能是特定類型而有些則可能是型別參數。 <xref:System.Type.IsGenericParameter%2A> 會傳回`false`類型和`true`的型別參數。 程式碼範例<xref:System.Type.ContainsGenericParameters%2A>屬性示範混用型別和型別參數的泛型類別。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.IsGenericParameter%2A>来測試是否為泛型類型的泛型型別參數的屬性。  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前類型是否為泛型類型。</summary>
        <value>
          <see langword="true" /> 如果目前的型別為泛型類型，否則， <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.IsGenericType%2A>屬性來判斷是否<xref:System.Type>物件代表泛型類型。 使用<xref:System.Type.ContainsGenericParameters%2A>屬性來判斷是否<xref:System.Type>物件都代表開放式建構的類型或封閉式的建構型別。  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A>屬性會傳回`false`如果立即的型別不是泛型。 比方說，其項目屬於型別陣列`A<int>`(`A(Of Integer)` Visual Basic 中) 會本身不是泛型型別。  
  
 下表摘要說明非變異條件 hapi 一般條款泛型反映中所使用。  
  
|詞彙|非變異值|  
|----------|---------------|  
|Generic Type Definition - 泛型類型定義|<xref:System.Type.IsGenericTypeDefinition%2A> 屬性為 `true`。<br /><br /> 定義泛型型別。 建構的型別由呼叫<xref:System.Type.MakeGenericType%2A>方法<xref:System.Type>物件代表泛型類型定義，並指定型別引數陣列。<br /><br /> <xref:System.Type.MakeGenericType%2A> 可以只在泛型類型定義上呼叫。<br /><br /> 任何泛型型別定義為泛型類型 (<xref:System.Type.IsGenericType%2A>屬性是`true`)，但是反過來說就不正確。|  
|Generic Type - 泛型類型|<xref:System.Type.IsGenericType%2A> 屬性為 `true`。<br /><br /> 可以是泛型類型定義、 開放式建構的類型或封閉式的建構型別。<br /><br /> 請注意，陣列類型的項目型別是泛型本身就不是泛型型別。 也是如此的<xref:System.Type>物件，代表泛型類型的指標。|  
|開放式建構的類型|<xref:System.Type.ContainsGenericParameters%2A> 屬性為 `true`。<br /><br /> 範例包括已指派的型別參數的泛型型別、 開放式建構類型，或泛型類型定義中巢狀型別或具有類型引數的泛型型別<xref:System.Type.ContainsGenericParameters%2A>屬性是`true`。<br /><br /> 您不可能建立開放式建構類型的執行個體。<br /><br /> 請注意，並非所有開放式建構的類型是泛型。 例如，其項目類型是泛型型別定義陣列不是泛型，而開放式建構類型的指標不是泛型。|  
|封閉式建構的類型|<xref:System.Type.ContainsGenericParameters%2A> 屬性為 `false`。<br /><br /> 當遞迴檢查，型別沒有任何未指派的泛型參數。|  
|Generic Type Parameter - 泛型型別參數|<xref:System.Type.IsGenericParameter%2A> 屬性為 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 屬性為 `true`。<br /><br /> 在泛型類型定義中，將會稍後再指派類型的預留位置。|  
|Generic Type Argument - 泛型類型引數|可以是任何類型，包括泛型類型參數。<br /><br /> 型別引數會指定為陣列<xref:System.Type>物件傳遞至<xref:System.Type.MakeGenericType%2A>方法建立建構的泛型型別時。 如果產生之型別的執行個體建立<xref:System.Type.ContainsGenericParameters%2A>屬性必須是`false`所有型別引數。|  
  
 下列程式碼範例及下表說明其中一些詞彙和非變異值。 `Derived`類別，特別感興趣的因為其基底型別建構的型別具有混合型別和型別參數，其型別引數清單中。  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 下表顯示範例會使用建立的類別`Base`， `Derived`，和`G`。 當 c + + 和 C# 程式碼中都相同時，則會顯示只有一個項目。  
  
|範例|非變異值|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|這種類型：<br /><br /> <xref:System.Type.IsGenericType%2A> 為 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 為 `true`。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|這種類型：<br /><br /> <xref:System.Type.IsGenericType%2A> 為 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 為 `true`。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|類型的變數`d`:<br /><br /> <xref:System.Type.IsGenericType%2A> 已`false`因為`d`是陣列。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 為 `false`。|  
|`T``U`，和`V`（everywhere 顯示）|<xref:System.Type.IsGenericParameter%2A> 為 `true`。<br /><br /> <xref:System.Type.IsGenericType%2A> 是`false`因為沒有任何方法來限制泛型類型的類型參數。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 已`true`因為`T`， `U`，和`V`本身是泛型型別參數。 這不表示有關稍後指派給他們的型別引數的任何項目。|  
|欄位的型別 `F`|<xref:System.Type.IsGenericType%2A> 為 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 已`false`因為型別具有指定的型別參數給`G`。 請注意，這相當於呼叫<xref:System.Type.MakeGenericType%2A>方法。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 已`true`因為欄位的型別`F`已是開放式建構的類型的類型引數。 建構的型別為開放型因為其型別引數 (也就是`Base`) 是泛型類型定義。 這說明的遞迴本質<xref:System.Type.IsGenericType%2A>屬性。|  
|巢狀的類別 `Nested`|<xref:System.Type.IsGenericType%2A> 已`true`，即使`Nested`類別具有自己的沒有泛型類型參數，因為它巢狀在泛型型別。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 為 `true`。 也就是說，您可以呼叫<xref:System.Type.MakeGenericType%2A>方法，並提供封入類型，型別參數`Derived`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 已`true`封入類型，因為`Derived`，泛型類型參數。 這說明的遞迴本質<xref:System.Type.ContainsGenericParameters%2A>屬性。|  
  
   
  
## Examples  
 下列程式碼範例顯示的值<xref:System.Type.IsGenericType%2A>， <xref:System.Type.IsGenericTypeDefinition%2A>， <xref:System.Type.IsGenericParameter%2A>，和<xref:System.Type.ContainsGenericParameters%2A>< 備註 > 一節所述的類型屬性。 如需更多的屬性值的說明，請參閱 < 備註 > 中的表格。  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前的 <see cref="T:System.Type" /> 是否表示可用於建構其他泛型類型的泛型類型定義。</summary>
        <value>如果 <see langword="true" /> 物件表示泛型類型定義，則為 <see cref="T:System.Type" />否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型類型定義是可從中建構其他類型的範本。 例如，從泛型類型定義`G<T>`（以 C# 語法;`G(Of T)`在 Visual Basic 中或`generic <typename T> ref class G`c + + 中) 您可以建構和具現化型別`G<int>`(`G(Of Integer)` Visual Basic 中)，藉由呼叫<xref:System.Type.MakeGenericType%2A>方法的泛型引數清單包含<xref:System.Int32>型別。 給定<xref:System.Type>物件，代表這個建構的型別，<xref:System.Type.GetGenericTypeDefinition%2A>方法取回的泛型類型定義一次。  
  
 使用<xref:System.Type.IsGenericTypeDefinition%2A>屬性來判斷您是否可以從目前的型別來建立新的型別。 如果<xref:System.Type.IsGenericTypeDefinition%2A>屬性會傳回`true`，您可以呼叫<xref:System.Type.MakeGenericType%2A>方法用來建立新的泛型類型。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
   
  
## Examples  
 下列範例會顯示類型，包括這是泛型型別定義的相關資訊。 建構的類型、 其泛型型別定義，以及一般型別，則會顯示資訊。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否套用了 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 屬性 (Attribute)，亦即其是否從 COM 類型程式庫匯入。</summary>
        <value>如果 <see langword="true" /> 具有 <see cref="T:System.Type" />，則為 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic 中)，這個屬性的值由 `MyGenericType<T>.`  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">要與目前的類型比較的物件。</param>
        <summary>判斷指定的物件是否為目前 <see cref="T:System.Type" /> 的執行個體。</summary>
        <returns>如果在目前 <see langword="Type" /> 位於 <paramref name="o" /> 所代表之物件的階層架構中，或者目前 <see langword="Type" /> 位於 <paramref name="o" /> 支援的介面中，則為 <see langword="true" />。 如果都不是這些情況，或者如果 <paramref name="o" /> 為 <see langword="null" />，又或者如果目前 <see langword="Type" /> 為開放式泛型類型 (亦即 <see cref="P:System.Type.ContainsGenericParameters" /> 會傳回 <see langword="true" />)，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫此方法。  
  
> [!NOTE]
>  建構的型別不是其泛型型別定義的執行個體。 亦即`MyGenericList<int>`(`MyGenericList(Of Integer)` Visual Basic 中) 不是的執行個體`MyGenericList<T>`(`MyGenericList(Of T)` Visual Basic 中)。  
  
   
  
## Examples  
 下列範例示範 `IsInstanceOfType` 方法的用法。  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為介面；也就是說，不是類別或實值類型。</summary>
        <value>如果 <see langword="true" /> 是介面，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask>區分型別宣告為類別、 介面或實值型別。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會建立一個介面，介面型別，會檢查並指出類別是否有`IsInterface`屬性集。  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前類型的欄位是否已依為其定義或發出至中繼資料之順序，循序配置版面的值。</summary>
        <value>如果目前類型的 <see langword="true" /> 屬性包含 <see cref="P:System.Type.Attributes" /> 則為 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了方便起見提供這個屬性。 或者，您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>列舉值，以選取類型版面配置屬性，然後測試是否<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>設定。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>， <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列舉值，表示類型的欄位配置記憶體中的方式。  
  
 動態類型，您可以指定<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>當您建立的類型。 在程式碼中，套用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性搭配<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>的型別，以指定該版面配置是循序的列舉值。  
  
> [!NOTE]
>  您無法使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法，以判斷是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>已套用至型別。  
  
 如需詳細資訊，請參閱章節 9.1.2 的規格，如 Common Language Infrastructure (CLI) 文件，而"Partition II:: 中繼資料定義和語意 >。 您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](https://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例會建立類別的執行個體的<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>中的列舉值<xref:System.Runtime.InteropServices.StructLayoutAttribute>類別已設定，會檢查<xref:System.Type.IsLayoutSequential%2A>屬性，並顯示結果。  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">中繼資料和自我描述元件</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否以傳址方式封送處理。</summary>
        <value>如果 <see langword="true" /> 是以傳址方式進行封送處理，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，並<xref:System.Type.IsPrimitive%2A>的屬性<xref:System.Type>類別。 它會檢查是否裝載於內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>實作 <see cref="P:System.Type.IsMarshalByRef" /> 屬性，判斷 <see cref="T:System.Type" /> 是否以傳址方式封送處理。</summary>
        <returns>如果 <see langword="true" /> 是以傳址方式進行封送處理，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別可以覆寫此方法。  
  
   
  
## Examples  
 下列範例會判斷指定的型別是否會傳址封送處理，並顯示結果。  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前的 <see cref="T:System.Type" /> 物件代表的類型之定義是否位於另一個類型的定義內部。</summary>
        <value>如果 <see langword="true" /> 巢狀於另一個類型中，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A>屬性會傳回`true`所有巢狀類型，不論可見性。 若要在此同時測試巢狀結構和可見性，使用相關的屬性<xref:System.Type.IsNestedAssembly%2A>， <xref:System.Type.IsNestedFamily%2A>， <xref:System.Type.IsNestedFamANDAssem%2A>， <xref:System.Type.IsNestedFamORAssem%2A>， <xref:System.Type.IsNestedPrivate%2A>，或<xref:System.Type.IsNestedPublic%2A>。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask>列舉成員選取類型的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以擁有各種類型的可見性的巢狀類別的數字。 然後會擷取的值數目的可見性相關<xref:System.Type>父型別和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只在它自己的組件內為可見。</summary>
        <value>如果 <see langword="true" /> 是巢狀並只在它自己的組件內為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以擁有各種類型的可見性的巢狀類別的數字。 然後會擷取的值數目的可見性相關<xref:System.Type>父型別和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只對同時屬於它自己家族和它自己組件的類別為可見。</summary>
        <value>如果 <see cref="T:System.Type" /> 是巢狀並只對同時屬於它自己家族和它自己組件的類別為可見，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
> [!NOTE]
>  C# 和 Visual Basic 語言不包含可讓您定義只在它自己組件中的受保護類型可以看到的巢狀的類型的語意。 `protected internal` 在 C# 中的可見性和`Protected Friend`Visual Basic 中的可見性定義會顯示受保護的類型和類型相同的組件中的巢狀的類型。  
  
 A<xref:System.Type>物件的系列指相同的所有物件<xref:System.Type>和及其子類型。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以擁有各種類型的可見性的巢狀類別的數字。 然後會擷取的值數目的可見性相關<xref:System.Type>父型別和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀，並只在它自己的系列內為可見。</summary>
        <value>如果 <see langword="true" /> 是巢狀並只在它自己的家族內為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
 A<xref:System.Type>物件的系列指所有物件的完全相同<xref:System.Type>和及其子類型。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以擁有各種類型的可見性的巢狀類別的數字。 然後會擷取的值數目的可見性相關<xref:System.Type>父型別和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀並只對屬於它自己家族或它自己組件的類別為可見。</summary>
        <value>如果 <see langword="true" /> 是巢狀並只對屬於它自己家族或它自己組件的類別為可見，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類型的可見性會`protected internal`C# 中或`Protected Friend`在 Visual Basic<xref:System.Type.IsNestedFamORAssem%2A>屬性會傳回`true`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
 A<xref:System.Type>物件的系列指所有物件的完全相同<xref:System.Type>和及其子類型。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以擁有各種類型的可見性的巢狀類別的數字。 然後會擷取的值數目的可見性相關<xref:System.Type>父型別和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為巢狀並且宣告為私用。</summary>
        <value>如果 <see langword="true" /> 是巢狀並且宣告為私用，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以擁有各種類型的可見性的巢狀類別的數字。 然後會擷取的值數目的可見性相關<xref:System.Type>父型別和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出類別是否為巢狀 (Nest) 並且宣告為公用 (Public)。</summary>
        <value>如果類別是巢狀並且宣告為公用，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
   
  
## Examples  
 下列範例會建立外部的類別，以擁有各種類型的可見性的巢狀類別的數字。 然後會擷取的值數目的可見性相關<xref:System.Type>父型別和其巢狀類型的每個屬性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否未宣告為公用。</summary>
        <value>如果 <see langword="true" /> 尚未宣告為公用而且不是巢狀類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要使用巢狀型別，這個屬性使用<xref:System.Type.IsNestedPublic%2A>屬性改為。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性會傳回`false`。  
  
   
  
## Examples  
 此範例使用`IsNotPublic`屬性來取得類型的可見性。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 下列程式碼範例示範您為何無法使用`IsPublic`和`IsNotPublic`巢狀類別。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 對於巢狀類別，略過的結果`IsPublic`並`IsNotPublic`和結果的注意`IsNestedPublic`和`IsNestedPrivate`。 此程式碼片段的反映輸出應如下所示：  
  
|類別|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為指標。</summary>
        <value>如果 <see cref="T:System.Type" /> 是指標，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>代表泛型類型或類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例示範使用`IsPointer`屬性。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsPointer" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為指標。</summary>
        <returns>如果 <see cref="T:System.Type" /> 是指標，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為其中一個基本類型 (Primitive Type)。</summary>
        <value>如果 <see langword="true" /> 是其中一個基本類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本類型所<xref:System.Boolean>， <xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.IntPtr>， <xref:System.UIntPtr>， <xref:System.Char>，<xref:System.Double>，和<xref:System.Single>。  
  
 如果目前<xref:System.Type>代表泛型類型或類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例示範`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，並<xref:System.Type.IsPrimitive%2A>的屬性<xref:System.Type>類別。 它會檢查是否裝載於內容中的指定型別是否它可以封送處理的參考，以及類型是否為基本資料類型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，實作 <see cref="P:System.Type.IsPrimitive" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為其中一個基本類型。</summary>
        <returns>如果 <see langword="true" /> 是其中一個基本類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本類型所<xref:System.Boolean>， <xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.Char>， <xref:System.Double>，和<xref:System.Single>。  
  
   
  
## Examples  
 下列範例會判斷指定的型別是否為基本型別，並顯示結果。  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否宣告為公用。</summary>
        <value>如果 <see langword="true" /> 已宣告為公用而且不是巢狀類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要在使用巢狀型別，使用<xref:System.Type.IsNestedPublic%2A>改。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性會傳回`true`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 選取的可見性屬性。  
  
   
  
## Examples  
 下列範例建立的執行個體`MyTestClass`，檢查是否有`IsPublic`屬性，並顯示結果。  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 對於巢狀類別，略過的結果`IsPublic`並`IsNotPublic`和結果的注意<xref:System.Type.IsNestedPublic%2A>和<xref:System.Type.IsNestedPrivate%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否宣告為密封。</summary>
        <value>如果 <see langword="true" /> 宣告為密封，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>表示的類型參數的泛型型別，這個屬性一律傳回`true`。  
  
   
  
## Examples  
 下列範例建立的執行個體`sealed`類別，檢查有無`IsSealed`屬性，並顯示結果。  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前類型在目前信任層級上是否為安全性關鍵或安全性安全關鍵，因而可以執行重要的作業。</summary>
        <value>如果目前類型在目前信任層級上為安全性關鍵或安全性安全關鍵，則為 <see langword="true" />，如果是安全性透明，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。 下表顯示這些屬性的組合：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
> [!IMPORTANT]
>  部分信任組件，這個屬性的值取決於目前的組件的信任層級。 如果組件載入至部分信任的應用程式網域 （例如，為沙箱化應用程式網域），執行階段會略過組件的安全性註釋。 組件及其所有類型中視為透明。 執行階段在該組件會載入至完全信任的應用程式網域 （例如，載入預設應用程式定義域的桌面應用程式） 時，才支付注意部分信任組件的安全性註釋。 相較之下，信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，無論信任層級的應用程式定義域中，因此其目前的信任層級永遠都是完全受信任。 您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。  
  
 如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 投影片的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反映的安全性考量</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性變更</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前類型在目前信任層級上是否為安全性安全關鍵，也就是說，它是否能執行重要作業並由安全性透明的程式碼存取。</summary>
        <value>如果目前類型在目前信任層級上為安全性安全關鍵，則為 <see langword="true" />；如果為安全性關鍵或安全性透明，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。 下表顯示這些屬性的組合：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
> [!IMPORTANT]
>  部分信任組件，這個屬性的值取決於目前的組件的信任層級。 如果組件載入至部分信任的應用程式網域 （例如，為沙箱化應用程式網域），執行階段會略過組件的安全性註釋。 組件及其所有類型中視為透明。 執行階段在該組件會載入至完全信任的應用程式網域 （例如，載入預設應用程式定義域的桌面應用程式） 時，才支付注意部分信任組件的安全性註釋。 相較之下，信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，無論信任層級的應用程式定義域中，因此其目前的信任層級永遠都是完全受信任。 您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。  
  
 如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 投影片的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反映的安全性考量</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性變更</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前類型在目前信任層級上是否為透明，因此無法執行重要作業。</summary>
        <value>如果型別在目前信任層級上為安全性透明，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性會傳回`true`，則<xref:System.Type.IsSecurityCritical%2A>並<xref:System.Type.IsSecuritySafeCritical%2A>屬性傳回`false`。  
  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>屬性報告在其目前信任層級，由 common language runtime (CLR) 類型的透明度。 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
> [!IMPORTANT]
>  部分信任組件，這個屬性的值取決於目前的組件的信任層級。 如果組件載入至部分信任的應用程式網域 （例如，為沙箱化應用程式網域），執行階段會略過組件的安全性註釋。 組件及其所有類型中視為透明。 執行階段在該組件會載入至完全信任的應用程式網域 （例如，載入預設應用程式定義域的桌面應用程式） 時，才支付注意部分信任組件的安全性註釋。 相較之下，信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，無論信任層級的應用程式定義域中，因此其目前的信任層級永遠都是完全受信任。 您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。  
  
 如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 投影片的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反映的安全性考量</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性變更</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否可序列化。</summary>
        <value>如果 <see cref="T:System.Type" /> 可序列化，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
在.NET Standard 所定義的類型未標示有<xref:System.SerializableAttribute>。 相反地，每個.NET 實作會決定是否可序列化類型。 在執行階段，您可以使用<xref:System.Type.IsSerializable%2A>屬性來判斷該實作是否支援序列化之型別的執行個體。 如需詳細資訊和範例，請參閱 <<c0> [ 如何判斷是否可序列化的.NET Standard 物件](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)。
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
   
  
## Examples  
 下列範例建立的執行個體`MyTestClass`類別，設定 [Serializable] 屬性，並檢查`IsSerializable`屬性`true`或`false`。  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示類型是否具有需要特殊處理的名稱。</summary>
        <value>如果類型具有需要特殊處理的名稱，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭或包含底線字元 (_)、 屬性存取子和運算子多載方法的名稱都是由某些編譯器需要特殊處理的類型的範例。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">要與目前的類型比較的類型。</param>
        <summary>判斷目前 <see cref="T:System.Type" /> 是否衍生自指定的 <see cref="T:System.Type" />。</summary>
        <returns>如果目前 <see langword="true" /> 衍生自 <see langword="Type" />，則為 <paramref name="c" />，否則為 <see langword="false" />。 如果 <see langword="false" /> 和目前 <paramref name="c" /> 相等，這個方法也會傳回 <see langword="Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以呼叫<xref:System.Type.IsSubclassOf%2A>方法，以判斷下列任一項：  
  
-   不論一個類別衍生自另一個。  
  
-   型別是否衍生自<xref:System.ValueType>。 不過，<xref:System.Type.IsValueType%2A>是更有效率的方式，來判斷類型是否為實值型別。  
  
-   型別是否衍生自<xref:System.Enum>。 不過，<xref:System.Type.IsEnum%2A>方法是更有效率的方式，來判斷類型是否為列舉型別。  
  
-   是否類型是委派，也就是它衍生自其中一個是否<xref:System.Delegate>或<xref:System.MulticastDelegate>。  
  
 <xref:System.Type.IsSubclassOf%2A>方法無法用來判斷是否介面是衍生自另一個介面，或者類別是否實作的介面。 使用<xref:System.Type.IsAssignableFrom%2A>基於這個目的，如下列範例所示的方法。  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 如果目前<xref:System.Type>表示的類型參數在泛型類型或泛型方法定義中，它會衍生從其類別條件約束或<xref:System.Object?displayProperty=nameWithType>是否沒有類別條件約束。  
  
> [!NOTE]
>  介面，搭配使用時，除非<xref:System.Type.IsSubclassOf%2A>是反向<xref:System.Type.IsAssignableFrom%2A>。 也就是說，如果`t1.IsSubclassOf(t2)`已`true`，然後`t2.IsAssignableFrom(t1)`也是`true`。  
  
 在衍生類別可以覆寫此方法。  
  
   
  
## Examples  
 下列範例會建立名為類別`Class1`和衍生的類別，名為`DerivedC1`。 它會呼叫<xref:System.Type.IsSubclassOf%2A>方法，以顯示`DerivedC1`是子類別的`Class1`。  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否為 <see langword="UnicodeClass" /> 選取字串格式屬性 <see cref="T:System.Type" />。</summary>
        <value>如果為 <see langword="true" /> 選取字串格式屬性 <see langword="UnicodeClass" />，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>用來選取字串格式屬性。 字串格式屬性增強互通性，藉由定義應該如何解譯字串。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Type" /> 是否為實值類型。</summary>
        <value>如果 <see langword="true" /> 是實值類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實值型別是以位元; 序列的表示的型別實值型別不是類別或介面。 實值型別稱為 「 結構 」 中的某些程式設計語言。 列舉是特殊案例的實值型別。  
  
 這個屬性會傳回`false`for<xref:System.ValueType>類別，因為<xref:System.ValueType>不是實值型別本身。 它是所有實值類型，基底類別，因此任何實值類型可以指派給它。 這不是可能如果<xref:System.ValueType>本身是實值型別。 指派給類型的欄位時，會進行 boxed 處理實值型別<xref:System.ValueType>。  
  
 這個屬性會傳回`true`列舉型別，但不是適合用於<xref:System.Enum>型別。 如需示範此行為的範例，請參閱<xref:System.Type.IsEnum%2A>。  
  
 這個屬性是唯讀的。  
  
   
  
## Examples  
 下列範例會建立類型的變數`MyEnum`，檢查是否有`IsValueType`屬性，並顯示結果。  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>實作 <see cref="P:System.Type.IsValueType" /> 屬性並判斷 <see cref="T:System.Type" /> 是否為實值類型；也就是說，不是類別或介面。</summary>
        <returns>如果 <see langword="true" /> 是實值類型，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可啟用替代的型別系統的實作。 它不是常用的應用程式程式碼中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得一個值，表示位於組件之外的程式碼是否能存取 <see cref="T:System.Type" />。</summary>
        <value>如果目前 <see langword="true" /> 是公用類型或公用巢狀類型 (所有封入類型均為公用)，則為 <see cref="T:System.Type" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性來判斷類型是否為元件組件的公用介面的一部分。  
  
   
  
## Examples  
 下列程式碼範例會測試兩個類別，只是其中之一就是組件外部可見。  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回代表目前類型之陣列的 <see cref="T:System.Type" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Type" /> 物件，代表由目前類型組成的一維陣列，其下限為零。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，代表由目前類型組成的一維陣列，其下限為零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>方法可用來產生在執行階段計算其項目類型的陣列類型。  
  
 **請注意**common language runtime 會區分向量 （也就是一維陣列，會一律以零為起始） 和多維度陣列。 向量，其一律只能有一個維度，不是剛好有只有一個維度的多維陣列相同。 這個方法多載可以只用來建立的向量類型，它是唯一的方式建立的向量型別。 使用<xref:System.Type.MakeArrayType%28System.Int32%29>方法多載來建立多維陣列型別。  
  
   
  
## Examples  
 下列程式碼範例會建立陣列， `ref` (`ByRef` Visual Basic 中)，和指標類型`Test`類別。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <exception cref="T:System.TypeLoadException">目前的類型為 <see cref="T:System.TypedReference" />。  
  
-或- 
目前的類型為 <see langword="ByRef" /> 類型。 亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">陣列的維度數目。 這個數字必須小於或等於 32。</param>
        <summary>傳回 <see cref="T:System.Type" /> 物件，代表由目前類型組成且為指定維度個數的陣列。</summary>
        <returns>物件，代表由目前類型組成且為指定維度個數的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>方法可用來產生在執行階段計算其項目類型的陣列類型。  
  
> [!NOTE]
>  Common language runtime 會區分向量 （也就是一維陣列，會一律以零為起始） 和多維度陣列。 向量，其一律只能有一個維度，不是剛好有只有一個維度的多維陣列相同。 您無法使用這個方法多載來建立的向量型別;如果`rank`為 1，此方法多載會傳回剛好有一個維度的多維陣列類型。 使用<xref:System.Type.MakeArrayType>方法多載來建立的向量類型。  
  
   
  
## Examples  
 下列程式碼範例會建立陣列， `ref` (`ByRef` Visual Basic 中)，和指標類型`Test`類別。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> 無效。 例如，0 或負數。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <exception cref="T:System.TypeLoadException">目前的類型為 <see cref="T:System.TypedReference" />。  
  
-或- 
目前的類型為 <see langword="ByRef" /> 類型。 亦即，<see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" />。  
  
-或- 
 <paramref name="rank" /> 大於 32。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Type" /> 物件，當做 <see langword="ref" /> (Visual Basic 中的 <see langword="ByRef" />) 參數傳遞時，代表目前的類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，當做 <see langword="ref" /> 參數 (在 Visual Basic 中為 <see langword="ByRef" /> 參數) 傳遞時，代表目前的類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A>方法可用來產生`ref`型別 (`ByRef` Visual Basic 中) 的參數清單。  
  
 使用語法的 Microsoft intermediate language (MSIL)，如果目前<xref:System.Type>物件代表<xref:System.Int32>，這個方法會傳回<xref:System.Type>物件，表示`Int32&`。  
  
   
  
## Examples  
 下列程式碼範例會建立陣列， `ref` (`ByRef` Visual Basic 中)，和指標類型`Test`類別。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <exception cref="T:System.TypeLoadException">目前的類型為 <see cref="T:System.TypedReference" />。  
  
-或- 
目前的類型為 <see langword="ByRef" /> 類型。 亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">由類型組成的陣列，用來取代目前泛型類型的型別參數。</param>
        <summary>用類型陣列的項目取代目前泛型類型定義的型別參數，並傳回代表所得結果建構類型的 <see cref="T:System.Type" /> 物件。</summary>
        <returns>
          <see cref="T:System.Type" />，表示用 <paramref name="typeArguments" /> 的項目取代目前泛型類型之型別參數所得到的建構類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A>方法可讓您撰寫程式碼，將特定類型指派給類型參數的泛型類型定義，因此建立<xref:System.Type>代表特定的建構的類型的物件。 您可以使用這個<xref:System.Type>物件來建立建構類型的執行階段執行個體。  
  
 類型建構<xref:System.Type.MakeGenericType%2A>可以開啟，也就是某些其類型引數可以是封閉式泛型方法或類型的型別參數。 當發出動態組件時，您可以使用這種開放式建構的類型。 例如，假設類別`Base`和`Derived`下列程式碼。  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 若要產生`Derived`在動態組件，就必須建構其基底類型。 若要這樣做，請呼叫<xref:System.Type.MakeGenericType%2A>方法<xref:System.Type>物件，表示類別`Base`，使用泛型型別引數<xref:System.Int32>型別參數`V`從`Derived`。 因為型別和泛型型別參數都表示所<xref:System.Type>物件，包含這兩個陣列可以傳遞至<xref:System.Type.MakeGenericType%2A>方法。  
  
> [!NOTE]
>  建構的類型，例如`Base<int, V>`有用時，發出程式碼，但您不能呼叫<xref:System.Type.MakeGenericType%2A>方法，這個型別上的因為它不是泛型類型定義。 若要建立封閉式的建構型別可以具現化，請先呼叫<xref:System.Type.GetGenericTypeDefinition%2A>方法來取得<xref:System.Type>物件，代表泛型類型定義，然後呼叫<xref:System.Type.MakeGenericType%2A>使用所需的類型引數。  
  
 <xref:System.Type>所傳回的物件<xref:System.Type.MakeGenericType%2A>等同於<xref:System.Type>藉由呼叫取得<xref:System.Object.GetType%2A>產生的方法建構的型別，或<xref:System.Object.GetType%2A>建構建立從相同泛型類型的任何的方法。使用相同的型別引數的型別定義。  
  
> [!NOTE]
>  泛型型別的陣列本身就不是泛型型別。 您不能呼叫<xref:System.Type.MakeGenericType%2A>陣列上輸入，例如`C<T>[]`(`Dim ac() As C(Of T)` Visual Basic 中)。 若要建構的封閉式泛型型別，從`C<T>[]`，呼叫<xref:System.Type.GetElementType%2A>取得泛型型別定義`C<T>`; 呼叫<xref:System.Type.MakeGenericType%2A>泛型型別定義，來建立建構的類型，最後呼叫<xref:System.Type.MakeArrayType%2A>方法若要建立此陣列型別建構的型別。 這也是指標類型，則為 true 並`ref`型別 (`ByRef` Visual Basic 中)。  
  
 如需泛型反映中所使用之規範的恆成立條件清單，請參閱 <xref:System.Type.IsGenericType%2A> 屬性備註。  
  
## <a name="nested-types"></a>巢狀類型  
 如果泛型類型定義使用 C#、 c + + 或 Visual Basic，其巢狀的類型是所有泛用的。 這是 true，即使巢狀型別有自己的任何型別參數，因為所有的三種語言包含封入型別的型別參數清單中的巢狀型別的型別參數。 請考慮下列類別：  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 巢狀類別的型別參數清單`Inner`有兩個類型參數，`T`和`U`，其中第一個是其封入類別的型別參數。 同樣地，巢狀類別的型別參數清單`Innermost1`有三個類型參數， `T`， `U`，以及`V`，使用`T`和`U`來自其封入類別。 巢狀的類別`Innermost2`有兩個類型參數，`T`和`U`，這是來自其封入類別。  
  
 如果封入類型的參數清單會有一個以上的型別參數，在順序中的所有型別參數會包含巢狀類型的類型參數清單中。  
  
 若要建構泛型型別從巢狀類型的泛型類型定義，請呼叫<xref:System.Type.MakeGenericType%2A>串連起來型別引數陣列的所有封入類型、 最外層的泛型型別，開頭和結尾所構成的陣列的方法型別引數陣列的巢狀型別本身，如果它有自己的型別參數。 若要建立的執行個體`Innermost1`，呼叫<xref:System.Type.MakeGenericType%2A>與陣列，包含要指派給 T、 U 和 V 的三種類型的方法。若要建立的執行個體`Innermost2`，呼叫<xref:System.Type.MakeGenericType%2A>方法與陣列，包含兩種類型，以指派給 T 和 u。  
  
 語言傳播型別參數，以這種方式中封入類型，因此您可以使用封入類型的型別參數，以定義巢狀類型的欄位。 否則，型別參數不是在範圍內的巢狀類型的主體內。 您可定義巢狀的類型，而不會傳播的封入類型，透過發出動態組件中的程式碼或使用的型別參數[Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)。 MSIL 組譯工具，請考慮下列程式碼：  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 在此範例中，它不是可以定義類型的欄位`T`或是`U`類別中`Innermost`，因為這些型別參數不在範圍內。 下列的組合器程式碼定義，其行為的方式就好似 c + +、 Visual Basic 和 C# 中定義的巢狀的類別：  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 您可以使用[Ildasm.exe （IL 反組譯工具）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)檢查高階語言中定義的巢狀的類別，並觀察這個命名配置。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.MakeGenericType%2A>方法用來建立建構的類型的泛型型別定義從<xref:System.Collections.Generic.Dictionary%602>型別。 建構的型別代表<xref:System.Collections.Generic.Dictionary%602>的`Test`具有字串索引鍵的物件。  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前類型不代表泛型型別定義。 亦即，<see cref="P:System.Type.IsGenericTypeDefinition" /> 傳回 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> 為 <see langword="null" />。  
  
-或- 
<paramref name="typeArguments" /> 的所有項目都是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArguments" /> 中的項目數和目前泛型型別定義的類型參數數目不同。  
  
-或- 
<paramref name="typeArguments" /> 的所有項目都不符合目前泛型型別的對應類型參數所指定的條件約束。  
  
-或- 
 <paramref name="typeArguments" /> 包含的項目是指標類型 (<see cref="P:System.Type.IsPointer" /> 傳回 <see langword="true" />)、傳址類型 (<see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" />) 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。 衍生類別必須提供實作。</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反映和泛用類型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反映檢視和執行個體化泛型類型</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Type" /> 物件，代表指向目前類型的指標。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，代表指向目前類型的指標。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A>方法可用來產生參數清單的指標類型。  
  
 使用語法的 Microsoft intermediate language (MSIL)，如果目前<xref:System.Type>物件代表<xref:System.Int32>，這個方法會傳回<xref:System.Type>物件，表示`Int32*`。  
  
   
  
## Examples  
 下列程式碼範例會建立陣列， `ref` (`ByRef` Visual Basic 中)，和指標類型`Test`類別。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <exception cref="T:System.TypeLoadException">目前的類型為 <see cref="T:System.TypedReference" />。  
  
-或- 
目前的類型為 <see langword="ByRef" /> 類型。 亦即，<see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得一個 <see cref="T:System.Reflection.MemberTypes" /> 值，代表這個成員是類型或巢狀類型。</summary>
        <value>一個 <see cref="T:System.Reflection.MemberTypes" /> 值，代表這個成員是類型或巢狀類型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性會覆寫<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>。 因此，當您檢查一組<xref:System.Reflection.MemberInfo>物件，例如，將所傳回的陣列<xref:System.Type.GetMembers%2A>—<xref:System.Reflection.MemberInfo.MemberType%2A>屬性會傳回<xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>時指定的成員是巢狀型別。  
  
 如果目前<xref:System.Type>代表建構泛型型別，這個屬性會套用至泛型型別定義從中建構的類型。 例如，如果目前<xref:System.Type>代表`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，這個屬性的值取決於`MyGenericType<T>`。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性一律傳回<xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例所示`MemberType`欄位做為參數`GetMember`方法：  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示在 <see cref="T:System.Type" /> 資訊中的遺漏值。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Missing`欄位透過反射啟動以取得參數的預設值的引動過程。 如果`Missing`欄位會傳遞為參數值，並針對該參數，沒有預設值<xref:System.ArgumentException>就會擲回。  
  
   
  
## Examples  
 下列程式碼範例示範使用`Missing`欄位來叫用具有預設引數的方法。  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 此程式碼會產生下列輸出：  
  
 = 10 b = 55.3 c = 12  
  
 = 10 b = 1.3 c = 1  
  
 = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在已定義的目前 <see cref="T:System.Type" /> 中取得模組 (DLL)。</summary>
        <value>在目前已定義之 <see cref="T:System.Type" /> 中的模組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性會傳回的模組中定義的泛型類型定義。 例如，如果您建立的執行個體`MyGenericStack<int>`，則<xref:System.Type.Module%2A>建構類型的屬性會傳回模組中`MyGenericStack<T>`定義。  
  
 同樣地，如果目前<xref:System.Type>代表泛型參數`T`，這個屬性會傳回包含泛型型別定義的組件`T`。  
  
   
  
## Examples  
 下列範例示範的用法<xref:System.Type.Namespace%2A>並`Module`屬性和<xref:System.Type.ToString%2A>方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Type" /> 的命名空間。</summary>
        <value>
          <see cref="T:System.Type" /> 的命名空間；如果目前執行個體沒有命名空間或代表泛型參數，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 命名空間是邏輯設計階段命名慣例，主要用來定義應用程式中的範圍和組織類別和其他類型的單一階層式結構中。 從執行階段的觀點來看，沒有命名空間。  
  
 如果目前<xref:System.Type>代表建構的泛型類型，這個屬性會傳回包含泛型型別定義的命名空間。 同樣地，如果目前<xref:System.Type>代表泛型參數`T`，這個屬性會傳回包含定義的泛型類型定義的命名空間`T`。  
  
 如果目前<xref:System.Type>物件代表泛型參數，則這個屬性會傳回`null`。  
  
   
  
## Examples  
 下列範例示範的用法`Namespace`並<xref:System.Type.Module%2A>屬性和<xref:System.Type.ToString%2A>方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個物件。</param>
        <param name="right">要比較的第二個物件。</param>
        <summary>表示兩個 <see cref="T:System.Type" /> 物件是否相等。</summary>
        <returns>如果 <see langword="true" /> 等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個物件。</param>
        <param name="right">要比較的第二個物件。</param>
        <summary>表示兩個 <see cref="T:System.Type" /> 物件是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來取得這個成員的類別物件。</summary>
        <value>
          <see langword="Type" /> 物件，用來取得這個 <see cref="T:System.Type" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對<xref:System.Type>物件，這個屬性的值一律是相同的值為<xref:System.Type.DeclaringType%2A>屬性。  
  
   
  
## Examples  
 此範例會顯示巢狀類別的反映型別。  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要取得之 <see cref="T:System.Type" /> 的組件限定名稱。</param>
        <param name="throwIfNotFound">
          <see langword="true" /> 表示找不到類型時擲回 <see cref="T:System.TypeLoadException" />，<see langword="false" /> 表示找不到類型時傳回 <see langword="null" />。 指定 <see langword="false" /> 也會隱藏其他某些例外狀況條件，但並不是全部。 請參閱＜例外狀況＞一節。</param>
        <param name="ignoreCase">
          <see langword="true" /> 表示對 <c>typeName</c> 執行不區分大小寫的搜尋，<see langword="false" /> 表示對 <c>typeName</c> 執行區分大小寫的搜尋。</param>
        <summary>取得具有指定名稱的 <see cref="T:System.Type" />，指定是否執行區分大小寫的搜尋，以及若找不到該類型時是否擲回例外狀況。 載入此類型的目的在於反映，而不是執行。</summary>
        <returns>具有指定名稱的類型 (如有找到)，否則為 <see langword="null" />。 如果找不到該類型，<paramref name="throwIfNotFound" /> 參數會指定是要傳回 <see langword="null" /> 或是擲回例外狀況。 在某些情況下，不論 <paramref name="throwIfNotFound" /> 的值為何，都會擲回例外狀況。 請參閱＜例外狀況＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果包含類型的組件尚未載入僅限反映的內容，使用<xref:System.Type.ReflectionOnlyGetType%2A>方法，是相當於第一個載入僅限反映的組件使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>方法，並接著藉由呼叫載入型別組件的<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法。 如需組件限定名稱的資訊，請參閱<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>屬性。 如需有關指定的類型名稱的詳細資訊，請參閱<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載。  
  
 如果已執行載入組件，會將另一個複本載入僅限反映的內容。  
  
 `throwIfNotFound`參數會指定時會發生什麼事的型別找不到，並會隱藏其他某些例外情況，例外狀況 」 一節中所述。 某些例外狀況的值為何`throwIfNotFound`。 例如，如果組件無效<xref:System.BadImageFormatException>就會擲回即使`throwIfNotFound`是`false`。  
  
 如需使用僅限反映內容的詳細資訊，請參閱[如何： 將組件載入僅限反映內容](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且找不到類型。  
  
-或- 
 <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效字元，例如內嵌的定位字元。 
-或- 
 <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 是空字串。  
  
-或- 
 <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 代表大小無效的陣列類型。  
  
-或- 
 <paramref name="typeName" /> 代表 <see cref="T:System.TypedReference" /> 物件的陣列。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 不包含組件名稱。  
  
-或- 
 <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且 <paramref name="typeName" /> 包含無效語法 (例如 "MyType[,*,]")。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型以指標類型、<see langword="ByRef" /> 類型或 <see cref="T:System.Void" /> 做為其中一個類型引數。  
  
-或- 
 <paramref name="typeName" /> 代表的泛型類型具有不正確的類型引數數目。  
  
-或- 
 <paramref name="typeName" /> 代表泛型類型，其中一個類型引數不符合對應類型參數的條件約束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> 為 <see langword="true" />，而且找不到組件或組件的其中一個相依性。</exception>
        <exception cref="T:System.IO.FileLoadException">找到組件或其相依性的其中一個，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">組件或組件的其中一個相依性無效。  
  
-或- 
用以編譯組件的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">如何：將組件載入僅限反映的內容</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得描述目前類型配置的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</summary>
        <value>取得描述目前類型概略配置特性的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 不會傳回<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法。 相反地，使用這個屬性來取得它。  
  
   
  
## Examples  
 下列程式碼範例會先定義類別、 結構和具有特殊的版面配置屬性 （在類別內，巢狀結構） 的結構。 然後此範例使用<xref:System.Type.StructLayoutAttribute%2A>屬性，以取得<xref:System.Runtime.InteropServices.StructLayoutAttribute>的每個型別，並顯示屬性的屬性。  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基底類別不支援叫用的方法。</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應之傳入的名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，用於接收對應於名稱的 ID。</param>
        <summary>將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的類型資訊。</param>
        <param name="lcid">類型資訊的地區設定識別項。</param>
        <param name="ppTInfo">所要求類型資訊物件的指標。</param>
        <summary>擷取物件的類型資訊，可以用來取得介面的類型資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向接收物件提供的類型資訊介面數目的位置。</param>
        <summary>擷取物件提供的類型資訊介面數目 (0 或 1)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">辨識成員。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</param>
        <param name="pVarResult">指向用於儲存結果之位置的指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊的結構指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>提供物件所公開的屬性和方法的存取權。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回表示目前 <see langword="String" /> 的名稱的 <see langword="Type" />。</summary>
        <returns>表示目前 <see cref="T:System.String" /> 的名稱的 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回所有的基本類型的名稱與完整的 common language runtime 命名空間。 例如，C# 指令`(long)0.Type().ToString()`傳回 「 System.Int64"，而不是只是"Int64"。  
  
 如果目前<xref:System.Type>代表泛型類型、 類型和其類型引數會限定命名空間和巢狀型別，但不是由組件。 如果目前<xref:System.Type>代表型別參數定義中的泛型類型或泛型方法，這個方法會傳回非限定的型別參數名稱。  
  
   
  
## Examples  
 下列範例示範的用法<xref:System.Type.Namespace%2A>並<xref:System.Type.Module%2A>屬性和`ToString`方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 下列範例會比較所傳回的字串<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>屬性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Type" /> 的控制代碼。</summary>
        <value>目前 <see cref="T:System.Type" /> 的控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` 封裝代表類型的內部資料結構的指標。 這個控制代碼的處理序存留期間是唯一的。 控制代碼無效，只能在取得應用程式定義域中。  
  
   
  
## Examples  
 下列範例會傳回對應的型別控制代碼，並將控制代碼傳遞取得控制代碼的類型，並顯示它的方法。  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 目前不支援這個屬性。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得類型的初始設定式。</summary>
        <value>物件，包含 <see cref="T:System.Type" /> 的類別建構函式名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別初始設定式也都可透過<xref:System.Type.FindMembers%2A>方法，或透過多載<xref:System.Type.GetMember%2A>， <xref:System.Type.GetMembers%2A>， <xref:System.Type.GetConstructor%2A>，並<xref:System.Type.GetConstructors%2A>採用的方法<xref:System.Reflection.BindingFlags>做為參數。  
  
 如果目前<xref:System.Type>表示的類型參數的泛型類型或泛型方法定義中這個屬性會傳回`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示類型，該類型是由表示這個類型的 Common Language Runtime 所提供的。</summary>
        <value>
          <see cref="T:System.Type" /> 的基礎系統類型。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>