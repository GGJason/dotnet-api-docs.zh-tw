<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a2c42b4da1c7b0ee11963dcad14520dc83134e6" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52238567" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="1e955-101">表示虛擬亂數產生器，為產生數字序列的裝置，符合隨機方式的特定統計需求。</span>
      <span class="sxs-lookup">
        <span data-stu-id="1e955-101">Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-102">虛擬隨機數字是從一組有限的數字選擇相等的可能性。</span><span class="sxs-lookup"><span data-stu-id="1e955-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="1e955-103">選取的數字不是完全隨機的因為會使用數學演算法來選取它們，但它們實際上是夠隨機。</span><span class="sxs-lookup"><span data-stu-id="1e955-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="1e955-104">目前的實作<xref:System.Random>類別根據 Donald E.Knuth 的涉及刪減亂數產生器演算法的修改版本。</span><span class="sxs-lookup"><span data-stu-id="1e955-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="1e955-105">如需詳細資訊，請參閱 < D.e。</span><span class="sxs-lookup"><span data-stu-id="1e955-105">For more information, see D. E.</span></span> <span data-ttu-id="1e955-106">Knuth。</span><span class="sxs-lookup"><span data-stu-id="1e955-106">Knuth.</span></span> <span data-ttu-id="1e955-107">*電腦程式設計，磁碟區 2 的藝術： Seminumerical 演算法*。</span><span class="sxs-lookup"><span data-stu-id="1e955-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="1e955-108">Addison-wesley，讀取拼湊的麻薩諸塞州，第三個版本，1997年。</span><span class="sxs-lookup"><span data-stu-id="1e955-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="1e955-109">若要產生的密碼編譯安全隨機數字，例如另一個則是適合用來建立隨機的密碼，使用<xref:System.Security.Cryptography.RNGCryptoServiceProvider>類別或衍生的類別<xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="1e955-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1e955-110">本主題內容：</span><span class="sxs-lookup"><span data-stu-id="1e955-110">In this topic:</span></span>  
  
 <span data-ttu-id="1e955-111">[具現化之隨機號碼產生器](#Instantiate) </span><span class="sxs-lookup"><span data-stu-id="1e955-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="1e955-112">[避免多個具現化](#Multiple) </span><span class="sxs-lookup"><span data-stu-id="1e955-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="1e955-113">[System.Random 類別和執行緒安全](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="1e955-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="1e955-114">[產生不同類型的隨機數字](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="1e955-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="1e955-115">[取代您自己的演算法](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="1e955-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="1e955-116">[您要如何使用以 System.Random...](#Operations) </span><span class="sxs-lookup"><span data-stu-id="1e955-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="1e955-117">擷取相同的隨機值序列</span><span class="sxs-lookup"><span data-stu-id="1e955-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="1e955-118">擷取隨機值的唯一的序列</span><span class="sxs-lookup"><span data-stu-id="1e955-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="1e955-119">擷取指定範圍內的整數</span><span class="sxs-lookup"><span data-stu-id="1e955-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="1e955-120">擷取具有指定位數的整數</span><span class="sxs-lookup"><span data-stu-id="1e955-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="1e955-121">擷取指定範圍中的浮點值</span><span class="sxs-lookup"><span data-stu-id="1e955-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="1e955-122">產生隨機的布林值</span><span class="sxs-lookup"><span data-stu-id="1e955-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="1e955-123">產生隨機的 64 位元整數</span><span class="sxs-lookup"><span data-stu-id="1e955-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="1e955-124">擷取指定範圍內的位元組</span><span class="sxs-lookup"><span data-stu-id="1e955-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="1e955-125">從陣列或集合中隨機擷取項目</span><span class="sxs-lookup"><span data-stu-id="1e955-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="1e955-126">擷取陣列或集合的唯一項目</span><span class="sxs-lookup"><span data-stu-id="1e955-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="1e955-127">具現化之隨機號碼產生器</span><span class="sxs-lookup"><span data-stu-id="1e955-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="1e955-128">您具現化之隨機號碼產生器所提供的種子值 （虛擬亂數產生演算法的起始值） 來<xref:System.Random.%23ctor%2A>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="1e955-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="1e955-129">您可以在明確或隱含提供的種子值：</span><span class="sxs-lookup"><span data-stu-id="1e955-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="1e955-130"><xref:System.Random.%23ctor%28System.Int32%29>建構函式會使用您提供明確的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="1e955-131"><xref:System.Random.%23ctor>建構函式會使用系統時鐘來提供的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-131">The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value.</span></span> <span data-ttu-id="1e955-132">這是最常見的方法具現化之隨機號碼產生器。</span><span class="sxs-lookup"><span data-stu-id="1e955-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="1e955-133">如果相同的種子用於個別<xref:System.Random>物件，則會產生隨機數字的數列相同。</span><span class="sxs-lookup"><span data-stu-id="1e955-133">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="1e955-134">這可以是用來建立測試套件，以處理隨機值，或重新執行其資料源自隨機數字的遊戲。</span><span class="sxs-lookup"><span data-stu-id="1e955-134">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="1e955-135">但請注意，<xref:System.Random>不同版本的.NET Framework 下執行的處理序中的物件可能會傳回不同系列的隨機數字，即使它們具現化具有相同的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-135">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="1e955-136">若要產生隨機數字的不同時序，您可以進行的種子值時間而異，因而產生不同的系列的每個新執行個體<xref:System.Random>。</span><span class="sxs-lookup"><span data-stu-id="1e955-136">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="1e955-137">參數化<xref:System.Random.%23ctor%28System.Int32%29>建構函式可以採用<xref:System.Int32>值根據刻度數，在目前的時間，而無參數<xref:System.Random.%23ctor>建構函式會使用系統時鐘來產生其種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-137">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="1e955-138">不過，因為時鐘的解析度有限，使用無參數建構函式來建立不同<xref:System.Random>中連續物件建立亂數產生器產生的隨機數字的相同順序。</span><span class="sxs-lookup"><span data-stu-id="1e955-138">However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="1e955-139">下列範例說明如何在兩個<xref:System.Random>關閉連續具現化的物件產生相同的系列的隨機數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-139">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers.</span></span> <span data-ttu-id="1e955-140">在大多數的 Windows 系統<xref:System.Random>中 15 毫秒的另一個建立的物件可能會有相同的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-140">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 <span data-ttu-id="1e955-141">若要避免這個問題，建立單一<xref:System.Random>而不是多個物件的物件。</span><span class="sxs-lookup"><span data-stu-id="1e955-141">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span>  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="1e955-142">避免多個具現化</span><span class="sxs-lookup"><span data-stu-id="1e955-142">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="1e955-143">初始化兩個亂數產生器在緊密迴圈中，或快速地連續建立兩個亂數產生器可能會產生相同的隨機數字的序列。</span><span class="sxs-lookup"><span data-stu-id="1e955-143">Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="1e955-144">在大部分情況下，這不是開發人員的意圖，並可能會導致效能問題，因為具現化並初始化亂數產生器是相當耗成本的程序。</span><span class="sxs-lookup"><span data-stu-id="1e955-144">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="1e955-145">同時以改善效能並避免不小心建立個別的亂數產生器，產生相同的數字序列，我們建議您建立一個<xref:System.Random>物件來產生許多隨機的數字一段時間，而不是建立新<xref:System.Random>產生一個隨機數字的物件。</span><span class="sxs-lookup"><span data-stu-id="1e955-145">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="1e955-146">不過，<xref:System.Random>類別不具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="1e955-146">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="1e955-147">如果您呼叫<xref:System.Random>方法，從多個執行緒，請遵循下一節所述的指導方針。</span><span class="sxs-lookup"><span data-stu-id="1e955-147">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="1e955-148">System.Random 類別和執行緒安全</span><span class="sxs-lookup"><span data-stu-id="1e955-148">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="1e955-149">而不是具現化的個別<xref:System.Random>物件，我們建議您建立單一<xref:System.Random>產生應用程式所需的所有隨機數字的執行個體。</span><span class="sxs-lookup"><span data-stu-id="1e955-149">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="1e955-150">不過，<xref:System.Random>物件不是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="1e955-150">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="1e955-151">如果您的應用程式呼叫<xref:System.Random>從多個執行緒的方法，您必須使用同步物件來確保只有一個執行緒可以存取一次的亂數產生器。</span><span class="sxs-lookup"><span data-stu-id="1e955-151">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="1e955-152">如果您不確定<xref:System.Random>執行緒安全的方式存取物件時，會傳回隨機數字的方法呼叫會傳回 0。</span><span class="sxs-lookup"><span data-stu-id="1e955-152">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="1e955-153">下列範例會使用 C# [lock 陳述式](~/docs/csharp/language-reference/keywords/lock-statement.md)和 Visual Basic [SyncLock 陳述式](~/docs/visual-basic/language-reference/statements/synclock-statement.md)確保單一亂數產生器的 11 個執行緒存取具備執行緒安全的方式。</span><span class="sxs-lookup"><span data-stu-id="1e955-153">The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="1e955-154">每個執行緒會產生 2 百萬個隨機數字、 計算產生的隨機數字的數目和計算其總和，並完成執行時，然後更新所有執行緒的總計。</span><span class="sxs-lookup"><span data-stu-id="1e955-154">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="1e955-155">範例會確保執行緒安全性，以下列方式：</span><span class="sxs-lookup"><span data-stu-id="1e955-155">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="1e955-156"><xref:System.ThreadStaticAttribute>屬性用來定義執行緒區域變數，可追蹤產生的隨機數字和其總和的每個執行緒的總數。</span><span class="sxs-lookup"><span data-stu-id="1e955-156">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="1e955-157">鎖定 ( `lock` C# 中的陳述式和`SyncLock`Visual Basic 中的陳述式) 可保護變數的存取權的總計數和所有產生的所有執行緒上的隨機數字的總和。</span><span class="sxs-lookup"><span data-stu-id="1e955-157">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="1e955-158">號誌 (<xref:System.Threading.CountdownEvent>物件) 用來確保主要執行緒會封鎖直到所有其他執行緒完成執行。</span><span class="sxs-lookup"><span data-stu-id="1e955-158">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="1e955-159">此範例會檢查是否隨機號碼產生器已損毀藉由判斷是否要隨機數字產生方法的兩個連續呼叫會傳回 0。</span><span class="sxs-lookup"><span data-stu-id="1e955-159">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="1e955-160">如果偵測到損毀時，此範例會使用<xref:System.Threading.CancellationTokenSource>發出信號，表示應該取消所有執行緒的物件。</span><span class="sxs-lookup"><span data-stu-id="1e955-160">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="1e955-161">才會產生每個隨機數字，每個執行緒檢查狀態<xref:System.Threading.CancellationToken>物件。</span><span class="sxs-lookup"><span data-stu-id="1e955-161">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="1e955-162">如果要求取消，則此範例會呼叫<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法來取消執行緒。</span><span class="sxs-lookup"><span data-stu-id="1e955-162">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="1e955-163">下列範例等同於第一天，不同之處在於它會使用<xref:System.Threading.Tasks.Task>物件，而不是 lambda 運算式<xref:System.Threading.Thread>物件。</span><span class="sxs-lookup"><span data-stu-id="1e955-163">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="1e955-164">不同於第一個範例如下：</span><span class="sxs-lookup"><span data-stu-id="1e955-164">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="1e955-165">這樣就不需要使用變數來追蹤產生的隨機數字的數目，以及每個工作中的其總和都是本機工作，<xref:System.ThreadStaticAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="1e955-165">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="1e955-166">靜態<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法用來確保不會完成主執行緒，才能完成所有工作。</span><span class="sxs-lookup"><span data-stu-id="1e955-166">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="1e955-167">不需要針對<xref:System.Threading.CountdownEvent>物件。</span><span class="sxs-lookup"><span data-stu-id="1e955-167">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="1e955-168">所產生的工作取消的例外狀況會顯示在<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-168">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1e955-169">在上述範例中，它是由每個執行緒處理。</span><span class="sxs-lookup"><span data-stu-id="1e955-169">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="1e955-170">產生不同類型的隨機數字</span><span class="sxs-lookup"><span data-stu-id="1e955-170">Generating different types of random numbers</span></span>  
 <span data-ttu-id="1e955-171">亂數產生器會提供方法，讓您產生下列類型的隨機數字：</span><span class="sxs-lookup"><span data-stu-id="1e955-171">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="1e955-172">一系列的<xref:System.Byte>值。</span><span class="sxs-lookup"><span data-stu-id="1e955-172">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="1e955-173">您傳遞陣列初始化為您想要返回方法的項目數目來判斷位元組值的數目<xref:System.Random.NextBytes%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-173">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="1e955-174">下列範例會產生 20 個位元組。</span><span class="sxs-lookup"><span data-stu-id="1e955-174">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="1e955-175">單一的整數。</span><span class="sxs-lookup"><span data-stu-id="1e955-175">A single integer.</span></span> <span data-ttu-id="1e955-176">您可以選擇是否要從 0 到最大值的整數 (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) 藉由呼叫<xref:System.Random.Next>方法中，整數介於 0 到特定的值，藉由呼叫<xref:System.Random.Next%28System.Int32%29>方法或藉由呼叫值的範圍內的整數<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-176">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="1e955-177">參數化的多載，在指定的最大值是獨佔;也就是說，產生的實際數目上限是其中一個指定的值大於或等於。</span><span class="sxs-lookup"><span data-stu-id="1e955-177">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="1e955-178">下列範例會呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，以產生 10 個隨機數字，介於-10 到 10 之間。</span><span class="sxs-lookup"><span data-stu-id="1e955-178">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="1e955-179">請注意，此方法的第二個引數指定範圍的方法所傳回的隨機值的獨佔上限。</span><span class="sxs-lookup"><span data-stu-id="1e955-179">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="1e955-180">換句話說，這個方法會傳回一個的最大整數低於此數的值。</span><span class="sxs-lookup"><span data-stu-id="1e955-180">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="1e955-181">從 0.0 到小於 1.0 藉由呼叫的單一浮點值<xref:System.Random.NextDouble%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-181">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="1e955-182">方法所傳回之亂數的獨佔上限會是 1，所以它實際的上限是 0.99999999999999978。</span><span class="sxs-lookup"><span data-stu-id="1e955-182">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="1e955-183">下列範例會產生 10 個隨機浮點數。</span><span class="sxs-lookup"><span data-stu-id="1e955-183">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="1e955-184"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法可讓您指定傳回的隨機數字的範圍。</span><span class="sxs-lookup"><span data-stu-id="1e955-184">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="1e955-185">不過，`maxValue`參數，指定較高的範圍傳回數字，其是獨佔，不含值。</span><span class="sxs-lookup"><span data-stu-id="1e955-185">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="1e955-186">這表示在方法呼叫`Next(0, 100)`傳回值，介於 0 到 99，並不是介於 0 到 100 之間。</span><span class="sxs-lookup"><span data-stu-id="1e955-186">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="1e955-187">您也可以使用<xref:System.Random>這類工作產生的類別[隨機 t: system.boolean< 值](#Boolean)、 產生[值範圍以外的 0 到 1 的隨機浮點數](#Floats)，產生[隨機的 64 位元整數](#Long)，並[隨機從陣列或集合中擷取的唯一項目](#UniqueArray)。</span><span class="sxs-lookup"><span data-stu-id="1e955-187">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="1e955-188">如需這些和其他一般工作，請參閱[您該如何使用以 System.Random...](#Operations)</span><span class="sxs-lookup"><span data-stu-id="1e955-188">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="1e955-189">一節。</span><span class="sxs-lookup"><span data-stu-id="1e955-189">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="1e955-190">取代您自己的演算法</span><span class="sxs-lookup"><span data-stu-id="1e955-190">Substituting your own algorithm</span></span>  
 <span data-ttu-id="1e955-191">您可以藉由繼承自實作您自己亂數產生器<xref:System.Random>類別，並提供您亂數產生演算法。</span><span class="sxs-lookup"><span data-stu-id="1e955-191">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="1e955-192">若要提供您自己的演算法，您必須覆寫<xref:System.Random.Sample%2A>方法，它會實作隨機的數字產生演算法。</span><span class="sxs-lookup"><span data-stu-id="1e955-192">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="1e955-193">您也應該覆寫<xref:System.Random.Next>， <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>，並<xref:System.Random.NextBytes%2A>方法，以確保它們呼叫覆寫<xref:System.Random.Sample%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-193">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="1e955-194">您不需要覆寫<xref:System.Random.Next%28System.Int32%29>和<xref:System.Random.NextDouble%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-194">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="1e955-195">如需範例衍生自<xref:System.Random>類別，並修改其預設虛擬亂數產生器，請參閱<xref:System.Random.Sample%2A>參考頁面。</span><span class="sxs-lookup"><span data-stu-id="1e955-195">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="1e955-196">您要如何使用以 System.Random...</span><span class="sxs-lookup"><span data-stu-id="1e955-196">How do you use System.Random to…</span></span>  
 <span data-ttu-id="1e955-197">下列各節討論，並提供一些您可能想要使用應用程式中的隨機數字的方式的範例程式碼。</span><span class="sxs-lookup"><span data-stu-id="1e955-197">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="1e955-198">擷取相同的隨機值序列</span><span class="sxs-lookup"><span data-stu-id="1e955-198">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="1e955-199">有時您想要在軟體測試案例和遊戲播放產生相同的隨機數字序列。</span><span class="sxs-lookup"><span data-stu-id="1e955-199">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="1e955-200">使用相同的隨機數字順序進行測試，可讓您偵測迴歸，並確認 bug 修正。</span><span class="sxs-lookup"><span data-stu-id="1e955-200">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="1e955-201">在遊戲中使用相同的隨機數字序列，可讓您重新執行先前的遊戲。</span><span class="sxs-lookup"><span data-stu-id="1e955-201">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="1e955-202">您可以藉由提供相同的初始值，以產生相同的隨機數字序列<xref:System.Random.%23ctor%28System.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="1e955-202">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="1e955-203">種子值提供的虛擬隨機的數字產生演算法的起始值。</span><span class="sxs-lookup"><span data-stu-id="1e955-203">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="1e955-204">下列範例使用為任意的種子值來具現化 100100<xref:System.Random>物件，會顯示 20 個隨機浮點值，並保存的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-204">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="1e955-205">然後將還原的種子值，會具現化新的隨機數字產生器，並會顯示相同的 20 個隨機浮點值。</span><span class="sxs-lookup"><span data-stu-id="1e955-205">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="1e955-206">請注意此範例可能會產生隨機數字的不同時序，是否在不同版本的.NET Framework 上執行。</span><span class="sxs-lookup"><span data-stu-id="1e955-206">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="1e955-207">擷取隨機數字的唯一的序列</span><span class="sxs-lookup"><span data-stu-id="1e955-207">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="1e955-208">提供的執行個體的不同的種子值<xref:System.Random>類別會導致每個亂數產生器來產生不同的一連串的值。</span><span class="sxs-lookup"><span data-stu-id="1e955-208">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="1e955-209">您可以明確地呼叫其中一個提供初始值<xref:System.Random.%23ctor%28System.Int32%29>建構函式，或以隱含方式呼叫<xref:System.Random.%23ctor>建構函式。</span><span class="sxs-lookup"><span data-stu-id="1e955-209">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="1e955-210">大部分的開發人員呼叫無參數建構函式，它會使用系統時鐘。</span><span class="sxs-lookup"><span data-stu-id="1e955-210">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="1e955-211">下列範例會使用這種方法來具現化兩個<xref:System.Random>執行個體。</span><span class="sxs-lookup"><span data-stu-id="1e955-211">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="1e955-212">每個執行個體顯示一系列的 10 個隨機整數。</span><span class="sxs-lookup"><span data-stu-id="1e955-212">Each instance displays a series of 10 random integers.</span></span>  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 <span data-ttu-id="1e955-213">不過，因為其有限的解析度，而系統時鐘偵測不到大約少於 15 毫秒的時間差異。</span><span class="sxs-lookup"><span data-stu-id="1e955-213">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="1e955-214">因此，如果您的程式碼會呼叫<xref:System.Random.%23ctor>具現化兩個多載<xref:System.Random>物件連續，您可能會不小心提供的物件具有相同的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-214">Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="1e955-215">若要查看這在上述範例中，標記為註解<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法呼叫，並編譯和執行一次的範例。</span><span class="sxs-lookup"><span data-stu-id="1e955-215">To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="1e955-216">若要避免這種情況，我們建議您具現化一個<xref:System.Random>物件而不是多個項目。</span><span class="sxs-lookup"><span data-stu-id="1e955-216">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="1e955-217">不過，由於<xref:System.Random>不具備執行緒安全，您必須使用一些同步處理的裝置，如果您存取<xref:System.Random>執行個體從多個執行緒; 如需詳細資訊，請參閱[隨機的類別和執行緒安全](#ThreadSafety)稍早在此主題。</span><span class="sxs-lookup"><span data-stu-id="1e955-217">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="1e955-218">或者，您可以使用延遲機制，例如<xref:System.Threading.Thread.Sleep%2A>方法在先前範例中，用以確保具現化不會發生相差超過 15 毫秒。</span><span class="sxs-lookup"><span data-stu-id="1e955-218">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="1e955-219">擷取指定範圍內的整數</span><span class="sxs-lookup"><span data-stu-id="1e955-219">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="1e955-220">您可以呼叫來擷取指定範圍內的整數<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，可讓您指定下限和上限，您想要傳回之隨機號碼產生器的數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-220">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="1e955-221">上限是獨佔，不含值。</span><span class="sxs-lookup"><span data-stu-id="1e955-221">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="1e955-222">也就是說，它不包含範圍內的方法所傳回的值。</span><span class="sxs-lookup"><span data-stu-id="1e955-222">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="1e955-223">下列範例會使用這個方法來產生介於-10 到 10 之間的隨機整數。</span><span class="sxs-lookup"><span data-stu-id="1e955-223">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="1e955-224">請注意，它指定 11 中，這是一必須大於想要的值，做為值的`maxValue`方法呼叫中的引數。</span><span class="sxs-lookup"><span data-stu-id="1e955-224">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="1e955-225">擷取具有指定位數的整數</span><span class="sxs-lookup"><span data-stu-id="1e955-225">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="1e955-226">您可以呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法來擷取具有指定位數的數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-226">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="1e955-227">例如，若要擷取具有四個位數 （也就是數字，範圍從 1000年到 9999） 的數字，您呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法`minValue`1000年的值和`maxValue`10000，如下列範例所示的值。</span><span class="sxs-lookup"><span data-stu-id="1e955-227">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="1e955-228">擷取指定範圍中的浮點值</span><span class="sxs-lookup"><span data-stu-id="1e955-228">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="1e955-229"><xref:System.Random.NextDouble%2A>方法會傳回隨機浮點數的值範圍從 0 到小於 1。</span><span class="sxs-lookup"><span data-stu-id="1e955-229">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="1e955-230">不過，您通常會想要在其他範圍內產生隨機值。</span><span class="sxs-lookup"><span data-stu-id="1e955-230">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="1e955-231">如果需要最小和最大的值之間的間隔為 1 時，您可以新增想要的啟動間隔與 0 之間的差異所傳回的數字<xref:System.Random.NextDouble%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-231">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="1e955-232">下列範例會產生 10 個隨機數字，介於-1 和 0。</span><span class="sxs-lookup"><span data-stu-id="1e955-232">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="1e955-233">若要產生隨機浮點數，其下限為 0，但上限大於 1 （或，如果是負數，其下限為小於-1，上限為 0），乘以非零繫結中的隨機數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-233">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="1e955-234">下列範例會產生 20 萬個隨機浮點數的數字範圍從 0 到<xref:System.Int64.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="1e955-234">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1e955-235">中也會顯示方法所產生的隨機值的分佈。</span><span class="sxs-lookup"><span data-stu-id="1e955-235">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="1e955-236">若要產生兩個的任意值之間的隨機浮點數，例如<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法會為整數，請使用下列公式：</span><span class="sxs-lookup"><span data-stu-id="1e955-236">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 <span data-ttu-id="1e955-237">下列範例會產生 1 百萬個亂數的範圍則是從 10.0 為 11.0，並顯示其散發。</span><span class="sxs-lookup"><span data-stu-id="1e955-237">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="1e955-238">產生隨機的布林值</span><span class="sxs-lookup"><span data-stu-id="1e955-238">Generate random Boolean values</span></span>  
 <span data-ttu-id="1e955-239"><xref:System.Random>類別不提供方法，可產生<xref:System.Boolean>值。</span><span class="sxs-lookup"><span data-stu-id="1e955-239">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="1e955-240">不過，您可以定義自己的類別或方法，若要這麼做。</span><span class="sxs-lookup"><span data-stu-id="1e955-240">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="1e955-241">下列範例會定義類別`BooleanGenerator`，具有單一方法， `NextBoolean`。</span><span class="sxs-lookup"><span data-stu-id="1e955-241">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="1e955-242">`BooleanGenerator`類別存放區<xref:System.Random>物件做為私用變數。</span><span class="sxs-lookup"><span data-stu-id="1e955-242">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="1e955-243">`NextBoolean`方法呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，並將結果傳遞<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-243">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1e955-244">請注意，2 做為引數用來指定隨機數字上限。</span><span class="sxs-lookup"><span data-stu-id="1e955-244">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="1e955-245">由於這是獨佔的值，則方法呼叫會傳回 0 或 1。</span><span class="sxs-lookup"><span data-stu-id="1e955-245">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 <span data-ttu-id="1e955-246">而不是建立個別的類別，來產生隨機<xref:System.Boolean>值，此範例可能只是定義單一方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-246">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="1e955-247">在此情況下，不過，<xref:System.Random>物件應該已定義為類別層級變數，以避免具現化新<xref:System.Random>中每個方法呼叫的執行個體。</span><span class="sxs-lookup"><span data-stu-id="1e955-247">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="1e955-248">在 Visual Basic 中的 Random 執行個體可以定義為[靜態](~/docs/visual-basic/language-reference/modifiers/static.md)變數中`NextBoolean`方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-248">In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="1e955-249">下列範例提供的實作。</span><span class="sxs-lookup"><span data-stu-id="1e955-249">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="1e955-250">產生隨機的 64 位元整數</span><span class="sxs-lookup"><span data-stu-id="1e955-250">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="1e955-251">多載<xref:System.Random.Next%2A>方法會傳回 32 位元整數。</span><span class="sxs-lookup"><span data-stu-id="1e955-251">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="1e955-252">不過，在某些情況下，您可能想要使用 64 位元整數。</span><span class="sxs-lookup"><span data-stu-id="1e955-252">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="1e955-253">您可以依照下列方式來執行這項操作：</span><span class="sxs-lookup"><span data-stu-id="1e955-253">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="1e955-254">呼叫<xref:System.Random.NextDouble%2A>方法來擷取雙精確度浮點數的值。</span><span class="sxs-lookup"><span data-stu-id="1e955-254">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="1e955-255">將由該值乘以<xref:System.Int64.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="1e955-255">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1e955-256">下列範例會產生 20 萬個隨機的長整數使用這項技術，並將它們分類中 10 個相等的群組。</span><span class="sxs-lookup"><span data-stu-id="1e955-256">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="1e955-257">它接著會評估分佈的隨機數字，來計算從 0 到每個群組中的數字<xref:System.Int64.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="1e955-257">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1e955-258">如範例輸出所示，數字會增加或減少平均分散整個長整數的範圍。</span><span class="sxs-lookup"><span data-stu-id="1e955-258">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="1e955-259">替代方法，會使用位元操作不會產生真正的隨機數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-259">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="1e955-260">這項技術會呼叫<xref:System.Random.Next>來產生兩個整數、 左移一個由 32 位元為單位和 Or 在一起。</span><span class="sxs-lookup"><span data-stu-id="1e955-260">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="1e955-261">這項技術有兩項限制：</span><span class="sxs-lookup"><span data-stu-id="1e955-261">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="1e955-262">位元 31 為正負號位元，因為產生的長整數的位元 31 中的值一律是 0。</span><span class="sxs-lookup"><span data-stu-id="1e955-262">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="1e955-263">這可藉由產生隨機的 0 或 1，向左移位它 31 位元為單位，並搭配使用 or 與它與原始的隨機長整數。</span><span class="sxs-lookup"><span data-stu-id="1e955-263">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="1e955-264">更嚴重，因為所傳回的值的機率<xref:System.Random.Next>將會是 0，如果有的話，將幾個隨機數字會出在範圍內 0x0 0x00000000FFFFFFFF。</span><span class="sxs-lookup"><span data-stu-id="1e955-264">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="1e955-265">擷取指定範圍內的位元組</span><span class="sxs-lookup"><span data-stu-id="1e955-265">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="1e955-266">多載<xref:System.Random.Next%2A>方法可讓您指定的隨機數字，範圍但<xref:System.Random.NextBytes%2A>方法則否。</span><span class="sxs-lookup"><span data-stu-id="1e955-266">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="1e955-267">下列範例會實作`NextBytes`方法，可讓您指定的傳回的位元組範圍。</span><span class="sxs-lookup"><span data-stu-id="1e955-267">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="1e955-268">它會定義`Random2`類別衍生自<xref:System.Random>並且可以多載其`NextBytes`方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-268">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 <span data-ttu-id="1e955-269">`NextBytes(Byte[], Byte, Byte)`方法會包裝對<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法並指定最小值和一個大於最大值 (在此情況下，0 到 101) 我們要傳回的位元組陣列中。</span><span class="sxs-lookup"><span data-stu-id="1e955-269">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="1e955-270">因為我們已經確定所傳回的整數值<xref:System.Random.Next%2A>方法會在範圍內<xref:System.Byte>資料型別，我們可以安全地將參數轉換 （在 C# 中) 或將它們 （在 Visual Basic 中) 從整數轉換為位元組。</span><span class="sxs-lookup"><span data-stu-id="1e955-270">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="1e955-271">從陣列或集合中隨機擷取項目</span><span class="sxs-lookup"><span data-stu-id="1e955-271">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="1e955-272">隨機數字通常會做為索引來擷取陣列或集合中的值。</span><span class="sxs-lookup"><span data-stu-id="1e955-272">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="1e955-273">若要擷取的隨機的索引值，您可以呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，並使用較低的陣列繫結的值為其`minValue`引數和大於上限的值陣列的其中一個其`maxValue`引數。</span><span class="sxs-lookup"><span data-stu-id="1e955-273">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="1e955-274">以零為起始的陣列，這相當於其<xref:System.Array.Length%2A>屬性，或大於所傳回的值的其中一個<xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-274">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1e955-275">隨機，下列範例會擷取在美國境內的城市名稱從陣列的城市。</span><span class="sxs-lookup"><span data-stu-id="1e955-275">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="1e955-276">擷取陣列或集合的唯一項目</span><span class="sxs-lookup"><span data-stu-id="1e955-276">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="1e955-277">亂數產生器一律會傳回重複的值。</span><span class="sxs-lookup"><span data-stu-id="1e955-277">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="1e955-278">當數字範圍變得比較小，或產生的值數目變得更大，重複的可能性就會成長。</span><span class="sxs-lookup"><span data-stu-id="1e955-278">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="1e955-279">如果隨機的值必須是唯一的更多的數字會產生補償重複項目，導致越來越不佳的效能。</span><span class="sxs-lookup"><span data-stu-id="1e955-279">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="1e955-280">有幾個方法來處理這種情況。</span><span class="sxs-lookup"><span data-stu-id="1e955-280">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="1e955-281">一個常用的解決方案是建立陣列或集合，其中包含要擷取的值和平行的陣列，其中包含隨機浮點數。</span><span class="sxs-lookup"><span data-stu-id="1e955-281">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="1e955-282">第二個陣列，會在建立第一個陣列時，填入與隨機數字和<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>方法用來排序第一個陣列所使用的平行陣列中的值。</span><span class="sxs-lookup"><span data-stu-id="1e955-282">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="1e955-283">比方說，如果您正在開發的單人遊戲，您會想要確保每張卡片只有使用一次。</span><span class="sxs-lookup"><span data-stu-id="1e955-283">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="1e955-284">而不是產生隨機數字，以擷取卡片和追蹤是否已處理該卡片，您可以建立可用來排序的牌堆的隨機數字的平行陣列。</span><span class="sxs-lookup"><span data-stu-id="1e955-284">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="1e955-285">一旦已排序的投影片，您的應用程式可以維護的指標，表示下一張牌，投影片上的索引。</span><span class="sxs-lookup"><span data-stu-id="1e955-285">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="1e955-286">下列範例將示範這個方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-286">The following example illustrates this approach.</span></span> <span data-ttu-id="1e955-287">它會定義`Card`類別，代表紙牌的以及`Dealer`處理隨機播放一疊紙牌的類別。</span><span class="sxs-lookup"><span data-stu-id="1e955-287">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="1e955-288">`Dealer`類別建構函式會填入這兩個陣列：`deck`陣列具有類別範圍，以及表示在牌堆; 和本機中的所有卡片`order`具有相同數目的項目與陣列`deck`陣列，而且會填入使用隨機產生<xref:System.Double>值。</span><span class="sxs-lookup"><span data-stu-id="1e955-288">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="1e955-289"><xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>接著會呼叫方法來排序`deck`中的值為基礎的陣列`order`陣列。</span><span class="sxs-lookup"><span data-stu-id="1e955-289">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="1e955-290">下列範例會建立單一的隨機號碼產生器並呼叫其<xref:System.Random.NextBytes%2A>， <xref:System.Random.Next%2A>，和<xref:System.Random.NextDouble%2A>方法來產生不同的範圍內的隨機數字的序列。</span><span class="sxs-lookup"><span data-stu-id="1e955-290">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="1e955-291">下列範例會產生隨機整數，它會做為索引來擷取陣列中的字串值。</span><span class="sxs-lookup"><span data-stu-id="1e955-291">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="1e955-292">在.NET Framework 1.0 和 1.1 中，類別的最小實作衍生自<see cref="T:System.Random" />需要覆寫<see cref="M:System.Random.Sample" />方法來定義新的或修改過的演算法來產生隨機數字。</span>
        <span class="sxs-lookup">
          <span data-stu-id="1e955-292">In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers.</span>
        </span>
        <span data-ttu-id="1e955-293">衍生的類別無法再仰賴的基底類別實作<see cref="M:System.Random.Next" />， <see cref="M:System.Random.Next(System.Int32)" />， <see cref="M:System.Random.Next(System.Int32,System.Int32)" />， <see cref="M:System.Random.NextBytes(System.Byte[])" />，並<see cref="M:System.Random.NextDouble" />方法來呼叫的衍生的類別實作<see cref="M:System.Random.Sample" />方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="1e955-293">The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span>
        </span>
        <span data-ttu-id="1e955-294">在.NET Framework 2.0 和更新版本的行為<see cref="M:System.Random.Next" />， <see cref="M:System.Random.Next(System.Int32,System.Int32)" />，並<see cref="M:System.Random.NextBytes(System.Byte[])" />方法已變更，以便讓這些方法不一定是呼叫的衍生的類別實作<see cref="M:System.Random.Sample" />方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="1e955-294">In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span>
        </span>
        <span data-ttu-id="1e955-295">如此一來，衍生自<see cref="T:System.Random" />的目標.NET Framework 2.0 和更新版本也會覆寫這三種方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="1e955-295">As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</span>
        </span>
      </para>
    </block>
    <block subset="none" type="usage">
      <para>
        <span data-ttu-id="1e955-296">亂數產生器中的實作<see cref="T:System.Random" />類別不保證維持不變的.NET framework 的主要版本。</span>
        <span class="sxs-lookup">
          <span data-stu-id="1e955-296">The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework.</span>
        </span>
        <span data-ttu-id="1e955-297">如此一來，您不應該假設相同的種子會導致不同版本的.NET Framework 中的相同虛擬隨機序列。</span>
        <span class="sxs-lookup">
          <span data-stu-id="1e955-297">As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</span>
        </span>
      </para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1e955-298">初始化 <see cref="T:System.Random" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-298">Initializes a new instance of the <see cref="T:System.Random" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1e955-299">使用時間相依預設種子值來初始化 <see cref="T:System.Random" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-299">Initializes a new instance of the <see cref="T:System.Random" /> class, using a time-dependent default seed value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-300">預設種子值衍生自系統時鐘，而且具有有限的解析度。</span><span class="sxs-lookup"><span data-stu-id="1e955-300">The default seed value is derived from the system clock and has finite resolution.</span></span> <span data-ttu-id="1e955-301">如此一來，不同<xref:System.Random>預設建構函式呼叫中連續建立的物件會都會有相同的預設種子值，並因此，會產生隨機數字的同一組。</span><span class="sxs-lookup"><span data-stu-id="1e955-301">As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</span></span> <span data-ttu-id="1e955-302">即可避免這個問題，請使用單一<xref:System.Random>物件來產生所有的隨機數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-302">This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="1e955-303">您也可以解決它修改系統時鐘所傳回的種子值，然後明確地提供這個新的初始值來<xref:System.Random.%23ctor%28System.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="1e955-303">You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="1e955-304">如需詳細資訊，請參閱<xref:System.Random.%23ctor%28System.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="1e955-304">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="1e955-305">如果您想要您亂數產生器來產生隨機數字序列，請呼叫這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="1e955-305">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="1e955-306">若要產生隨機數字，將會相同，不同的隨機數字產生器的固定的順序，請呼叫<xref:System.Random.%23ctor%28System.Int32%29>建構函式，以固定的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-306">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value .</span></span> <span data-ttu-id="1e955-307">這<xref:System.Random>測試使用隨機數字的應用程式時，經常會使用建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="1e955-307">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="1e955-308">一旦您已具現化之隨機號碼產生器，就呼叫個別<xref:System.Random>方法，例如<xref:System.Random.Next>或<xref:System.Random.NextDouble>，以產生隨機數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-308">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e955-309">下列範例會使用預設建構函式來具現化三個<xref:System.Random>物件，並顯示每個序列的五個隨機整數。</span><span class="sxs-lookup"><span data-stu-id="1e955-309">The following example uses the default constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="1e955-310">因為前兩個<xref:System.Random>關閉連續建立物件、 產生它們使用相同的種子值，根據系統時鐘和，因此，它們會產生隨機數字的相同順序。</span><span class="sxs-lookup"><span data-stu-id="1e955-310">Because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="1e955-311">另一方面，第三個預設建構函式<xref:System.Random>物件會呼叫後兩秒的延遲，藉由呼叫造成<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-311">On the other hand, the default constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1e955-312">因為這會產生第三個不同的種子值<xref:System.Random>物件，它會產生不同的隨機數字序列。</span><span class="sxs-lookup"><span data-stu-id="1e955-312">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">
          <span data-ttu-id="1e955-313">用來計算虛擬亂數序列起始值的數字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-313">A number used to calculate a starting value for the pseudo-random number sequence.</span>
          </span>
          <span data-ttu-id="1e955-314">如果指定了負數，則會採用數字的絕對值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-314">If a negative number is specified, the absolute value of the number is used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1e955-315">使用指定的種子值，初始化 <see cref="T:System.Random" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-315">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-316">提供在相同的種子值上方以不同<xref:System.Random>物件會導致產生的隨機數字的相同順序的每個執行個體。</span><span class="sxs-lookup"><span data-stu-id="1e955-316">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="1e955-317">這通常是測試依賴亂數產生器應用程式時。</span><span class="sxs-lookup"><span data-stu-id="1e955-317">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="1e955-318">如果您的應用程式需要不同的隨機數字序列，叫用這個建構函式重複使用不同的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-318">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="1e955-319">用來產生唯一的識別值種子值的一個方式是讓時間相依。</span><span class="sxs-lookup"><span data-stu-id="1e955-319">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="1e955-320">例如，從系統時鐘，做為衍生的種子值<xref:System.Random.%23ctor>未多載。</span><span class="sxs-lookup"><span data-stu-id="1e955-320">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="1e955-321">不過，系統時鐘可能沒有足夠的解析度，以提供不同的種子值不同的引動過程的這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="1e955-321">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="1e955-322">這會導致亂數產生器產生的似隨機的數字的相同順序的前兩個所示<xref:System.Random>在下列範例中的物件。</span><span class="sxs-lookup"><span data-stu-id="1e955-322">This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="1e955-323">若要避免這個問題，將套用演算法來區分每個引動過程或呼叫中的種子值<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法，以確保每個建構函式提供不同的種子值。</span><span class="sxs-lookup"><span data-stu-id="1e955-323">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="1e955-324">另一個選項是一個具現化<xref:System.Random>物件，您用來產生應用程式中的所有隨機的數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-324">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="1e955-325">這會產生稍微較佳的效能，因為具現化亂數產生器是相當耗費資源。</span><span class="sxs-lookup"><span data-stu-id="1e955-325">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e955-326">下列範例會建立<xref:System.Random>物件的類別建構函式會採用種子參數，並產生一串隨機整數和雙精度浮點數。</span><span class="sxs-lookup"><span data-stu-id="1e955-326">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="1e955-327">此範例說明的相同順序，會產生當<xref:System.Random>具有建構函式和種子參數重新建立物件。</span><span class="sxs-lookup"><span data-stu-id="1e955-327">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1e955-328">傳回隨機整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-328">Returns a random integer.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1e955-329">傳回非負值的隨機整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-329">Returns a non-negative random integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1e955-330">32 位元帶正負號的整數大於或等於 0，並且小於 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-330">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> 產生隨機的數字，其值的範圍是從 0 到小於<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="1e955-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1e955-332">若要產生隨機數字的值範圍從 0 到一些其他的正數，使用<xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="1e955-332">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="1e955-333">若要產生不同的範圍內的隨機數字，請使用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="1e955-333">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e955-334">下列範例會重複的呼叫<xref:System.Random.Next%2A>方法來產生特定數目的使用者所要求的隨機數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-334">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="1e955-335"><xref:System.Console.ReadLine%2A?displayProperty=nameWithType>方法用來取得客戶意見。</span><span class="sxs-lookup"><span data-stu-id="1e955-335">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="1e955-336">下列範例衍生的類別<xref:System.Random>若要從所產生統一分佈產生其發佈不同的隨機數字的序列<xref:System.Random.Sample%2A>基底類別的方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-336">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="1e955-337">它會覆寫<xref:System.Random.Sample%2A>方法，以提供的隨機數字，並且會覆寫分佈<xref:System.Random.Next%2A?displayProperty=nameWithType>方法，以使用一系列的隨機數字。</span><span class="sxs-lookup"><span data-stu-id="1e955-337">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="1e955-338">從.NET Framework 2.0 版中，如果您衍生的類別<see cref="T:System.Random" />，並覆寫<see cref="M:System.Random.Sample" />方法，藉由衍生的類別實作所提供的散發<see cref="M:System.Random.Sample" />方法不會在呼叫基底類別實作<see cref="M:System.Random.Next" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-338">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method.</span>
            </span>
            <span data-ttu-id="1e955-339">基底傳回統一分佈的相反地，<see cref="T:System.Random" />類別使用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-339">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span>
            </span>
            <span data-ttu-id="1e955-340">此行為可改善整體效能的<see cref="T:System.Random" />類別。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-340">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span>
            </span>
            <span data-ttu-id="1e955-341">若要修改此行為，以呼叫<see cref="M:System.Random.Sample" />方法在衍生類別中的，您也必須覆寫<see cref="M:System.Random.Next" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-341">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">
          <span data-ttu-id="1e955-342">要產生之亂數的獨佔上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-342">The exclusive upper bound of the random number to be generated.</span>
          </span>
          <span data-ttu-id="1e955-343">
            <paramref name="maxValue" /> 必須大於或等於 0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-343">
              <paramref name="maxValue" /> must be greater than or equal to 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1e955-344">傳回小於指定之最大值的非負值隨機整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-344">Returns a non-negative random integer that is less than the specified maximum.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1e955-345">32 位元帶正負號的整數大於或等於 0，並且小於 <paramref name="maxValue" />；也就是說，傳回值的範圍通常包含 0 但不包含 <paramref name="maxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-345">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span>
          </span>
          <span data-ttu-id="1e955-346">然而，如果 <paramref name="maxValue" /> 等於 0，則會傳回 <paramref name="maxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-346">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-347"><xref:System.Random.Next%28System.Int32%29>多載會傳回隨機整數，範圍從 0 到`maxValue`– 1。</span><span class="sxs-lookup"><span data-stu-id="1e955-347">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` – 1.</span></span> <span data-ttu-id="1e955-348">不過，如果`maxValue`是 0，則方法會傳回 0。</span><span class="sxs-lookup"><span data-stu-id="1e955-348">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e955-349">下列範例會產生隨機整數的各種多載<xref:System.Random.Next%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-349">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="1e955-350">下列範例會產生隨機整數，它會做為索引來擷取陣列中的字串值。</span><span class="sxs-lookup"><span data-stu-id="1e955-350">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="1e955-351">因為陣列的最高的索引是一個小於它的長度，值<xref:System.Array.Length%2A?displayProperty=nameWithType>屬性會提供為`maxValue`參數。</span><span class="sxs-lookup"><span data-stu-id="1e955-351">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1e955-352">
            <paramref name="maxValue" /> 小於 0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-352">
              <paramref name="maxValue" /> is less than 0.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">
          <span data-ttu-id="1e955-353">傳回亂數的內含下限 (Inclusive Lower Bound)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-353">The inclusive lower bound of the random number returned.</span>
          </span>
        </param>
        <param name="maxValue">
          <span data-ttu-id="1e955-354">傳回亂數的獨佔上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-354">The exclusive upper bound of the random number returned.</span>
          </span>
          <span data-ttu-id="1e955-355">
            <paramref name="maxValue" /> 必須大於或等於 <paramref name="minValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-355">
              <paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1e955-356">傳回指定範圍內的隨機整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-356">Returns a random integer that is within a specified range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1e955-357">32 位元帶正負號的整數大於或等於 <paramref name="minValue" />，並且小於 <paramref name="maxValue" />；也就是說，傳回值的範圍包含 <paramref name="minValue" /> 但不包含 <paramref name="maxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-357">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span>
          </span>
          <span data-ttu-id="1e955-358">如果 <paramref name="minValue" /> 等於 <paramref name="maxValue" />，會傳回 <paramref name="minValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-358">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-359"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>多載會傳回隨機整數範圍`minValue`到`maxValue`– 1。</span><span class="sxs-lookup"><span data-stu-id="1e955-359">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` – 1.</span></span> <span data-ttu-id="1e955-360">不過，如果`maxValue`equals `minValue`，則方法會傳回`minValue`。</span><span class="sxs-lookup"><span data-stu-id="1e955-360">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="1e955-361">不同的其他多載於<xref:System.Random.Next%2A>方法，這個方法會傳回只非負數的值，這個方法可以傳回負值的隨機整數。</span><span class="sxs-lookup"><span data-stu-id="1e955-361">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e955-362">下列範例會使用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法來產生隨機整數具有三個相異的範圍。</span><span class="sxs-lookup"><span data-stu-id="1e955-362">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="1e955-363">請注意，確切的輸出範例中，取決於傳遞至系統提供的種子值<xref:System.Random>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="1e955-363">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="1e955-364">下列範例會產生隨機整數，它會做為索引來擷取陣列中的字串值。</span><span class="sxs-lookup"><span data-stu-id="1e955-364">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="1e955-365">因為陣列的最高的索引是一個小於它的長度，值<xref:System.Array.Length%2A?displayProperty=nameWithType>屬性會提供為`maxValue`參數。</span><span class="sxs-lookup"><span data-stu-id="1e955-365">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1e955-366">
            <paramref name="minValue" /> 大於 <paramref name="maxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-366">
              <paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="1e955-367">從.NET Framework 2.0 版中，如果您衍生的類別<see cref="T:System.Random" />，並覆寫<see cref="M:System.Random.Sample" />方法，藉由衍生的類別實作所提供的散發<see cref="M:System.Random.Sample" />方法不會在呼叫基底類別實作<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法多載，如果之間的差異<paramref name="minValue" />並<paramref name="maxValue" />參數是否大於<see cref="F:System.Int32.MaxValue" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-367">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />.</span>
            </span>
            <span data-ttu-id="1e955-368">基底傳回統一分佈的相反地，<see cref="T:System.Random" />類別使用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-368">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span>
            </span>
            <span data-ttu-id="1e955-369">此行為可改善整體效能的<see cref="T:System.Random" />類別。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-369">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span>
            </span>
            <span data-ttu-id="1e955-370">若要修改此行為，以呼叫<see cref="M:System.Random.Sample" />方法在衍生類別中的，您也必須覆寫<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法多載。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-370">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="1e955-371">要包含亂數的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-371">An array of bytes to contain random numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1e955-372">以亂數填入指定位元組陣列的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-372">Fills the elements of a specified array of bytes with random numbers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-373">位元組陣列的每個項目設為隨機的數字大於或等於 0，且小於或等於<xref:System.Byte.MaxValue>。</span><span class="sxs-lookup"><span data-stu-id="1e955-373">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="1e955-374">比方說，若要產生的密碼編譯安全隨機數字適合用來建立隨機的密碼，使用方法這類<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="1e955-374">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e955-375">下列範例示範如何使用<xref:System.Random.NextBytes%2A>方法將填入隨機位元組值的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="1e955-375">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1e955-376">
            <paramref name="buffer" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-376">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="1e955-377">從.NET Framework 2.0 版中，如果您衍生的類別<see cref="T:System.Random" />，並覆寫<see cref="M:System.Random.Sample" />方法，藉由衍生的類別實作所提供的散發<see cref="M:System.Random.Sample" />方法不會在呼叫基底類別實作<see cref="M:System.Random.NextBytes(System.Byte[])" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-377">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span>
            </span>
            <span data-ttu-id="1e955-378">基底傳回統一分佈的相反地，<see cref="T:System.Random" />類別使用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-378">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span>
            </span>
            <span data-ttu-id="1e955-379">此行為可改善整體效能的<see cref="T:System.Random" />類別。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-379">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span>
            </span>
            <span data-ttu-id="1e955-380">若要修改此行為，以呼叫<see cref="M:System.Random.Sample" />方法在衍生類別中的，您也必須覆寫<see cref="M:System.Random.NextBytes(System.Byte[])" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-380">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1e955-381">傳回大於或等於 0.0，且小於 1.0 的隨機浮點數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-381">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1e955-382">雙精確度浮點數大於或等於 0.0，且小於 1.0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-382">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-383">這個方法所傳回之亂數的實際上限是 0.99999999999999978。</span><span class="sxs-lookup"><span data-stu-id="1e955-383">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="1e955-384">若要擷取以外介於 0.0 到 1.0 的範圍內的隨機浮點值，請參閱 「 擷取在指定範圍中的浮點值 」 一節<xref:System.Random>類別主題。</span><span class="sxs-lookup"><span data-stu-id="1e955-384">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="1e955-385">這個方法是公用版本的受保護的方法， <xref:System.Random.Sample%2A>。</span><span class="sxs-lookup"><span data-stu-id="1e955-385">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e955-386">下列範例會使用<xref:System.Random.NextDouble%2A>方法來產生隨機的雙精度浮點數的序列。</span><span class="sxs-lookup"><span data-stu-id="1e955-386">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="1e955-387">下列範例會呼叫<xref:System.Random.NextDouble%2A>方法來產生 100 個隨機數字，並顯示其頻率散發。</span><span class="sxs-lookup"><span data-stu-id="1e955-387">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1e955-388">傳回 0.0 和 1.0 之間的隨機浮點數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-388">Returns a random floating-point number between 0.0 and 1.0.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1e955-389">雙精確度浮點數大於或等於 0.0，且小於 1.0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="1e955-389">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e955-390">若要產生不同的隨機散發或不同隨機號碼產生器原則，衍生的類別<xref:System.Random>類別並覆寫<xref:System.Random.Sample%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-390">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1e955-391"><xref:System.Random.Sample%2A>方式`protected`，這表示它是只能在內存取<xref:System.Random>類別和其衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="1e955-391">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="1e955-392">若要產生隨機的數字，介於 0 和 1 之間<xref:System.Random>執行個體，呼叫<xref:System.Random.NextDouble%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-392">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e955-393">下列範例衍生的類別<xref:System.Random>且會覆寫<xref:System.Random.Sample%2A>方法來產生隨機數字的分佈。</span><span class="sxs-lookup"><span data-stu-id="1e955-393">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="1e955-394">這個分佈是不同於所產生統一分佈<xref:System.Random.Sample%2A>基底類別的方法。</span><span class="sxs-lookup"><span data-stu-id="1e955-394">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="1e955-395">從.NET Framework 2.0 版中，如果您衍生的類別<see cref="T:System.Random" />，並覆寫<see cref="M:System.Random.Sample" />方法，藉由衍生的類別實作所提供的散發<see cref="M:System.Random.Sample" />方法不會在呼叫基底類別實作下列方法：</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-395">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:</span>
            </span>
            <span data-ttu-id="1e955-396">-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> 方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-396">-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span>
            </span>
            <span data-ttu-id="1e955-397">-   <see cref="M:System.Random.Next" /> 方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-397">-   The <see cref="M:System.Random.Next" /> method.</span>
            </span>
            <span data-ttu-id="1e955-398">-<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法，如果 (<paramref name="maxValue" /> - <paramref name="minValue" />) 大於<see cref="F:System.Int32.MaxValue" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-398">-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.</span>
            </span>
            <span data-ttu-id="1e955-399">相反地，統一分佈所提供的基底<see cref="T:System.Random" />類別使用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-399">Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used.</span>
            </span>
            <span data-ttu-id="1e955-400">此行為可改善整體效能的<see cref="T:System.Random" />類別。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-400">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span>
            </span>
            <span data-ttu-id="1e955-401">若要修改此行為，以呼叫實作<see cref="M:System.Random.Sample" />方法在衍生類別中，您也必須覆寫這些三個成員的行為。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-401">To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members.</span>
            </span>
            <span data-ttu-id="1e955-402">這個範例將提供說明。</span>
            <span class="sxs-lookup">
              <span data-stu-id="1e955-402">The example provides an illustration.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>