<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5a9ab5223f061610781d60d0586c407114bafe65" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39766015" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示虛擬亂數產生器，為產生數字序列的裝置，符合隨機方式的特定統計需求。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虛擬隨機數字是從一組有限的數字選擇相等的可能性。 選取的數字不是完全隨機的因為會使用數學演算法來選取它們，但它們實際上是夠隨機。 目前的實作<xref:System.Random>類別根據 Donald E.Knuth 的涉及刪減亂數產生器演算法的修改版本。 如需詳細資訊，請參閱 < D.e。 Knuth。 *電腦程式設計，磁碟區 2 的藝術： Seminumerical 演算法*。 Addison-wesley，讀取拼湊的麻薩諸塞州，第三個版本，1997年。  
  
 若要產生的密碼編譯安全隨機數字，例如另一個則是適合用來建立隨機的密碼，使用<xref:System.Security.Cryptography.RNGCryptoServiceProvider>類別或衍生的類別<xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>。  
  
 本主題內容：  
  
 [具現化之隨機號碼產生器](#Instantiate)   
 [避免多個具現化](#Multiple)   
 [System.Random 類別和執行緒安全](#ThreadSafety)   
 [產生不同類型的隨機數字](#Functionality)   
 [取代您自己的演算法](#Overriding)   
 [您要如何使用以 System.Random...](#Operations)   
 [擷取相同的隨機值序列](#Same)  
 [擷取隨機值的唯一的序列](#Unique)  
 [擷取指定範圍內的整數](#Range)  
 [擷取具有指定位數的整數](#Digits)  
 [擷取指定範圍中的浮點值](#Floats)  
 [產生隨機的布林值](#Boolean)  
 [產生隨機的 64 位元整數](#Long)  
 [擷取指定範圍內的位元組](#Bytes)  
 [從陣列或集合中隨機擷取項目](#Array)  
 [擷取陣列或集合的唯一項目](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>具現化之隨機號碼產生器  
 您具現化之隨機號碼產生器所提供的種子值 （虛擬亂數產生演算法的起始值） 來<xref:System.Random.%23ctor%2A>類別建構函式。  您可以在明確或隱含提供的種子值：  
  
-   <xref:System.Random.%23ctor%28System.Int32%29>建構函式會使用您提供明確的種子值。  
  
-   <xref:System.Random.%23ctor>建構函式會使用系統時鐘來提供的種子值。 這是最常見的方法具現化之隨機號碼產生器。  
  
 如果相同的種子用於個別<xref:System.Random>物件，則會產生隨機數字的數列相同。 這可以是用來建立測試套件，以處理隨機值，或重新執行其資料源自隨機數字的遊戲。 但請注意，<xref:System.Random>不同版本的.NET Framework 下執行的處理序中的物件可能會傳回不同系列的隨機數字，即使它們具現化具有相同的種子值。  
  
 若要產生隨機數字的不同時序，您可以進行的種子值時間而異，因而產生不同的系列的每個新執行個體<xref:System.Random>。 參數化<xref:System.Random.%23ctor%28System.Int32%29>建構函式可以採用<xref:System.Int32>值根據刻度數，在目前的時間，而無參數<xref:System.Random.%23ctor>建構函式會使用系統時鐘來產生其種子值。 不過，因為時鐘的解析度有限，使用無參數建構函式來建立不同<xref:System.Random>中連續物件建立亂數產生器產生的隨機數字的相同順序。 下列範例說明如何在兩個<xref:System.Random>關閉連續具現化的物件產生相同的系列的隨機數字。 在大多數的 Windows 系統<xref:System.Random>中 15 毫秒的另一個建立的物件可能會有相同的種子值。  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 若要避免這個問題，建立單一<xref:System.Random>而不是多個物件的物件。  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>避免多個具現化  
 初始化兩個亂數產生器在緊密迴圈中，或快速地連續建立兩個亂數產生器可能會產生相同的隨機數字的序列。 在大部分情況下，這不是開發人員的意圖，並可能會導致效能問題，因為具現化並初始化亂數產生器是相當耗成本的程序。  
  
 同時以改善效能並避免不小心建立個別的亂數產生器，產生相同的數字序列，我們建議您建立一個<xref:System.Random>物件來產生許多隨機的數字一段時間，而不是建立新<xref:System.Random>產生一個隨機數字的物件。  
  
 不過，<xref:System.Random>類別不具備執行緒安全。 如果您呼叫<xref:System.Random>方法，從多個執行緒，請遵循下一節所述的指導方針。  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System.Random 類別和執行緒安全  
 而不是具現化的個別<xref:System.Random>物件，我們建議您建立單一<xref:System.Random>產生應用程式所需的所有隨機數字的執行個體。 不過，<xref:System.Random>物件不是安全執行緒。 如果您的應用程式呼叫<xref:System.Random>從多個執行緒的方法，您必須使用同步物件來確保只有一個執行緒可以存取一次的亂數產生器。 如果您不確定<xref:System.Random>執行緒安全的方式存取物件時，會傳回隨機數字的方法呼叫會傳回 0。  
  
 下列範例會使用 C# [lock 陳述式](~/docs/csharp/language-reference/keywords/lock-statement.md)和 Visual Basic [SyncLock 陳述式](~/docs/visual-basic/language-reference/statements/synclock-statement.md)確保單一亂數產生器的 11 個執行緒存取具備執行緒安全的方式。 每個執行緒會產生 2 百萬個隨機數字、 計算產生的隨機數字的數目和計算其總和，並完成執行時，然後更新所有執行緒的總計。  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 範例會確保執行緒安全性，以下列方式：  
  
-   <xref:System.ThreadStaticAttribute>屬性用來定義執行緒區域變數，可追蹤產生的隨機數字和其總和的每個執行緒的總數。  
  
-   鎖定 ( `lock` C# 中的陳述式和`SyncLock`Visual Basic 中的陳述式) 可保護變數的存取權的總計數和所有產生的所有執行緒上的隨機數字的總和。  
  
-   號誌 (<xref:System.Threading.CountdownEvent>物件) 用來確保主要執行緒會封鎖直到所有其他執行緒完成執行。  
  
-   此範例會檢查是否隨機號碼產生器已損毀藉由判斷是否要隨機數字產生方法的兩個連續呼叫會傳回 0。 如果偵測到損毀時，此範例會使用<xref:System.Threading.CancellationTokenSource>發出信號，表示應該取消所有執行緒的物件。  
  
-   才會產生每個隨機數字，每個執行緒檢查狀態<xref:System.Threading.CancellationToken>物件。 如果要求取消，則此範例會呼叫<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法來取消執行緒。  
  
 下列範例等同於第一天，不同之處在於它會使用<xref:System.Threading.Tasks.Task>物件，而不是 lambda 運算式<xref:System.Threading.Thread>物件。  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 不同於第一個範例如下：  
  
-   這樣就不需要使用變數來追蹤產生的隨機數字的數目，以及每個工作中的其總和都是本機工作，<xref:System.ThreadStaticAttribute>屬性。  
  
-   靜態<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法用來確保不會完成主執行緒，才能完成所有工作。 不需要針對<xref:System.Threading.CountdownEvent>物件。  
  
-   所產生的工作取消的例外狀況會顯示在<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法。 在上述範例中，它是由每個執行緒處理。  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>產生不同類型的隨機數字  
 亂數產生器會提供方法，讓您產生下列類型的隨機數字：  
  
-   一系列的<xref:System.Byte>值。 您傳遞陣列初始化為您想要返回方法的項目數目來判斷位元組值的數目<xref:System.Random.NextBytes%2A>方法。 下列範例會產生 20 個位元組。  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   單一的整數。 您可以選擇是否要從 0 到最大值的整數 (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) 藉由呼叫<xref:System.Random.Next>方法中，整數介於 0 到特定的值，藉由呼叫<xref:System.Random.Next%28System.Int32%29>方法或藉由呼叫值的範圍內的整數<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法。 參數化的多載，在指定的最大值是獨佔;也就是說，產生的實際數目上限是其中一個指定的值大於或等於。  
  
     下列範例會呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，以產生 10 個隨機數字，介於-10 到 10 之間。 請注意，此方法的第二個引數指定範圍的方法所傳回的隨機值的獨佔上限。 換句話說，這個方法會傳回一個的最大整數低於此數的值。  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   從 0.0 到小於 1.0 藉由呼叫的單一浮點值<xref:System.Random.NextDouble%2A>方法。 方法所傳回之亂數的獨佔上限會是 1，所以它實際的上限是 0.99999999999999978。 下列範例會產生 10 個隨機浮點數。  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法可讓您指定傳回的隨機數字的範圍。 不過，`maxValue`參數，指定較高的範圍傳回數字，其是獨佔，不含值。 這表示在方法呼叫`Next(0, 100)`傳回值，介於 0 到 99，並不是介於 0 到 100 之間。  
  
 您也可以使用<xref:System.Random>這類工作產生的類別[隨機 t: system.boolean< 值](#Boolean)、 產生[值範圍以外的 0 到 1 的隨機浮點數](#Floats)，產生[隨機的 64 位元整數](#Long)，並[隨機從陣列或集合中擷取的唯一項目](#UniqueArray)。 如需這些和其他一般工作，請參閱[您該如何使用以 System.Random...](#Operations) 一節。  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>取代您自己的演算法  
 您可以藉由繼承自實作您自己亂數產生器<xref:System.Random>類別，並提供您亂數產生演算法。 若要提供您自己的演算法，您必須覆寫<xref:System.Random.Sample%2A>方法，它會實作隨機的數字產生演算法。 您也應該覆寫<xref:System.Random.Next>， <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>，並<xref:System.Random.NextBytes%2A>方法，以確保它們呼叫覆寫<xref:System.Random.Sample%2A>方法。 您不需要覆寫<xref:System.Random.Next%28System.Int32%29>和<xref:System.Random.NextDouble%2A>方法。  
  
 如需範例衍生自<xref:System.Random>類別，並修改其預設虛擬亂數產生器，請參閱<xref:System.Random.Sample%2A>參考頁面。  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>您要如何使用以 System.Random...  
 下列各節討論，並提供一些您可能想要使用應用程式中的隨機數字的方式的範例程式碼。  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>擷取相同的隨機值序列  
 有時您想要在軟體測試案例和遊戲播放產生相同的隨機數字序列。 使用相同的隨機數字順序進行測試，可讓您偵測迴歸，並確認 bug 修正。 在遊戲中使用相同的隨機數字序列，可讓您重新執行先前的遊戲。  
  
 您可以藉由提供相同的初始值，以產生相同的隨機數字序列<xref:System.Random.%23ctor%28System.Int32%29>建構函式。 種子值提供的虛擬隨機的數字產生演算法的起始值。 下列範例使用為任意的種子值來具現化 100100<xref:System.Random>物件，會顯示 20 個隨機浮點值，並保存的種子值。 然後將還原的種子值，會具現化新的隨機數字產生器，並會顯示相同的 20 個隨機浮點值。  請注意此範例可能會產生隨機數字的不同時序，是否在不同版本的.NET Framework 上執行。  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>擷取隨機數字的唯一的序列  
 提供的執行個體的不同的種子值<xref:System.Random>類別會導致每個亂數產生器來產生不同的一連串的值。 您可以明確地呼叫其中一個提供初始值<xref:System.Random.%23ctor%28System.Int32%29>建構函式，或以隱含方式呼叫<xref:System.Random.%23ctor>建構函式。 大部分的開發人員呼叫無參數建構函式，它會使用系統時鐘。 下列範例會使用這種方法來具現化兩個<xref:System.Random>執行個體。 每個執行個體顯示一系列的 10 個隨機整數。  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 不過，因為其有限的解析度，而系統時鐘偵測不到大約少於 15 毫秒的時間差異。 因此，如果您的程式碼會呼叫<xref:System.Random.%23ctor>具現化兩個多載<xref:System.Random>物件連續，您可能會不小心提供的物件具有相同的種子值。 若要查看這在上述範例中，標記為註解<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法呼叫，並編譯和執行一次的範例。  
  
 若要避免這種情況，我們建議您具現化一個<xref:System.Random>物件而不是多個項目。 不過，由於<xref:System.Random>不具備執行緒安全，您必須使用一些同步處理的裝置，如果您存取<xref:System.Random>執行個體從多個執行緒; 如需詳細資訊，請參閱[隨機的類別和執行緒安全](#ThreadSafety)稍早在此主題。 或者，您可以使用延遲機制，例如<xref:System.Threading.Thread.Sleep%2A>方法在先前範例中，用以確保具現化不會發生相差超過 15 毫秒。  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>擷取指定範圍內的整數  
 您可以呼叫來擷取指定範圍內的整數<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，可讓您指定下限和上限，您想要傳回之隨機號碼產生器的數字。 上限是獨佔，不含值。 也就是說，它不包含範圍內的方法所傳回的值。 下列範例會使用這個方法來產生介於-10 到 10 之間的隨機整數。 請注意，它指定 11 中，這是一必須大於想要的值，做為值的`maxValue`方法呼叫中的引數。  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>擷取具有指定位數的整數  
 您可以呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法來擷取具有指定位數的數字。 例如，若要擷取具有四個位數 （也就是數字，範圍從 1000年到 9999） 的數字，您呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法`minValue`1000年的值和`maxValue`10000，如下列範例所示的值。  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>擷取指定範圍中的浮點值  
 <xref:System.Random.NextDouble%2A>方法會傳回隨機浮點數的值範圍從 0 到小於 1。 不過，您通常會想要在其他範圍內產生隨機值。  
  
 如果需要最小和最大的值之間的間隔為 1 時，您可以新增想要的啟動間隔與 0 之間的差異所傳回的數字<xref:System.Random.NextDouble%2A>方法。 下列範例會產生 10 個隨機數字，介於-1 和 0。  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 若要產生隨機浮點數，其下限為 0，但上限大於 1 （或，如果是負數，其下限為小於-1，上限為 0），乘以非零繫結中的隨機數字。 下列範例會產生 20 萬個隨機浮點數的數字範圍從 0 到<xref:System.Int64.MaxValue?displayProperty=nameWithType>。 中也會顯示方法所產生的隨機值的分佈。  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 若要產生兩個的任意值之間的隨機浮點數，例如<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法會為整數，請使用下列公式：  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 下列範例會產生 1 百萬個亂數的範圍則是從 10.0 為 11.0，並顯示其散發。  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>產生隨機的布林值  
 <xref:System.Random>類別不提供方法，可產生<xref:System.Boolean>值。 不過，您可以定義自己的類別或方法，若要這麼做。 下列範例會定義類別`BooleanGenerator`，具有單一方法， `NextBoolean`。 `BooleanGenerator`類別存放區<xref:System.Random>物件做為私用變數。 `NextBoolean`方法呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，並將結果傳遞<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType>方法。 請注意，2 做為引數用來指定隨機數字上限。 由於這是獨佔的值，則方法呼叫會傳回 0 或 1。  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 而不是建立個別的類別，來產生隨機<xref:System.Boolean>值，此範例可能只是定義單一方法。 在此情況下，不過，<xref:System.Random>物件應該已定義為類別層級變數，以避免具現化新<xref:System.Random>中每個方法呼叫的執行個體。 在 Visual Basic 中的 Random 執行個體可以定義為[靜態](~/docs/visual-basic/language-reference/modifiers/static.md)變數中`NextBoolean`方法。  下列範例提供的實作。  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>產生隨機的 64 位元整數  
 多載<xref:System.Random.Next%2A>方法會傳回 32 位元整數。 不過，在某些情況下，您可能想要使用 64 位元整數。 您可以依照下列方式來執行這項操作：  
  
1.  呼叫<xref:System.Random.NextDouble%2A>方法來擷取雙精確度浮點數的值。  
  
2.  將由該值乘以<xref:System.Int64.MaxValue?displayProperty=nameWithType>。  
  
 下列範例會產生 20 萬個隨機的長整數使用這項技術，並將它們分類中 10 個相等的群組。 它接著會評估分佈的隨機數字，來計算從 0 到每個群組中的數字<xref:System.Int64.MaxValue?displayProperty=nameWithType>。 如範例輸出所示，數字會增加或減少平均分散整個長整數的範圍。  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 替代方法，會使用位元操作不會產生真正的隨機數字。 這項技術會呼叫<xref:System.Random.Next>來產生兩個整數、 左移一個由 32 位元為單位和 Or 在一起。 這項技術有兩項限制：  
  
1.  位元 31 為正負號位元，因為產生的長整數的位元 31 中的值一律是 0。  這可藉由產生隨機的 0 或 1，向左移位它 31 位元為單位，並搭配使用 or 與它與原始的隨機長整數。  
  
2.  更嚴重，因為所傳回的值的機率<xref:System.Random.Next>將會是 0，如果有的話，將幾個隨機數字會出在範圍內 0x0 0x00000000FFFFFFFF。  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>擷取指定範圍內的位元組  
 多載<xref:System.Random.Next%2A>方法可讓您指定的隨機數字，範圍但<xref:System.Random.NextBytes%2A>方法則否。 下列範例會實作`NextBytes`方法，可讓您指定的傳回的位元組範圍。 它會定義`Random2`類別衍生自<xref:System.Random>並且可以多載其`NextBytes`方法。  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)`方法會包裝對<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法並指定最小值和一個大於最大值 (在此情況下，0 到 101) 我們要傳回的位元組陣列中。 因為我們已經確定所傳回的整數值<xref:System.Random.Next%2A>方法會在範圍內<xref:System.Byte>資料型別，我們可以安全地將參數轉換 （在 C# 中) 或將它們 （在 Visual Basic 中) 從整數轉換為位元組。  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>從陣列或集合中隨機擷取項目  
 隨機數字通常會做為索引來擷取陣列或集合中的值。 若要擷取的隨機的索引值，您可以呼叫<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，並使用較低的陣列繫結的值為其`minValue`引數和大於上限的值陣列的其中一個其`maxValue`引數。 以零為起始的陣列，這相當於其<xref:System.Array.Length%2A>屬性，或大於所傳回的值的其中一個<xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>方法。 隨機，下列範例會擷取在美國境內的城市名稱從陣列的城市。  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>擷取陣列或集合的唯一項目  
 亂數產生器一律會傳回重複的值。 當數字範圍變得比較小，或產生的值數目變得更大，重複的可能性就會成長。 如果隨機的值必須是唯一的更多的數字會產生補償重複項目，導致越來越不佳的效能。  
  
 有幾個方法來處理這種情況。 一個常用的解決方案是建立陣列或集合，其中包含要擷取的值和平行的陣列，其中包含隨機浮點數。 第二個陣列，會在建立第一個陣列時，填入與隨機數字和<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>方法用來排序第一個陣列所使用的平行陣列中的值。  
  
 比方說，如果您正在開發的單人遊戲，您會想要確保每張卡片只有使用一次。 而不是產生隨機數字，以擷取卡片和追蹤是否已處理該卡片，您可以建立可用來排序的牌堆的隨機數字的平行陣列。 一旦已排序的投影片，您的應用程式可以維護的指標，表示下一張牌，投影片上的索引。  
  
 下列範例將示範這個方法。 它會定義`Card`類別，代表紙牌的以及`Dealer`處理隨機播放一疊紙牌的類別。 `Dealer`類別建構函式會填入這兩個陣列：`deck`陣列具有類別範圍，以及表示在牌堆; 和本機中的所有卡片`order`具有相同數目的項目與陣列`deck`陣列，而且會填入使用隨機產生<xref:System.Double>值。  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>接著會呼叫方法來排序`deck`中的值為基礎的陣列`order`陣列。  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 下列範例會建立單一的隨機號碼產生器並呼叫其<xref:System.Random.NextBytes%2A>， <xref:System.Random.Next%2A>，和<xref:System.Random.NextDouble%2A>方法來產生不同的範圍內的隨機數字的序列。  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 下列範例會產生隨機整數，它會做為索引來擷取陣列中的字串值。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>在.NET Framework 1.0 和 1.1 中，類別的最小實作衍生自<see cref="T:System.Random" />需要覆寫<see cref="M:System.Random.Sample" />方法來定義新的或修改過的演算法來產生隨機數字。衍生的類別無法再仰賴的基底類別實作<see cref="M:System.Random.Next" />， <see cref="M:System.Random.Next(System.Int32)" />， <see cref="M:System.Random.Next(System.Int32,System.Int32)" />， <see cref="M:System.Random.NextBytes(System.Byte[])" />，並<see cref="M:System.Random.NextDouble" />方法來呼叫的衍生的類別實作<see cref="M:System.Random.Sample" />方法。在.NET Framework 2.0 和更新版本的行為<see cref="M:System.Random.Next" />， <see cref="M:System.Random.Next(System.Int32,System.Int32)" />，並<see cref="M:System.Random.NextBytes(System.Byte[])" />方法已變更，以便讓這些方法不一定是呼叫的衍生的類別實作<see cref="M:System.Random.Sample" />方法。如此一來，衍生自<see cref="T:System.Random" />的目標.NET Framework 2.0 和更新版本也會覆寫這三種方法。</para>
    </block>
    <block subset="none" type="usage">
      <para>亂數產生器中的實作<see cref="T:System.Random" />類別不保證維持不變的.NET framework 的主要版本。如此一來，您不應該假設相同的種子會導致不同版本的.NET Framework 中的相同虛擬隨機序列。</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Random" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用時間相依預設種子值來初始化 <see cref="T:System.Random" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設種子值衍生自系統時鐘，而且具有有限的解析度。 如此一來，不同<xref:System.Random>預設建構函式呼叫中連續建立的物件會都會有相同的預設種子值，並因此，會產生隨機數字的同一組。 即可避免這個問題，請使用單一<xref:System.Random>物件來產生所有的隨機數字。 您也可以解決它修改系統時鐘所傳回的種子值，然後明確地提供這個新的初始值來<xref:System.Random.%23ctor%28System.Int32%29>建構函式。 如需詳細資訊，請參閱<xref:System.Random.%23ctor%28System.Int32%29>建構函式。  
  
 如果您想要您亂數產生器來產生隨機數字序列，請呼叫這個建構函式。 若要產生隨機數字，將會相同，不同的隨機數字產生器的固定的順序，請呼叫<xref:System.Random.%23ctor%28System.Int32%29>建構函式，以固定的種子值。 這<xref:System.Random>測試使用隨機數字的應用程式時，經常會使用建構函式多載。  
  
 一旦您已具現化之隨機號碼產生器，就呼叫個別<xref:System.Random>方法，例如<xref:System.Random.Next>或<xref:System.Random.NextDouble>，以產生隨機數字。  
  
   
  
## Examples  
 下列範例會使用預設建構函式來具現化三個<xref:System.Random>物件，並顯示每個序列的五個隨機整數。 因為前兩個<xref:System.Random>關閉連續建立物件、 產生它們使用相同的種子值，根據系統時鐘和，因此，它們會產生隨機數字的相同順序。 另一方面，第三個預設建構函式<xref:System.Random>物件會呼叫後兩秒的延遲，藉由呼叫造成<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法。 因為這會產生第三個不同的種子值<xref:System.Random>物件，它會產生不同的隨機數字序列。  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">用來計算虛擬亂數序列起始值的數字。 如果指定了負數，則會採用數字的絕對值。</param>
        <summary>使用指定的種子值，初始化 <see cref="T:System.Random" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供在相同的種子值上方以不同<xref:System.Random>物件會導致產生的隨機數字的相同順序的每個執行個體。 這通常是測試依賴亂數產生器應用程式時。  
  
 如果您的應用程式需要不同的隨機數字序列，叫用這個建構函式重複使用不同的種子值。 用來產生唯一的識別值種子值的一個方式是讓時間相依。 例如，從系統時鐘，做為衍生的種子值<xref:System.Random.%23ctor>未多載。 不過，系統時鐘可能沒有足夠的解析度，以提供不同的種子值不同的引動過程的這個建構函式。 這會導致亂數產生器產生的似隨機的數字的相同順序的前兩個所示<xref:System.Random>在下列範例中的物件。 若要避免這個問題，將套用演算法來區分每個引動過程或呼叫中的種子值<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法，以確保每個建構函式提供不同的種子值。  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 另一個選項是一個具現化<xref:System.Random>物件，您用來產生應用程式中的所有隨機的數字。 這會產生稍微較佳的效能，因為具現化亂數產生器是相當耗費資源。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Random>物件的類別建構函式會採用種子參數，並產生一串隨機整數和雙精度浮點數。 此範例說明的相同順序，會產生當<xref:System.Random>具有建構函式和種子參數重新建立物件。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回隨機整數。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回非負值的隨機整數。</summary>
        <returns>32 位元帶正負號的整數大於或等於 0，並且小於 <see cref="F:System.Int32.MaxValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> 產生隨機的數字，其值的範圍是從 0 到小於<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 若要產生隨機數字的值範圍從 0 到一些其他的正數，使用<xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType>方法多載。 若要產生不同的範圍內的隨機數字，請使用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法多載。  
  
   
  
## Examples  
 下列範例會重複的呼叫<xref:System.Random.Next%2A>方法來產生特定數目的使用者所要求的隨機數字。 <xref:System.Console.ReadLine%2A?displayProperty=nameWithType>方法用來取得客戶意見。  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 下列範例衍生的類別<xref:System.Random>若要從所產生統一分佈產生其發佈不同的隨機數字的序列<xref:System.Random.Sample%2A>基底類別的方法。 它會覆寫<xref:System.Random.Sample%2A>方法，以提供的隨機數字，並且會覆寫分佈<xref:System.Random.Next%2A?displayProperty=nameWithType>方法，以使用一系列的隨機數字。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>從.NET Framework 2.0 版中，如果您衍生的類別<see cref="T:System.Random" />，並覆寫<see cref="M:System.Random.Sample" />方法，藉由衍生的類別實作所提供的散發<see cref="M:System.Random.Sample" />方法不會在呼叫基底類別實作<see cref="M:System.Random.Next" />方法。基底傳回統一分佈的相反地，<see cref="T:System.Random" />類別使用。此行為可改善整體效能的<see cref="T:System.Random" />類別。若要修改此行為，以呼叫<see cref="M:System.Random.Sample" />方法在衍生類別中的，您也必須覆寫<see cref="M:System.Random.Next" />方法。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">要產生之亂數的獨佔上限。 <c>maxValue</c> 必須大於或等於 0。</param>
        <summary>傳回小於指定之最大值的非負值隨機整數。</summary>
        <returns>32 位元帶正負號的整數大於或等於 0，並且小於 <paramref name="maxValue" />；也就是說，傳回值的範圍通常包含 0 但不包含 <paramref name="maxValue" />。 然而，如果 <paramref name="maxValue" /> 等於 0，則會傳回 <paramref name="maxValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29>多載會傳回隨機整數，範圍從 0 到`maxValue`– 1。 不過，如果`maxValue`是 0，則方法會傳回 0。  
  
   
  
## Examples  
 下列範例會產生隨機整數的各種多載<xref:System.Random.Next%2A>方法。  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 下列範例會產生隨機整數，它會做為索引來擷取陣列中的字串值。 因為陣列的最高的索引是一個小於它的長度，值<xref:System.Array.Length%2A?displayProperty=nameWithType>屬性會提供為`maxValue`參數。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> 小於 0。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">傳回亂數的內含下限 (Inclusive Lower Bound)。</param>
        <param name="maxValue">傳回亂數的獨佔上限。 <c>maxValue</c> 必須大於或等於 <c>minValue</c>。</param>
        <summary>傳回指定範圍內的隨機整數。</summary>
        <returns>32 位元帶正負號的整數大於或等於 <paramref name="minValue" />，並且小於 <paramref name="maxValue" />；也就是說，傳回值的範圍包含 <paramref name="minValue" /> 但不包含 <paramref name="maxValue" />。 如果 <paramref name="minValue" /> 等於 <paramref name="maxValue" />，會傳回 <paramref name="minValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>多載會傳回隨機整數範圍`minValue`到`maxValue`– 1。 不過，如果`maxValue`equals `minValue`，則方法會傳回`minValue`。  
  
 不同的其他多載於<xref:System.Random.Next%2A>方法，這個方法會傳回只非負數的值，這個方法可以傳回負值的隨機整數。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法來產生隨機整數具有三個相異的範圍。 請注意，確切的輸出範例中，取決於傳遞至系統提供的種子值<xref:System.Random>類別建構函式。  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 下列範例會產生隨機整數，它會做為索引來擷取陣列中的字串值。 因為陣列的最高的索引是一個小於它的長度，值<xref:System.Array.Length%2A?displayProperty=nameWithType>屬性會提供為`maxValue`參數。  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> 大於 <paramref name="maxValue" />。</exception>
        <block subset="none" type="overrides">
          <para>從.NET Framework 2.0 版中，如果您衍生的類別<see cref="T:System.Random" />，並覆寫<see cref="M:System.Random.Sample" />方法，藉由衍生的類別實作所提供的散發<see cref="M:System.Random.Sample" />方法不會在呼叫基底類別實作<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法多載，如果之間的差異<paramref name="minValue" />並<paramref name="maxValue" />參數是否大於<see cref="F:System.Int32.MaxValue" />。基底傳回統一分佈的相反地，<see cref="T:System.Random" />類別使用。此行為可改善整體效能的<see cref="T:System.Random" />類別。若要修改此行為，以呼叫<see cref="M:System.Random.Sample" />方法在衍生類別中的，您也必須覆寫<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法多載。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">要包含亂數的位元組陣列。</param>
        <summary>以亂數填入指定位元組陣列的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 位元組陣列的每個項目設為隨機的數字大於或等於 0，且小於或等於<xref:System.Byte.MaxValue>。  
  
 比方說，若要產生的密碼編譯安全隨機數字適合用來建立隨機的密碼，使用方法這類<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Random.NextBytes%2A>方法將填入隨機位元組值的位元組陣列。  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>從.NET Framework 2.0 版中，如果您衍生的類別<see cref="T:System.Random" />，並覆寫<see cref="M:System.Random.Sample" />方法，藉由衍生的類別實作所提供的散發<see cref="M:System.Random.Sample" />方法不會在呼叫基底類別實作<see cref="M:System.Random.NextBytes(System.Byte[])" />方法。基底傳回統一分佈的相反地，<see cref="T:System.Random" />類別使用。此行為可改善整體效能的<see cref="T:System.Random" />類別。若要修改此行為，以呼叫<see cref="M:System.Random.Sample" />方法在衍生類別中的，您也必須覆寫<see cref="M:System.Random.NextBytes(System.Byte[])" />方法。</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回大於或等於 0.0，且小於 1.0 的隨機浮點數。</summary>
        <returns>雙精確度浮點數大於或等於 0.0，且小於 1.0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法所傳回之亂數的實際上限是 0.99999999999999978。  
  
 若要擷取以外介於 0.0 到 1.0 的範圍內的隨機浮點值，請參閱 「 擷取在指定範圍中的浮點值 」 一節<xref:System.Random>類別主題。  
  
 這個方法是公用版本的受保護的方法， <xref:System.Random.Sample%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Random.NextDouble%2A>方法來產生隨機的雙精度浮點數的序列。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 下列範例會呼叫<xref:System.Random.NextDouble%2A>方法來產生 100 個隨機數字，並顯示其頻率散發。  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 0.0 和 1.0 之間的隨機浮點數。</summary>
        <returns>雙精確度浮點數大於或等於 0.0，且小於 1.0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要產生不同的隨機散發或不同隨機號碼產生器原則，衍生的類別<xref:System.Random>類別並覆寫<xref:System.Random.Sample%2A>方法。  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A>方式`protected`，這表示它是只能在內存取<xref:System.Random>類別和其衍生的類別。 若要產生隨機的數字，介於 0 和 1 之間<xref:System.Random>執行個體，呼叫<xref:System.Random.NextDouble%2A>方法。  
  
   
  
## Examples  
 下列範例衍生的類別<xref:System.Random>且會覆寫<xref:System.Random.Sample%2A>方法來產生隨機數字的分佈。 這個分佈是不同於所產生統一分佈<xref:System.Random.Sample%2A>基底類別的方法。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>從.NET Framework 2.0 版中，如果您衍生的類別<see cref="T:System.Random" />，並覆寫<see cref="M:System.Random.Sample" />方法，藉由衍生的類別實作所提供的散發<see cref="M:System.Random.Sample" />方法不會在呼叫基底類別實作下列方法之一:-<see cref="M:System.Random.NextBytes(System.Byte[])" />方法。 -<see cref="M:System.Random.Next" />方法。 -<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法，如果 (<paramref name="maxValue" /> - <paramref name="minValue" />) 大於<see cref="F:System.Int32.MaxValue" />。相反地，統一分佈所提供的基底<see cref="T:System.Random" />類別使用。此行為可改善整體效能的<see cref="T:System.Random" />類別。若要修改此行為，以呼叫實作<see cref="M:System.Random.Sample" />方法在衍生類別中，您也必須覆寫這些三個成員的行為。此範例將提供說明。</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>