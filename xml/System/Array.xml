<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f1e5542ce17228b81ac98e22af0444d4203ab07" />
    <Meta Name="ms.sourcegitcommit" Value="ad09e88f48ca55b181e8d272cfc3742eadc3f939" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/08/2018" />
    <Meta Name="ms.locfileid" Value="35231186" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供建立、管理、搜尋和排序陣列的方法，可在 Common Language Runtime 時做為所有陣列的基底類別。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>類別不是屬於<xref:System.Collections>命名空間。 不過，它仍然是集合因為它根據<xref:System.Collections.IList>介面。  
  
 <xref:System.Array>類別是支援陣列的語言實作的基底類別。 不過，只有系統和編譯器可以明確地從衍生<xref:System.Array>類別。 使用者應該使用的語言所提供的陣列建構。  
  
 項目是中的值<xref:System.Array>。 長度<xref:System.Array>是它可以包含的元素總數。 下限為<xref:System.Array>是其第一個元素的索引。 <xref:System.Array>可以有任何下限，但其下限為零的預設值。 建立的執行個體時，就可以定義其他下限<xref:System.Array>類別使用<xref:System.Array.CreateInstance%2A>。多維度<xref:System.Array>可以有不同的繫結，每個維度。 陣列可以有 32 個維度的最大值。  
  
 不同於在類別<xref:System.Collections>命名空間，<xref:System.Array>具有固定的容量。 若要增加容量，您必須建立新<xref:System.Array>物件具有所需容量，請複製項目從舊<xref:System.Array>物件到新的專案，並刪除舊<xref:System.Array>。  
  
 根據預設，最大<xref:System.Array>為 2 gb (GB)。 在 64 位元環境中，您可以避免大小限制，藉由設定`enabled`屬性[gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)組態項目`true`在執行階段環境中。 不過，陣列仍會限制為 4 10 億個項目的總計和 0X7FEFFFFF 中任何指定的維度 (0X7FFFFFC7 位元組陣列和陣列的單一位元組結構) 的最大索引。  
  
 一維陣列實作<xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>， <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>， <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>，<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>和<xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>泛型介面。 陣列中提供實作在執行階段，以及泛型介面如此一來，未出現在宣告語法<xref:System.Array>類別。 此外，還有介面的成員可存取只能透過將轉型為泛型介面型別 （明確介面實作） 的陣列沒有參考主題。 留意這些介面的其中一個陣列的轉換時的重點是成員的加入，請插入或移除項目 throw <xref:System.NotSupportedException>。  
  
 <xref:System.Type> 物件會提供資訊的陣列型別宣告。 <xref:System.Array> 具有相同的陣列型別的物件共用相同<xref:System.Type>物件。  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> 和<xref:System.Type.GetElementType%2A?displayProperty=nameWithType>可能不會傳回預期的結果與<xref:System.Array>因為如果陣列轉換成類型<xref:System.Array>，結果是一個物件，而非陣列。 也就是說，`typeof(System.Array).IsArray`傳回`false`，和`typeof(System.Array).GetElementType`傳回`null`。  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType>方法會複製項目相同的類型陣列之間的不只但不同類型的標準陣列之間; 它會處理類型會自動轉換。  
  
 某些方法，例如<xref:System.Array.CreateInstance%2A>， <xref:System.Array.Copy%2A>， <xref:System.Array.CopyTo%2A>， <xref:System.Array.GetValue%2A>，和<xref:System.Array.SetValue%2A>，提供多載，可接受參數，以容納陣列大容量為 64 位元整數。 <xref:System.Array.LongLength%2A> 和<xref:System.Array.GetLongLength%2A>傳回 64 位元整數，指出陣列的長度。  
  
 <xref:System.Array>不保證排序。  必須排序<xref:System.Array>之前執行的作業 (例如<xref:System.Array.BinarySearch%2A>) 需要的<xref:System.Array>來排序。  
  
 使用<xref:System.Array>的原生程式碼中的指標物件不支援，將會擲回<xref:System.NotSupportedException>數個方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.Array.Copy%2A?displayProperty=nameWithType>項目型別整數的陣列型別的陣列之間複製<xref:System.Object>。  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 下列程式碼範例會建立並初始化<xref:System.Array>，並顯示其屬性和其項目。  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公用靜態 (<see langword="Shared" />在 Visual Basic 中) 這種類型的成員都具備執行緒安全。 不保證任何執行個體成員是安全執行緒。  此實作不會提供同步處理 （安全執行緒） 包裝函式<see cref="T:System.Array" />; 不過，.NET Framework 類別根據<see cref="T:System.Array" />提供自己的集合的同步化的版本<see cref="P:System.Array.SyncRoot" />屬性。  透過集合進行列舉在本質上並非安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要在唯讀 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包裝函式中包裝的以零為起始的一維陣列。</param>
        <summary>傳回指定之陣列的唯讀包裝函式。</summary>
        <returns>指定之陣列的唯讀 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包裝函式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要避免陣列的任何修改，公開的陣列，只能透過這個包裝函式。  
  
 是唯讀的集合是唯讀的集合只具有可防止修改集合的包裝函式因此，如果基礎集合進行變更，唯讀的集合會反映這些變更。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列範例中的唯讀包裝陣列<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>。  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用二進位搜尋演算法，在一維且已排序的 <see cref="T:System.Array" /> 中搜尋值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋之已排序的一維 <see cref="T:System.Array" />。</param>
        <param name="value">要搜尋的物件。</param>
        <summary>使用陣列每個項目和指定物件所實作的 <see cref="T:System.IComparable" /> 介面，在整個一維已排序的陣列中搜尋特定的項目。</summary>
        <returns>如果找到 <paramref name="value" />，則為指定的 <paramref name="array" /> 中指定的 <paramref name="value" /> 索引；否則為負數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小於 <paramref name="array" /> 的一或多個項目，傳回的負數是大於 <paramref name="value" /> 的第一個項目索引的位元補數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大於 <paramref name="array" /> 的所有項目，傳回的負數是 (最後一個項目索引加 1) 的位元補數。 如果以未排序的 <paramref name="array" /> 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 <paramref name="value" /> 出現在 <paramref name="array" /> 中也一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不支援搜尋的陣列，其中包含負值的索引。 `array` 呼叫這個方法之前，必須先排序。  
  
 如果<xref:System.Array>不包含指定的值，此方法會傳回負整數。 您可以將套用的位元補數 」 運算子 (~ 在 C# 中，`Not`在 Visual Basic 中) 設為負數的結果來產生索引。 此索引大於陣列的上限是否有任何元素大於`value`陣列中。 否則，它是第一個元素大於索引`value`。  
  
 可能是`value`或每個項目`array`必須實作<xref:System.IComparable>介面，用於比較。 項目`array`已必須以遞增的值，根據所定義的排序次序排序<xref:System.IComparable>實作; 否則結果可能不正確。  
  
> [!NOTE]
>  如果`value`未實作<xref:System.IComparable>介面的項目`array`不需要測試的<xref:System.IComparable>之前開始搜尋。 如果搜尋遇到未實作的項目，會擲回例外狀況<xref:System.IComparable>。  
  
 允許重複的項目。 如果<xref:System.Array>包含多個元素等於`value`，方法會傳回的其中一個相符項目，並不一定是第一個索引。  
  
 `null` 一定要與其他任何參考類型; 比較因此，比較`null`並不會產生例外狀況。  
  
> [!NOTE]
>  每個項目測試，`value`傳遞至適當<xref:System.IComparable>實作，即使`value`是`null`。 也就是說，<xref:System.IComparable>實作可讓您決定如何為指定項目與比較`null`。  
  
 這個方法是 O (記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Array.BinarySearch%2A>找不到中的特定物件<xref:System.Array>。  
  
> [!NOTE]
>  建立陣列的元素以遞增排序次序。 <xref:System.Array.BinarySearch%2A>方法必須要以遞增順序排序的陣列。  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 的類型與 <paramref name="array" /> 項目不相容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 不會實作 <see cref="T:System.IComparable" /> 介面，且搜尋時遇到未實作 <see cref="T:System.IComparable" /> 介面的項目。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋之已排序的一維 <see cref="T:System.Array" />。</param>
        <param name="value">要搜尋的物件。</param>
        <param name="comparer">比較項目時所要使用的 <see cref="T:System.Collections.IComparer" /> 實作。  -或-  <see langword="null" /> 表示會使用每個項目的 <see cref="T:System.IComparable" /> 實作。</param>
        <summary>使用指定的 <see cref="T:System.Collections.IComparer" /> 介面，在整個一維已排序的陣列中搜尋值。</summary>
        <returns>如果找到 <paramref name="value" />，則為指定的 <paramref name="array" /> 中指定的 <paramref name="value" /> 索引；否則為負數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小於 <paramref name="array" /> 的一或多個項目，傳回的負數是大於 <paramref name="value" /> 的第一個項目索引的位元補數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大於 <paramref name="array" /> 的所有項目，傳回的負數是 (最後一個項目索引加 1) 的位元補數。 如果以未排序的 <paramref name="array" /> 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 <paramref name="value" /> 出現在 <paramref name="array" /> 中也一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不支援搜尋的陣列，其中包含負值的索引。 `array` 呼叫這個方法之前，必須先排序。  
  
 如果<xref:System.Array>不包含指定的值，此方法會傳回負整數。 您可以將套用的位元補數 」 運算子 (~ 在 C# 中，`Not`在 Visual Basic 中) 設為負數的結果來產生索引。 此索引大於陣列的上限是否有任何元素大於`value`陣列中。 否則，它是第一個元素大於索引`value`。  
  
 比較子自訂元素的比較方式。 例如，您可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>為要執行不區分大小寫的字串搜尋的比較子。  
  
 如果`comparer`不`null`的項目`array`指定使用指定的值比較<xref:System.Collections.IComparer>實作。 項目`array`已必須以遞增的值，根據所定義的排序次序排序`comparer`; 否則結果可能不正確。  
  
 如果`comparer`是`null`，進行比較使用<xref:System.IComparable>實作所提供項目本身，或指定的值。 項目`array`已必須以遞增的值，根據所定義的排序次序排序<xref:System.IComparable>實作; 否則結果可能不正確。  
  
> [!NOTE]
>  如果`comparer`是`null`和`value`未實作<xref:System.IComparable>介面的項目`array`不需要測試的<xref:System.IComparable>之前開始搜尋。 如果搜尋遇到未實作的項目，會擲回例外狀況<xref:System.IComparable>。  
  
 允許重複的項目。 如果<xref:System.Array>包含多個元素等於`value`，方法會傳回的其中一個相符項目，並不一定是第一個索引。  
  
 `null` 一定要與其他任何參考類型; 比較因此，比較`null`並不會產生例外狀況。  
  
> [!NOTE]
>  每個項目測試，`value`傳遞至適當<xref:System.IComparable>實作，即使`value`是`null`。 也就是說，<xref:System.IComparable>實作可讓您決定如何為指定項目與比較`null`。  
  
 這個方法是 O (記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 是 <see langword="null" />，且 <paramref name="value" /> 的類型與 <paramref name="array" /> 項目不相容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 是 <see langword="null" />，<paramref name="value" /> 不會實作 <see cref="T:System.IComparable" /> 介面，且搜尋時遇到未實作 <see cref="T:System.IComparable" /> 介面的項目。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋之已排序的一維 <see cref="T:System.Array" />。</param>
        <param name="index">要搜尋範圍的起始索引。</param>
        <param name="length">搜尋範圍的長度。</param>
        <param name="value">要搜尋的物件。</param>
        <summary>使用陣列的每個項目和指定之值所實作的 <see cref="T:System.IComparable" /> 介面，在已排序的一維陣列內某個範圍的項目中搜尋值。</summary>
        <returns>如果找到 <paramref name="value" />，則為指定的 <paramref name="array" /> 中指定的 <paramref name="value" /> 索引；否則為負數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小於 <paramref name="array" /> 的一或多個項目，傳回的負數是大於 <paramref name="value" /> 的第一個項目索引的位元補數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大於 <paramref name="array" /> 的所有項目，傳回的負數是 (最後一個項目索引加 1) 的位元補數。 如果以未排序的 <paramref name="array" /> 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 <paramref name="value" /> 出現在 <paramref name="array" /> 中也一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不支援搜尋的陣列，其中包含負值的索引。 `array` 呼叫這個方法之前，必須先排序。  
  
 如果<xref:System.Array>不包含指定的值，此方法會傳回負整數。 您可以將套用的位元補數 」 運算子 (~ 在 C# 中，`Not`在 Visual Basic 中) 設為負數的結果來產生索引。 此索引大於陣列的上限是否有任何元素大於`value`陣列中。 否則，它是第一個元素大於索引`value`。  
  
 可能是`value`或每個項目`array`必須實作<xref:System.IComparable>介面，用於比較。 項目`array`已必須以遞增的值，根據所定義的排序次序排序<xref:System.IComparable>實作; 否則結果可能不正確。  
  
> [!NOTE]
>  如果`value`未實作<xref:System.IComparable>介面的項目`array`不需要測試的<xref:System.IComparable>之前開始搜尋。 如果搜尋遇到未實作的項目，會擲回例外狀況<xref:System.IComparable>。  
  
 允許重複的項目。 如果<xref:System.Array>包含多個元素等於`value`，方法會傳回的其中一個相符項目，並不一定是第一個索引。  
  
 `null` 一定要與其他任何參考類型; 比較因此，比較`null`並不會產生例外狀況。  
  
> [!NOTE]
>  每個項目測試，`value`傳遞至適當<xref:System.IComparable>實作，即使`value`是`null`。 也就是說，<xref:System.IComparable>實作可讓您決定如何為指定項目與比較`null`。  
  
 這個方法是 O (記錄`n`) 作業，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。  -或-  <paramref name="value" /> 的型別與 <paramref name="array" /> 項目不相容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 不會實作 <see cref="T:System.IComparable" /> 介面，且搜尋時遇到未實作 <see cref="T:System.IComparable" /> 介面的項目。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋之已排序的一維 <see cref="T:System.Array" />。</param>
        <param name="index">要搜尋範圍的起始索引。</param>
        <param name="length">搜尋範圍的長度。</param>
        <param name="value">要搜尋的物件。</param>
        <param name="comparer">比較項目時所要使用的 <see cref="T:System.Collections.IComparer" /> 實作。  -或-  <see langword="null" /> 表示會使用每個項目的 <see cref="T:System.IComparable" /> 實作。</param>
        <summary>使用指定的 <see cref="T:System.Collections.IComparer" /> 介面，在已排序的一維陣列內某範圍的項目中搜尋值。</summary>
        <returns>如果找到 <paramref name="value" />，則為指定的 <paramref name="array" /> 中指定的 <paramref name="value" /> 索引；否則為負數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小於 <paramref name="array" /> 的一或多個項目，傳回的負數是大於 <paramref name="value" /> 的第一個項目索引的位元補數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大於 <paramref name="array" /> 的所有項目，傳回的負數是 (最後一個項目索引加 1) 的位元補數。 如果以未排序的 <paramref name="array" /> 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 <paramref name="value" /> 出現在 <paramref name="array" /> 中也一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不支援搜尋的陣列，其中包含負值的索引。 `array` 呼叫這個方法之前，必須先排序。  
  
 如果<xref:System.Array>不包含指定的值，此方法會傳回負整數。 您可以將套用的位元補數 」 運算子 (~ 在 C# 中，`Not`在 Visual Basic 中) 設為負數的結果來產生索引。 此索引大於陣列的上限是否有任何元素大於`value`陣列中。 否則，它是第一個元素大於索引`value`。  
  
 比較子自訂元素的比較方式。 例如，您可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>為要執行不區分大小寫的字串搜尋的比較子。  
  
 如果`comparer`不`null`的項目`array`指定使用指定的值比較<xref:System.Collections.IComparer>實作。 項目`array`已必須以遞增的值，根據所定義的排序次序排序`comparer`; 否則結果可能不正確。  
  
 如果`comparer`是`null`，進行比較使用<xref:System.IComparable>實作所提供項目本身，或指定的值。 項目`array`已必須以遞增的值，根據所定義的排序次序排序<xref:System.IComparable>實作; 否則結果可能不正確。  
  
> [!NOTE]
>  如果`comparer`是`null`和`value`未實作<xref:System.IComparable>介面的項目`array`不需要測試的<xref:System.IComparable>之前開始搜尋。 如果搜尋遇到未實作的項目，會擲回例外狀況<xref:System.IComparable>。  
  
 允許重複的項目。 如果<xref:System.Array>包含多個元素等於`value`，方法會傳回的其中一個相符項目，並不一定是第一個索引。  
  
 `null` 一定要與其他任何參考類型; 比較因此，比較`null`不會產生例外狀況時使用<xref:System.IComparable>。  
  
> [!NOTE]
>  每個項目測試，`value`傳遞至適當<xref:System.IComparable>實作，即使`value`是`null`。 也就是說，<xref:System.IComparable>實作可讓您決定如何為指定項目與比較`null`。  
  
 這個方法是 O (記錄`n`) 作業，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。  -或-  <paramref name="comparer" /> 是 <see langword="null" />，且 <paramref name="value" /> 的型別與 <paramref name="array" /> 項目不相容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 是 <see langword="null" />，<paramref name="value" /> 不會實作 <see cref="T:System.IComparable" /> 介面，且搜尋時遇到未實作 <see cref="T:System.IComparable" /> 介面的項目。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維 <see cref="T:System.Array" /> (其以零為起始且已排序)。</param>
        <param name="value">要搜尋的物件。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每個項目和指定之物件所實作的 <see cref="T:System.IComparable`1" /> 泛型介面，在整個已排序的一維陣列中搜尋特定的項目。</summary>
        <returns>如果找到 <paramref name="value" />，則為指定的 <paramref name="array" /> 中指定的 <paramref name="value" /> 索引；否則為負數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小於 <paramref name="array" /> 的一或多個項目，傳回的負數是大於 <paramref name="value" /> 的第一個項目索引的位元補數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大於 <paramref name="array" /> 的所有項目，傳回的負數是 (最後一個項目索引加 1) 的位元補數。 如果以未排序的 <paramref name="array" /> 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 <paramref name="value" /> 出現在 <paramref name="array" /> 中也一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不支援搜尋的陣列，其中包含負值的索引。 `array` 呼叫這個方法之前，必須先排序。  
  
 如果`array`不包含指定的值，此方法會傳回負整數。 您可以將套用的位元補數 」 運算子 (~ 在 C# 中，`Not`在 Visual Basic 中) 設為負數的結果來產生索引。 這個索引等於陣列的大小，如果有任何項目大於`value`陣列中。 否則，它是第一個元素大於索引`value`。  
  
 `T` 必須實作<xref:System.IComparable%601>泛型介面，用於比較。 項目`array`已必須以遞增的值，根據所定義的排序次序排序<xref:System.IComparable%601>實作; 否則結果可能不正確。  
  
 允許重複的項目。 如果<xref:System.Array>包含多個元素等於`value`，方法會傳回的其中一個相符項目，並不一定是第一個索引。  
  
 `null` 一定要與其他任何參考類型; 比較因此，比較`null`並不會產生例外狀況。  
  
> [!NOTE]
>  每個項目測試，`value`傳遞至適當<xref:System.IComparable%601>實作，即使`value`是`null`。 也就是說，<xref:System.IComparable%601>實作可讓您決定如何為指定項目與比較`null`。  
  
 這個方法是 O (記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法的多載而<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法的多載。 建立字串陣列，不依特定順序。  
  
 陣列會顯示、 已排序，並且會再次顯示。 必須排序陣列，才能使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  若要呼叫<xref:System.Array.Sort%2A>和<xref:System.Array.BinarySearch%2A>泛型方法看起來不任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的第一個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法的多載然後來搜尋兩個字串，而非在陣列與其中一個，為。 陣列和傳回值<xref:System.Array.BinarySearch%2A>方法會傳遞至`ShowWhere`泛型的方法，如果找到字串，否則項目搜尋字串會介於陣列中時顯示的索引值。 索引是負值，如果字串不是陣列，所以`ShowWhere`方法會採用的位元補數 (~ 運算子，在 C# 和 Visual c + +，`Xor`在 Visual Basic 中的為-1) 取得第一個元素大於搜尋清單中的索引 str正執行。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> 不實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維 <see cref="T:System.Array" /> (其以零為起始且已排序)。</param>
        <param name="value">要搜尋的物件。</param>
        <param name="comparer">比較項目時所要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 實作。  -或-  <see langword="null" /> 表示會使用每個項目的 <see cref="T:System.IComparable`1" /> 實作。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型介面，在整個已排序的一維陣列中搜尋值。</summary>
        <returns>如果找到 <paramref name="value" />，則為指定的 <paramref name="array" /> 中指定的 <paramref name="value" /> 索引；否則為負數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小於 <paramref name="array" /> 的一或多個項目，傳回的負數是大於 <paramref name="value" /> 的第一個項目索引的位元補數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大於 <paramref name="array" /> 的所有項目，傳回的負數是 (最後一個項目索引加 1) 的位元補數。 如果以未排序的 <paramref name="array" /> 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 <paramref name="value" /> 出現在 <paramref name="array" /> 中也一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不支援搜尋的陣列，其中包含負值的索引。 `array` 呼叫這個方法之前，必須先排序。  
  
 如果<xref:System.Array>不包含指定的值，此方法會傳回負整數。 您可以將套用的位元補數 」 運算子 (~ 在 C# 中，`Not`在 Visual Basic 中) 設為負數的結果來產生索引。 這個索引等於陣列的大小，如果有任何項目大於`value`陣列中。 否則，它是第一個元素大於索引`value`。  
  
 比較子自訂元素的比較方式。 例如，您可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>為要執行不區分大小寫的字串搜尋的比較子。  
  
 如果`comparer`不`null`的項目`array`指定使用指定的值比較<xref:System.Collections.Generic.IComparer%601>泛型介面實作。 項目`array`已必須以遞增的值，根據所定義的排序次序排序`comparer`; 否則結果可能不正確。  
  
 如果`comparer`是`null`，進行比較使用<xref:System.IComparable%601>所提供的泛型介面實作`T`。 項目`array`已必須以遞增的值，根據所定義的排序次序排序<xref:System.IComparable%601>實作; 否則結果可能不正確。  
  
> [!NOTE]
>  如果`comparer`是`null`和`value`未實作<xref:System.IComparable%601>泛型介面的項目`array`不需要測試的<xref:System.IComparable%601>之前開始搜尋。 如果搜尋遇到未實作的項目，會擲回例外狀況<xref:System.IComparable%601>。  
  
 允許重複的項目。 如果<xref:System.Array>包含多個元素等於`value`，方法會傳回的其中一個相符項目，並不一定是第一個索引。  
  
 `null` 一定要與其他任何參考類型; 比較因此，比較`null`並不會產生例外狀況。  
  
> [!NOTE]
>  每個項目測試，`value`傳遞至適當<xref:System.IComparable%601>實作，即使`value`是`null`。 也就是說，<xref:System.IComparable%601>實作可讓您決定如何為指定項目與比較`null`。  
  
 這個方法是 O (記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列範例會示範<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載而<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載。  
  
 程式碼範例定義的替代的比較子字串，名為`ReverseCompare`，它會實作`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型介面。 比較子的呼叫<xref:System.String.CompareTo%28System.String%29>方法，使字串排序高-到-低而不是低到高反轉比較元的順序。  
  
 陣列會顯示、 已排序，並且會再次顯示。 必須排序陣列，才能使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  若要呼叫<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法看起來不任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的第一個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載然後來搜尋兩個字串，而非在陣列與其中一個，為。 陣列和傳回值<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法會傳遞至`ShowWhere`泛型的方法，如果找到字串，否則項目搜尋字串會介於陣列中時顯示的索引值。 索引是負值，如果字串不是 n 陣列，所以`ShowWhere`方法會採用的位元補數 (~ 運算子，在 C# 和 Visual c + +，`Xor`在 Visual Basic 中的為-1) 取得第一個元素大於搜尋 stri 清單中的索引ng。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 為 <see langword="null" />，且 <paramref name="value" /> 的類型與 <paramref name="array" /> 的項目不相容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，且 <paramref name="T" /> 未實作 <see cref="T:System.IComparable`1" /> 泛型介面</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的已排序且為一維之以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="index">要搜尋範圍的起始索引。</param>
        <param name="length">搜尋範圍的長度。</param>
        <param name="value">要搜尋的物件。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每個項目和指定值所實作的 <see cref="T:System.IComparable`1" /> 泛型介面，在一維已排序的陣列內某個範圍的項目中搜尋值。</summary>
        <returns>如果找到 <paramref name="value" />，則為指定的 <paramref name="array" /> 中指定的 <paramref name="value" /> 索引；否則為負數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小於 <paramref name="array" /> 的一或多個項目，傳回的負數是大於 <paramref name="value" /> 的第一個項目索引的位元補數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大於 <paramref name="array" /> 的所有項目，傳回的負數是 (最後一個項目索引加 1) 的位元補數。 如果以未排序的 <paramref name="array" /> 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 <paramref name="value" /> 出現在 <paramref name="array" /> 中也一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不支援搜尋的陣列，其中包含負值的索引。 `array` 呼叫這個方法之前，必須先排序。  
  
 如果陣列未包含指定的值，則方法會傳回負整數。 您可以將套用的位元補數 」 運算子 (~ 在 C# 中，`Not`在 Visual Basic 中) 設為負數的結果來產生索引。 這個索引等於陣列的大小，如果有任何項目大於`value`陣列中。 否則，它是第一個元素大於索引`value`。  
  
 `T` 必須實作<xref:System.IComparable%601>泛型介面，用於比較。 項目`array`已必須以遞增的值，根據所定義的排序次序排序<xref:System.IComparable%601>實作; 否則結果可能不正確。  
  
 允許重複的項目。 如果<xref:System.Array>包含多個元素等於`value`，方法會傳回的其中一個相符項目，並不一定是第一個索引。  
  
 `null` 一定要與其他任何參考類型; 比較因此，比較`null`並不會產生例外狀況。  
  
> [!NOTE]
>  每個項目測試，`value`傳遞至適當<xref:System.IComparable%601>實作，即使`value`是`null`。 也就是說，<xref:System.IComparable%601>實作可讓您決定如何為指定項目與比較`null`。  
  
 這個方法是 O (記錄`n`) 作業，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。  -或-  <paramref name="value" /> 的型別與 <paramref name="array" /> 項目不相容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> 不實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的已排序且為一維之以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="index">要搜尋範圍的起始索引。</param>
        <param name="length">搜尋範圍的長度。</param>
        <param name="value">要搜尋的物件。</param>
        <param name="comparer">比較項目時所要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 實作。  -或-  <see langword="null" /> 表示會使用每個項目的 <see cref="T:System.IComparable`1" /> 實作。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型介面，在已排序的一維陣列內某範圍的項目中搜尋值。</summary>
        <returns>如果找到 <paramref name="value" />，則為指定的 <paramref name="array" /> 中指定的 <paramref name="value" /> 索引；否則為負數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小於 <paramref name="array" /> 的一或多個項目，傳回的負數是大於 <paramref name="value" /> 的第一個項目索引的位元補數。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大於 <paramref name="array" /> 的所有項目，傳回的負數是 (最後一個項目索引加 1) 的位元補數。 如果以未排序的 <paramref name="array" /> 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 <paramref name="value" /> 出現在 <paramref name="array" /> 中也一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不支援搜尋的陣列，其中包含負值的索引。 `array` 呼叫這個方法之前，必須先排序。  
  
 如果陣列未包含指定的值，則方法會傳回負整數。 您可以將套用的位元補數 」 運算子 (~ 在 C# 中，`Not`在 Visual Basic 中) 設為負數的結果來產生索引。 這個索引等於陣列的大小，如果有任何項目大於`value`陣列中。 否則，它是第一個元素大於索引`value`。  
  
 比較子自訂元素的比較方式。 例如，您可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>為要執行不區分大小寫的字串搜尋的比較子。  
  
 如果`comparer`不`null`的項目`array`指定使用指定的值比較<xref:System.Collections.Generic.IComparer%601>泛型介面實作。 項目`array`已必須以遞增的值，根據所定義的排序次序排序`comparer`; 否則結果可能不正確。  
  
 如果`comparer`是`null`，進行比較使用<xref:System.IComparable%601>類型提供的泛型介面實作`T`。 項目`array`已必須以遞增的值，根據所定義的排序次序排序<xref:System.IComparable%601>實作; 否則結果可能不正確。  
  
 允許重複的項目。 如果<xref:System.Array>包含多個元素等於`value`，方法會傳回的其中一個相符項目，並不一定是第一個索引。  
  
 `null` 一定要與其他任何參考類型; 比較因此，比較`null`不會產生例外狀況時使用<xref:System.IComparable%601>。  
  
> [!NOTE]
>  每個項目測試，`value`傳遞至適當<xref:System.IComparable%601>實作，即使`value`是`null`。 也就是說，<xref:System.IComparable%601>實作可讓您決定如何為指定項目與比較`null`。  
  
 這個方法是 O (記錄`n`) 作業，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。  -或-  <paramref name="comparer" /> 是 <see langword="null" />，且 <paramref name="value" /> 的型別與 <paramref name="array" /> 項目不相容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，且 <paramref name="T" /> 未實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">項目需要加以清除的陣列。</param>
        <param name="index">要清除之項目範圍的起始索引。</param>
        <param name="length">要清除的項目數目。</param>
        <summary>將陣列中的項目範圍設定為每個項目類型的預設值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法重設項目類型的預設值為陣列中的每個項目。 它會設定參考類型的項目 (包括<xref:System.String>項目) 來`null`，並將實值類型的項目設定為下表中所顯示的預設值。  
  
|類型|值|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|所有整數和浮點數值類型|0 （零）|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|其他實值類型|預設值是類型的欄位|  
  
 範圍清除項目自動換行逐列多維陣列中。  
  
 這個方法只會清除的項目; 的值它不會刪除項目本身。 陣列有固定的大小。因此，無法加入或移除項目。  
  
 這個方法是 O (`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Array.Clear%2A>方法來重設一維、 二維和三維陣列中的整數值。  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 下列範例會定義`TimeZoneTime`結構，其中包含<xref:System.TimeZoneInfo>欄位和<xref:System.DateTimeOffset>欄位。 然後它會呼叫<xref:System.Array.Clear%2A>方法，以清除一個項目中的兩個元素陣列`TimeZoneTime`值。 方法會將已清除項目的值設定的預設值<xref:System.TimeZoneInfo>物件，它是`null`的預設值和<xref:System.DateTimeOffset>物件，它是<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 的總和大於 <paramref name="array" /> 的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立 <see cref="T:System.Array" /> 的淺層複本。</summary>
        <returns>
          <see cref="T:System.Array" /> 的淺層複本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 淺層複本<xref:System.Array>的元素複製<xref:System.Array>，不論它們是參考類型或實值類型，但是不會複製參考所參考的物件。 在新的參考<xref:System.Array>指向相同物件中原始的參考<xref:System.Array>指向。  
  
 相反地，深層複製的<xref:System.Array>複製項目，並直接或間接參考之元素的所有項目。  
  
 複製是相同<xref:System.Type>與原始<xref:System.Array>。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>。  
  
   
  
## Examples  
 下列程式碼範例複製品<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>陣列，並示範的淺層複本的行為。  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要複製資料的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">32 位元的整數，代表 <c>sourceArray</c> 中的索引，由此開始複製。</param>
        <param name="destinationArray">接收資料的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">32 位元的整數，代表 <c>destinationArray</c> 中的索引，由此開始複製。</param>
        <param name="length">32 位元整數，表示要複製的項目數目。</param>
        <summary>從 <see cref="T:System.Array" /> 複製某範圍的項目 (從指定的來源索引開始)，並且將它們貼至另一個 <see cref="T:System.Array" /> (從指定的目的索引開始)。  如果此複本未完全成功，則保證所有的變更一定未完成。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`參數必須有相同的維度數目。  `sourceArray`類型必須相同，或衍生自`destinationArray`輸入; 否則<xref:System.ArrayTypeMismatchException>就會擲回。  不同於<xref:System.Array.Copy%2A>，<xref:System.Array.ConstrainedCopy%2A>執行任何作業之前先確認陣列類型的相容性。  
  
 多維陣列之間進行複製，當陣列的行為如同長的一維陣列，其中資料列 （或資料行） 會在概念上排列端對端。 例如，如果陣列有三個資料列 （或資料行） 使用四個元素陣列的開頭，複製六個項目會複製全部的四個元素的第一個資料列 （或資料行） 和第二個資料列 （或資料行） 的前兩個項目。 若要開始複製的第三個資料列 （或資料行），第二個項目從`sourceIndex`必須第一個資料列 （或資料行） 的上限加上第二個資料列 （或資料行） 的長度再加上兩個。  
  
 如果`sourceArray`和`destinationArray`重疊，這個方法的行為如同的原始值`sourceArray`已保留在暫存位置之前`destinationArray`會覆寫。  
  
 [C++]  
  
 這個方法相當於標準的 C/c + + 函式`memmove`，而非`memcpy`。  
  
 陣列可以是參考類型的陣列或實值型別陣列。  如果`sourceArray`和`destinationArray`有兩個參考類型的陣列或類型的兩個陣列<xref:System.Object>，會執行的淺層複本。 淺層複本<xref:System.Array>新<xref:System.Array>包含相同項目與原始參考<xref:System.Array>。 項目不會複製本身或項目所參考的任何項目。 相反地，深層複製的<xref:System.Array>複製項目，並直接或間接參考之元素的所有項目。  
  
 如果此方法會擲回的例外狀況，正在複製`destinationArray`仍維持不變; 因此，<xref:System.Array.ConstrainedCopy%2A>可用於限制的執行區域 (<xref:System.Runtime.ConstrainedExecution.Cer>)。  
  
 這個方法是 O (`n`) 作業，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 為 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 的順位不同。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 類型不同於、也非衍生自 <paramref name="destinationArray" /> 類型。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 至少有一個項目無法轉換成 <paramref name="destinationArray" /> 的類型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> 小於 <paramref name="sourceArray" /> 的第一個維度下限。  -或-  <paramref name="destinationIndex" /> 小於 <paramref name="destinationArray" /> 的第一個維度下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大於從 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 結尾的項目數。  -或-  <paramref name="length" /> 大於從 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 結尾的項目數。</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">來源陣列項目的類型。</typeparam>
        <typeparam name="TOutput">目標陣列項目的類型。</typeparam>
        <param name="array">要轉換成目標類型之以零為起始的一維 <see cref="T:System.Array" />。</param>
        <param name="converter">
          <see cref="T:System.Converter`2" />，可將某一個類型的每一個項目轉換成另一個類型。</param>
        <summary>將某一個類型的陣列轉換成另一個類型的陣列。</summary>
        <returns>目標類型的陣列，其中包含來源陣列中已轉換的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>是將物件轉換成目標型別方法委派。  項目`array`分別傳遞至<xref:System.Converter%602>，和已轉換的項目會儲存在新的陣列。  
  
 來源`array`維持不變。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例會定義方法，名為`PointFToPoint`將轉換<xref:System.Drawing.PointF>結構以<xref:System.Drawing.Point>結構。 這個範例會建立的陣列<xref:System.Drawing.PointF>結構、 建立`Converter<PointF, Point>`委派 (`Converter(Of PointF, Point)`在 Visual Basic 中) 來代表`PointFToPoint`方法，並傳遞至委派<xref:System.Array.ConvertAll%2A>方法。 <xref:System.Array.ConvertAll%2A>方法會將傳遞的輸入清單的每個項目`PointFToPoint`方法並將已轉換的項目放入新的清單<xref:System.Drawing.Point>結構。 這兩份清單會顯示。  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="converter" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將一個 <see cref="T:System.Array" /> 中某範圍的元素複製到另一個 <see cref="T:System.Array" />，並在必要時執行型別轉換和 Boxing。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要複製資料的 <see cref="T:System.Array" />。</param>
        <param name="destinationArray">接收資料的 <see cref="T:System.Array" />。</param>
        <param name="length">32 位元整數，表示要複製的項目數目。</param>
        <summary>從 <see cref="T:System.Array" /> 複製某範圍的項目 (從第一個項目開始)，並且將它們貼至另一個 <see cref="T:System.Array" /> (從第一個項目開始)。 長度已指定為 32 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`參數必須有相同的維度數目。 此外，`destinationArray`必須已有已建立維度，必須有足夠數目的項目，以容納所複製的資料。  
  
 多維陣列之間進行複製，當陣列的行為如同長的一維陣列，其中資料列 （或資料行） 會在概念上排列端對端。 例如，如果陣列有三個資料列 （或資料行） 使用四個元素陣列的開頭，複製六個項目會複製全部的四個元素的第一個資料列 （或資料行） 和第二個資料列 （或資料行） 的前兩個項目。  
  
 如果`sourceArray`和`destinationArray`重疊，這個方法的行為如同的原始值`sourceArray`已保留在暫存位置之前`destinationArray`會覆寫。  
  
 [C++]  
  
 這個方法相當於標準的 C/c + + 函式`memmove`，而非`memcpy`。  
  
 陣列可以是參考類型的陣列或實值型別陣列。 執行類型向下轉型時，視需要而定。  
  
-   當複製到實值類型陣列的參考型別陣列，每個項目會進行 unboxed 處理，然後再複製。 當實值型別陣列中複製到參考型別陣列，每個項目會進行 boxed 處理，然後再複製。  
  
-   從參考類型或實值類型陣列到<xref:System.Object>陣列、<xref:System.Object>建立來保存每個值或參考，然後再複製。 從複製時<xref:System.Object>陣列是參考類型或實值型別陣列和指派，則不可能<xref:System.InvalidCastException>就會擲回。  
  
-   如果`sourceArray`和`destinationArray`有兩個參考類型的陣列或類型的兩個陣列<xref:System.Object>，會執行的淺層複本。 淺層複本<xref:System.Array>新<xref:System.Array>包含相同項目與原始參考<xref:System.Array>。 項目不會複製本身或項目所參考的任何項目。 相反地，深層複製的<xref:System.Array>複製項目，並直接或間接參考之元素的所有項目。  
  
 <xref:System.ArrayTypeMismatchException>如果陣列不相容的型別會擲回。 型別相容性的定義方式如下：  
  
-   類型為與其本身相容。  
  
-   實值類型會與相容<xref:System.Object>和該實值型別所實作的介面型別。 連接至介面，它會直接實作該介面時，才視為實值類型。 已中斷連線的類型不相容。  
  
-   兩個內建函式 （預先定義） 的實值型別都相容，是否從來源類型複製到目的地類型進行擴展轉換。 擴展轉換不會遺失資訊，而縮小轉換可能會遺失資訊。 例如，將 32 位元帶正負號的整數轉換為 64 位元帶正負號的整數擴展轉換，並將 64 位元帶正負號的整數轉換為 32 位元帶正負號的整數是縮小轉換。 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
-   在非內建 （使用者定義） 的實值類型是只與其本身相容。  
  
-   列舉值有隱含轉換成<xref:System.Enum>以及其基礎類型。  
  
 如果在每個項目`sourceArray`需要向下轉型 （比方說，從基底類別衍生的類別或介面的物件） 以及一或多個項目無法轉換成對應的型別中`destinationArray`、<xref:System.InvalidCastException>就會擲回。  
  
 如果此方法會擲回的例外狀況，同時將複製的狀態`destinationArray`是未定義。  
  
 這個方法是 O (`n`) 作業，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 為 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 的順位不同。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 類型不相容。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 至少有一個項目無法轉換成 <paramref name="destinationArray" /> 的類型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大於 <paramref name="sourceArray" /> 的項目數。  -或-  <paramref name="length" /> 大於 <paramref name="destinationArray" /> 的項目數。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要複製資料的 <see cref="T:System.Array" />。</param>
        <param name="destinationArray">接收資料的 <see cref="T:System.Array" />。</param>
        <param name="length">64 位元整數，表示要複製的項目數目。 這個整數必須在零和 <see cref="F:System.Int32.MaxValue" /> 之間 (包含頭尾)。</param>
        <summary>從 <see cref="T:System.Array" /> 複製某範圍的項目 (從第一個項目開始)，並且將它們貼至另一個 <see cref="T:System.Array" /> (從第一個項目開始)。 長度已指定為 64 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`參數必須有相同的維度數目。 此外，`destinationArray`必須已有已建立維度，必須有足夠數目的項目，以容納所複製的資料。  
  
 多維陣列之間進行複製，當陣列的行為如同長的一維陣列，其中資料列 （或資料行） 會在概念上排列端對端。 例如，如果陣列有三個資料列 （或資料行） 使用四個元素陣列的開頭，複製六個項目會複製全部的四個元素的第一個資料列 （或資料行） 和第二個資料列 （或資料行） 的前兩個項目。  
  
 如果`sourceArray`和`destinationArray`重疊，這個方法的行為如同的原始值`sourceArray`已保留在暫存位置之前`destinationArray`會覆寫。  
  
 [C++]  
  
 這個方法相當於標準的 C/c + + 函式`memmove`，而非`memcpy`。  
  
 陣列可以是參考類型的陣列或實值型別陣列。 執行類型向下轉型時，視需要而定。  
  
-   當複製到實值類型陣列的參考型別陣列，每個項目會進行 unboxed 處理，然後再複製。 當實值型別陣列中複製到參考型別陣列，每個項目會進行 boxed 處理，然後再複製。  
  
-   從參考類型或實值類型陣列到<xref:System.Object>陣列、<xref:System.Object>建立來保存每個值或參考，然後再複製。 從複製時<xref:System.Object>陣列是參考類型或實值型別陣列和指派，則不可能<xref:System.InvalidCastException>就會擲回。  
  
-   如果`sourceArray`和`destinationArray`有兩個參考類型的陣列或類型的兩個陣列<xref:System.Object>，會執行的淺層複本。 淺層複本<xref:System.Array>新<xref:System.Array>包含相同項目與原始參考<xref:System.Array>。 項目不會複製本身或項目所參考的任何項目。 相反地，深層複製的<xref:System.Array>複製項目，並直接或間接參考之元素的所有項目。  
  
 <xref:System.ArrayTypeMismatchException>如果陣列不相容的型別會擲回。 型別相容性的定義方式如下：  
  
-   類型為與其本身相容。  
  
-   實值類型會與相容<xref:System.Object>和該實值型別所實作的介面型別。 連接至介面，它會直接實作該介面時，才視為實值類型。 已中斷連線的類型不相容。  
  
-   兩個內建函式 （預先定義） 的實值型別都相容，是否從來源類型複製到目的地類型進行擴展轉換。 擴展轉換不會遺失資訊，而縮小轉換可能會遺失資訊。 例如，將 32 位元帶正負號的整數轉換為 64 位元帶正負號的整數擴展轉換，並將 64 位元帶正負號的整數轉換為 32 位元帶正負號的整數是縮小轉換。 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
-   在非內建 （使用者定義） 的實值類型是只與其本身相容。  
  
-   列舉值有隱含轉換成<xref:System.Enum>以及其基礎類型。  
  
 如果在每個項目`sourceArray`需要向下轉型 （比方說，從基底類別衍生的類別或介面的物件） 以及一或多個項目無法轉換成對應的型別中`destinationArray`、<xref:System.InvalidCastException>就會擲回。  
  
 如果此方法會擲回的例外狀況，同時將複製的狀態`destinationArray`是未定義。  
  
 這個方法是 O (`n`) 作業，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 為 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 的順位不同。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 類型不相容。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 至少有一個項目無法轉換成 <paramref name="destinationArray" /> 的類型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> 小於 0 或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大於 <paramref name="sourceArray" /> 的項目數。  -或-  <paramref name="length" /> 大於 <paramref name="destinationArray" /> 的項目數。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要複製資料的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">32 位元的整數，代表 <c>sourceArray</c> 中的索引，由此開始複製。</param>
        <param name="destinationArray">接收資料的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">32 位元的整數，代表 <c>destinationArray</c> 中的索引，由此開始複製。</param>
        <param name="length">32 位元整數，表示要複製的項目數目。</param>
        <summary>從 <see cref="T:System.Array" /> 複製某範圍的項目 (從指定的來源索引開始)，並且將它們貼至另一個 <see cref="T:System.Array" /> (從指定的目的索引開始)。 長度與索引都指定為 32 位元的整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`參數必須有相同的維度數目。 此外，`destinationArray`必須已有已建立維度，必須有足夠數目的項目從開始`destinationIndex`以容納所複製的資料的位置。  
  
 多維陣列之間進行複製，當陣列的行為如同長的一維陣列，其中資料列 （或資料行） 會在概念上排列端對端。 例如，如果陣列有三個資料列 （或資料行） 使用四個元素陣列的開頭，複製六個項目會複製全部的四個元素的第一個資料列 （或資料行） 和第二個資料列 （或資料行） 的前兩個項目。 若要開始複製的第三個資料列 （或資料行），第二個項目從`sourceIndex`必須第一個資料列 （或資料行） 的上限加上第二個資料列 （或資料行） 的長度再加上兩個。  
  
 如果`sourceArray`和`destinationArray`重疊，這個方法的行為如同的原始值`sourceArray`已保留在暫存位置之前`destinationArray`會覆寫。  
  
 [C++]  
  
 這個方法相當於標準的 C/c + + 函式`memmove`，而非`memcpy`。  
  
 陣列可以是參考類型的陣列或實值型別陣列。 執行類型向下轉型時，視需要而定。  
  
-   當複製到實值類型陣列的參考型別陣列，每個項目會進行 unboxed 處理，然後再複製。 當實值型別陣列中複製到參考型別陣列，每個項目會進行 boxed 處理，然後再複製。  
  
-   從參考類型或實值類型陣列到<xref:System.Object>陣列、<xref:System.Object>建立來保存每個值或參考，然後再複製。 從複製時<xref:System.Object>陣列是參考類型或實值型別陣列和指派，則不可能<xref:System.InvalidCastException>就會擲回。  
  
-   如果`sourceArray`和`destinationArray`有兩個參考類型的陣列或類型的兩個陣列<xref:System.Object>，會執行的淺層複本。 淺層複本<xref:System.Array>新<xref:System.Array>包含相同項目與原始參考<xref:System.Array>。 項目不會複製本身或項目所參考的任何項目。 相反地，深層複製的<xref:System.Array>複製項目，並直接或間接參考之元素的所有項目。  
  
 <xref:System.ArrayTypeMismatchException>如果陣列不相容的型別會擲回。 型別相容性的定義方式如下：  
  
-   類型為與其本身相容。  
  
-   實值類型會與相容<xref:System.Object>和該實值型別所實作的介面型別。 連接至介面，它會直接實作該介面時，才視為實值類型。 已中斷連線的類型不相容。  
  
-   兩個內建函式 （預先定義） 的實值型別都相容，是否從來源類型複製到目的地類型進行擴展轉換。 擴展轉換不會遺失資訊，而縮小轉換可能會遺失資訊。 例如，將 32 位元帶正負號的整數轉換為 64 位元帶正負號的整數擴展轉換，並將 64 位元帶正負號的整數轉換為 32 位元帶正負號的整數是縮小轉換。 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
-   在非內建 （使用者定義） 的實值類型是只與其本身相容。  
  
-   列舉值有隱含轉換成<xref:System.Enum>以及其基礎類型。  
  
 如果在每個項目`sourceArray`需要向下轉型 （比方說，從基底類別衍生的類別或介面的物件） 以及一或多個項目無法轉換成對應的型別中`destinationArray`、<xref:System.InvalidCastException>就會擲回。  
  
 如果此方法會擲回的例外狀況，同時將複製的狀態`destinationArray`是未定義。  
  
 這個方法是 O (`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範如何從一個複製<xref:System.Array>型別的<xref:System.Object>到另一個<xref:System.Array>類型為整數。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 為 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 的順位不同。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 類型不相容。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 至少有一個項目無法轉換成 <paramref name="destinationArray" /> 的類型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> 小於 <paramref name="sourceArray" /> 的第一個維度下限。  -或-  <paramref name="destinationIndex" /> 小於 <paramref name="destinationArray" /> 的第一個維度下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大於從 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 結尾的項目數。  -或-  <paramref name="length" /> 大於從 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 結尾的項目數。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要複製資料的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">64 位元的整數，代表 <c>sourceArray</c> 中的索引，由此開始複製。</param>
        <param name="destinationArray">接收資料的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">64 位元的整數，代表 <c>destinationArray</c> 中的索引，由此開始複製。</param>
        <param name="length">64 位元整數，表示要複製的項目數目。 這個整數必須在零和 <see cref="F:System.Int32.MaxValue" /> 之間 (包含頭尾)。</param>
        <summary>從 <see cref="T:System.Array" /> 複製某範圍的項目 (從指定的來源索引開始)，並且將它們貼至另一個 <see cref="T:System.Array" /> (從指定的目的索引開始)。 長度與索引都指定為 64 位元的整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`參數必須有相同的維度數目。 此外，`destinationArray`必須已有已建立維度，必須有足夠數目的項目從開始`destinationIndex`以容納所複製的資料的位置。  
  
 多維陣列之間進行複製，當陣列的行為如同長的一維陣列，其中資料列 （或資料行） 會在概念上排列端對端。 例如，如果陣列有三個資料列 （或資料行） 使用四個元素陣列的開頭，複製六個項目會複製全部的四個元素的第一個資料列 （或資料行） 和第二個資料列 （或資料行） 的前兩個項目。 若要開始複製的第三個資料列 （或資料行），第二個項目從`sourceIndex`必須第一個資料列 （或資料行） 的上限加上第二個資料列 （或資料行） 的長度再加上兩個。  
  
 如果`sourceArray`和`destinationArray`重疊，這個方法的行為如同的原始值`sourceArray`已保留在暫存位置之前`destinationArray`會覆寫。  
  
 [C++]  
  
 這個方法相當於標準的 C/c + + 函式`memmove`，而非`memcpy`。  
  
 陣列可以是參考類型的陣列或實值型別陣列。 執行類型向下轉型時，視需要而定。  
  
-   當複製到實值類型陣列的參考型別陣列，每個項目會進行 unboxed 處理，然後再複製。 當實值型別陣列中複製到參考型別陣列，每個項目會進行 boxed 處理，然後再複製。  
  
-   從參考類型或實值類型陣列到<xref:System.Object>陣列、<xref:System.Object>建立來保存每個值或參考，然後再複製。 從複製時<xref:System.Object>陣列是參考類型或實值型別陣列和指派，則不可能<xref:System.InvalidCastException>就會擲回。  
  
-   如果`sourceArray`和`destinationArray`有兩個參考類型的陣列或類型的兩個陣列<xref:System.Object>，會執行的淺層複本。 淺層複本<xref:System.Array>新<xref:System.Array>包含相同項目與原始參考<xref:System.Array>。 項目不會複製本身或項目所參考的任何項目。 相反地，深層複製的<xref:System.Array>複製項目，並直接或間接參考之元素的所有項目。  
  
 <xref:System.ArrayTypeMismatchException>如果陣列不相容的型別會擲回。 型別相容性的定義方式如下：  
  
-   類型為與其本身相容。  
  
-   實值類型會與相容<xref:System.Object>和該實值型別所實作的介面型別。 連接至介面，它會直接實作該介面時，才視為實值類型。 已中斷連線的類型不相容。  
  
-   兩個內建函式 （預先定義） 的實值型別都相容，是否從來源類型複製到目的地類型進行擴展轉換。 擴展轉換不會遺失資訊，而縮小轉換可能會遺失資訊。 例如，將 32 位元帶正負號的整數轉換為 64 位元帶正負號的整數擴展轉換，並將 64 位元帶正負號的整數轉換為 32 位元帶正負號的整數是縮小轉換。 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
-   在非內建 （使用者定義） 的實值類型是只與其本身相容。  
  
-   列舉值有隱含轉換成<xref:System.Enum>以及其基礎類型。  
  
 如果在每個項目`sourceArray`需要向下轉型 （比方說，從基底類別衍生的類別或介面的物件） 以及一或多個項目無法轉換成對應的型別中`destinationArray`、<xref:System.InvalidCastException>就會擲回。  
  
 如果此方法會擲回的例外狀況，同時將複製的狀態`destinationArray`是未定義。  
  
 這個方法是 O (`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範如何從一個複製<xref:System.Array>型別的<xref:System.Object>到另一個<xref:System.Array>類型為整數。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 為 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 的順位不同。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 類型不相容。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 至少有一個項目無法轉換成 <paramref name="destinationArray" /> 的類型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> 超出 <paramref name="sourceArray" /> 的有效索引範圍。  -或-  <paramref name="destinationIndex" /> 超出 <paramref name="destinationArray" /> 的有效索引範圍。  -或-  <paramref name="length" /> 小於 0 或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大於從 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 結尾的項目數。  -或-  <paramref name="length" /> 大於從 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 結尾的項目數。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將目前一維陣列的所有項目複製到指定的一維陣列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一維陣列，從目前陣列複製過來的項目之目的端。</param>
        <param name="index">32 位元的整數，代表 <c>array</c> 中的索引，由此開始複製。</param>
        <summary>將目前一維陣列的所有項目複製到指定的一維陣列 (從指定的目的陣列索引開始)。 索引已指定為 32 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會複製到目前的陣列執行個體的所有項目`array`索引處開始的目的陣列`index`。 `array`目的陣列必須已經有尚未建立維度，而且必須具有足夠容納複製之元素的項目數目。 否則，方法會擲回例外狀況。  
  
 這個方法支援<xref:System.Collections.ICollection?displayProperty=nameWithType>介面。 如果實作<xref:System.Collections.ICollection?displayProperty=nameWithType>是不明確的需求，使用<xref:System.Array.Copy%2A>以避免額外的間接取值。  
  
 如果此方法會擲回的例外狀況，同時將複製的狀態`array`是未定義。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>。它會執行淺層複本。  
  
   
  
## Examples  
 下列程式碼範例示範如何將複製<xref:System.Array>到另一個<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 下列程式碼範例示範如何將複製<xref:System.Array>到另一個<xref:System.Array>，則為非零的下限。 請注意，整個來源<xref:System.Array>複製時，包括覆寫現有的項目在目標中的空項目<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多維的。  -或-  來源陣列中的項目數大於從 <paramref name="index" /> 到目的地 <paramref name="array" /> 結尾的可用項目數。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">來源 <see cref="T:System.Array" /> 的類型無法自動轉換成目的 <paramref name="array" /> 的類型。</exception>
        <exception cref="T:System.RankException">該來源陣列為多維。</exception>
        <exception cref="T:System.InvalidCastException">來源 <see cref="T:System.Array" /> 中至少有一個項目無法轉換成目的 <paramref name="array" /> 的類型。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">一維陣列，從目前陣列複製過來的項目之目的端。</param>
        <param name="index">64 位元的整數，代表 <c>array</c> 中的索引，由此開始複製。</param>
        <summary>將目前一維陣列的所有項目複製到指定的一維陣列 (從指定的目的陣列索引開始)。 索引已指定為 64 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會複製到目前的陣列執行個體的所有項目`array`索引處開始的目的陣列`index`。 `array`目的陣列必須已經有尚未建立維度，而且必須具有足夠容納複製之元素的項目數目。 否則，方法會擲回例外狀況。  
  
 這個方法支援<xref:System.Collections.ICollection?displayProperty=nameWithType>介面。 如果實作<xref:System.Collections.ICollection?displayProperty=nameWithType>是不明確的需求，使用<xref:System.Array.Copy%2A>以避免額外的間接取值。  
  
 如果此方法會擲回的例外狀況，同時將複製的狀態`array`是未定義。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>。它會執行淺層複本。  
  
   
  
## Examples  
 下列程式碼範例示範如何將複製<xref:System.Array>到另一個<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 下列程式碼範例示範如何將複製<xref:System.Array>到另一個<xref:System.Array>，則為非零的下限。 請注意，整個來源<xref:System.Array>複製時，包括覆寫現有的項目在目標中的空項目<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 超出 <paramref name="array" /> 的有效索引範圍。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多維的。  -或-  來源陣列中的項目數大於從 <paramref name="index" /> 到目的地 <paramref name="array" /> 結尾的可用項目數。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">來源 <see cref="T:System.Array" /> 的類型無法自動轉換成目的 <paramref name="array" /> 的類型。</exception>
        <exception cref="T:System.RankException">來源 <see cref="T:System.Array" /> 是多維的。</exception>
        <exception cref="T:System.InvalidCastException">來源 <see cref="T:System.Array" /> 中至少有一個項目無法轉換成目的 <paramref name="array" /> 的類型。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Array" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要建立之 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length">要建立的 <see cref="T:System.Array" /> 的大小。</param>
        <summary>建立指定 <see cref="T:System.Array" /> 和長度的一維 <see cref="T:System.Type" /> (具有以零起始的索引)。</summary>
        <returns>新的一維 <see cref="T:System.Array" />，具有指定的長度和指定的 <see cref="T:System.Type" />，並使用以零起始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於大部分的類別，<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公用建構函式，以允許晚期繫結的存取。  
  
 參考類型的項目會初始化為`null`。 實值型別元素會初始化為零。  
  
 這個方法是 O (`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立和初始化一維<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支援 <paramref name="elementType" />。 例如，<see cref="T:System.Void" /> 不受支援。  -或-  <paramref name="elementType" /> 是開放式泛型型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> 小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">要建立之 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">32 位元整數的陣列，代表 <see cref="T:System.Array" /> 所建立之每個維度的大小。</param>
        <summary>建立指定 <see cref="T:System.Array" /> 和維度長度的多維 <see cref="T:System.Type" /> (具有以零起始的索引)。 維度長度已指定在 32 位元整數的陣列中。</summary>
        <returns>新的多維 <see cref="T:System.Array" />，具有指定的 <see cref="T:System.Type" /> 且每個維度具有指定的長度，並使用以零起始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於大部分的類別，<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公用建構函式，以允許晚期繫結的存取。  
  
 中的項目數`lengths`陣列必須等於在新的維度數目<xref:System.Array>。 每個項目`lengths`陣列必須指定之相對應維度的長度，在新<xref:System.Array>。  
  
 參考類型的項目會初始化為`null`。 實值型別元素會初始化為零。  
  
 這個方法是 O (`n`) 作業，其中`n`是中的所有值的乘積`lengths`。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立和初始化多維度<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 為 <see langword="null" />。  -或-  <paramref name="lengths" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  -或-  <paramref name="lengths" /> 陣列包含少於一個項目。</exception>
        <exception cref="T:System.NotSupportedException">不支援 <paramref name="elementType" />。 例如，<see cref="T:System.Void" /> 不受支援。  -或-  <paramref name="elementType" /> 是開放式泛型型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 中的任何值小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">要建立之 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">64 位元整數的陣列，代表要建立的 <see cref="T:System.Array" /> 的每個維度大小。 陣列中的每一個整數必須在零和 <see cref="F:System.Int32.MaxValue" /> 之間 (包含頭尾)。</param>
        <summary>建立指定 <see cref="T:System.Array" /> 和維度長度的多維 <see cref="T:System.Type" /> (具有以零起始的索引)。 維度長度已指定在 64 位元整數的陣列中。</summary>
        <returns>新的多維 <see cref="T:System.Array" />，具有指定的 <see cref="T:System.Type" /> 且每個維度具有指定的長度，並使用以零起始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於大部分的類別，<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公用建構函式，以允許晚期繫結的存取。  
  
 中的項目數`lengths`陣列必須等於在新的維度數目<xref:System.Array>。 每個項目`lengths`陣列必須指定之相對應維度的長度，在新<xref:System.Array>。  
  
 參考類型的項目會初始化為`null`。 實值型別元素會初始化為零。  
  
 這個方法是 O (`n`) 作業，其中`n`是中的所有值的乘積`lengths`。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立和初始化多維度<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 為 <see langword="null" />。  -或-  <paramref name="lengths" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  -或-  <paramref name="lengths" /> 陣列包含少於一個項目。</exception>
        <exception cref="T:System.NotSupportedException">不支援 <paramref name="elementType" />。 例如，<see cref="T:System.Void" /> 不受支援。  -或-  <paramref name="elementType" /> 是開放式泛型型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 中的任何值小於零或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要建立之 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length1">要建立之 <see cref="T:System.Array" /> 的第一個維度大小。</param>
        <param name="length2">要建立之 <see cref="T:System.Array" /> 的第二個維度大小。</param>
        <summary>建立指定 <see cref="T:System.Type" /> 和維度長度的二維 <see cref="T:System.Array" /> (具有以零為起始的索引)。</summary>
        <returns>新的二維 <see cref="T:System.Array" />，具有指定的 <see cref="T:System.Type" /> 且每個維度具有指定的長度，並使用以零為起始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於大部分的類別，<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公用建構函式，以允許晚期繫結的存取。  
  
 參考類型的項目會初始化為`null`。 實值型別元素會初始化為零。  
  
 這個方法是 O (`n`) 作業，其中`n`的產品`length1`和`length2`。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立和初始化二維<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支援 <paramref name="elementType" />。 例如，<see cref="T:System.Void" /> 不受支援。  -或-  <paramref name="elementType" /> 是開放式泛型型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> 小於零。  -或-  <paramref name="length2" /> 小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">要建立之 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一維陣列，包含要建立的 <see cref="T:System.Array" /> 的每個維度大小。</param>
        <param name="lowerBounds">一維陣列，包含要建立的 <see cref="T:System.Array" /> 的每個維度下限 (起始索引)。</param>
        <summary>建立指定 <see cref="T:System.Type" /> 和維度長度的多維 <see cref="T:System.Array" /> (具有指定的下限)。</summary>
        <returns>新的多維 <see cref="T:System.Array" />，具有指定的 <see cref="T:System.Type" /> 且每個維度具有指定的長度和下限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於大部分的類別，<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公用建構函式，以允許晚期繫結的存取。  
  
 `lengths`和`lowerBounds`陣列必須有相同數目的項目。 中的項目數`lengths`陣列必須等於在新的維度數目<xref:System.Array>。  
  
 每個項目`lengths`陣列必須指定之相對應維度的長度，在新<xref:System.Array>。  
  
 每個項目`lowerBounds`陣列必須在新指定的相對應維度的下限<xref:System.Array>。 一般而言，.NET Framework 類別庫和許多程式語言不處理非零的下限。  
  
 參考類型的項目會初始化為`null`。 實值型別元素會初始化為零。  
  
 這個方法是 O (`n`) 作業，其中`n`是中的所有值的乘積`lengths`。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立和初始化多維度<xref:System.Array>與指定的下限。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 為 <see langword="null" />。  -或-  <paramref name="lengths" /> 為 <see langword="null" />。  -或-  <paramref name="lowerBounds" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  -或-  <paramref name="lengths" /> 陣列包含少於一個項目。  -或-  <paramref name="lengths" /> 和 <paramref name="lowerBounds" /> 陣列未包含相同數目的項目。</exception>
        <exception cref="T:System.NotSupportedException">不支援 <paramref name="elementType" />。 例如，<see cref="T:System.Void" /> 不受支援。  -或-  <paramref name="elementType" /> 是開放式泛型型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 中的任何值小於零。  -或-  <paramref name="lowerBounds" /> 中的任何值非常大，使用維度的下限和長度總和大於 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要建立之 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length1">要建立之 <see cref="T:System.Array" /> 的第一個維度大小。</param>
        <param name="length2">要建立的 <see cref="T:System.Array" /> 的第二個維度大小。</param>
        <param name="length3">要建立的 <see cref="T:System.Array" /> 的第三個維度大小。</param>
        <summary>建立指定 <see cref="T:System.Type" /> 和維度長度的三維 <see cref="T:System.Array" /> (具有以零為起始的索引)。</summary>
        <returns>指定之 <see cref="T:System.Type" /> 的新三維 <see cref="T:System.Array" />，且每個維度具有指定的長度，並使用以零為起始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於大部分的類別，<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公用建構函式，以允許晚期繫結的存取。  
  
 參考類型的項目會初始化為`null`。 實值型別元素會初始化為零。  
  
 這個方法是 O (`n`) 作業，其中`n`的產品`length1`， `length2`，和`length3`。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立和初始化 3d <xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支援 <paramref name="elementType" />。 例如，<see cref="T:System.Void" /> 不受支援。  -或-  <paramref name="elementType" /> 是開放式泛型型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> 小於零。  -或-  <paramref name="length2" /> 小於零。  -或-  <paramref name="length3" /> 小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <summary>傳回空陣列。</summary>
        <returns>傳回空的 <see cref="T:System.Array" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的以零為起始的一維 <see cref="T:System.Array" />。</param>
        <param name="match">定義搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>判斷指定的陣列是否包含符合指定之述詞 (Predicate) 所定義的條件之項目。</summary>
        <returns>如果 <paramref name="array" /> 包含的一或多個項目符合指定述詞所定義的條件，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>，並在找到相符項目時，會停止處理。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立<xref:System.Predicate%601>明確委派。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列範例會指定比對條件<xref:System.Array.Exists%2A>方法 usinglambda 運算式，以檢查是否憑藉開頭為指定的字母或世界各地是否位於指定的陣列。  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 下列範例會使用<xref:System.Array.Exists%2A>方法，指出是否將字串陣列中的任何名稱開頭為指定的字元。 此範例會具現化`StringSearcher`物件，並傳遞要搜尋其類別建構函式的字串。 `StringSearcher.StartsWith`方法具有相同的簽章<xref:System.Predicate%601>委派。 當<xref:System.Array.Exists%2A>方法呼叫，直到傳回陣列的每個成員會傳遞給委派`true`或會逐一查看陣列中的所有項目。  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 您可以也使用 lambda 運算式而非明確定義其簽章對應的方法委派。 下列範例會取代`StringSearcher`類別和其`StartsWith`方法與 lambda 運算式。  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維、以零為起始的陣列。</param>
        <param name="match">定義要搜尋項目之條件的述詞。</param>
        <summary>搜尋符合指定之述詞所定義的條件之項目，並傳回整個 <see cref="T:System.Array" /> 內第一個相符的項目。</summary>
        <returns>第一個符合指定之述詞所定義的條件之項目 (如有找到)，否則為類型 <paramref name="T" /> 的預設值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是一種委派的方法或 lambda 運算式以傳回`true`傳送至的物件是否符合委派或 lambda 運算式中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>、 第一個元素開始和結尾最後一個項目。  找到相符項目時，會停止處理。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Predicate%601>委派與<xref:System.Array.Find%2A>泛型的方法來搜尋的陣列<xref:System.Drawing.Point>結構。 委派所表示的方法`ProductGT10`，傳回`true`產品 X 和 Y 欄位是否大於 100000。 <xref:System.Array.Find%2A>方法會呼叫委派的陣列，傳回符合測試條件的第一個點的每個項目。  
  
> [!NOTE]
>  Visual Basic 和 C# 使用者不必明確地建立委派，或指定之泛型方法的型別引數。 在編譯器判斷您提供的方法引數的必要型別。  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 而不是具有所需的簽章的方法中明確定義具現化<xref:System.Predicate%601>委派，並傳遞至委派<xref:System.Array.Find%2A>方法，您就可使用 lambda 運算式。 下列範例等同於前一個，不同之處在於它會使用 lambda 運算式，當做`match`引數。  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的以零為起始的一維 <see cref="T:System.Array" />。</param>
        <param name="match">定義搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>擷取符合指定之述詞所定義的條件之所有項目。</summary>
        <returns>
          <see cref="T:System.Array" />，其中包含符合指定之述詞所定義的條件之所有元素 (如果有找到的話)，否則為空的 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>，和符合之條件的項目會儲存在傳回的陣列。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列範例會建立 50 的隨機數字的陣列，範圍從 0 到 1000 的值。 然後它會呼叫<xref:System.Array.FindAll%2A>方法與 lambda 運算式的傳回值範圍從 300 為 600。 請注意，lambda 運算式傳遞參數，名為`x`; 這代表傳遞至個別的陣列成員<xref:System.Predicate%601>。 也請注意，本機`lBound`和`uBound`變數是 lambda 運算式內存取。  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 下列程式碼範例示範<xref:System.Array.Find%2A>， <xref:System.Array.FindLast%2A>，和<xref:System.Array.FindAll%2A>泛型方法。 會建立字串陣列，包含 8 恐龍名稱，兩個 （在位置 1 和 5） 」 saurus 」 以結束。 程式碼範例也會定義名為的搜尋述詞方法`EndsWithSaurus`、 可接受字串參數和傳回布林值，指出是否"saurus"輸入的字串結尾。  
  
 <xref:System.Array.Find%2A>泛型方法會從開始，接著為傳遞每個項目來周遊陣列`EndsWithSaurus`方法。 搜尋會停止時`EndsWithSaurus`方法會傳回`true`"Amargasaurus"的項目。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 <xref:System.Array.FindLast%2A>泛型的方法用來搜尋從結尾回溯陣列。 它會找到項目 」 Dilophosaurus 」 在位置 5。 <xref:System.Array.FindAll%2A>泛型的方法用來傳回陣列，其中包含 「 saurus"結尾的所有項目。 所顯示的項目。  
  
 程式碼範例也示範<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜尋符合指定之述詞所定義的條件之元素，並傳回 <see cref="T:System.Array" /> 內或它的一部分中第一個相符項目之以零起始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維且以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="match">定義要搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>搜尋符合指定之述詞所定義的條件之項目，並傳回整個 <see cref="T:System.Array" /> 內第一次出現之以零為起始的索引。</summary>
        <returns>第一次出現符合 <paramref name="match" /> 所定義之條件的項目以零為起始的索引 (如有找到)；否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>搜尋向前第一個項目開始和結束時間的最後一個元素。  
  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範的所有三個多載<xref:System.Array.FindIndex%2A>泛型方法。 會建立字串陣列，包含 8 恐龍名稱，兩個 （在位置 1 和 5） 」 saurus 」 以結束。 程式碼範例也會定義名為的搜尋述詞方法`EndsWithSaurus`、 可接受字串參數和傳回布林值，指出是否"saurus"輸入的字串結尾。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法多載會從開始，接著為傳遞每個項目來周遊陣列`EndsWithSaurus`方法。 搜尋會停止時`EndsWithSaurus`方法會傳回`true`位置 1 處的項目。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋位置 2 開始，延續至陣列結尾的陣列。 它會找到 5 處的項目。 最後，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋的位置 2 開始的三個項目範圍。 因為沒有在該範圍內恐龍名稱結尾是"saurus"，它會傳回-1。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維且以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="startIndex">搜尋之以零為起始的起始索引。</param>
        <param name="match">定義要搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>搜尋符合指定之述詞所定義的條件之項目，並傳回 <see cref="T:System.Array" /> 內 (從指定之索引延伸到最後一個項目)，於某項目範圍中第一次出現之以零為起始的索引。</summary>
        <returns>第一次出現符合 <paramref name="match" /> 所定義之條件的項目以零為起始的索引 (如有找到)；否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>開始向前搜尋`startIndex`和結束時間的最後一個元素。  
  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>。  
  
 這個方法是 O (`n`) 作業，其中`n`是從元素數目`startIndex`結尾`array`。  
  
   
  
## Examples  
 下列程式碼範例示範的所有三個多載<xref:System.Array.FindIndex%2A>泛型方法。 會建立字串陣列，包含 8 恐龍名稱，兩個 （在位置 1 和 5） 」 saurus 」 以結束。 程式碼範例也會定義名為的搜尋述詞方法`EndsWithSaurus`、 可接受字串參數和傳回布林值，指出是否"saurus"輸入的字串結尾。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法多載會從開始，接著為傳遞每個項目來周遊陣列`EndsWithSaurus`方法。 搜尋會停止時`EndsWithSaurus`方法會傳回`true`位置 1 處的項目。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋位置 2 開始，延續至陣列結尾的陣列。 它會找到 5 處的項目。 最後，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋的位置 2 開始的三個項目範圍。 因為沒有在該範圍內恐龍名稱結尾是"saurus"，它會傳回-1。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維且以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="startIndex">搜尋之以零為起始的起始索引。</param>
        <param name="count">區段中要搜尋的項目數目。</param>
        <param name="match">定義要搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>搜尋符合指定之述詞所定義的條件之項目，並傳回 <see cref="T:System.Array" /> 中從指定之索引開始，且包含指定之項目數目的項目範圍內第一個符合項目之以零為起始的索引。</summary>
        <returns>第一次出現符合 <paramref name="match" /> 所定義之條件的項目以零為起始的索引 (如有找到)；否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>開始向前搜尋`startIndex`結束為`startIndex`加上`count`減 1，如果`count`大於 0。  
  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>。  
  
 這個方法是 O (`n`) 作業，其中`n`是`count`。  
  
   
  
## Examples  
 下列程式碼範例示範的所有三個多載<xref:System.Array.FindIndex%2A>泛型方法。 會建立字串陣列，包含 8 恐龍名稱，兩個 （在位置 1 和 5） 」 saurus 」 以結束。 程式碼範例也會定義名為的搜尋述詞方法`EndsWithSaurus`、 可接受字串參數和傳回布林值，指出是否"saurus"輸入的字串結尾。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法多載會從開始，接著為傳遞每個項目來周遊陣列`EndsWithSaurus`方法。 搜尋會停止時`EndsWithSaurus`方法會傳回`true`位置 1 處的項目。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋位置 2 開始，延續至陣列結尾的陣列。 它會找到 5 處的項目。 最後，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋的位置 2 開始的三個項目範圍。 因為沒有在該範圍內恐龍名稱結尾是"saurus"，它會傳回-1。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。  -或-  <paramref name="count" /> 小於零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <paramref name="array" /> 中的有效區段。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維且以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="match">定義要搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>搜尋符合指定之述詞所定義的條件之項目，並傳回整個 <see cref="T:System.Array" /> 內最後一個相符的項目。</summary>
        <returns>最後一個符合指定之述詞所定義的條件之項目 (如有找到)，否則為類型 <paramref name="T" /> 的預設值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>、 移動中回溯<xref:System.Array>、 最後一個元素開始和結束的第一個元素。  找到相符項目時，會停止處理。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Find%2A>， <xref:System.Array.FindLast%2A>，和<xref:System.Array.FindAll%2A>泛型方法。 會建立字串陣列，包含 8 恐龍名稱，兩個 （在位置 1 和 5） 」 saurus 」 以結束。 程式碼範例也會定義名為的搜尋述詞方法`EndsWithSaurus`、 可接受字串參數和傳回布林值，指出是否"saurus"輸入的字串結尾。  
  
 <xref:System.Array.Find%2A>泛型方法會從開始，接著為傳遞每個項目來周遊陣列`EndsWithSaurus`方法。 搜尋會停止時`EndsWithSaurus`方法會傳回`true`"Amargasaurus"的項目。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 <xref:System.Array.FindLast%2A>泛型的方法用來搜尋從結尾回溯陣列。 它會找到項目 」 Dilophosaurus 」 在位置 5。 <xref:System.Array.FindAll%2A>泛型的方法用來傳回陣列，其中包含 「 saurus"結尾的所有項目。 所顯示的項目。  
  
 程式碼範例也示範<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜尋符合指定之述詞所定義的條件之元素，並傳回 <see cref="T:System.Array" /> 內或它的一部分中最後一個相符項目之以零起始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維且以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="match">定義要搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>搜尋符合指定之述詞所定義的條件之項目，並傳回整個 <see cref="T:System.Array" /> 內最後一次出現之以為零起始的索引。</summary>
        <returns>符合 <paramref name="match" /> 所定義之條件且最後一次出現之項目的以零為起始的索引 (如有找到)，如未找到則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向後的最後一個項目開始和結束時間的第一個項目中搜尋。  
  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範的所有三個多載<xref:System.Array.FindLastIndex%2A>泛型方法。 會建立字串陣列，包含 8 恐龍名稱，兩個 （在位置 1 和 5） 」 saurus 」 以結束。 程式碼範例也會定義名為的搜尋述詞方法`EndsWithSaurus`、 可接受字串參數和傳回布林值，指出是否"saurus"輸入的字串結尾。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法多載周遊回溯陣列結束時，依序為傳遞每個項目從`EndsWithSaurus`方法。 搜尋會停止時`EndsWithSaurus`方法會傳回`true`位置 5 處的項目。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋位置 4 開始，並繼續向後陣列開頭的陣列。 它會尋找在位置 1 的項目。 最後，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋的三個項目範圍從 4 位置開始並回溯 （也就是項目 4、 3 和 2）。 因為沒有在該範圍內恐龍名稱結尾是"saurus"，它會傳回-1。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的以零為起始的一維 <see cref="T:System.Array" />。</param>
        <param name="startIndex">向後搜尋之以零為起始的起始索引。</param>
        <param name="match">定義要搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>搜尋符合指定之述詞所定義的條件之項目，並傳回 <see cref="T:System.Array" /> 中從第一個項目延伸到指定之索引的項目範圍內，最後一個符合項目之以零為起始的索引。</summary>
        <returns>符合 <paramref name="match" /> 所定義之條件且最後一次出現之項目的以零為起始的索引 (如有找到)，如未找到則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜尋回溯開始`startIndex`和結束時間的第一個項目。  
  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>。  
  
 這個方法是 O (`n`) 作業，其中`n`是從開頭的項目數`array`至`startIndex`。  
  
   
  
## Examples  
 下列程式碼範例示範的所有三個多載<xref:System.Array.FindLastIndex%2A>泛型方法。 會建立字串陣列，包含 8 恐龍名稱，兩個 （在位置 1 和 5） 」 saurus 」 以結束。 程式碼範例也會定義名為的搜尋述詞方法`EndsWithSaurus`、 可接受字串參數和傳回布林值，指出是否"saurus"輸入的字串結尾。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法多載周遊回溯陣列結束時，依序為傳遞每個項目從`EndsWithSaurus`方法。 搜尋會停止時`EndsWithSaurus`方法會傳回`true`位置 5 處的項目。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋位置 4 開始，並繼續向後陣列開頭的陣列。 它會尋找在位置 1 的項目。 最後，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋的三個項目範圍從 4 位置開始並回溯 （也就是項目 4、 3 和 2）。 因為沒有在該範圍內恐龍名稱結尾是"saurus"，它會傳回-1。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的以零為起始的一維 <see cref="T:System.Array" />。</param>
        <param name="startIndex">向後搜尋之以零為起始的起始索引。</param>
        <param name="count">區段中要搜尋的項目數目。</param>
        <param name="match">定義要搜尋項目之條件的 <see cref="T:System.Predicate`1" />。</param>
        <summary>搜尋符合指定之述詞所定義的條件之項目，並傳回 <see cref="T:System.Array" /> 中包含指定之項目數目，且結束於指定之索引的項目範圍內最後一個符合項目之以零為起始的索引。</summary>
        <returns>符合 <paramref name="match" /> 所定義之條件且最後一次出現之項目的以零為起始的索引 (如有找到)，如未找到則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜尋回溯開始`startIndex`結束為`startIndex`減去`count`再加上 1，如果`count`大於 0。  
  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>。  
  
 這個方法是 O (`n`) 作業，其中`n`是`count`。  
  
   
  
## Examples  
 下列程式碼範例示範的所有三個多載<xref:System.Array.FindLastIndex%2A>泛型方法。 會建立字串陣列，包含 8 恐龍名稱，兩個 （在位置 1 和 5） 」 saurus 」 以結束。 程式碼範例也會定義名為的搜尋述詞方法`EndsWithSaurus`、 可接受字串參數和傳回布林值，指出是否"saurus"輸入的字串結尾。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法多載周遊回溯陣列結束時，依序為傳遞每個項目從`EndsWithSaurus`方法。 搜尋會停止時`EndsWithSaurus`方法會傳回`true`位置 5 處的項目。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，就不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋位置 4 開始，並繼續向後陣列開頭的陣列。 它會尋找在位置 1 的項目。 最後，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法多載用來搜尋的三個項目範圍從 4 位置開始並回溯 （也就是項目 4、 3 和 2）。 因為沒有在該範圍內恐龍名稱結尾是"saurus"，它會傳回-1。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。  -或-  <paramref name="count" /> 小於零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <paramref name="array" /> 中的有效區段。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">以零起始的一維 <see cref="T:System.Array" />，要在其元素上執行動作。</param>
        <param name="action">要在 <c>array</c> 的每一個元素上執行的 <see cref="T:System.Action`1" />。</param>
        <summary>在指定之陣列的每一個項目上執行指定之動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>物件執行的動作方法的委派傳遞給它。  項目`array`分別傳遞至<xref:System.Action%601>。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Array.ForEach%2A>顯示整數陣列中的每個項目的平方。  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="action" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Array" />。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、 C#]  
  
 `foreach` C# 語言的陳述式 (`for each` c + +`For Each`在 Visual Basic 中) 會隱藏列舉值的複雜度。 因此，建議您使用 `foreach`，而不要直接使用列舉值。  
  
 列舉程式可以用來讀取集合中的資料，但是無法用來修改基礎集合。  
  
 一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A> 也會將列舉值帶回至這個位置。  在這個位置上，<xref:System.Collections.IEnumerator.Current%2A> 並未定義。 因此，在讀取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必須呼叫 <xref:System.Collections.IEnumerator.Current%2A> 以將列舉值前移至集合的第一個項目。  
  
 <xref:System.Collections.IEnumerator.Current%2A> 會傳回相同的物件直到呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A> 或 <xref:System.Collections.IEnumerator.Reset%2A>。 <xref:System.Collections.IEnumerator.MoveNext%2A> 會將 <xref:System.Collections.IEnumerator.Current%2A> 設定為下一個項目。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>超過集合的列舉值的結尾會位於集合中的最後一個元素之後和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。 列舉值位於這個位置上，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。 如果最後一個呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，<xref:System.Collections.IEnumerator.Current%2A>是未定義。 若要再次將 <xref:System.Collections.IEnumerator.Current%2A> 設定為集合的第一個元素，您可以在呼叫 <xref:System.Collections.IEnumerator.Reset%2A> 之後，接著呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合維持不變，列舉程式就持續有效。 如果對集合進行變更，例如加入、修改或刪除項目，列舉程式會永久失效，且其行為未定義。  
  
 列舉值對集合並沒有獨佔存取，因此列舉集合在本質上並非安全執行緒的程序。  若要確保列舉期間的執行緒安全性，您可以在整個列舉期間鎖定集合。  若要讓多重執行緒能夠存取集合以便進行讀取和寫入，您必須實作自己的同步處理。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Array.GetEnumerator%2A>陣列的項目列出。  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">需要決定長度之 <see cref="T:System.Array" /> 的以零起始維度。</param>
        <summary>取得代表 <see cref="T:System.Array" /> 指定維度之元素數目的 32 位元整數。</summary>
        <returns>32 位元的整數，代表指定維度的項目數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 舉例來說，<xref:System.Array.GetLength%2A>是`GetLength(0)`，它會傳回的項目數的第一個維度<xref:System.Array>。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Array.GetLength%2A>來顯示不同等級的兩個陣列的維度。  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> 小於零。  -或-  <paramref name="dimension" /> 等於或大於 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">需要決定長度之 <see cref="T:System.Array" /> 的以零起始維度。</param>
        <summary>取得代表 <see cref="T:System.Array" /> 指定維度之元素數目的 64 位元整數。</summary>
        <returns>64 位元的整數，代表指定維度的項目數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 舉例來說，<xref:System.Array.GetLongLength%2A>是`GetLongLength(0)`，它會傳回的項目數的第一個維度<xref:System.Array>。  
  
 這個方法是一種 o （1） 運算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> 小於零。  -或-  <paramref name="dimension" /> 等於或大於 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">需要決定開始索引之陣列的以零為起始的維度。</param>
        <summary>取得陣列中指定之維度的第一個項目的索引。</summary>
        <returns>陣列中指定之維度的第一個項目的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` 傳回陣列的第一個維度的起始索引和`GetLowerBound(Rank - 1)`傳回陣列的最後一個維度的起始索引。  
  
 <xref:System.Array.GetLowerBound%2A>方法一律會傳回值，指出索引陣列的下限即使陣列是空的。  
  
 請注意，雖然大部分的陣列，在.NET Framework 是以零為起始 (也就是<xref:System.Array.GetLowerBound%2A>方法會傳回零的陣列，每個維度)，.NET Framework 支援不是以零為起始的陣列。 您可以使用建立這類陣列<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>方法，和也會傳回從 unmanaged 程式碼。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法以顯示一維和二維陣列的界限，並顯示其陣列元素的值。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> 小於零。  -或-  <paramref name="dimension" /> 等於或大於 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">需要決定上限之陣列的以零為起始的維度。</param>
        <summary>取得陣列中指定之維度的最後一個項目的索引。</summary>
        <returns>陣列中指定之維度的最後一個項目的索引，如果指定之維度是空的則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` 傳回陣列的第一個維度中的最後一個索引和`GetUpperBound(Rank - 1)`傳回陣列的最後一個維度的最後一個索引。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法以顯示一維和二維陣列的界限，並顯示其陣列元素的值。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> 小於零。  -或-  <paramref name="dimension" /> 等於或大於 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前 <see cref="T:System.Array" /> 中指定元素的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">32 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>取得一維 <see cref="T:System.Array" /> 中位於指定位置的值。 索引已指定為 32 位元整數。</summary>
        <returns>一維 <see cref="T:System.Array" /> 中位於指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否值`index`超出範圍。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好一維的維度。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> 在目前 <see cref="T:System.Array" /> 的有效索引範圍之外。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">32 位元整數的一維陣列，代表索引，指定要取得的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>取得多維 <see cref="T:System.Array" /> 中位於指定位置的值。 索引已指定為 32 位元整數的陣列。</summary>
        <returns>多維 <see cref="T:System.Array" /> 中位於指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的項目數`indices`必須等於中的維度數目<xref:System.Array>。 中的所有項目`indices`陣列必須共同指定所需項目的位置，以多維度<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">目前 <see cref="T:System.Array" /> 中的維度數目不等於 <paramref name="indices" /> 中的元素數目。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" /> 中的任一元素超過目前 <see cref="T:System.Array" /> 中對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">64 位元整數，代表要取得之 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>取得一維 <see cref="T:System.Array" /> 中位於指定位置的值。 索引已指定為 64 位元整數。</summary>
        <returns>一維 <see cref="T:System.Array" /> 中位於指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否值`index`超出範圍。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好一維的維度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 在目前 <see cref="T:System.Array" /> 的有效索引範圍之外。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">64 位元整數的一維陣列，代表指定要取得之 <see cref="T:System.Array" /> 元素位置的索引。</param>
        <summary>取得多維 <see cref="T:System.Array" /> 中位於指定位置的值。 索引已指定為 64 位元整數的陣列。</summary>
        <returns>多維 <see cref="T:System.Array" /> 中位於指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的項目數`indices`必須等於中的維度數目<xref:System.Array>。 中的所有項目`indices`陣列必須共同指定所需項目的位置，以多維度<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">目前 <see cref="T:System.Array" /> 中的維度數目不等於 <paramref name="indices" /> 中的元素數目。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" /> 中的任一元素超過目前 <see cref="T:System.Array" /> 中對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">32 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的第一維索引。</param>
        <param name="index2">32 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的第二維索引。</param>
        <summary>取得二維 <see cref="T:System.Array" /> 中位於指定位置的值。 索引已指定為 32 位元整數。</summary>
        <returns>二維 <see cref="T:System.Array" /> 中位於指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好二維的維度。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 超過目前 <see cref="T:System.Array" /> 之對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">64 位元整數，代表要取得的 <see cref="T:System.Array" /> 元素的第一維索引。</param>
        <param name="index2">64 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的第二維索引。</param>
        <summary>取得二維 <see cref="T:System.Array" /> 中位於指定位置的值。 索引已指定為 64 位元整數。</summary>
        <returns>二維 <see cref="T:System.Array" /> 中位於指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好二維的維度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 超過目前 <see cref="T:System.Array" /> 之對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">32 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的第一維索引。</param>
        <param name="index2">32 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的第二維索引。</param>
        <param name="index3">32 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的第三維索引。</param>
        <summary>取得三維 <see cref="T:System.Array" /> 中位於指定位置的值。 索引已指定為 32 位元整數。</summary>
        <returns>三維 <see cref="T:System.Array" /> 中位於指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好三維的維度。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超過目前 <see cref="T:System.Array" /> 對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">64 位元整數，代表要取得的 <see cref="T:System.Array" /> 元素的第一維索引。</param>
        <param name="index2">64 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的第二維索引。</param>
        <param name="index3">64 位元整數，表示要取得的 <see cref="T:System.Array" /> 元素的第三維索引。</param>
        <summary>取得三維 <see cref="T:System.Array" /> 中位於指定位置的值。 索引已指定為 64 位元整數。</summary>
        <returns>三維 <see cref="T:System.Array" /> 中位於指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 這個方法是一種 o （1） 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好三維的維度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超過目前 <see cref="T:System.Array" /> 對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜尋指定的物件，並傳回其在一維陣列或陣列中某個項目範圍內第一次出現的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋的一維陣列。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <summary>搜尋指定的物件，並傳回一維陣列中第一個相符項目的索引。</summary>
        <returns>如有找到，則為 <paramref name="array" /> 中 <paramref name="value" /> 第一個相符項目的索引；否則為陣列的下限減 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會搜尋的一維 arrayfor 的所有項目`value`。 若要判斷是否`value`存在於`array`，此方法會藉由呼叫每個項目執行相等比較`Equals`方法，直到找到相符項目。 這表示，如果項目會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>呼叫方法，覆寫。  
  
 因為大部分的陣列都具有下限為零，這個方法通常會傳回 – 1 如果`value`找不到。 在少數情況下，陣列的下限等於<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，這個方法會傳回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 此範例會呼叫下列三個多載的<xref:System.Array.IndexOf%2A>方法來尋找字串陣列中字串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以判斷第一個符合的字串"the"字串陣列中。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以判斷第一個符合的字串"the"中的第四個字串陣列的最後一個項目。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以判斷第一個符合的字串"the"中的字串陣列從陣列結尾後面次成功比對的項目。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋的一維陣列。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <param name="startIndex">搜尋的起始索引。 0 (零) 在空白陣列中有效。</param>
        <summary>在一維陣列的項目範圍中搜尋指定的物件，並傳回其第一次出現的索引。 此範圍從指定的索引延伸到陣列的結尾。</summary>
        <returns>如有找到，則為 <paramref name="array" /> 中從 <paramref name="startIndex" /> 延伸至最後一個元素的元素範圍內，<paramref name="value" /> 第一個發生的索引；否則為陣列的下限減 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會搜尋索引處的項目從一維陣列`startIndex`最後一個項目。 若要判斷是否`value`存在於`array`，此方法會藉由呼叫執行相等比較`Equals`方法的每個項目，直到找到相符項目。 這表示，如果項目會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>呼叫方法，覆寫。  
  
 因為大部分的陣列都具有下限為零，這個方法通常會傳回 – 1 如果`value`找不到。 在少數情況下，陣列的下限等於<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，這個方法會傳回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 如果`startIndex`等於<xref:System.Array.Length%2A?displayProperty=nameWithType>，方法會傳回-1。 如果`startIndex`大於<xref:System.Array.Length%2A?displayProperty=nameWithType>，方法會擲回<xref:System.ArgumentOutOfRangeException>。  
  
 這個方法是 O (`n`) 作業，其中`n`是從元素數目`startIndex`結尾`array`。  
  
   
  
## Examples  
 此範例會呼叫下列三個多載的<xref:System.Array.IndexOf%2A>方法來尋找字串陣列中字串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以判斷第一個符合的字串"the"字串陣列中。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以判斷第一個符合的字串"the"中的第四個字串陣列的最後一個項目。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以判斷第一個符合的字串"the"中的字串陣列從陣列結尾後面次成功比對的項目。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋的一維陣列。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <param name="startIndex">搜尋的起始索引。 0 (零) 在空白陣列中有效。</param>
        <param name="count">要搜尋的項目數目。</param>
        <summary>在一維陣列的項目範圍中搜尋指定的物件，並傳回其第一次出現的索引。 此範圍的延伸起點為指定項目數的指定索引。</summary>
        <returns>如有找到，則為 <paramref name="array" /> 中從索引 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> -1 的範圍內，<paramref name="value" /> 第一個相符項目的索引；否則為陣列的下限減 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會搜尋的一維 arrayfrom 項目`startIndex`至`startIndex`加上`count`減 1，如果`count`大於 0。 若要判斷是否`value`存在於`array`，此方法會藉由呼叫執行相等比較`Equals`方法的每個項目，直到找到相符項目。 這表示，如果項目會覆寫<xref:System.Object.Equals%2A?displayProperty=nameWithType>呼叫方法，覆寫。  
  
 Becausemost 陣列的下限為零，這個方法通常會傳回-1 時`value`找不到。 在少數情況下，陣列的下限等於<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，這個方法會傳回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 如果`startindex`等於<xref:System.Array.Length%2A?displayProperty=nameWithType>，方法會傳回-1。 如果`startIndex`大於<xref:System.Array.Length%2A?displayProperty=nameWithType>，方法會擲回<xref:System.ArgumentOutOfRangeException>。  
  
 這個方法是 O (`n`) 作業，其中`n`是`count`。  
  
   
  
## Examples  
 此範例會呼叫下列三個多載的<xref:System.Array.IndexOf%2A>方法來尋找字串陣列中字串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以判斷第一個符合的字串"the"字串陣列中。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以判斷第一個符合的字串"the"中的第四個字串陣列的最後一個項目。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以判斷第一個符合的字串"the"中的字串陣列從陣列結尾後面次成功比對的項目。 若要判斷的值`count`引數，它減去從起始的索引陣列的上限，並新增一個。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。  -或-  <paramref name="count" /> 小於零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <paramref name="array" /> 中的有效區段。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維、以零為起始的陣列。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <summary>搜尋指定的物件，並傳回一維陣列中第一個相符項目的索引。</summary>
        <returns>整個 <paramref name="array" /> 中第一個出現 <paramref name="value" /> 之以零為起始的索引 (如有找到)，如未找到則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會搜尋的一維陣列的所有項目`value`。 若要判斷是否`value`存在於`array`，此方法會藉由呼叫執行相等比較`T.Equals`每個項目上的方法。 這表示如果`T`會覆寫<xref:System.Object.Equals%2A>呼叫方法，覆寫。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列範例將示範三種一般的所有多載<xref:System.Array.IndexOf%2A>方法。 將建立字串陣列，一個會出現兩次，在索引位置 0 和 5 的索引位置的項目。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法多載開始時，從陣列中搜尋和尋找字串的第一個項目。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法多載用於搜尋的索引位置 3 開頭的陣列和陣列的結尾繼續，並尋找字串的第二個項目。 最後，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法多載用來搜尋指定範圍的開頭的索引位置 2 的兩個項目; 它會傳回 – 1，因為沒有在該範圍內的搜尋字串的執行個體。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維、以零為起始的陣列。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <param name="startIndex">搜尋之以零為起始的起始索引。 0 (零) 在空白陣列中有效。</param>
        <summary>在一維陣列的項目範圍中搜尋指定的物件，並傳回其第一次出現的索引。 此範圍從指定的索引延伸到陣列的結尾。</summary>
        <returns>在 <paramref name="value" /> 中從 <paramref name="array" /> 延伸到最後一個項目的元素範圍內，<paramref name="startIndex" /> 的第一個相符項目之以零起始的索引 (如果找到的話)，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會搜尋處的項目從一維陣列`startIndex`陣列的結尾。 若要判斷是否`value`存在於`array`，此方法會藉由呼叫執行相等比較`T.Equals`每個項目上的方法。 這表示如果`T`會覆寫<xref:System.Object.Equals%2A>呼叫方法，覆寫。  
  
 如果`startIndex`等於<xref:System.Array.Length%2A>，方法會傳回-1.If`startIndex`大於<xref:System.Array.Length%2A?displayProperty=nameWithType>，方法會擲回<xref:System.ArgumentOutOfRangeException>。  
  
 這個方法是 O (`n`) 作業，其中`n`是從元素數目`startIndex`結尾`array`。  
  
   
  
## Examples  
 下列範例將示範三種一般的所有多載<xref:System.Array.IndexOf%2A>方法。 將建立字串陣列，一個會出現兩次，在索引位置 0 和 5 的索引位置的項目。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法多載開始時，從陣列中搜尋和尋找字串的第一個項目。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法多載用於搜尋的索引位置 3 開頭的陣列和陣列的結尾繼續，並尋找字串的第二個項目。 最後，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法多載用來搜尋指定範圍的開頭的索引位置 2 的兩個項目; 它會傳回 – 1，因為沒有在該範圍內的搜尋字串的執行個體。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維、以零為起始的陣列。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <param name="startIndex">搜尋之以零為起始的起始索引。 0 (零) 在空白陣列中有效。</param>
        <param name="count">區段中要搜尋的項目數目。</param>
        <summary>在一維陣列的項目範圍中搜尋指定的物件，並傳回其第一次出現的索引。 此範圍的延伸起點為指定項目數的指定索引。</summary>
        <returns>在 <paramref name="value" /> 中從 <paramref name="array" /> 開始且包含 <paramref name="startIndex" /> 內指定之元素數的元素範圍內之 <paramref name="count" /> 的第一個相符項目之以零起始的索引 (如果有找到)，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法 searchesthe 項目從一維陣列的`startIndex`至`startIndex`加上`count`減 1，如果`count`大於 0。 若要判斷是否`value`存在於`array`，此方法會藉由呼叫執行相等比較`T.Equals`每個項目上的方法。 這表示如果`T`會覆寫<xref:System.Object.Equals%2A>呼叫方法，覆寫。  
  
 如果`startIndex`等於<xref:System.Array.Length%2A?displayProperty=nameWithType>，方法會傳回-1。  如果`startIndex`大於<xref:System.Array.Length%2A?displayProperty=nameWithType>，方法會擲回<xref:System.ArgumentOutOfRangeException>。  
  
 這個方法是 O (`n`) 作業，其中`n`是`count`。  
  
   
  
## Examples  
 下列範例將示範三種一般的所有多載<xref:System.Array.IndexOf%2A>方法。 將建立字串陣列，一個會出現兩次，在索引位置 0 和 5 的索引位置的項目。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法多載開始時，從陣列中搜尋和尋找字串的第一個項目。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法多載用於搜尋的索引位置 3 開頭的陣列和陣列的結尾繼續，並尋找字串的第二個項目。 最後，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法多載用來搜尋指定範圍的開頭的索引位置 2 的兩個項目; 它會傳回 – 1，因為沒有在該範圍內的搜尋字串的執行個體。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。  -或-  <paramref name="count" /> 小於零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <paramref name="array" /> 中的有效區段。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼叫實值型別的預設建構函式，初始化實值型別 <see cref="T:System.Array" /> 的每個元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被設計來協助編譯器支援實值型別陣列。大部分的使用者不需要這個方法。 它必須不能參考型別陣列上。  
  
 如果<xref:System.Array>不是實值類型<xref:System.Array>或實值型別沒有預設建構函式，如果<xref:System.Array>則不會修改。  
  
 實值型別<xref:System.Array>可以有任何的下限和任何數目的維度。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>。  
  
> [!CAUTION]
>  您可以使用這個方法只能在具有建構函式; 實值類型上不過，原生 C# 的實值類型沒有建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Array" /> 是否有固定的大小。</summary>
        <value>所有陣列的這個屬性永遠為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 實作<xref:System.Array.IsFixedSize%2A>屬性因為的需要<xref:System.Collections.IList?displayProperty=nameWithType>介面。  
  
 具有固定大小陣列不允許在建立陣列，但允許修改現有的項目後新增或移除項目。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Array" /> 是否唯讀。</summary>
        <value>所有陣列的這個屬性永遠為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 實作<xref:System.Array.IsReadOnly%2A>屬性因為的需要<xref:System.Collections.IList?displayProperty=nameWithType>介面。 陣列是唯讀的不允許陣列建立後增加、 移除或修改項目。  
  
 如果您需要唯讀集合，使用<xref:System.Collections>類別可實作<xref:System.Collections.IList?displayProperty=nameWithType>介面。  
  
 如果您轉型或轉換至陣列<xref:System.Collections.IList>介面物件<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>屬性會傳回`false`。 不過，如果您轉型或轉換至陣列<xref:System.Collections.Generic.IList%601>介面，`IsReadOnly`屬性會傳回`true`。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示對 <see cref="T:System.Array" /> 的存取是否同步 (安全執行緒)。</summary>
        <value>所有陣列的這個屬性永遠為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 實作<xref:System.Array.IsSynchronized%2A>屬性因為的需要<xref:System.Collections.ICollection?displayProperty=nameWithType>介面。  
  
 .NET framework 類別根據<xref:System.Array>提供自己的集合的同步化的版本<xref:System.Array.SyncRoot%2A>屬性。  
  
 使用陣列的類別也可以實作自己的同步處理使用<xref:System.Array.SyncRoot%2A>屬性。 同步處理的程式碼必須在上執行作業`SyncRoot`的集合，而不是直接在集合。 如此可確保衍生自其他物件的集合可以正常運作， 具體而言，保持正常的同步處理與其他可能同時修改集合的執行緒。 請注意，某些實作<xref:System.Array.SyncRoot%2A>可能會傳回<xref:System.Array>本身。  
  
 透過集合進行列舉在本質上並不是執行緒安全的程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何在整個列舉過程中鎖定陣列使用<xref:System.Array.SyncRoot%2A>屬性。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回一維 <see cref="T:System.Array" /> 或 <see cref="T:System.Array" /> 的某部分中數值的最後一個相符項目索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋的一維 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <summary>搜尋指定物件，並且傳回整個一維 <see cref="T:System.Array" /> 中最後一個相符項目的索引。</summary>
        <returns>如果找到的話，則為整個 <paramref name="value" /> 中 <paramref name="array" /> 的最後一個相符項目的索引，否則為陣列的下限減 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一維<xref:System.Array>向後的最後一個項目開始和結束時間的第一個項目中搜尋。  
  
 項目與指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果項目類型為非內建 （使用者定義） 的類型，`Equals`會使用該類型的實作。  
  
 因為大部分的陣列都有下限為零，所以這個方法通常會傳回-1 時`value`找不到。 在少數情況下，陣列的下限等於<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`找不到，這個方法會傳回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，也就是`System.Int32.MinValue - 1`。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 在.NET Framework 2.0 版中，這個方法會使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>來判斷是否<xref:System.Object>所指定`value`參數存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。  
  
 <xref:System.IComparable.CompareTo%2A> 方法的`item`參數集合中的物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷陣列中指定的項目，最後一個出現的索引。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋的一維 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <param name="startIndex">反向搜尋的起始索引。</param>
        <summary>搜尋指定的物件，並傳回一維 <see cref="T:System.Array" /> 內從第一個元素延伸至指定之索引的元素範圍中，最後一個相符項目的索引。</summary>
        <returns>如果找到的話，則為 <paramref name="value" /> 中從第一個元素延伸到 <paramref name="array" /> 的元素範圍內，<paramref name="startIndex" /> 的最後一個相符項目的索引，否則為陣列的下限減 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一維<xref:System.Array>是搜尋回溯開始`startIndex`和結束時間的第一個項目。  
  
 項目與指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果項目類型為非內建 （使用者定義） 的類型，`Equals`會使用該類型的實作。  
  
 因為大部分的陣列都有下限為零，所以這個方法通常會傳回-1 時`value`找不到。 在少數情況下，陣列的下限等於<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`找不到，這個方法會傳回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，也就是`System.Int32.MinValue - 1`。  
  
 這個方法是 O (`n`) 作業，其中`n`是從開頭的項目數`array`至`startIndex`。  
  
 在.NET Framework 2.0 版中，這個方法會使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>來判斷是否<xref:System.Object>所指定`value`參數存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷陣列中指定的項目，最後一個出現的索引。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜尋的一維 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <param name="startIndex">反向搜尋的起始索引。</param>
        <param name="count">區段中要搜尋的項目數目。</param>
        <summary>搜尋指定的物件，並傳回一維 <see cref="T:System.Array" /> 中包含指定之元素數且結束於指定之索引的元素範圍內，最後一個相符項目的索引。</summary>
        <returns>如果找到的話，則為在 <paramref name="value" /> 中包含 <paramref name="array" /> 內指定之元素數且結束於 <paramref name="count" /> 的元素範圍內，<paramref name="startIndex" /> 的最後一個相符項目之索引，否則為陣列的下限減 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一維<xref:System.Array>是搜尋回溯開始`startIndex`結束為`startIndex`減去`count`再加上 1，如果`count`大於 0。  
  
 項目與指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果項目類型為非內建 （使用者定義） 的類型，`Equals`會使用該類型的實作。  
  
 因為大部分的陣列都有下限為零，所以這個方法通常會傳回-1 時`value`找不到。 在少數情況下，陣列的下限等於<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`找不到，這個方法會傳回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，也就是`System.Int32.MinValue - 1`。  
  
 這個方法是 O (`n`) 作業，其中`n`是`count`。  
  
 在.NET Framework 2.0 版中，這個方法會使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>來判斷是否<xref:System.Object>所指定`value`參數存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷陣列中指定的項目，最後一個出現的索引。 請注意，<xref:System.Array.LastIndexOf%2A>方法是向後搜尋; 因此，`count`必須小於或等於 (`startIndex`陣列加 1 的下限減)。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。  -或-  <paramref name="count" /> 小於零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <paramref name="array" /> 中的有效區段。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維且以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <summary>搜尋指定的物件，並傳回整個 <see cref="T:System.Array" /> 中最後一個相符項目的索引。</summary>
        <returns>如果有找到，則是在整個 <paramref name="value" /> 內，<paramref name="array" /> 最後一次出現的以零起始的索引，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向後的最後一個項目開始和結束時間的第一個項目中搜尋。  
  
 項目與指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果項目類型為非內建 （使用者定義） 的類型，`Equals`會使用該類型的實作。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範三種一般的所有多載<xref:System.Array.LastIndexOf%2A>方法。 將建立字串陣列，一個會出現兩次，在索引位置 0 和 5 的索引位置的項目。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法多載整個結束時，從陣列中搜尋和尋找字串的第二個項目。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法多載用來與索引位置 3 回溯開始的陣列和陣列的開頭繼續搜尋和尋找字串的第一個項目。 最後，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法多載用於範圍之四個項目，索引位置 4 開始，並擴充向後搜尋 （也就是說，它會搜尋的項目在位置 4、 3、 2 和 1）; 此搜尋會傳回 – 1，因為沒有搜尋的執行個體在該範圍內的字串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維且以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <param name="startIndex">向後搜尋之以零為起始的起始索引。</param>
        <summary>搜尋指定的物件，並傳回在 <see cref="T:System.Array" /> 內從第一個元素延伸至指定之索引的元素範圍中，最後一個相符項目的索引。</summary>
        <returns>在 <paramref name="value" /> 中從第一個元素延伸到 <paramref name="array" /> 的元素範圍內，<paramref name="startIndex" /> 的最後一個相符項目之以零起始的索引 (如果找到的話)，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜尋回溯開始`startIndex`和結束時間的第一個項目。  
  
 項目與指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果項目類型為非內建 （使用者定義） 的類型，`Equals`會使用該類型的實作。  
  
 這個方法是 O (`n`) 作業，其中`n`是從開頭的項目數`array`至`startIndex`。  
  
   
  
## Examples  
 下列程式碼範例示範三種一般的所有多載<xref:System.Array.LastIndexOf%2A>方法。 將建立字串陣列，一個會出現兩次，在索引位置 0 和 5 的索引位置的項目。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法多載整個結束時，從陣列中搜尋和尋找字串的第二個項目。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法多載用來與索引位置 3 回溯開始的陣列和陣列的開頭繼續搜尋和尋找字串的第一個項目。 最後，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法多載用於範圍之四個項目，索引位置 4 開始，並擴充向後搜尋 （也就是說，它會搜尋的項目在位置 4、 3、 2 和 1）; 此搜尋會傳回 – 1，因為沒有搜尋的執行個體在該範圍內的字串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要搜尋的一維且以零為起始的 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中尋找的物件。</param>
        <param name="startIndex">向後搜尋之以零為起始的起始索引。</param>
        <param name="count">區段中要搜尋的項目數目。</param>
        <summary>搜尋指定的物件，並傳回 <see cref="T:System.Array" /> 中包含指定之元素數且結束於指定之索引的元素範圍內，最後一個相符項目的索引。</summary>
        <returns>在 <paramref name="value" /> 中包含 <paramref name="array" /> 內指定之元素數且結束於 <paramref name="count" /> 的元素範圍內，<paramref name="startIndex" /> 的最後一個相符項目之以零起始的索引 (如果有找到)，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜尋回溯開始`startIndex`結束為`startIndex`減去`count`再加上 1，如果`count`大於 0。  
  
 項目與指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果項目類型為非內建 （使用者定義） 的類型，`Equals`會使用該類型的實作。  
  
 這個方法是 O (`n`) 作業，其中`n`是`count`。  
  
   
  
## Examples  
 下列程式碼範例示範三種一般的所有多載<xref:System.Array.LastIndexOf%2A>方法。 將建立字串陣列，一個會出現兩次，在索引位置 0 和 5 的索引位置的項目。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法多載整個結束時，從陣列中搜尋和尋找字串的第二個項目。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法多載用來與索引位置 3 回溯開始的陣列和陣列的開頭繼續搜尋和尋找字串的第一個項目。 最後，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法多載用於範圍之四個項目，索引位置 4 開始，並擴充向後搜尋 （也就是說，它會搜尋的項目在位置 4、 3、 2 和 1）; 此搜尋會傳回 – 1，因為沒有搜尋的執行個體在該範圍內的字串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出 <paramref name="array" /> 的有效索引範圍。  -或-  <paramref name="count" /> 小於零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <paramref name="array" /> 中的有效區段。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Array" /> 所有維度的元素總數。</summary>
        <value>所有維度的項目總數<see cref="T:System.Array" />，則為零的陣列中有任何項目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擷取這個屬性的值是一種 O(1) 運算。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Array.Length%2A>屬性來取得陣列中的項目總數。 它也會使用<xref:System.Array.GetUpperBound%2A>方法，以判斷每個維度的多維陣列中的項目數。  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">陣列是多維的且包含多個<see cref="F:System.Int32.MaxValue" />項目。</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得代表 <see cref="T:System.Array" /> 所有維度的元素總數之 64 位元整數。</summary>
        <value>64 位元的整數，代表 <see cref="T:System.Array" /> 所有維度的元素總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Array" /> 的陣序 (維度數目)。 例如，一維陣列傳回 1，二維陣列傳回 2，依此類推。</summary>
        <value>
          <see cref="T:System.Array" /> 的陣序規範 (維度數目)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，Visual Basic 程式碼  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 和 C# 程式碼  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 建立具有三個維度的陣列<xref:System.Array.Rank%2A>屬性值為 3。  
  
 不規則的陣列 （陣列的陣列） 是一維陣列。值及其<xref:System.Array.Rank%2A>屬性為 1。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
   
  
## Examples  
 下列範例會初始化一維陣列、 二維陣列和不規則的陣列，並擷取<xref:System.Array.Rank%2A>每個屬性。  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要調整大小之以零為起始的一維陣列，或是 <see langword="null" />，表示要以指定之大小建立新陣列。</param>
        <param name="newSize">新陣列的大小。</param>
        <summary>將一維陣列中的項目數目變更為指定的新大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會配置新的陣列，以指定的大小、 從舊的陣列項目複製到新的專案，，然後以新的取代舊的陣列。 `array` 必須是一維陣列。  
  
 如果`array`是`null`，這個方法會建立新的陣列，以指定的大小。  
  
 如果`newSize`大於<xref:System.Array.Length%2A>的舊的陣列，會配置新的陣列和所有項目會從舊的陣列複製到新的專案。  如果`newSize`是小於<xref:System.Array.Length%2A>的舊的陣列，會配置新的陣列和項目複製從舊的陣列轉換為新直到新的填滿; 舊陣列中元素的其餘部分會被忽略。  如果`newSize`等於<xref:System.Array.Length%2A>的舊的陣列，這個方法不會執行任何動作。  
  
 這個方法是 O (`n`) 作業，其中`n`是`newSize`。  
  
 <xref:System.Array.Resize%2A>方法調整大小，只是一維陣列。 <xref:System.Array>類別不包含調整大小的多維陣列的方法。 若要這樣做，您必須提供自己的程式碼，或呼叫協力廠商的文件庫中的特殊用途的方法。 下列程式碼將說明可能會調整大小的陣列方法實作*n*維度。  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 下列範例顯示如何調整大小會影響陣列。  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> 小於零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>反轉一維 <see cref="T:System.Array" /> 或 <see cref="T:System.Array" /> 某部分中的元素順序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">要反轉的一維 <see cref="T:System.Array" />。</param>
        <summary>反轉整個一維 <see cref="T:System.Array" /> 中的元素順序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法，處的項目之後`myArray[i]`，其中`i`是陣列中的任何索引，將移至`myArray[j]`，其中`j`等於`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 如下列範例所示，<xref:System.Array.Reverse%2A>方法可用來反向不規則的陣列。 它會初始化今年目前文化特性的日曆中的每個月的不規則的陣列，含有一個項目。 每個項目包含與該月有天的元素的陣列。 此範例會顯示為陣列，呼叫的內容<xref:System.Array.Reverse%2A>方法，然後按一下 顯示反轉陣列的內容。  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 下列程式碼範例示範如何反向中值的排序<xref:System.Array>。  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要反轉的一維 <see cref="T:System.Array" />。</param>
        <param name="index">要反轉之區段的起始索引。</param>
        <param name="length">區段中要反轉的項目數目。</param>
        <summary>將一維 <see cref="T:System.Array" /> 中某個範圍的元素之元素順序顛倒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法，處的項目之後`myArray[i]`，其中`i`是陣列中的任何索引，將移至`myArray[j]`，其中`j`等於`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。  
  
 <xref:System.Array.Reverse%2A>方法可用來反向不規則的陣列。  
  
 這個方法是 O (`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範如何反向範圍中的項目中的值排序<xref:System.Array>。  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將目前 <see cref="T:System.Array" /> 中的指定元素設定為指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定項目的新值。</param>
        <param name="index">32 位元整數，表示要設定的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>設定一維 <see cref="T:System.Array" /> 中指定位置之元素的值。 索引已指定為 32 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否值`index`超出範圍。  
  
 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
 這個方法是一種 o （1） 運算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用來指派`null`實值類型陣列的項目，項目的所有欄位都初始化為零。 元素的值不是 null 參考，並無法找到所搜尋的 null 參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好一維的維度。</exception>
        <exception cref="T:System.InvalidCastException">不可以將 <paramref name="value" /> 轉換成目前 <see cref="T:System.Array" /> 的項目型別。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> 在目前 <see cref="T:System.Array" /> 的有效索引範圍之外。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定項目的新值。</param>
        <param name="indices">32 位元整數的一維陣列，代表指定要設定之項目位置的索引。</param>
        <summary>設定多維 <see cref="T:System.Array" /> 中指定位置之元素的值。 索引已指定為 32 位元整數的陣列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的項目數`indices`必須等於中的維度數目<xref:System.Array>。 中的所有項目`indices`陣列必須共同指定所需項目的位置，以多維度<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何值的`indices`陣列超出界限。  
  
 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
 這個方法是一種 o （1） 運算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用來指派`null`實值類型陣列的項目，項目的所有欄位都初始化為零。 元素的值不是 null 參考，並無法找到所搜尋的 null 參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">目前 <see cref="T:System.Array" /> 中的維度數目不等於 <paramref name="indices" /> 中的元素數目。</exception>
        <exception cref="T:System.InvalidCastException">不可以將 <paramref name="value" /> 轉換成目前 <see cref="T:System.Array" /> 的項目型別。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" /> 中的任一元素超過目前 <see cref="T:System.Array" /> 中對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定項目的新值。</param>
        <param name="index">64 位元整數，表示要設定的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>設定一維 <see cref="T:System.Array" /> 中指定位置之元素的值。 索引已指定為 64 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否值`index`超出範圍。  
  
 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
 這個方法是一種 o （1） 運算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用來指派`null`實值類型陣列的項目，項目的所有欄位都初始化為零。 元素的值不是 null 參考，並無法找到所搜尋的 null 參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好一維的維度。</exception>
        <exception cref="T:System.InvalidCastException">不可以將 <paramref name="value" /> 轉換成目前 <see cref="T:System.Array" /> 的項目型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 在目前 <see cref="T:System.Array" /> 的有效索引範圍之外。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定項目的新值。</param>
        <param name="indices">64 位元整數的一維陣列，代表指定要設定之項目位置的索引。</param>
        <summary>設定多維 <see cref="T:System.Array" /> 中指定位置之元素的值。 索引已指定為 64 位元整數的陣列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的項目數`indices`必須等於中的維度數目<xref:System.Array>。 中的所有項目`indices`陣列必須共同指定所需項目的位置，以多維度<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何值的`indices`陣列超出界限。  
  
 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
 這個方法是一種 o （1） 運算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用來指派`null`實值類型陣列的項目，項目的所有欄位都初始化為零。 元素的值不是 null 參考，並無法找到所搜尋的 null 參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">目前 <see cref="T:System.Array" /> 中的維度數目不等於 <paramref name="indices" /> 中的元素數目。</exception>
        <exception cref="T:System.InvalidCastException">不可以將 <paramref name="value" /> 轉換成目前 <see cref="T:System.Array" /> 的項目型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" /> 中的任一元素超過目前 <see cref="T:System.Array" /> 中對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定項目的新值。</param>
        <param name="index1">32 位元整數，表示要設定的 <see cref="T:System.Array" /> 元素的第一維索引。</param>
        <param name="index2">32 位元整數，表示要設定的 <see cref="T:System.Array" /> 元素的第二維索引。</param>
        <summary>設定二維 <see cref="T:System.Array" /> 中指定位置之元素的值。 索引已指定為 32 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
 這個方法是一種 o （1） 運算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用來指派`null`實值類型陣列的項目，項目的所有欄位都初始化為零。 元素的值不是 null 參考，並無法找到所搜尋的 null 參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好二維的維度。</exception>
        <exception cref="T:System.InvalidCastException">不可以將 <paramref name="value" /> 轉換成目前 <see cref="T:System.Array" /> 的項目型別。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 超過目前 <see cref="T:System.Array" /> 之對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定項目的新值。</param>
        <param name="index1">64 位元整數，表示要設定之 <see cref="T:System.Array" /> 元素的第一維索引。</param>
        <param name="index2">64 位元整數，表示要設定之 <see cref="T:System.Array" /> 元素的第二維索引。</param>
        <summary>設定二維 <see cref="T:System.Array" /> 中指定位置之元素的值。 索引已指定為 64 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
 這個方法是一種 o （1） 運算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用來指派`null`實值類型陣列的項目，項目的所有欄位都初始化為零。 元素的值不是 null 參考，並無法找到所搜尋的 null 參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好二維的維度。</exception>
        <exception cref="T:System.InvalidCastException">不可以將 <paramref name="value" /> 轉換成目前 <see cref="T:System.Array" /> 的項目型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 超過目前 <see cref="T:System.Array" /> 之對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定項目的新值。</param>
        <param name="index1">32 位元整數，表示要設定的 <see cref="T:System.Array" /> 元素的第一維索引。</param>
        <param name="index2">32 位元整數，表示要設定的 <see cref="T:System.Array" /> 元素的第二維索引。</param>
        <param name="index3">32 位元整數，表示要設定的 <see cref="T:System.Array" /> 元素的第三維索引。</param>
        <summary>設定三維 <see cref="T:System.Array" /> 中指定位置之元素的值。 索引已指定為 32 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
 這個方法是一種 o （1） 運算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用來指派`null`實值類型陣列的項目，項目的所有欄位都初始化為零。 元素的值不是 null 參考，並無法找到所搜尋的 null 參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好三維的維度。</exception>
        <exception cref="T:System.InvalidCastException">不可以將 <paramref name="value" /> 轉換成目前 <see cref="T:System.Array" /> 的項目型別。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超過目前 <see cref="T:System.Array" /> 對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定項目的新值。</param>
        <param name="index1">64 位元整數，表示要設定之 <see cref="T:System.Array" /> 元素的第一維索引。</param>
        <param name="index2">64 位元整數，表示要設定之 <see cref="T:System.Array" /> 元素的第二維索引。</param>
        <param name="index3">64 位元整數，表示要設定之 <see cref="T:System.Array" /> 元素的第三維索引。</param>
        <summary>設定三維 <see cref="T:System.Array" /> 中指定位置之元素的值。 索引已指定為 64 位元整數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以判斷是否有任何索引超出範圍。  
  
 如需有關轉換的詳細資訊，請參閱<xref:System.Convert>。  
  
 這個方法是一種 o （1） 運算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用來指派`null`實值類型陣列的項目，項目的所有欄位都初始化為零。 元素的值不是 null 參考，並無法找到所搜尋的 null 參考。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定並取得一維或多維陣列中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好三維的維度。</exception>
        <exception cref="T:System.InvalidCastException">不可以將 <paramref name="value" /> 轉換成目前 <see cref="T:System.Array" /> 的項目型別。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超過目前 <see cref="T:System.Array" /> 對應維度的有效索引範圍。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>排序一維陣列中的項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一維 <see cref="T:System.Array" />。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每個元素的 <see cref="T:System.IComparable" /> 實作，排序整個一維 <see cref="T:System.Array" /> 中的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個項目`array`必須實作<xref:System.IComparable>介面中的項目比較能夠`array`。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範如何排序值<xref:System.Array>使用預設比較子和自訂比較子，會反轉排序順序。 請注意，結果可能會有所不同目前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">一維 <see cref="T:System.Array" />，包含要排序的索引鍵。</param>
        <param name="items">一維 <see cref="T:System.Array" />，包含對應至 <c>keys</c><see cref="T:System.Array" /> 中每個索引鍵的項目。  -或-  <see langword="null" /> 表示只排序 <c>keys</c><see cref="T:System.Array" />。</param>
        <summary>使用每個索引鍵的 <see cref="T:System.Array" /> 實作，根據第一個 <see cref="T:System.Array" /> 中的索引鍵，排序一對一維的 <see cref="T:System.IComparable" /> 物件 (一個物件包含索引鍵，另一個物件包含對應的項目)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每個索引鍵`keys`<xref:System.Array>中有對應的項目`items` <xref:System.Array>。 索引鍵排序期間，在對應的項目時重新定位`items`<xref:System.Array>同樣會重新調整位置。 因此， `items` <xref:System.Array>根據對應中的索引鍵的排列方式排序`keys` <xref:System.Array>。  
  
 在每個索引鍵`keys`<xref:System.Array>必須實作<xref:System.IComparable>介面若要能夠與每個索引鍵的比較。  
  
 如果有多個項目與索引鍵，但不含對應的索引鍵的項目將不會排序，您可以排序。 如果有多個索引鍵項目，比無法排序如此一來，這會擲回<xref:System.ArgumentException>。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`keys`。  
  
   
  
## Examples  
 下列範例會示範如何排序兩個相關聯的陣列，其中的第一個陣列包含的索引鍵，而第二個陣列包含的值。 完成排序使用預設比較子和自訂比較子，會反轉排序順序。 請注意，結果可能會有所不同目前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 是多維的。  -或-  <paramref name="items" /><see cref="T:System.Array" /> 為多維。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，而且 <paramref name="keys" /> 的長度大於 <paramref name="items" /> 的長度。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 中的一或多個元素不會實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一維陣列。</param>
        <param name="comparer">比較項目時所要使用的實作。  -或-  <see langword="null" /> 表示會使用每個項目的 <see cref="T:System.IComparable" /> 實作。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，排序一維 <see cref="T:System.Collections.IComparer" /> 中的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每個項目`array`必須實作<xref:System.IComparable>介面中的項目比較能夠`array`。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 .NET Framework 包含預先定義<xref:System.Collections.IComparer>實作如下表所示。  
  
|實作|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比較任何兩個物件，但是執行不區分大小寫的字串比較。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用目前文化特性的排序慣例來比較任意兩個物件。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|比較任意兩個物件所使用的排序慣例的文化特性而異。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比較兩個物件的型別`T`使用類型的預設排序順序。|  
  
 您也可以藉由提供您自己的執行個體來支援自訂比較<xref:System.Collections.IComparer>實作`comparer`參數。 這個範例會藉由定義`ReverseComparer`反轉的預設排序順序的類別類型的執行個體和執行不區分大小寫字串的比較。  
  
   
  
## Examples  
 下列範例會排序中使用預設比較子字串 arrayby 的值。 它也會定義自訂<xref:System.Collections.IComparer>實作名為`ReverseComparer`，反轉執行不區分大小寫字串比較物件的預設排序順序。 請注意，輸出可能會根據目前文化特性而有所不同。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="array" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparer" /> 可能不會傳回 0。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，則可能擲回的先前排序作業<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">一維 <see cref="T:System.Array" />，包含要排序的索引鍵。</param>
        <param name="items">一維 <see cref="T:System.Array" />，包含對應至 <c>keys</c><see cref="T:System.Array" /> 中每個索引鍵的項目。  -或-  <see langword="null" /> 表示只排序 <c>keys</c><see cref="T:System.Array" />。</param>
        <param name="comparer">比較項目時所要使用的 <see cref="T:System.Collections.IComparer" /> 實作。  -或-  <see langword="null" /> 表示會使用每個項目的 <see cref="T:System.IComparable" /> 實作。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，根據第一個 <see cref="T:System.Array" /> 中的索引鍵，排序一對一維的<see cref="T:System.Collections.IComparer" /> 物件 (一個物件包含索引鍵，另一個物件包含對應的項目)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每個索引鍵`keys`<xref:System.Array>中有對應的項目`items` <xref:System.Array>。 索引鍵排序期間，在對應的項目時重新定位`items`<xref:System.Array>同樣會重新調整位置。 因此， `items` <xref:System.Array>根據對應中的索引鍵的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，每個索引鍵中`keys`<xref:System.Array>必須實作<xref:System.IComparable>介面若要能夠與每個索引鍵的比較。  
  
 如果有多個項目與索引鍵，但不含對應的索引鍵的項目將不會排序，您可以排序。 如果有多個索引鍵項目，比無法排序如此一來，這會擲回<xref:System.ArgumentException>。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 .NET Framework 包含預先定義<xref:System.Collections.IComparer>實作如下表所示。  
  
|實作|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比較任何兩個物件，但是執行不區分大小寫的字串比較。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用目前文化特性的排序慣例來比較任意兩個物件。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|比較任意兩個物件所使用的排序慣例的文化特性而異。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比較兩個物件的型別`T`使用類型的預設排序順序。|  
  
 您也可以藉由提供您自己的執行個體來支援自訂比較<xref:System.Collections.IComparer>實作`comparer`參數。 這個範例會藉由定義<xref:System.Collections.IComparer>的實作，保留預設排序順序，並執行不區分大小寫字串的比較。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`keys`。  
  
   
  
## Examples  
 下列範例會示範如何排序兩個相關聯的陣列，其中的第一個陣列包含的索引鍵，而第二個陣列包含的值。 完成排序使用預設比較子和自訂比較子，會反轉排序順序。 請注意，結果可能會有所不同目前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 是多維的。  -或-  <paramref name="items" /><see cref="T:System.Array" /> 為多維。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，而且 <paramref name="keys" /> 的長度大於 <paramref name="items" /> 的長度。  -或-  <paramref name="comparer" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparer" /> 可能不會傳回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一或多個元素不會實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！很可能 INCLUDE[net_v45](~/includes/net-v45-md.md)]，排序作業該 previouslythrew<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一維 <see cref="T:System.Array" />。</param>
        <param name="index">要排序之範圍的起始索引。</param>
        <param name="length">區段中要排序的項目數目。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每個元素的 <see cref="T:System.IComparable" /> 實作，排序一維 <see cref="T:System.Array" /> 中某個元素範圍內的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的項目指定的範圍內的每個項目`array`必須實作<xref:System.IComparable>介面中的項目比較能夠`array`。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範如何排序值<xref:System.Array>使用預設比較子和自訂比較子，會反轉排序順序。 請注意，結果可能會有所不同目前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">一維 <see cref="T:System.Array" />，包含要排序的索引鍵。</param>
        <param name="items">一維 <see cref="T:System.Array" />，包含對應至 <c>keys</c><see cref="T:System.Array" /> 中每個索引鍵的項目。  -或-  <see langword="null" /> 表示只排序 <c>keys</c><see cref="T:System.Array" />。</param>
        <param name="index">要排序之範圍的起始索引。</param>
        <param name="length">區段中要排序的項目數目。</param>
        <summary>使用每個索引鍵的 <see cref="T:System.Array" /> 實作，根據第一個 <see cref="T:System.Array" /> 中的索引鍵，排序一對一維的 <see cref="T:System.IComparable" /> 物件中某個範圍的元素 (一個物件包含索引鍵，另一個物件包含對應的項目)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每個索引鍵`keys`<xref:System.Array>中有對應的項目`items` <xref:System.Array>。 索引鍵排序期間，在對應的項目時重新定位`items`<xref:System.Array>同樣會重新調整位置。 因此， `items` <xref:System.Array>根據對應中的索引鍵的排列方式排序`keys` <xref:System.Array>。  
  
 每個索引鍵的項目中指定的範圍內`keys`<xref:System.Array>必須實作<xref:System.IComparable>介面若要能夠與每個索引鍵的比較。  
  
 如果有多個項目與索引鍵，但不含對應的索引鍵的項目將不會排序，您可以排序。 如果有多個索引鍵項目，比無法排序如此一來，這會擲回<xref:System.ArgumentException>。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範如何排序兩個相關聯的陣列，其中的第一個陣列包含的索引鍵，而第二個陣列包含的值。 完成排序使用預設比較子和自訂比較子，會反轉排序順序。 請注意，結果可能會有所不同目前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 是多維的。  -或-  <paramref name="items" /><see cref="T:System.Array" /> 為多維。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="keys" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，而且 <paramref name="keys" /> 的長度大於 <paramref name="items" /> 的長度。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="keys" /><see cref="T:System.Array" /> 中的有效範圍。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="items" /><see cref="T:System.Array" /> 中的有效範圍。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 中的一或多個元素不會實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一維 <see cref="T:System.Array" />。</param>
        <param name="index">要排序之範圍的起始索引。</param>
        <param name="length">區段中要排序的項目數目。</param>
        <param name="comparer">比較項目時所要使用的 <see cref="T:System.Collections.IComparer" /> 實作。  -或-  <see langword="null" /> 表示會使用每個項目的 <see cref="T:System.IComparable" /> 實作。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，排序一維 <see cref="T:System.Collections.IComparer" /> 中元素範圍內的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每個項目中的項目指定的範圍內`array`必須實作<xref:System.IComparable>介面中的項目比較能夠`array`。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 .NET Framework 包含預先定義<xref:System.Collections.IComparer>實作如下表所示。  
  
|實作|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比較任何兩個物件，但是執行不區分大小寫的字串比較。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用目前文化特性的排序慣例來比較任意兩個物件。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|比較任意兩個物件所使用的排序慣例的文化特性而異。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比較兩個物件的型別`T`使用類型的預設排序順序。|  
  
 您也可以藉由提供您自己的執行個體來支援自訂比較<xref:System.Collections.IComparer>實作`comparer`參數。 這個範例會藉由定義`ReverseComparer`反轉的預設排序順序的類別類型的執行個體和執行不區分大小寫字串的比較。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範如何排序值<xref:System.Array>使用預設比較子和自訂比較子，會反轉排序順序。 請注意，結果可能會有所不同目前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多維的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。  -或-  <paramref name="comparer" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparer" /> 可能不會傳回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="array" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，則可能擲回的先前排序作業<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">一維 <see cref="T:System.Array" />，包含要排序的索引鍵。</param>
        <param name="items">一維 <see cref="T:System.Array" />，包含對應至 <c>keys</c><see cref="T:System.Array" /> 中每個索引鍵的項目。  -或-  <see langword="null" /> 表示只排序 <c>keys</c><see cref="T:System.Array" />。</param>
        <param name="index">要排序之範圍的起始索引。</param>
        <param name="length">區段中要排序的項目數目。</param>
        <param name="comparer">比較項目時所要使用的 <see cref="T:System.Collections.IComparer" /> 實作。  -或-  <see langword="null" /> 表示會使用每個項目的 <see cref="T:System.IComparable" /> 實作。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，根據第一個 <see cref="T:System.Array" /> 中的索引鍵，排序一對一維的 <see cref="T:System.Collections.IComparer" /> 物件中某範圍的元素 (一個物件包含索引鍵，另一個物件包含對應的項目)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每個索引鍵`keys`<xref:System.Array>中有對應的項目`items` <xref:System.Array>。 索引鍵排序期間，在對應的項目時重新定位`items`<xref:System.Array>同樣會重新調整位置。 因此， `items` <xref:System.Array>根據對應中的索引鍵的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，每個索引鍵的項目中指定的範圍內`keys`<xref:System.Array>必須實作<xref:System.IComparable>介面若要能夠與每個索引鍵的比較。  
  
 如果有多個項目與索引鍵，但不含對應的索引鍵的項目將不會排序，您可以排序。 如果有多個索引鍵項目，比無法排序如此一來，這會擲回<xref:System.ArgumentException>。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 .NET Framework 包含預先定義<xref:System.Collections.IComparer>實作如下表所示。  
  
|實作|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比較任何兩個物件，但是執行不區分大小寫的字串比較。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用目前文化特性的排序慣例來比較任意兩個物件。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|比較任意兩個物件所使用的排序慣例的文化特性而異。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比較兩個物件的型別`T`使用類型的預設排序順序。|  
  
 您也可以藉由提供您自己的執行個體來支援自訂比較<xref:System.Collections.IComparer>實作`comparer`參數。 這個範例會藉由定義自訂<xref:System.Collections.IComparer>的實作，保留預設排序順序，並執行不區分大小寫字串的比較。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範如何排序兩個相關聯的陣列，其中的第一個陣列包含的索引鍵，而第二個陣列包含的值。 完成排序使用預設比較子和自訂比較子，會反轉排序順序。 請注意，結果可能會有所不同目前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 是多維的。  -或-  <paramref name="items" /><see cref="T:System.Array" /> 為多維。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="keys" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，並且 <paramref name="keys" /> 的下限和 <paramref name="items" /> 的下限不相符。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的長度大於 <paramref name="items" /> 的長度。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="keys" /><see cref="T:System.Array" /> 中的有效範圍。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="items" /><see cref="T:System.Array" /> 中的有效範圍。  -或-  <paramref name="comparer" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparer" /> 可能不會傳回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一或多個元素不會實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，則可能擲回的先前排序作業<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要排序之以零起始的一維 <see cref="T:System.Array" />。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每個元素之 <see cref="T:System.IComparable`1" /> 泛型介面實作，排序整個 <see cref="T:System.Array" /> 中的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個項目`array`必須實作<xref:System.IComparable%601>泛型介面中的項目比較能夠`array`。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法的多載而<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法的多載。 建立字串陣列，不依特定順序。  
  
 陣列會顯示、 已排序，並且會再次顯示。  
  
> [!NOTE]
>  若要呼叫<xref:System.Array.Sort%2A>和<xref:System.Array.BinarySearch%2A>泛型方法看起來不任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的第一個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法的多載然後來搜尋兩個字串，而非在陣列與其中一個，為。 陣列和傳回值<xref:System.Array.BinarySearch%2A>方法會傳遞至`ShowWhere`泛型的方法，如果找到字串，否則項目搜尋字串會介於陣列中時顯示的索引值。 索引是負值，如果字串不是 n 陣列，所以`ShowWhere`方法會採用的位元補數 (~ 運算子，在 C# 和 Visual c + +，`Xor`在 Visual Basic 中的為-1) 取得第一個元素大於搜尋 stri 清單中的索引ng。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要排序之以零起始的一維 <see cref="T:System.Array" />。</param>
        <param name="comparer">在比較項目時所使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型介面實作，或是 <see langword="null" /> 以使用每個項目的 <see cref="T:System.IComparable`1" /> 泛型介面實作。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 泛型介面，排序 <see cref="T:System.Collections.Generic.IComparer`1" /> 中的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每個項目`array`必須實作<xref:System.IComparable%601>泛型介面中的項目比較能夠`array`。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載而<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載。  
  
 程式碼範例定義的替代的比較子字串，名為`ReverseCompare`，它會實作`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型介面。 比較子的呼叫<xref:System.String.CompareTo%28System.String%29>方法，使字串排序高-到-低而不是低到高反轉比較元的順序。  
  
 陣列會顯示、 已排序，並且會再次顯示。 必須排序陣列，才能使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  若要呼叫<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法看起來不任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的第一個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載然後來搜尋兩個字串，而非在陣列與其中一個，為。 陣列和傳回值<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法會傳遞至`ShowWhere`泛型的方法，如果找到字串，否則項目搜尋字串會介於陣列中時顯示的索引值。 索引是負值，如果字串不是 n 陣列，所以`ShowWhere`方法會採用的位元補數 (~ 運算子，在 C# 和 Visual c + +，`Xor`在 Visual Basic 中的為-1) 取得第一個元素大於搜尋 stri 清單中的索引ng。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="array" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparer" /> 可能不會傳回 0。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，則可能擲回的先前排序作業<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要排序之以零起始的一維 <see cref="T:System.Array" />。</param>
        <param name="comparison">比較項目時所要使用的 <see cref="T:System.Comparison`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，排序 <see cref="T:System.Comparison`1" /> 中的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>方法多載。  
  
 程式碼範例會定義具名字串的替代的比較方法`CompareDinosByLength`。 這個方法的運作方式如下： comparandsare 先，測試`null`，而且 null 的參考被視為小於一個非 null。 第二，進行比較的字串長度，以及較長的字串會視為大於。 第三，如果長度相等，則使用一般的字串比較。  
  
 建立並填入不依特定順序中的四個字串的字串陣列。 清單也會包含空字串和 null 參考。 清單會顯示使用排序<xref:System.Comparison%601>代表的泛型委派`CompareDinosByLength`方法，並顯示一次。  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="comparison" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparison" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparison" /> 可能不會傳回 0。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，則可能擲回的先前排序作業<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要排序之以零起始的一維 <see cref="T:System.Array" />。</param>
        <param name="index">要排序之範圍的起始索引。</param>
        <param name="length">區段中要排序的項目數目。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每個元素之 <see cref="T:System.IComparable`1" /> 泛型介面實作，排序 <see cref="T:System.Array" /> 中某個元素範圍中的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的項目指定的範圍內的每個項目`array`必須實作<xref:System.IComparable%601>泛型介面中的項目比較能夠`array`。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法的多載而<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載來排序陣列中的範圍。  
  
 程式碼範例定義的替代的比較子字串，名為`ReverseCompare`，它會實作`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型介面。 比較子的呼叫<xref:System.String.CompareTo%28System.String%29>方法，使字串排序高-到-低而不是低到高反轉比較元的順序。  
  
 程式碼範例會建立，並顯示恐龍名稱，後面接著三個肉食性恐龍 (更明確地說 tyrannosaurids) 的三個草食所組成的陣列。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法的多載會用來排序的陣列，接著會顯示最後三個項目。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載會搭配`ReverseCompare`以相反順序排序的最後三個項目。 恐龍會再次顯示。  
  
> [!NOTE]
>  若要呼叫<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法看起來不任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的第一個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要排序之以零起始的一維 <see cref="T:System.Array" />。</param>
        <param name="index">要排序之範圍的起始索引。</param>
        <param name="length">區段中要排序的項目數目。</param>
        <param name="comparer">在比較項目時所使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型介面實作，或是 <see langword="null" /> 以使用每個項目的 <see cref="T:System.IComparable`1" /> 泛型介面實作。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 泛型介面，對 <see cref="T:System.Collections.Generic.IComparer`1" /> 中的某個元素範圍內的元素進行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每個項目中的項目指定的範圍內`array`必須實作<xref:System.IComparable%601>泛型介面中的項目比較能夠`array`。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法的多載而<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載來排序陣列中的範圍。  
  
 程式碼範例定義的替代的比較子字串，名為`ReverseCompare`，它會實作`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型介面。 比較子的呼叫<xref:System.String.CompareTo%28System.String%29>方法，使字串排序高-到-低而不是低到高反轉比較元的順序。  
  
 程式碼範例會建立，並顯示恐龍名稱，後面接著三個肉食性恐龍 (更明確地說 tyrannosaurids) 的三個草食所組成的陣列。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法的多載會用來排序的陣列，接著會顯示最後三個項目。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載會搭配`ReverseCompare`以相反順序排序的最後三個項目。 恐龍會再次顯示。  
  
> [!NOTE]
>  若要呼叫<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法看起來不任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的第一個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="array" /> 中的有效範圍。  -或-  <paramref name="comparer" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparer" /> 可能不會傳回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="array" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，則可能擲回的先前排序作業<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">索引鍵陣列項目的類型。</typeparam>
        <typeparam name="TValue">項目陣列項目的類型。</typeparam>
        <param name="keys">一維、以零起始的 <see cref="T:System.Array" />，包含要排序的索引鍵。</param>
        <param name="items">包含 <c>keys</c> 中的索引鍵對應項目，且以零為起始的一維 <see cref="T:System.Array" />；<see langword="null" /> 則表示只會排序 <c>keys</c>。</param>
        <summary>使用每個索引鍵的 <see cref="T:System.Array" /> 泛型介面實作，根據第一個 <see cref="T:System.Array" /> 中的索引鍵，排序一對 <see cref="T:System.IComparable`1" /> 物件 (一個物件包含索引鍵，另一個物件包含對應的項目)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每個索引鍵`keys`<xref:System.Array>中有對應的項目`items` <xref:System.Array>。 索引鍵排序期間，在對應的項目時重新定位`items`<xref:System.Array>同樣會重新調整位置。 因此， `items` <xref:System.Array>根據對應中的索引鍵的排列方式排序`keys` <xref:System.Array>。  
  
 在每個索引鍵`keys`<xref:System.Array>必須實作<xref:System.IComparable%601>能夠與每個索引鍵比較的泛型介面。  
  
 如果有多個項目與索引鍵，但不含對應的索引鍵的項目將不會排序，您可以排序。 如果有多個索引鍵項目，比無法排序如此一來，這會擲回<xref:System.ArgumentException>。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載，來排序的陣列，代表索引鍵和值組。  
  
 程式碼範例定義的替代的比較子字串，名為`ReverseCompare`，它會實作`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型介面。 比較子的呼叫<xref:System.String.CompareTo%28System.String%29>方法，使字串排序高-到-低而不是低到高反轉比較元的順序。  
  
 程式碼範例會建立，並顯示恐龍名稱 （索引鍵） 的陣列，表示每個恐龍以公尺為單位 （值） 的最大長度的整數陣列。 然後排序和顯示數次的陣列：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>多載會用來排序順序中的第一個陣列恐龍名稱的兩個陣列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>多載和執行個體`ReverseCompare`用來反轉排序次序的配對的陣列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>多載會用來排序的兩個陣列的最後三個項目。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>多載用來以相反順序排序的兩個陣列的最後三個項目。  
  
> [!NOTE]
>  與泛型方法的呼叫不要尋找任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的前兩個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，並且 <paramref name="keys" /> 的下限和 <paramref name="items" /> 的下限不相符。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的長度大於 <paramref name="items" /> 的長度。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 中的一個或多個元素不會實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">索引鍵陣列項目的類型。</typeparam>
        <typeparam name="TValue">項目陣列項目的類型。</typeparam>
        <param name="keys">一維、以零起始的 <see cref="T:System.Array" />，包含要排序的索引鍵。</param>
        <param name="items">包含 <c>keys</c> 中的索引鍵對應項目，且以零為起始的一維 <see cref="T:System.Array" />；<see langword="null" /> 則表示只會排序 <c>keys</c>。</param>
        <param name="comparer">在比較項目時所使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型介面實作，或是 <see langword="null" /> 以使用每個項目的 <see cref="T:System.IComparable`1" /> 泛型介面實作。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 泛型介面，根據第一個 <see cref="T:System.Array" /> 中的索引鍵，排序一對 <see cref="T:System.Collections.Generic.IComparer`1" /> 物件 (一個物件包含索引鍵，另一個物件包含對應的項目)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每個索引鍵`keys`<xref:System.Array>中有對應的項目`items` <xref:System.Array>。 索引鍵排序期間，在對應的項目時重新定位`items`<xref:System.Array>同樣會重新調整位置。 因此， `items` <xref:System.Array>根據對應中的索引鍵的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，每個索引鍵中`keys`<xref:System.Array>必須實作<xref:System.IComparable%601>能夠與每個索引鍵比較的泛型介面。  
  
 如果有多個項目與索引鍵，但不含對應的索引鍵的項目將不會排序，您可以排序。 如果有多個索引鍵項目，比無法排序如此一來，這會擲回<xref:System.ArgumentException>。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>，[\]，Tvalue>\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >，<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載，來排序的陣列，代表索引鍵和值組。  
  
 程式碼範例定義的替代的比較子字串，名為`ReverseCompare`，它會實作`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型介面。 比較子的呼叫<xref:System.String.CompareTo%28System.String%29>方法，使字串排序高-到-低而不是低到高反轉比較元的順序。  
  
 程式碼範例會建立，並顯示恐龍名稱 （索引鍵） 的陣列，表示每個恐龍以公尺為單位 （值） 的最大長度的整數陣列。 然後排序和顯示數次的陣列：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>多載會用來排序順序中的第一個陣列恐龍名稱的兩個陣列。  
  
-   [\]，Tvalue>\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 多載和執行個體`ReverseCompare`用來反轉排序次序配對的陣列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>多載會用來排序的兩個陣列的最後三個項目。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>多載用來以相反順序排序的兩個陣列的最後三個項目。  
  
> [!NOTE]
>  與泛型方法的呼叫不要尋找任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的前兩個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，並且 <paramref name="keys" /> 的下限和 <paramref name="items" /> 的下限不相符。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的長度大於 <paramref name="items" /> 的長度。  -或-  <paramref name="comparer" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparer" /> 可能不會傳回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一或多個元素未實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，則可能擲回的先前排序作業<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">索引鍵陣列項目的類型。</typeparam>
        <typeparam name="TValue">項目陣列項目的類型。</typeparam>
        <param name="keys">一維、以零起始的 <see cref="T:System.Array" />，包含要排序的索引鍵。</param>
        <param name="items">包含 <c>keys</c> 中的索引鍵對應項目，且以零為起始的一維 <see cref="T:System.Array" />；<see langword="null" /> 則表示只會排序 <c>keys</c>。</param>
        <param name="index">要排序之範圍的起始索引。</param>
        <param name="length">區段中要排序的項目數目。</param>
        <summary>使用每個索引鍵的 <see cref="T:System.Array" /> 泛型介面實作，根據第一個 <see cref="T:System.Array" /> 中的索引鍵，排序一對 <see cref="T:System.IComparable`1" /> 物件中某個範圍的元素 (一個物件包含索引鍵，另一個物件包含對應的項目)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每個索引鍵`keys`<xref:System.Array>中有對應的項目`items` <xref:System.Array>。 索引鍵排序期間，在對應的項目時重新定位`items`<xref:System.Array>同樣會重新調整位置。 因此， `items` <xref:System.Array>根據對應中的索引鍵的排列方式排序`keys` <xref:System.Array>。  
  
 每個索引鍵的項目中指定的範圍內`keys`<xref:System.Array>必須實作<xref:System.IComparable%601>能夠與每個索引鍵比較的泛型介面。  
  
 如果有多個項目與索引鍵，但不含對應的索引鍵的項目將不會排序，您可以排序。 如果有多個索引鍵項目，比無法排序如此一來，這會擲回<xref:System.ArgumentException>。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>，[\]，Tvalue>\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >，並<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的多載，排序的陣列，代表索引鍵和值組。  
  
 程式碼範例定義的替代的比較子字串，名為`ReverseCompare`，它會實作`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型介面。 比較子的呼叫<xref:System.String.CompareTo%28System.String%29>方法，使字串排序高-到-低而不是低到高反轉比較元的順序。  
  
 程式碼範例會建立，並顯示恐龍名稱 （索引鍵） 的陣列，表示每個恐龍以公尺為單位 （值） 的最大長度的整數陣列。 然後排序和顯示數次的陣列：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>多載會用來排序順序中的第一個陣列恐龍名稱的兩個陣列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>多載和執行個體`ReverseCompare`用來反轉排序次序的配對的陣列。  
  
-   [\]，Tvalue>\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > 多載會用來排序的兩個陣列的最後三個項目。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>多載用來以相反順序排序的兩個陣列的最後三個項目。  
  
> [!NOTE]
>  與泛型方法的呼叫不要尋找任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的前兩個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="keys" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，並且 <paramref name="keys" /> 的下限和 <paramref name="items" /> 的下限不相符。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的長度大於 <paramref name="items" /> 的長度。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="keys" /><see cref="T:System.Array" /> 中的有效範圍。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="items" /><see cref="T:System.Array" /> 中的有效範圍。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 中的一個或多個元素不會實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">索引鍵陣列項目的類型。</typeparam>
        <typeparam name="TValue">項目陣列項目的類型。</typeparam>
        <param name="keys">一維、以零起始的 <see cref="T:System.Array" />，包含要排序的索引鍵。</param>
        <param name="items">包含 <c>keys</c> 中的索引鍵對應項目，且以零為起始的一維 <see cref="T:System.Array" />；<see langword="null" /> 則表示只會排序 <c>keys</c>。</param>
        <param name="index">要排序之範圍的起始索引。</param>
        <param name="length">區段中要排序的項目數目。</param>
        <param name="comparer">在比較項目時所使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型介面實作，或是 <see langword="null" /> 以使用每個項目的 <see cref="T:System.IComparable`1" /> 泛型介面實作。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 泛型介面，根據第一個 <see cref="T:System.Array" /> 中的索引鍵，排序一對 <see cref="T:System.Collections.Generic.IComparer`1" /> 物件中某範圍的元素 (一個物件包含索引鍵，另一個物件包含對應的項目)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每個索引鍵`keys`<xref:System.Array>中有對應的項目`items` <xref:System.Array>。 索引鍵排序期間，在對應的項目時重新定位`items`<xref:System.Array>同樣會重新調整位置。 因此， `items` <xref:System.Array>根據對應中的索引鍵的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，每個索引鍵的項目中指定的範圍內`keys`<xref:System.Array>必須實作<xref:System.IComparable%601>能夠與每個索引鍵比較的泛型介面。  
  
 如果有多個項目與索引鍵，但不含對應的索引鍵的項目將不會排序，您可以排序。 如果有多個索引鍵項目，比無法排序如此一來，這會擲回<xref:System.ArgumentException>。  
  
 如果未順利完成排序，則結果會是未定義。  
  
 這個方法會使用內省式排序 (introsort) 演算法，如下所示：  
  
-   如果磁碟分割大小是 16 個元素，它會使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)演算法。  
  
-   如果資料分割數目超過 2 * 記錄<sup>N</sup>，其中*N*為範圍之輸入的陣列，它會使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)演算法。  
  
-   否則，它會使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)演算法。  
  
 此實作會執行不穩定的排序。也就是說，如果兩個項目相同，可能不會保留它們的順序。 相較之下，穩定的排序會保留相同的項目的順序。  
  
 對於使用 Heapsort 和快速排序演算法，最壞的情況下會排序的陣列，這個方法是 O (`n`記錄`n`) 作業，其中`n`是`length`。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和 [\]，Tvalue>\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 泛型方法的多載，來排序的陣列，代表索引鍵和值組。  
  
 程式碼範例定義的替代的比較子字串，名為`ReverseCompare`，它會實作`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型介面。 比較子的呼叫<xref:System.String.CompareTo%28System.String%29>方法，使字串排序高-到-低而不是低到高反轉比較元的順序。  
  
 程式碼範例會建立，並顯示恐龍名稱 （索引鍵） 的陣列，表示每個恐龍以公尺為單位 （值） 的最大長度的整數陣列。 然後排序和顯示數次的陣列：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>多載會用來排序順序中的第一個陣列恐龍名稱的兩個陣列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>多載和執行個體`ReverseCompare`用來反轉排序次序的配對的陣列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>多載會用來排序的兩個陣列的最後三個項目。  
  
-   [\]，Tvalue>\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 用來排序最後三個多載兩者的項目陣列以反向順序。  
  
> [!NOTE]
>  與泛型方法的呼叫不要尋找任何不同於呼叫其非泛型對應項目，因為 Visual Basic、 C# 和 c + + 推斷的前兩個引數類型的泛型型別參數的型別。 如果您使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢查的 Microsoft intermediate language (MSIL)，您可以查看呼叫泛型方法。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 <paramref name="keys" /> 的下限。  -或-  <paramref name="length" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，並且 <paramref name="keys" /> 的下限和 <paramref name="items" /> 的下限不相符。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的長度大於 <paramref name="items" /> 的長度。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="keys" /><see cref="T:System.Array" /> 中的有效範圍。  -或-  <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未指定 <paramref name="items" /><see cref="T:System.Array" /> 中的有效範圍。  -或-  <paramref name="comparer" /> 的實作在排序期間造成錯誤。 例如，在將項目與其本身比較時，<paramref name="comparer" /> 可能不會傳回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一或多個元素未實作 <see cref="T:System.IComparable`1" /> 泛型介面。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和舊版使用快速排序演算法。快速排序識別無效的比較子，在某些情況下，排序作業擲回<see cref="T:System.IndexOutOfRangeException" />例外狀況，並擲回<see cref="T:System.ArgumentException" />例外狀況至呼叫端。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，則可能擲回的先前排序作業<see cref="T:System.ArgumentException" />不會擲回例外狀況，因為插入排序和 heapsort 演算法則不會偵測無效的比較子。大部分的情況下，這適用於具有 16 個元素的陣列。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可用以同步存取 <see cref="T:System.Array" /> 的物件。</summary>
        <value>可用以同步存取 <see cref="T:System.Array" /> 的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會實作<xref:System.Collections.ICollection?displayProperty=nameWithType>介面。  
  
 .NET framework 類別根據<xref:System.Array>提供自己的集合的同步化的版本<xref:System.Array.SyncRoot%2A>屬性。  
  
 使用陣列的類別也可以實作自己的同步處理使用<xref:System.Array.SyncRoot%2A>屬性。 同步處理的程式碼必須在上執行作業`SyncRoot`的集合，而不是直接在集合。 如此可確保衍生自其他物件的集合可以正常運作， 具體而言，保持正常的同步處理與其他可能同時修改集合的執行緒。 請注意，某些實作<xref:System.Array.SyncRoot%2A>可能會傳回<xref:System.Array>本身。  
  
 透過集合進行列舉在本質上並不是執行緒安全的程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
   
  
## Examples  
 下列程式碼範例示範如何在整個列舉過程中鎖定陣列使用<xref:System.Array.SyncRoot%2A>屬性。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Array" /> 中所包含的項目數。</summary>
        <value>集合中所包含的項目數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.ICollection> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要加入 <see cref="T:System.Collections.IList" /> 的物件。</param>
        <summary>呼叫這個方法一律會擲回 <see cref="T:System.NotSupportedException" /> 例外狀況。</summary>
        <returns>不支援將值加入陣列。 沒有傳回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般情況下，<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>實作會將成員新增至集合。 不過，因為陣列有固定的大小 (<xref:System.Array.IsFixedSize%2A>屬性一律會傳回`true`)，這個方法一律會擲回<xref:System.NotSupportedException>例外狀況。  
  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IList> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從 <see cref="T:System.Collections.IList" /> 中移除所有項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IList> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 是唯讀的。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在目前清單中尋找的物件。 對於參考型別而言，要尋找的元素可以是 <see langword="null" />。</param>
        <summary>判斷某項目是否在 <see cref="T:System.Collections.IList" /> 中。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="value" />，則為 <see cref="T:System.Collections.IList" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IList> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在目前清單中尋找的物件。</param>
        <summary>判斷 <see cref="T:System.Collections.IList" /> 中指定項目的索引。</summary>
        <returns>如果在清單中有找到，則為值的索引，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IList> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">應該插入 <c>value</c> 的索引。</param>
        <param name="value">要插入的物件。</param>
        <summary>將項目插入位於指定索引的 <see cref="T:System.Collections.IList" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IList> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 是唯讀的。  -或-  <see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> 是 <see cref="T:System.Collections.IList" /> 中的 null 參考。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要取得或設定的項目之索引。</param>
        <summary>在指定的索引位置上取得或設定項目。</summary>
        <value>在指定索引上的項目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IList> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於零。  -或-  <paramref name="index" /> 等於或大於 <see cref="P:System.Collections.ICollection.Count" />。</exception>
        <exception cref="T:System.ArgumentException">目前的 <see cref="T:System.Array" /> 不具有剛好一維的維度。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要從 <see cref="T:System.Collections.IList" /> 移除的物件。</param>
        <summary>從 <see cref="T:System.Collections.IList" /> 移除特定物件之第一個符合的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IList> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 是唯讀的。  -或-  <see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的項目索引。</param>
        <summary>移除在指定索引處的 <see cref="T:System.Collections.IList" /> 項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IList> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">索引不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 是唯讀的。  -或-  <see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">要與目前執行個體比較的物件。</param>
        <param name="comparer">將目前的物件與 <c>other</c> 相比較的物件。</param>
        <summary>判斷目前的集合物件在排序次序中位於另一個物件之前、相同位置或之後。</summary>
        <returns>整數，表示目前集合物件與 other 的關聯性，如下表所示。  
  
 <list type="table"><listheader><term> 傳回值  </term><description> 描述  </description></listheader><item><term> -1  </term><description> 目前的執行個體在 <paramref name="other" /> 之前。</description></item><item><term> 0  </term><description> 目前的執行個體與 <paramref name="other" /> 相等。</description></item><item><term> 1  </term><description> 目前的執行個體在 <paramref name="other" /> 之後。</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IStructuralComparable> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">要與目前執行個體比較的物件。</param>
        <param name="comparer">判斷目前的執行個體與 <c>other</c> 是否相等的物件。</param>
        <summary>判斷物件與目前的執行個體是否相等。</summary>
        <returns>如果兩個物件相等則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IStructuralEquatable> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">物件，會計算目前物件的雜湊碼。</param>
        <summary>傳回目前執行個體的雜湊碼。</summary>
        <returns>目前執行個體的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Array> 執行個體轉換成 <xref:System.Collections.IStructuralEquatable> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">陣列項目的類型。</typeparam>
        <param name="array">要檢查之以零起始的一維 <see cref="T:System.Array" /> 所根據的條件。</param>
        <param name="match">述詞，可定義檢查項目所根據的條件。</param>
        <summary>判斷陣列中的每一個項目是否符合指定之述詞所定義的條件。</summary>
        <returns>如果 <paramref name="array" /> 中的每一個元素都符合指定之述詞所定義的條件，則為 <see langword="true" />，否則為 <see langword="false" />。 如果陣列中沒有元素，則傳回值為 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>委派的方法會傳回以`true`傳送至的物件是否符合在委派中定義的條件。  項目`array`分別傳遞至<xref:System.Predicate%601>，並停止處理在委派傳回時`false`的任何項目。  
  
 這個方法是 O (`n`) 作業，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下列範例會判斷是否將字串陣列中每個元素的最後一個字元是數字。 它會建立兩個字串陣列。 第一個 arrayincludes 字串結尾為英數字元和字串與數字字元結尾。第二個陣列只包含結尾的數字字元的字串。 此範例也會定義`EndWithANumber`方法的簽章符合<xref:System.Predicate%601>委派。 此範例會傳遞至每個陣列<xref:System.Array.TrueForAll%2A>方法表示的委派，以及`EndsWithANumber`方法。  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 下列範例是類似於第一個，不同之處在於它會將字串陣列，以傳遞<xref:System.Array.TrueForAll%2A>方法以及 lambda 運算式以判斷特定的陣列項目是否結束之數字的字串表示法。  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 在這兩種情況下，<xref:System.Array.TrueForAll%2A>方法會傳回`false`只要遇到結尾不是數字的第一個陣列元素。 否則，它會傳回`true`後逐一查看陣列中的所有項目。  
  
> [!NOTE]
>  如這兩個範例所示，在 C# 和 Visual Basic 中，不需要建立`Predicate<string>`委派 (`Predicate(Of String)`在 Visual Basic 中) 明確。 這些語言推斷正確的委派，從內容，並自動建立。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。  -或-  <paramref name="match" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>